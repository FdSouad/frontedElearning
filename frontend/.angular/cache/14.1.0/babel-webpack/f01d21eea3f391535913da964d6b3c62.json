{"ast":null,"code":"import { Browser, ChildProperty, Collection, Complex, Component, Draggable, Droppable, Event, EventHandler, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, addClass, append, attributes, blazorTemplates, classList, closest, compile, createElement, debounce, detach, extend, formatUnit, getEnumValue, getValue, isNullOrUndefined, isObject, isUndefined, matches, merge, print, remove, removeClass, resetBlazorTemplate, select, selectAll, setCulture, setStyleAttribute, setValue, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { DataManager, DataUtil, Deferred, Predicate, Query, UrlAdaptor } from '@syncfusion/ej2-data';\nimport { Dialog, Tooltip, calculatePosition, calculateRelativeBasedPosition, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';\nimport { Button, CheckBox, RadioButton, Switch, createCheckBox } from '@syncfusion/ej2-buttons';\nimport { FormValidator, Input, MaskedTextBox, NumericTextBox, TextBox } from '@syncfusion/ej2-inputs';\nimport { AutoComplete, ComboBox, DropDownList, MultiSelect } from '@syncfusion/ej2-dropdowns';\nimport { DatePicker, DateTimePicker, TimePicker } from '@syncfusion/ej2-calendars';\nimport { ContextMenu, Toolbar } from '@syncfusion/ej2-navigations';\nimport { Workbook } from '@syncfusion/ej2-excel-export';\nimport { PdfBitmap, PdfBorders, PdfColor, PdfCompositeField, PdfDocument, PdfFontFamily, PdfFontStyle, PdfGrid, PdfPaddings, PdfPageCountField, PdfPageNumberField, PdfPageOrientation, PdfPageSettings, PdfPageTemplateElement, PdfPen, PdfSolidBrush, PdfStandardFont, PdfStringFormat, PdfTextAlignment, PdfTextWebLink, PdfTrueTypeFont, PdfVerticalAlignment, PointF, RectangleF, SizeF } from '@syncfusion/ej2-pdf-export';\n/**\n * ValueFormatter class to globalize the value.\n *\n * @hidden\n */\n\nvar ValueFormatter =\n/** @__PURE__ @class */\nfunction () {\n  function ValueFormatter(cultureName) {\n    this.intl = new Internationalization();\n\n    if (!isNullOrUndefined(cultureName)) {\n      this.intl.culture = cultureName;\n    }\n  }\n\n  ValueFormatter.prototype.getFormatFunction = function (format) {\n    if (format.type) {\n      return this.intl.getDateFormat(format);\n    } else {\n      return this.intl.getNumberFormat(format);\n    }\n  };\n\n  ValueFormatter.prototype.getParserFunction = function (format) {\n    if (format.type) {\n      return this.intl.getDateParser(format);\n    } else {\n      return this.intl.getNumberParser(format);\n    }\n  };\n\n  ValueFormatter.prototype.fromView = function (value, format, type) {\n    if ((type === 'date' || type === 'datetime' || type === 'number') && !isNullOrUndefined(format)) {\n      return format(value);\n    } else {\n      return value;\n    }\n  };\n\n  ValueFormatter.prototype.toView = function (value, format) {\n    var result = value;\n\n    if (!isNullOrUndefined(format) && !isNullOrUndefined(value)) {\n      result = format(value);\n    }\n\n    return result;\n  };\n\n  ValueFormatter.prototype.setCulture = function (cultureName) {\n    if (!isNullOrUndefined(cultureName)) {\n      setCulture(cultureName);\n    }\n  };\n\n  return ValueFormatter;\n}();\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Represents Grid `Column` model class.\n */\n\n\nvar Column =\n/** @__PURE__ @class */\nfunction () {\n  function Column(options, parent) {\n    var _this = this;\n    /**\n     * If `disableHtmlEncode` is set to true, it encodes the HTML of the header and content cells.\n     *\n     * @default true\n     */\n\n\n    this.disableHtmlEncode = true;\n    /**\n     * If `allowSorting` set to false, then it disables sorting option of a particular column.\n     * By default all columns are sortable.\n     *\n     * @default true\n     */\n\n    this.allowSorting = true;\n    /**\n     * If `allowResizing` is set to false, it disables resize option of a particular column.\n     * By default all the columns can be resized.\n     *\n     * @default true\n     */\n\n    this.allowResizing = true;\n    /**\n     * If `allowFiltering` set to false, then it disables filtering option and filter bar element of a particular column.\n     * By default all columns are filterable.\n     *\n     * @default true\n     */\n\n    this.allowFiltering = true;\n    /**\n     * If `allowGrouping` set to false, then it disables grouping of a particular column.\n     * By default all columns are groupable.\n     *\n     * @default true\n     */\n\n    this.allowGrouping = true;\n    /**\n     * If `allowReordering` set to false, then it disables reorder of a particular column.\n     * By default all columns can be reorder.\n     *\n     * @default true\n     */\n\n    this.allowReordering = true;\n    /**\n     * If `showColumnMenu` set to false, then it disable the column menu of a particular column.\n     * By default column menu will show for all columns\n     *\n     * @default true\n     */\n\n    this.showColumnMenu = true;\n    /**\n     * If `enableGroupByFormat` set to true, then it groups the particular column by formatted values.\n     *\n     * @default true\n     */\n\n    this.enableGroupByFormat = false;\n    /**\n     * If `allowEditing` set to false, then it disables editing of a particular column.\n     * By default all columns are editable.\n     *\n     * @default true\n     */\n\n    this.allowEditing = true;\n    /**\n     *  It is used to customize the default filter options for a specific columns.\n     * * type -  Specifies the filter type as menu or checkbox.\n     * * ui - to render custom component for specific column it has following functions.\n     * * ui.create â€“ It is used for creating custom components.\n     * * ui.read -  It is used for read the value from the component.\n     * * ui.write - It is used to apply component model as dynamically.\n     * {% codeBlock src=\"grid/filter-menu-api/index.ts\" %}{% endcodeBlock %}\n     *\n     * > Check the [`Filter UI`](../../grid/filtering/filter-menu/#custom-component-in-filter-menu) for its customization.\n     *\n     *  @default {}\n     */\n\n    this.filter = {};\n    /**\n     * If `showInColumnChooser` set to false, then hide the particular column in column chooser.\n     *  By default all columns are displayed in column Chooser.\n     *\n     * @default true\n     */\n\n    this.showInColumnChooser = true;\n    /**\n     * Defines the `IEditCell` object to customize default edit cell.\n     *\n     * @default {}\n     */\n\n    this.edit = {};\n    /**\n     * If `allowSearching` set to false, then it disables Searching of a particular column.\n     * By default all columns allow Searching.\n     *\n     * @default true\n     */\n\n    this.allowSearching = true;\n    /**\n     * If `autoFit` set to true, then the particular column content width will be\n     * adjusted based on its content in the initial rendering itself.\n     * Setting this property as true is equivalent to calling `autoFitColumns` method in the `dataBound` event.\n     *\n     * @default false\n     */\n\n    this.autoFit = false;\n    this.sortDirection = 'Descending';\n    /**\n     * @returns {Function} returns the edit template\n     * @hidden */\n\n    this.getEditTemplate = function () {\n      return _this.editTemplateFn;\n    };\n    /**\n     * @returns {Function} returns the filter template\n     * @hidden */\n\n\n    this.getFilterTemplate = function () {\n      return _this.filterTemplateFn;\n    };\n\n    merge(this, options);\n    this.parent = parent;\n\n    if (this.type === 'none') {\n      this.type = null;\n    } else if (this.type) {\n      this.type = typeof this.type === 'string' ? this.type.toLowerCase() : undefined;\n    }\n\n    if (this.editType) {\n      this.editType = this.editType.toLowerCase();\n    }\n\n    if (isNullOrUndefined(this.uid)) {\n      this.uid = getUid('grid-column');\n    }\n\n    var valueFormatter = new ValueFormatter();\n\n    if (options.format && (options.format.skeleton || options.format.format && typeof options.format.format === 'string')) {\n      this.setFormatter(valueFormatter.getFormatFunction(extend({}, options.format)));\n      this.setParser(valueFormatter.getParserFunction(options.format));\n    }\n\n    this.toJSON = function () {\n      var col = {};\n      var skip = ['filter', 'dataSource', 'headerText', 'template', 'headerTemplate', 'edit', 'editTemplate', 'filterTemplate', 'commandsTemplate', 'parent'];\n      var keys = Object.keys(_this);\n\n      for (var i = 0; i < keys.length; i++) {\n        if (keys[i] === 'columns') {\n          col[keys[i]] = [];\n\n          for (var j = 0; j < _this[keys[i]].length; j++) {\n            col[keys[i]].push(_this[keys[i]][j].toJSON());\n          }\n        } else if (skip.indexOf(keys[i]) < 0) {\n          col[keys[i]] = _this[keys[i]];\n        }\n      }\n\n      return col;\n    };\n\n    if (!this.field) {\n      this.allowFiltering = false;\n      this.allowGrouping = false;\n      this.allowSorting = false;\n\n      if (this.columns) {\n        this.allowResizing = this.columns.some(function (col) {\n          return col.allowResizing;\n        });\n      }\n    }\n\n    if (this.commands && !this.textAlign) {\n      this.textAlign = 'Right';\n    }\n\n    if (this.template || this.commandsTemplate) {\n      this.templateFn = templateCompiler(this.template || this.commandsTemplate);\n    }\n\n    if (this.headerTemplate) {\n      this.headerTemplateFn = templateCompiler(this.headerTemplate);\n    }\n\n    if (!isNullOrUndefined(this.filter) && this.filter.itemTemplate) {\n      this.fltrTemplateFn = templateCompiler(this.filter.itemTemplate);\n    }\n\n    if (this.editTemplate) {\n      this.editTemplateFn = templateCompiler(this.editTemplate);\n    }\n\n    if (this.filterTemplate) {\n      this.filterTemplateFn = templateCompiler(this.filterTemplate);\n    }\n\n    if (this.isForeignColumn() && (isNullOrUndefined(this.editType) || this.editType === 'dropdownedit' || this.editType === 'defaultedit')) {\n      this.editType = 'dropdownedit';\n\n      if (this.edit.params && this.edit.params.dataSource) {\n        this.edit.params.ddEditedData = true;\n      }\n\n      this.edit.params = extend({\n        dataSource: this.dataSource,\n        query: new Query(),\n        fields: {\n          value: this.foreignKeyField || this.field,\n          text: this.foreignKeyValue\n        }\n      }, this.edit.params);\n    }\n\n    if (this.sortComparer) {\n      var a_1 = this.sortComparer;\n\n      this.sortComparer = function (x, y, xObj, yObj) {\n        if (typeof a_1 === 'string') {\n          a_1 = getObject(a_1, window);\n        }\n\n        if (_this.sortDirection === 'Descending') {\n          var z = x;\n          x = y;\n          y = z;\n          var obj = xObj;\n          xObj = yObj;\n          yObj = obj;\n        }\n\n        return a_1(x, y, xObj, yObj);\n      };\n    }\n\n    if (!this.sortComparer && this.isForeignColumn()) {\n      this.sortComparer = function (x, y) {\n        x = getObject(_this.foreignKeyValue, getForeignData(_this, {}, x)[0]);\n        y = getObject(_this.foreignKeyValue, getForeignData(_this, {}, y)[0]);\n        return _this.sortDirection === 'Descending' ? DataUtil.fnDescending(x, y) : DataUtil.fnAscending(x, y);\n      };\n    }\n  }\n  /**\n   * @returns {string} returns the sort direction\n   * @hidden */\n\n\n  Column.prototype.getSortDirection = function () {\n    return this.sortDirection;\n  };\n  /**\n   * @param {string} direction - specifies the direction\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Column.prototype.setSortDirection = function (direction) {\n    this.sortDirection = direction;\n  };\n  /**\n   * @returns {freezeTable} returns the FreezeTable\n   * @hidden */\n\n\n  Column.prototype.getFreezeTableName = function () {\n    return this.freezeTable;\n  };\n  /**\n   * @param {Column} column - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Column.prototype.setProperties = function (column) {\n    //Angular two way binding\n    var keys = Object.keys(column);\n\n    for (var i = 0; i < keys.length; i++) {\n      this[keys[i]] = column[keys[i]]; //Refresh the react columnTemplates on state change\n\n      if (this.parent && this.parent.isReact) {\n        if (keys[i] === 'template') {\n          this.parent.refreshReactColumnTemplateByUid(this.uid);\n        } else if (keys[i] === 'headerTemplate') {\n          this.headerTemplateFn = templateCompiler(column[keys[i]]);\n          this.parent.refreshReactHeaderTemplateByUid(this.uid);\n        } else if (keys[i] === 'editTemplate') {\n          this.editTemplateFn = templateCompiler(column[keys[i]]);\n        }\n      }\n    }\n  };\n  /**\n   * @returns {boolean} returns true for foreign column\n   * @hidden\n   * It defines the column is foreign key column or not.\n   */\n\n\n  Column.prototype.isForeignColumn = function () {\n    return !!(this.dataSource && this.foreignKeyValue);\n  };\n  /**\n   * @returns {Function} returns the function\n   * @hidden\n   */\n\n\n  Column.prototype.getFormatter = function () {\n    return this.formatFn;\n  };\n  /**\n   * @param {Function} value - specifies the value\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Column.prototype.setFormatter = function (value) {\n    this.formatFn = value;\n  };\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  Column.prototype.getParser = function () {\n    return this.parserFn;\n  };\n  /**\n   * @param {Function} value - specifies the value\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Column.prototype.setParser = function (value) {\n    this.parserFn = value;\n  };\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  Column.prototype.getColumnTemplate = function () {\n    return this.templateFn;\n  };\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  Column.prototype.getHeaderTemplate = function () {\n    return this.headerTemplateFn;\n  };\n  /**\n   * @returns {Function} returns the function\n   * @hidden */\n\n\n  Column.prototype.getFilterItemTemplate = function () {\n    return this.fltrTemplateFn;\n  };\n  /**\n   * @returns {string} returns the string\n   * @hidden */\n\n\n  Column.prototype.getDomSetter = function () {\n    return this.disableHtmlEncode ? 'textContent' : 'innerHTML';\n  };\n\n  return Column;\n}();\n/**\n * Define options for custom command buttons.\n */\n\n\nvar CommandColumnModel =\n/** @__PURE__ @class */\nfunction () {\n  function CommandColumnModel() {}\n\n  __decorate([Property()], CommandColumnModel.prototype, \"title\", void 0);\n\n  __decorate([Property()], CommandColumnModel.prototype, \"type\", void 0);\n\n  __decorate([Property()], CommandColumnModel.prototype, \"buttonOption\", void 0);\n\n  return CommandColumnModel;\n}();\n/**\n * Defines Grid column\n */\n\n\nvar GridColumn =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends(GridColumn, _super);\n\n  function GridColumn() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(null)], GridColumn.prototype, \"columns\", void 0);\n\n  return GridColumn;\n}(Column);\n/**\n * Defines stacked grid column\n */\n\n\nvar StackedColumn =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends(StackedColumn, _super);\n\n  function StackedColumn() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return StackedColumn;\n}(GridColumn);\n/** @hidden */\n\n\nvar created = 'create';\n/** @hidden */\n\nvar destroyed = 'destroy';\n/** @hidden */\n\nvar load = 'load';\n/** @hidden */\n\nvar rowDataBound = 'rowDataBound';\n/** @hidden */\n\nvar queryCellInfo = 'queryCellInfo';\n/** @hidden */\n\nvar headerCellInfo = 'headerCellInfo';\n/** @hidden */\n\nvar actionBegin = 'actionBegin';\n/** @hidden */\n\nvar actionComplete = 'actionComplete';\n/** @hidden */\n\nvar actionFailure = 'actionFailure';\n/** @hidden */\n\nvar dataBound = 'dataBound';\n/** @hidden */\n\nvar rowSelecting = 'rowSelecting';\n/** @hidden */\n\nvar rowSelected = 'rowSelected';\n/** @hidden */\n\nvar rowDeselecting = 'rowDeselecting';\n/** @hidden */\n\nvar rowDeselected = 'rowDeselected';\n/** @hidden */\n\nvar cellSelecting = 'cellSelecting';\n/** @hidden */\n\nvar cellSelected = 'cellSelected';\n/** @hidden */\n\nvar cellDeselecting = 'cellDeselecting';\n/** @hidden */\n\nvar cellDeselected = 'cellDeselected';\n/** @hidden */\n\nvar columnSelecting = 'columnSelecting';\n/** @hidden */\n\nvar columnSelected = 'columnSelected';\n/** @hidden */\n\nvar columnDeselecting = 'columnDeselecting';\n/** @hidden */\n\nvar columnDeselected = 'columnDeselected';\n/** @hidden */\n\nvar columnDragStart = 'columnDragStart';\n/** @hidden */\n\nvar columnDrag = 'columnDrag';\n/** @hidden */\n\nvar columnDrop = 'columnDrop';\n/** @hidden */\n\nvar rowDragStartHelper = 'rowDragStartHelper';\n/** @hidden */\n\nvar rowDragStart = 'rowDragStart';\n/** @hidden */\n\nvar rowDrag = 'rowDrag';\n/** @hidden */\n\nvar rowDrop = 'rowDrop';\n/** @hidden */\n\nvar beforePrint = 'beforePrint';\n/** @hidden */\n\nvar printComplete = 'printComplete';\n/** @hidden */\n\nvar detailDataBound = 'detailDataBound';\n/** @hidden */\n\nvar toolbarClick = 'toolbarClick';\n/** @hidden */\n\nvar batchAdd = 'batchAdd';\n/** @hidden */\n\nvar batchCancel = 'batchCancel';\n/** @hidden */\n\nvar batchDelete = 'batchDelete';\n/** @hidden */\n\nvar beforeBatchAdd = 'beforeBatchAdd';\n/** @hidden */\n\nvar beforeBatchDelete = 'beforeBatchDelete';\n/** @hidden */\n\nvar beforeBatchSave = 'beforeBatchSave';\n/** @hidden */\n\nvar beginEdit = 'beginEdit';\n/** @hidden */\n\nvar cellEdit = 'cellEdit';\n/** @hidden */\n\nvar cellSave = 'cellSave';\n/** @hidden */\n\nvar cellSaved = 'cellSaved';\n/** @hidden */\n\nvar endAdd = 'endAdd';\n/** @hidden */\n\nvar endDelete = 'endDelete';\n/** @hidden */\n\nvar endEdit = 'endEdit';\n/** @hidden */\n\nvar recordDoubleClick = 'recordDoubleClick';\n/** @hidden */\n\nvar recordClick = 'recordClick';\n/** @hidden */\n\nvar beforeDataBound = 'beforeDataBound';\n/** @hidden */\n\nvar beforeOpenColumnChooser = 'beforeOpenColumnChooser';\n/** @hidden */\n\nvar beforeOpenAdaptiveDialog = 'beforeOpenAdaptiveDialog';\n/** @hidden */\n\nvar resizeStart = 'resizeStart';\n/** @hidden */\n\nvar onResize = 'resizing';\n/** @hidden */\n\nvar resizeStop = 'resizeStop';\n/** @hidden */\n\nvar checkBoxChange = 'checkBoxChange';\n/** @hidden */\n\nvar beforeCopy = 'beforeCopy';\n/** @hidden */\n\nvar beforePaste = 'beforePaste';\n/** @hidden */\n\nvar beforeAutoFill = 'beforeAutoFill';\n/** @hidden */\n\nvar filterChoiceRequest = 'filterchoicerequest';\n/** @hidden */\n\nvar filterAfterOpen = 'filterafteropen';\n/** @hidden */\n\nvar filterBeforeOpen = 'filterbeforeopen';\n/** @hidden */\n\nvar filterSearchBegin = 'filtersearchbegin';\n/** @hidden */\n\nvar commandClick = 'commandClick';\n/** @hidden */\n\nvar exportGroupCaption = 'exportGroupCaption';\n/** @hidden */\n\nvar lazyLoadGroupExpand = 'lazyLoadGroupExpand';\n/** @hidden */\n\nvar lazyLoadGroupCollapse = 'lazyLoadGroupCollapse';\n/**\n * Specifies grid internal events\n */\n\n/** @hidden */\n\nvar initialLoad = 'initial-load';\n/** @hidden */\n\nvar initialEnd = 'initial-end';\n/** @hidden */\n\nvar dataReady = 'data-ready';\n/** @hidden */\n\nvar contentReady = 'content-ready';\n/** @hidden */\n\nvar uiUpdate = 'ui-update';\n/** @hidden */\n\nvar onEmpty = 'on-empty';\n/** @hidden */\n\nvar inBoundModelChanged = 'inbound-model-changed';\n/** @hidden */\n\nvar modelChanged = 'model-changed';\n/** @hidden */\n\nvar colGroupRefresh = 'colgroup-refresh';\n/** @hidden */\n\nvar headerRefreshed = 'header-refreshed';\n/** @hidden */\n\nvar pageBegin = 'paging-begin';\n/** @hidden */\n\nvar pageComplete = 'paging-complete';\n/** @hidden */\n\nvar sortBegin = 'sorting-begin';\n/** @hidden */\n\nvar sortComplete = 'sorting-complete';\n/** @hidden */\n\nvar filterBegin = 'filtering-begin';\n/** @hidden */\n\nvar filterComplete = 'filtering-complete';\n/** @hidden */\n\nvar searchBegin = 'searching-begin';\n/** @hidden */\n\nvar searchComplete = 'searching-complete';\n/** @hidden */\n\nvar reorderBegin = 'reorder-begin';\n/** @hidden */\n\nvar reorderComplete = 'reorder-complete';\n/** @hidden */\n\nvar rowDragAndDropBegin = 'rowdraganddrop-begin';\n/** @hidden */\n\nvar rowDragAndDropComplete = 'rowdraganddrop-complete';\n/** @hidden */\n\nvar groupBegin = 'grouping-begin';\n/** @hidden */\n\nvar groupComplete = 'grouping-complete';\n/** @hidden */\n\nvar ungroupBegin = 'ungrouping-begin';\n/** @hidden */\n\nvar ungroupComplete = 'ungrouping-complete';\n/** @hidden */\n\nvar groupAggregates = 'group-aggregates';\n/** @hidden */\n\nvar refreshFooterRenderer = 'refresh-footer-rendered';\n/** @hidden */\n\nvar refreshAggregateCell = 'refresh-aggregate-cell';\n/** @hidden */\n\nvar refreshAggregates = 'refresh-aggregates';\n/** @hidden */\n\nvar rowSelectionBegin = 'rowselecting';\n/** @hidden */\n\nvar rowSelectionComplete = 'rowselected';\n/** @hidden */\n\nvar columnSelectionBegin = 'columnselecting';\n/** @hidden */\n\nvar columnSelectionComplete = 'columnselected';\n/** @hidden */\n\nvar cellSelectionBegin = 'cellselecting';\n/** @hidden */\n\nvar cellSelectionComplete = 'cellselected';\n/** @hidden */\n\nvar beforeCellFocused = 'beforecellfocused';\n/** @hidden */\n\nvar cellFocused = 'cellfocused';\n/** @hidden */\n\nvar keyPressed = 'key-pressed';\n/** @hidden */\n\nvar click = 'click';\n/** @hidden */\n\nvar destroy = 'destroy';\n/** @hidden */\n\nvar columnVisibilityChanged = 'column-visible-changed';\n/** @hidden */\n\nvar scroll = 'scroll';\n/** @hidden */\n\nvar columnWidthChanged = 'column-width-changed';\n/** @hidden */\n\nvar columnPositionChanged = 'column-position-changed';\n/** @hidden */\n\nvar rowDragAndDrop = 'row-drag-and-drop';\n/** @hidden */\n\nvar rowsAdded = 'rows-added';\n/** @hidden */\n\nvar rowsRemoved = 'rows-removed';\n/** @hidden */\n\nvar columnDragStop = 'column-drag-stop';\n/** @hidden */\n\nvar headerDrop = 'header-drop';\n/** @hidden */\n\nvar dataSourceModified = 'datasource-modified';\n/** @hidden */\n\nvar refreshComplete = 'refresh-complete';\n/** @hidden */\n\nvar refreshVirtualBlock = 'refresh-virtual-block';\n/** @hidden */\n\nvar dblclick = 'dblclick';\n/** @hidden */\n\nvar toolbarRefresh = 'toolbar-refresh';\n/** @hidden */\n\nvar bulkSave = 'bulk-save';\n/** @hidden */\n\nvar autoCol = 'auto-col';\n/** @hidden */\n\nvar tooltipDestroy = 'tooltip-destroy';\n/** @hidden */\n\nvar updateData = 'update-data';\n/** @hidden */\n\nvar editBegin = 'edit-begin';\n/** @hidden */\n\nvar editComplete = 'edit-complete';\n/** @hidden */\n\nvar addBegin = 'add-begin';\n/** @hidden */\n\nvar addComplete = 'add-complete';\n/** @hidden */\n\nvar saveComplete = 'save-complete';\n/** @hidden */\n\nvar deleteBegin = 'delete-begin';\n/** @hidden */\n\nvar deleteComplete = 'delete-complete';\n/** @hidden */\n\nvar preventBatch = 'prevent-batch';\n/** @hidden */\n\nvar dialogDestroy = 'dialog-destroy';\n/** @hidden */\n\nvar crudAction = 'crud-Action';\n/** @hidden */\n\nvar addDeleteAction = 'add-delete-Action';\n/** @hidden */\n\nvar destroyForm = 'destroy-form';\n/** @hidden */\n\nvar doubleTap = 'double-tap';\n/** @hidden */\n\nvar beforeExcelExport = 'beforeExcelExport';\n/** @hidden */\n\nvar excelExportComplete = 'excelExportComplete';\n/** @hidden */\n\nvar excelQueryCellInfo = 'excelQueryCellInfo';\n/** @hidden */\n\nvar excelHeaderQueryCellInfo = 'excelHeaderQueryCellInfo';\n/** @hidden */\n\nvar exportDetailDataBound = 'exportDetailDataBound';\n/** @hidden */\n\nvar beforePdfExport = 'beforePdfExport';\n/** @hidden */\n\nvar pdfExportComplete = 'pdfExportComplete';\n/** @hidden */\n\nvar pdfQueryCellInfo = 'pdfQueryCellInfo';\n/** @hidden */\n\nvar pdfHeaderQueryCellInfo = 'pdfHeaderQueryCellInfo';\n/** @hidden */\n\nvar accessPredicate = 'access-predicate';\n/** @hidden */\n\nvar contextMenuClick = 'contextMenuClick';\n/** @hidden */\n\nvar freezeRender = 'freezerender';\n/** @hidden */\n\nvar freezeRefresh = 'freezerefresh';\n/** @hidden */\n\nvar contextMenuOpen = 'contextMenuOpen';\n/** @hidden */\n\nvar columnMenuClick = 'columnMenuClick';\n/** @hidden */\n\nvar columnMenuOpen = 'columnMenuOpen';\n/** @hidden */\n\nvar filterOpen = 'filterOpen';\n/** @hidden */\n\nvar filterDialogCreated = 'filterDialogCreated';\n/** @hidden */\n\nvar filterMenuClose = 'filter-menu-close';\n/** @hidden */\n\nvar initForeignKeyColumn = 'initForeignKeyColumn';\n/** @hidden */\n\nvar getForeignKeyData = 'getForeignKeyData';\n/** @hidden */\n\nvar generateQuery = 'generateQuery';\n/** @hidden */\n\nvar showEmptyGrid = 'showEmptyGrid';\n/** @hidden */\n\nvar foreignKeyData = 'foreignKeyData';\n/** @hidden */\n\nvar columnDataStateChange = 'columnDataStateChange';\n/** @hidden */\n\nvar dataStateChange = 'dataStateChange';\n/** @hidden */\n\nvar dataSourceChanged = 'dataSourceChanged';\n/** @hidden */\n\nvar rtlUpdated = 'rtl-updated';\n/** @hidden */\n\nvar beforeFragAppend = 'beforeFragAppend';\n/** @hidden */\n\nvar frozenHeight = 'frozenHeight';\n/** @hidden */\n\nvar textWrapRefresh = 'textWrapRefresh';\n/** @hidden */\n\nvar recordAdded = 'recordAdded';\n/** @hidden */\n\nvar cancelBegin = 'cancel-Begin';\n/** @hidden */\n\nvar editNextValCell = 'editNextValCell';\n/** @hidden */\n\nvar hierarchyPrint = 'hierarchyprint';\n/** @hidden */\n\nvar expandChildGrid = 'expandchildgrid';\n/** @hidden */\n\nvar printGridInit = 'printGrid-Init';\n/** @hidden */\n\nvar exportRowDataBound = 'export-RowDataBound';\n/** @hidden */\n\nvar exportDataBound = 'export-DataBound';\n/** @hidden */\n\nvar rowPositionChanged = 'row-position-changed';\n/** @hidden */\n\nvar columnChooserOpened = 'columnChooserOpened';\n/** @hidden */\n\nvar batchForm = 'batchedit-form';\n/** @hidden */\n\nvar beforeStartEdit = 'edit-form';\n/** @hidden */\n\nvar beforeBatchCancel = 'before-batch-cancel';\n/** @hidden */\n\nvar batchEditFormRendered = 'batcheditform-rendered';\n/** @hidden */\n\nvar partialRefresh = 'partial-refresh';\n/** @hidden */\n\nvar beforeCustomFilterOpen = 'beforeCustomFilterOpen';\n/** @hidden */\n\nvar selectVirtualRow = 'select-virtual-Row';\n/** @hidden */\n\nvar columnsPrepared = 'columns-prepared';\n/** @hidden */\n\nvar cBoxFltrBegin = 'cbox-filter-begin';\n/** @hidden */\n\nvar cBoxFltrComplete = 'cbox-filter-complete';\n/** @hidden */\n\nvar fltrPrevent = 'filter-Prevent';\n/** @hidden */\n\nvar beforeFltrcMenuOpen = 'before-filter-cmenu-open';\n/** @hidden */\n\nvar valCustomPlacement = 'validation-custom-placement';\n/** @hidden */\n\nvar filterCboxValue = 'filter-cbox-value';\n/** @hidden */\n\nvar componentRendered = 'component-rendered';\n/** @hidden */\n\nvar restoreFocus = 'restore-Focus';\n/** @hidden */\n\nvar detailStateChange = 'detail-state-change';\n/** @hidden */\n\nvar detailIndentCellInfo = 'detail-indentcell-info';\n/** @hidden */\n\nvar virtaulKeyHandler = 'virtaul-key-handler';\n/** @hidden */\n\nvar virtaulCellFocus = 'virtaul-cell-focus';\n/** @hidden */\n\nvar virtualScrollEditActionBegin = 'virtual-scroll-edit-action-begin';\n/** @hidden */\n\nvar virtualScrollEditSuccess = 'virtual-scroll-edit-success';\n/** @hidden */\n\nvar virtualScrollEditCancel = 'virtual-scroll-edit-cancel';\n/** @hidden */\n\nvar virtualScrollEdit = 'virtual-scroll-edit';\n/** @hidden */\n\nvar refreshVirtualCache = 'refresh-virtual-cache';\n/** @hidden */\n\nvar editReset = 'edit-reset';\n/** @hidden */\n\nvar virtualScrollAddActionBegin = 'virtual-scroll-add-action-begin';\n/** @hidden */\n\nvar getVirtualData = 'get-virtual-data';\n/** @hidden */\n\nvar refreshInfiniteModeBlocks = 'refresh-infinite-mode-blocks';\n/** @hidden */\n\nvar resetInfiniteBlocks = 'reset-infinite-blocks';\n/** @hidden */\n\nvar infiniteScrollHandler = 'infinite-scroll-handler';\n/** @hidden */\n\nvar infinitePageQuery = 'infinite-page-query';\n/** @hidden */\n\nvar infiniteShowHide = 'infinite-show-hide';\n/** @hidden */\n\nvar appendInfiniteContent = 'append-infinite-content';\n/** @hidden */\n\nvar removeInfiniteRows = 'remove-infinite-rows';\n/** @hidden */\n\nvar setInfiniteCache = 'set-infinite-cache';\n/** @hidden */\n\nvar infiniteEditHandler = 'infinite-edit-handler';\n/** @hidden */\n\nvar initialCollapse = 'initial-collapse';\n/** @hidden */\n\nvar getAggregateQuery = 'get-aggregate-query';\n/** @hidden */\n\nvar closeFilterDialog = 'close-filter-dialog';\n/** @hidden */\n\nvar columnChooserCancelBtnClick = 'columnChooserCancelBtnClick';\n/** @hidden */\n\nvar getFilterBarOperator = 'get-filterbar-operator';\n/** @hidden */\n\nvar resetColumns = 'reset-columns';\n/** @hidden */\n\nvar pdfAggregateQueryCellInfo = 'pdfAggregateQueryCellInfo';\n/** @hidden */\n\nvar excelAggregateQueryCellInfo = 'excelAggregateQueryCellInfo';\n/** @hidden */\n\nvar setGroupCache = 'group-cache';\n/** @hidden */\n\nvar lazyLoadScrollHandler = 'lazy-load-scroll-handler';\n/** @hidden */\n\nvar groupCollapse = 'group-collapse';\n/** @hidden */\n\nvar beforeCheckboxRenderer = 'beforeCheckboxRenderer';\n/** @hidden */\n\nvar refreshHandlers = 'refreshResizeHandlers';\n/** @hidden */\n\nvar refreshFrozenColumns = 'refresh-frozen-columns';\n/** @hidden */\n\nvar setReorderDestinationElement = 'set-reorder-destination-element';\n/** @hidden */\n\nvar refreshVirtualFrozenHeight = 'refresh-virtual-frozen-height';\n/** @hidden */\n\nvar setFreezeSelection = 'set-freeze-selection';\n/** @hidden */\n\nvar setInfiniteFrozenHeight = 'set-infinite-frozen-height';\n/** @hidden */\n\nvar setInfiniteColFrozenHeight = 'set-infinite-col-frozen-height';\n/** @hidden */\n\nvar beforeRefreshOnDataChange = 'before-refresh-on-data-change';\n/** @hidden */\n\nvar immutableBatchCancel = 'immutable-batch-cancel';\n/** @hidden */\n\nvar refreshVirtualFrozenRows = 'refresh-virtual-frozenrows';\n/** @hidden */\n\nvar checkScrollReset = 'check-scroll-reset';\n/** @hidden */\n\nvar refreshFrozenHeight = 'refresh-frozen-height';\n/** @hidden */\n\nvar setHeightToFrozenElement = 'set-height-to-frozen-element';\n/** @hidden */\n\nvar preventFrozenScrollRefresh = 'prevent-frozen-scroll-refresh';\n/** @hidden */\n\nvar nextCellIndex = 'next-cell-index';\n/** @hidden */\n\nvar refreshInfiniteCurrentViewData = 'refresh-infinite-current-view-data';\n/** @hidden */\n\nvar infiniteCrudCancel = 'infinite-crud-cancel';\n/** @hidden */\n\nvar filterDialogClose = 'filter-dialog-close';\n/** @hidden */\n\nvar refreshCustomFilterOkBtn = 'refresh-cutsom-filter-ok-button';\n/** @hidden */\n\nvar refreshCustomFilterClearBtn = 'refresh-cutsom-filter-clear-button';\n/** @hidden */\n\nvar renderResponsiveCmenu = 'render-responsive-cmenu';\n/** @hidden */\n\nvar filterCmenuSelect = 'filter-cmenu-select';\n/** @hidden */\n\nvar customFilterClose = 'custom-filter-close';\n/** @hidden */\n\nvar setFullScreenDialog = 'set-fullscreen-dialog';\n/** @hidden */\n\nvar refreshExpandandCollapse = 'refresh-Expand-and-Collapse';\n/** @hidden */\n\nvar rowModeChange = 'row-mode-change';\n/** @hidden */\n\nvar enterKeyHandler = 'enter-key-handler';\n/** @hidden */\n\nvar refreshVirtualMaxPage = 'refresh-virtual-max-page';\n/** @hidden */\n\nvar setVirtualPageQuery = 'set-virtual-page-query';\n/** @hidden */\n\nvar selectRowOnContextOpen = 'select-row-on-context-open';\n/** @hidden */\n\nvar pagerRefresh = 'pager-refresh';\n/** @hidden */\n\nvar closeInline = 'closeinline';\n/** @hidden */\n\nvar closeBatch = 'closebatch';\n/** @hidden */\n\nvar closeEdit = 'close-edit';\n/** @hidden */\n\nvar resetVirtualFocus = 'reset-virtual-focus';\n/** @hidden */\n\nvar afterContentRender = 'after-content-renderer';\n/** @hidden */\n\nvar refreshVirtualEditFormCells = 'refresh-virtual-editform-cells';\n/** @hidden */\n\nvar scrollToEdit = 'scroll-to-edit';\n/** @hidden */\n\nvar beforeCheckboxRendererQuery = 'before-checkbox-renderer-query';\n/** @hidden */\n\nvar createVirtualValidationForm = 'create-virtual-validation-form';\n/** @hidden */\n\nvar validateVirtualForm = 'validate-virtual-form';\n/** @hidden */\n\nvar destroyChildGrid = 'destroy-child-grid';\n/** @hidden */\n\nvar stickyScrollComplete = 'sticky-scroll-complete';\n/** @hidden */\n\nvar captionActionComplete = 'infinite-group-collapse';\n/** @hidden */\n\nvar refreshInfinitePersistSelection = 'refresh-infinite-persist-selection';\n/** @hidden */\n\nvar refreshInfiniteEditrowindex = 'refresh-infinite-editrowindex';\n/** @hidden */\n\nvar afterFilterColumnMenuClose = 'after-filter-column-menu-close';\n/** @hidden */\n\nvar beforeCheckboxfilterRenderer = 'beforeCheckboxfilterRenderer';\n/** @hidden */\n\nvar commandColumnDestroy = 'commandColumnDestroy';\n/**\n * Defines types of Cell\n *\n * @hidden\n */\n\nvar CellType = /*#__PURE__*/(() => {\n  (function (CellType) {\n    /**  Defines CellType as Data */\n    CellType[CellType[\"Data\"] = 0] = \"Data\";\n    /**  Defines CellType as Header */\n\n    CellType[CellType[\"Header\"] = 1] = \"Header\";\n    /**  Defines CellType as Summary */\n\n    CellType[CellType[\"Summary\"] = 2] = \"Summary\";\n    /**  Defines CellType as GroupSummary */\n\n    CellType[CellType[\"GroupSummary\"] = 3] = \"GroupSummary\";\n    /**  Defines CellType as CaptionSummary */\n\n    CellType[CellType[\"CaptionSummary\"] = 4] = \"CaptionSummary\";\n    /**  Defines CellType as Filter */\n\n    CellType[CellType[\"Filter\"] = 5] = \"Filter\";\n    /**  Defines CellType as Indent */\n\n    CellType[CellType[\"Indent\"] = 6] = \"Indent\";\n    /**  Defines CellType as GroupCaption */\n\n    CellType[CellType[\"GroupCaption\"] = 7] = \"GroupCaption\";\n    /**  Defines CellType as GroupCaptionEmpty */\n\n    CellType[CellType[\"GroupCaptionEmpty\"] = 8] = \"GroupCaptionEmpty\";\n    /**  Defines CellType as Expand */\n\n    CellType[CellType[\"Expand\"] = 9] = \"Expand\";\n    /**  Defines CellType as HeaderIndent */\n\n    CellType[CellType[\"HeaderIndent\"] = 10] = \"HeaderIndent\";\n    /**  Defines CellType as StackedHeader */\n\n    CellType[CellType[\"StackedHeader\"] = 11] = \"StackedHeader\";\n    /**  Defines CellType as DetailHeader */\n\n    CellType[CellType[\"DetailHeader\"] = 12] = \"DetailHeader\";\n    /**  Defines CellType as DetailExpand */\n\n    CellType[CellType[\"DetailExpand\"] = 13] = \"DetailExpand\";\n    /**  Defines CellType as CommandColumn */\n\n    CellType[CellType[\"CommandColumn\"] = 14] = \"CommandColumn\";\n    /**  Defines CellType as DetailFooterIntent */\n\n    CellType[CellType[\"DetailFooterIntent\"] = 15] = \"DetailFooterIntent\";\n    /**  Defines CellType as RowDrag */\n\n    CellType[CellType[\"RowDragIcon\"] = 16] = \"RowDragIcon\";\n    /**  Defines CellType as RowDragHeader */\n\n    CellType[CellType[\"RowDragHIcon\"] = 17] = \"RowDragHIcon\";\n  })(CellType || (CellType = {}));\n\n  return CellType;\n})();\n\n/**\n * Defines types of Render\n *\n * @hidden\n */\nvar RenderType = /*#__PURE__*/(() => {\n  (function (RenderType) {\n    /**  Defines RenderType as Header */\n    RenderType[RenderType[\"Header\"] = 0] = \"Header\";\n    /**  Defines RenderType as Content */\n\n    RenderType[RenderType[\"Content\"] = 1] = \"Content\";\n    /**  Defines RenderType as Summary */\n\n    RenderType[RenderType[\"Summary\"] = 2] = \"Summary\";\n  })(RenderType || (RenderType = {}));\n\n  return RenderType;\n})();\n\n/**\n * Defines Predefined toolbar items.\n *\n * @hidden\n */\nvar ToolbarItem = /*#__PURE__*/(() => {\n  (function (ToolbarItem) {\n    ToolbarItem[ToolbarItem[\"Add\"] = 0] = \"Add\";\n    ToolbarItem[ToolbarItem[\"Edit\"] = 1] = \"Edit\";\n    ToolbarItem[ToolbarItem[\"Update\"] = 2] = \"Update\";\n    ToolbarItem[ToolbarItem[\"Delete\"] = 3] = \"Delete\";\n    ToolbarItem[ToolbarItem[\"Cancel\"] = 4] = \"Cancel\";\n    ToolbarItem[ToolbarItem[\"Print\"] = 5] = \"Print\";\n    ToolbarItem[ToolbarItem[\"Search\"] = 6] = \"Search\";\n    ToolbarItem[ToolbarItem[\"ColumnChooser\"] = 7] = \"ColumnChooser\";\n    ToolbarItem[ToolbarItem[\"PdfExport\"] = 8] = \"PdfExport\";\n    ToolbarItem[ToolbarItem[\"ExcelExport\"] = 9] = \"ExcelExport\";\n    ToolbarItem[ToolbarItem[\"CsvExport\"] = 10] = \"CsvExport\";\n    ToolbarItem[ToolbarItem[\"WordExport\"] = 11] = \"WordExport\";\n  })(ToolbarItem || (ToolbarItem = {}));\n\n  return ToolbarItem;\n})();\n\n/**\n * Defines types of responsive dialogs\n *\n * @hidden\n */\nvar ResponsiveDialogAction = /*#__PURE__*/(() => {\n  (function (ResponsiveDialogAction) {\n    /**  Defines dialog type as Edit */\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isEdit\"] = 0] = \"isEdit\";\n    /**  Defines dialog type as Add */\n\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isAdd\"] = 1] = \"isAdd\";\n    /**  Defines dialog type as Sort */\n\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isSort\"] = 2] = \"isSort\";\n    /**  Defines dialog type as Filter */\n\n    ResponsiveDialogAction[ResponsiveDialogAction[\"isFilter\"] = 3] = \"isFilter\";\n  })(ResponsiveDialogAction || (ResponsiveDialogAction = {}));\n\n  return ResponsiveDialogAction;\n})();\n\n/**\n * Defines responsive toolbar actions\n *\n * @hidden\n */\nvar ResponsiveToolbarAction = /*#__PURE__*/(() => {\n  (function (ResponsiveToolbarAction) {\n    /**  Defines initial responsive toolbar buttons */\n    ResponsiveToolbarAction[ResponsiveToolbarAction[\"isInitial\"] = 0] = \"isInitial\";\n    /**  Defines responsive toolbar search */\n\n    ResponsiveToolbarAction[ResponsiveToolbarAction[\"isSearch\"] = 1] = \"isSearch\";\n  })(ResponsiveToolbarAction || (ResponsiveToolbarAction = {}));\n\n  return ResponsiveToolbarAction;\n})();\n\n/**\n * Grid data module is used to generate query and data source.\n *\n * @hidden\n */\nvar Data =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for data module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the service locator\n   * @hidden\n   */\n  function Data(parent, serviceLocator) {\n    this.dataState = {\n      isPending: false,\n      resolver: null,\n      group: []\n    };\n    this.foreignKeyDataState = {\n      isPending: false,\n      resolver: null\n    };\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.initDataManager();\n\n    if (this.parent.isDestroyed || this.getModuleName() === 'foreignKey') {\n      return;\n    }\n\n    this.parent.on(rowsAdded, this.addRows, this);\n    this.parent.on(rowPositionChanged, this.reorderRows, this);\n    this.parent.on(rowsRemoved, this.removeRows, this);\n    this.parent.on(dataSourceModified, this.initDataManager, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(updateData, this.crudActions, this);\n    this.parent.on(addDeleteAction, this.getData, this);\n    this.parent.on(autoCol, this.refreshFilteredCols, this);\n    this.parent.on(columnsPrepared, this.refreshFilteredCols, this);\n  }\n\n  Data.prototype.reorderRows = function (e) {\n    this.dataManager.dataSource.json.splice(e.toIndex, 0, this.dataManager.dataSource.json.splice(e.fromIndex, 1)[0]);\n  };\n\n  Data.prototype.getModuleName = function () {\n    return 'data';\n  };\n  /**\n   * The function used to initialize dataManager and external query\n   *\n   * @returns {void}\n   */\n\n\n  Data.prototype.initDataManager = function () {\n    var gObj = this.parent;\n    this.dataManager = gObj.dataSource instanceof DataManager ? gObj.dataSource : isNullOrUndefined(gObj.dataSource) ? new DataManager() : new DataManager(gObj.dataSource);\n\n    if (gObj.isAngular && !(gObj.query instanceof Query)) {\n      gObj.setProperties({\n        query: new Query()\n      }, true);\n    } else {\n      this.isQueryInvokedFromData = true;\n      gObj.query = gObj.query instanceof Query ? gObj.query : new Query();\n    }\n  };\n  /**\n   * The function is used to generate updated Query from Grid model.\n   *\n   * @param {boolean} skipPage - specifies the boolean to skip the page\n   * @returns {Query} returns the Query\n   * @hidden\n   */\n\n\n  Data.prototype.generateQuery = function (skipPage) {\n    var gObj = this.parent;\n    var query = gObj.getQuery().clone();\n\n    if (this.parent.columnQueryMode === 'ExcludeHidden') {\n      query.select(this.parent.getColumns().filter(function (column) {\n        return !(column.isPrimaryKey !== true && column.visible === false || column.field === undefined);\n      }).map(function (column) {\n        return column.field;\n      }));\n    } else if (this.parent.columnQueryMode === 'Schema') {\n      var selectQueryFields = [];\n      var columns = this.parent.columns;\n\n      for (var i = 0; i < columns.length; i++) {\n        selectQueryFields.push(columns[i].field);\n      }\n\n      query.select(selectQueryFields);\n    }\n\n    this.filterQuery(query);\n    this.searchQuery(query);\n    this.aggregateQuery(query);\n    this.sortQuery(query);\n\n    if (isGroupAdaptive(this.parent)) {\n      this.virtualGroupPageQuery(query);\n    } else {\n      this.pageQuery(query, skipPage);\n    }\n\n    this.groupQuery(query);\n    return query;\n  };\n  /**\n   * @param {Query} query - specifies the query\n   * @returns {Query} - returns the query\n   * @hidden\n   */\n\n\n  Data.prototype.aggregateQuery = function (query) {\n    var rows = this.parent.aggregates;\n\n    for (var i = 0; i < rows.length; i++) {\n      var row = rows[i];\n\n      for (var j = 0; j < row.columns.length; j++) {\n        var cols = row.columns[j];\n        var types = cols.type instanceof Array ? cols.type : [cols.type];\n\n        for (var k = 0; k < types.length; k++) {\n          query.aggregate(types[k].toLowerCase(), cols.field);\n        }\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.virtualGroupPageQuery = function (query) {\n    var fName = 'fn';\n\n    if (query.queries.length) {\n      for (var i = 0; i < query.queries.length; i++) {\n        if (query.queries[i][fName] === 'onPage') {\n          query.queries.splice(i, 1);\n        }\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.pageQuery = function (query, skipPage) {\n    var gObj = this.parent;\n    var fName = 'fn';\n    var args = {\n      query: query,\n      skipPage: false\n    };\n    gObj.notify(setVirtualPageQuery, args);\n\n    if (args.skipPage) {\n      return query;\n    }\n\n    if ((gObj.allowPaging || gObj.enableVirtualization || gObj.enableInfiniteScrolling) && skipPage !== true) {\n      gObj.pageSettings.currentPage = Math.max(1, gObj.pageSettings.currentPage);\n\n      if (gObj.pageSettings.pageCount <= 0) {\n        gObj.pageSettings.pageCount = 8;\n      }\n\n      if (gObj.pageSettings.pageSize <= 0) {\n        gObj.pageSettings.pageSize = 12;\n      }\n\n      if (query.queries.length) {\n        for (var i = 0; i < query.queries.length; i++) {\n          if (query.queries[i][fName] === 'onPage') {\n            query.queries.splice(i, 1);\n          }\n        }\n      }\n\n      if (!isNullOrUndefined(gObj.infiniteScrollModule) && gObj.enableInfiniteScrolling) {\n        this.parent.notify(infinitePageQuery, query);\n      } else {\n        query.page(gObj.pageSettings.currentPage, gObj.allowPaging && gObj.pagerModule && gObj.pagerModule.pagerObj.isAllPage && !this.dataManager.dataSource.offline ? null : gObj.pageSettings.pageSize);\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.groupQuery = function (query) {\n    var gObj = this.parent;\n\n    if (gObj.allowGrouping && gObj.groupSettings.columns.length) {\n      if (this.parent.groupSettings.enableLazyLoading) {\n        query.lazyLoad.push({\n          key: 'isLazyLoad',\n          value: this.parent.groupSettings.enableLazyLoading\n        });\n      }\n\n      var columns = gObj.groupSettings.columns;\n\n      for (var i = 0, len = columns.length; i < len; i++) {\n        var column = this.getColumnByField(columns[i]);\n\n        if (!column) {\n          this.parent.log('initial_action', {\n            moduleName: 'group',\n            columnName: columns[i]\n          });\n        }\n\n        var isGrpFmt = column.enableGroupByFormat;\n        var format = column.format;\n\n        if (isGrpFmt) {\n          query.group(columns[i], this.formatGroupColumn.bind(this), format);\n        } else {\n          query.group(columns[i], null);\n        }\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.sortQuery = function (query) {\n    var gObj = this.parent;\n\n    if ((gObj.allowSorting || gObj.allowGrouping) && gObj.sortSettings.columns.length) {\n      var columns = gObj.sortSettings.columns;\n      var sortGrp = [];\n\n      for (var i = columns.length - 1; i > -1; i--) {\n        var col = this.getColumnByField(columns[i].field);\n\n        if (col) {\n          col.setSortDirection(columns[i].direction);\n        } else {\n          this.parent.log('initial_action', {\n            moduleName: 'sort',\n            columnName: columns[i].field\n          });\n          return query;\n        }\n\n        var fn = columns[i].direction;\n\n        if (col.sortComparer) {\n          this.parent.log('grid_sort_comparer');\n          fn = !this.isRemote() ? col.sortComparer.bind(col) : columns[i].direction;\n        }\n\n        if (gObj.groupSettings.columns.indexOf(columns[i].field) === -1) {\n          if (col.isForeignColumn() || col.sortComparer) {\n            query.sortByForeignKey(col.field, fn, undefined, columns[i].direction.toLowerCase());\n          } else {\n            query.sortBy(col.field, fn);\n          }\n        } else {\n          sortGrp.push({\n            direction: fn,\n            field: col.field\n          });\n        }\n      }\n\n      for (var i = 0, len = sortGrp.length; i < len; i++) {\n        if (typeof sortGrp[i].direction === 'string') {\n          query.sortBy(sortGrp[i].field, sortGrp[i].direction);\n        } else {\n          var col = this.getColumnByField(sortGrp[i].field);\n          query.sortByForeignKey(sortGrp[i].field, sortGrp[i].direction, undefined, col.getSortDirection().toLowerCase());\n        }\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.searchQuery = function (query, fcolumn, isForeignKey) {\n    var sSettings = this.parent.searchSettings;\n    var fields = sSettings.fields.length ? sSettings.fields : this.getSearchColumnFieldNames();\n    var predicateList = [];\n    var needForeignKeySearch = false;\n\n    if (this.parent.searchSettings.key.length) {\n      needForeignKeySearch = this.parent.getForeignKeyColumns().some(function (col) {\n        return fields.indexOf(col.field) > -1;\n      });\n      var adaptor = !isForeignKey ? this.dataManager.adaptor : fcolumn.dataSource.adaptor;\n\n      if (needForeignKeySearch || adaptor.getModuleName && adaptor.getModuleName() === 'ODataV4Adaptor') {\n        fields = isForeignKey ? [fcolumn.foreignKeyValue] : fields;\n\n        for (var i = 0; i < fields.length; i++) {\n          var column = isForeignKey ? fcolumn : this.getColumnByField(fields[i]);\n\n          if (column.isForeignColumn() && !isForeignKey) {\n            predicateList = this.fGeneratePredicate(column, predicateList);\n          } else {\n            predicateList.push(new Predicate(fields[i], sSettings.operator, sSettings.key, sSettings.ignoreCase, sSettings.ignoreAccent));\n          }\n        }\n\n        var predList = Predicate.or(predicateList);\n        predList.key = sSettings.key;\n        query.where(predList);\n      } else {\n        query.search(sSettings.key, fields, sSettings.operator, sSettings.ignoreCase, sSettings.ignoreAccent);\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.filterQuery = function (query, column, skipFoerign) {\n    var gObj = this.parent;\n    var predicateList = [];\n    var actualFilter = [];\n    var foreignColumn = this.parent.getForeignKeyColumns();\n    var foreignColEmpty;\n\n    if (gObj.allowFiltering && gObj.filterSettings.columns.length) {\n      var columns = column ? column : gObj.filterSettings.columns;\n      var colType = {};\n\n      for (var _i = 0, _a = gObj.getColumns(); _i < _a.length; _i++) {\n        var col = _a[_i];\n        colType[col.field] = col.filter.type ? col.filter.type : gObj.filterSettings.type;\n      }\n\n      var foreignCols = [];\n      var defaultFltrCols = [];\n\n      for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) {\n        var col = columns_1[_b];\n        var gridColumn = gObj.getColumnByField(col.field);\n\n        if (isNullOrUndefined(col.type) && gridColumn && (gridColumn.type === 'date' || gridColumn.type === 'datetime')) {\n          col.type = gObj.getColumnByField(col.field).type;\n        }\n\n        if (col.isForeignKey) {\n          foreignCols.push(col);\n        } else {\n          defaultFltrCols.push(col);\n        }\n      }\n\n      if (defaultFltrCols.length) {\n        for (var i = 0, len = defaultFltrCols.length; i < len; i++) {\n          defaultFltrCols[i].uid = defaultFltrCols[i].uid || this.parent.grabColumnByFieldFromAllCols(defaultFltrCols[i].field).uid;\n        }\n\n        var excelPredicate = CheckBoxFilterBase.getPredicate(defaultFltrCols);\n\n        for (var _c = 0, _d = Object.keys(excelPredicate); _c < _d.length; _c++) {\n          var prop = _d[_c];\n          predicateList.push(excelPredicate[prop]);\n        }\n      }\n\n      if (foreignCols.length) {\n        for (var _e = 0, foreignCols_1 = foreignCols; _e < foreignCols_1.length; _e++) {\n          var col = foreignCols_1[_e];\n          col.uid = col.uid || this.parent.grabColumnByFieldFromAllCols(col.field).uid;\n          var column_1 = this.parent.grabColumnByUidFromAllCols(col.uid);\n\n          if (!column_1) {\n            this.parent.log('initial_action', {\n              moduleName: 'filter',\n              columnName: col.field\n            });\n          }\n\n          if (column_1.isForeignColumn() && getColumnByForeignKeyValue(col.field, foreignColumn) && !skipFoerign) {\n            actualFilter.push(col);\n\n            if (!column_1.columnData.length) {\n              foreignColEmpty = true;\n            }\n\n            predicateList = this.fGeneratePredicate(column_1, predicateList);\n          } else {\n            var excelPredicate = CheckBoxFilterBase.getPredicate(columns);\n\n            for (var _f = 0, _g = Object.keys(excelPredicate); _f < _g.length; _f++) {\n              var prop = _g[_f];\n              predicateList.push(excelPredicate[prop]);\n            }\n          }\n        }\n      }\n\n      if (predicateList.length && !foreignColEmpty) {\n        query.where(Predicate.and(predicateList));\n      } else {\n        this.parent.notify(showEmptyGrid, {});\n      }\n    }\n\n    return query;\n  };\n\n  Data.prototype.fGeneratePredicate = function (col, predicateList) {\n    var fPredicate = {};\n\n    if (col) {\n      this.parent.notify(generateQuery, {\n        predicate: fPredicate,\n        column: col\n      });\n\n      if (fPredicate.predicate.predicates.length) {\n        predicateList.push(fPredicate.predicate);\n      }\n    }\n\n    return predicateList;\n  };\n  /**\n   * The function is used to get dataManager promise by executing given Query.\n   *\n   * @param {object} args - specifies the object\n   * @param {string} args.requestType - Defines the request type\n   * @param {string[]} args.foreignKeyData - Defines the foreignKeyData.string\n   * @param {Object} args.data - Defines the data.\n   * @param {number} args.index - Defines the index .\n   * @param {Query} query - Defines the query which will execute along with data processing.\n   * @returns {Promise<Object>} - returns the object\n   * @hidden\n   */\n\n\n  Data.prototype.getData = function (args, query) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = {\n        requestType: ''\n      };\n    }\n\n    var key = this.getKey(args.foreignKeyData && Object.keys(args.foreignKeyData).length ? args.foreignKeyData : this.parent.getPrimaryKeyFieldNames());\n    this.parent.log('datasource_syntax_mismatch', {\n      dataState: this.parent\n    });\n\n    if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n      var def = this.eventPromise(args, query, key);\n      return def.promise;\n    } else {\n      var crud = void 0;\n\n      switch (args.requestType) {\n        case 'delete':\n          query = query ? query : this.generateQuery(); // eslint-disable-next-line no-case-declarations\n\n          var len = Object.keys(args.data).length;\n\n          if (len === 1) {\n            crud = this.dataManager.remove(key, args.data[0], query.fromTable, query);\n          } else {\n            var changes = {\n              addedRecords: [],\n              deletedRecords: [],\n              changedRecords: []\n            };\n            changes.deletedRecords = args.data;\n            crud = this.dataManager.saveChanges(changes, key, query.fromTable, query.requiresCount());\n          }\n\n          break;\n\n        case 'save':\n          query = query ? query : this.generateQuery();\n          args.index = isNullOrUndefined(args.index) ? 0 : args.index;\n          crud = this.dataManager.insert(args.data, query.fromTable, query, args.index);\n          break;\n      }\n\n      var promise = 'promise';\n      args[promise] = crud; // eslint-disable-next-line no-prototype-builtins\n\n      if (crud && !Array.isArray(crud) && !crud.hasOwnProperty('deletedRecords')) {\n        return crud.then(function () {\n          return _this.insert(query, args);\n        });\n      } else {\n        return this.insert(query, args);\n      }\n    }\n  };\n\n  Data.prototype.insert = function (query, args) {\n    if (args.requestType === 'save') {\n      this.parent.notify(recordAdded, args);\n    }\n\n    return this.executeQuery(query);\n  };\n\n  Data.prototype.executeQuery = function (query) {\n    var _this = this;\n\n    if (this.dataManager.ready) {\n      var deferred_1 = new Deferred();\n      var ready = this.dataManager.ready;\n      ready.then(function () {\n        _this.dataManager.executeQuery(query).then(function (result) {\n          deferred_1.resolve(result);\n        });\n      }).catch(function (e) {\n        deferred_1.reject(e);\n      });\n      return deferred_1.promise;\n    } else {\n      return this.dataManager.executeQuery(query);\n    }\n  };\n\n  Data.prototype.formatGroupColumn = function (value, field) {\n    var serviceLocator = this.serviceLocator;\n    var column = this.getColumnByField(field);\n    var date = value;\n\n    if (!column.type) {\n      column.type = date.getDay ? date.getHours() > 0 || date.getMinutes() > 0 || date.getSeconds() > 0 || date.getMilliseconds() > 0 ? 'datetime' : 'date' : typeof value;\n    }\n\n    if (isNullOrUndefined(column.getFormatter())) {\n      setFormatter(serviceLocator, column);\n    }\n\n    var formatVal = ValueFormatter.prototype.toView(value, column.getFormatter());\n    return formatVal;\n  };\n\n  Data.prototype.crudActions = function (args) {\n    var query = this.generateQuery();\n    var promise = null;\n    var pr = 'promise';\n    var key = this.getKey(args.foreignKeyData && Object.keys(args.foreignKeyData).length ? args.foreignKeyData : this.parent.getPrimaryKeyFieldNames());\n\n    if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n      this.eventPromise(args, query, key);\n    }\n\n    switch (args.requestType) {\n      case 'save':\n        promise = this.dataManager.update(key, args.data, query.fromTable, query, args.previousData);\n        break;\n    }\n\n    args[pr] = promise ? promise : args[pr];\n    this.parent.notify(crudAction, args);\n  };\n  /**\n   * @param {object} changes - specifies the changes\n   * @param {string} key - specifies the key\n   * @param {object} original - specifies the original data\n   * @param {Query} query - specifies the query\n   * @returns {Promise<Object>} returns the object\n   * @hidden\n   */\n\n\n  Data.prototype.saveChanges = function (changes, key, original, query) {\n    if (query === void 0) {\n      query = this.generateQuery();\n    }\n\n    query.requiresCount();\n\n    if ('result' in this.parent.dataSource) {\n      var deff = new Deferred();\n      var args = {\n        requestType: 'batchsave',\n        changes: changes,\n        key: key,\n        query: query,\n        endEdit: deff.resolve\n      };\n      this.setState({\n        isPending: true,\n        resolver: deff.resolve\n      });\n      this.parent.trigger(dataSourceChanged, args);\n      return deff.promise;\n    } else {\n      var promise = this.dataManager.saveChanges(changes, key, query.fromTable, query, original);\n      return promise;\n    }\n  };\n\n  Data.prototype.getKey = function (keys) {\n    if (keys && keys.length) {\n      return keys[0];\n    }\n\n    return undefined;\n  };\n  /**\n   * @returns {boolean} returns whether its remote data\n   * @hidden\n   */\n\n\n  Data.prototype.isRemote = function () {\n    return this.dataManager.dataSource.offline !== true && this.dataManager.dataSource.url !== undefined && this.dataManager.dataSource.url !== '';\n  };\n\n  Data.prototype.addRows = function (e) {\n    for (var i = e.records.length; i > 0; i--) {\n      this.dataManager.dataSource.json.splice(e.toIndex, 0, e.records[i - 1]);\n    }\n  };\n\n  Data.prototype.removeRows = function (e) {\n    var json = this.dataManager.dataSource.json;\n    this.dataManager.dataSource.json = json.filter(function (value) {\n      return e.records.indexOf(value) === -1;\n    });\n  };\n\n  Data.prototype.getColumnByField = function (field) {\n    var col;\n    return this.parent.columnModel.some(function (column) {\n      col = column;\n      return column.field === field;\n    }) && col;\n  };\n\n  Data.prototype.destroy = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(rowsAdded, this.addRows);\n    this.parent.off(rowsRemoved, this.removeRows);\n    this.parent.off(dataSourceModified, this.initDataManager);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(updateData, this.crudActions);\n    this.parent.off(addDeleteAction, this.getData);\n    this.parent.off(autoCol, this.refreshFilteredCols);\n    this.parent.off(columnsPrepared, this.refreshFilteredCols);\n  };\n\n  Data.prototype.getState = function () {\n    return this.dataState;\n  };\n\n  Data.prototype.setState = function (state) {\n    return this.dataState = state;\n  };\n\n  Data.prototype.getForeignKeyDataState = function () {\n    return this.foreignKeyDataState;\n  };\n\n  Data.prototype.setForeignKeyDataState = function (state) {\n    this.foreignKeyDataState = state;\n  };\n\n  Data.prototype.getStateEventArgument = function (query) {\n    var adaptr = new UrlAdaptor();\n    var dm = new DataManager({\n      url: '',\n      adaptor: new UrlAdaptor()\n    });\n    var state = adaptr.processQuery(dm, query);\n    var data = JSON.parse(state.data);\n    return extend(data, state.pvtData);\n  };\n\n  Data.prototype.eventPromise = function (args, query, key) {\n    var _this = this;\n\n    var dataArgs = args;\n    var state = this.getStateEventArgument(query);\n    var def = new Deferred();\n    var deff = new Deferred();\n\n    if (args.requestType !== undefined && this.dataState.isDataChanged !== false) {\n      state.action = args;\n\n      if (args.requestType === 'save' || args.requestType === 'delete') {\n        var editArgs_1 = args;\n        editArgs_1.key = key;\n        var promise = 'promise';\n        editArgs_1[promise] = deff.promise;\n        editArgs_1.state = state;\n        this.setState({\n          isPending: true,\n          resolver: deff.resolve\n        });\n        dataArgs.endEdit = deff.resolve;\n        dataArgs.cancelEdit = deff.reject;\n        this.parent.trigger(dataSourceChanged, editArgs_1);\n        deff.promise.then(function () {\n          _this.setState({\n            isPending: true,\n            resolver: def.resolve,\n            group: state.group,\n            aggregates: state.aggregates\n          });\n\n          if (editArgs_1.requestType === 'save') {\n            _this.parent.notify(recordAdded, editArgs_1);\n          }\n\n          _this.parent.trigger(dataStateChange, state);\n        }).catch(function () {\n          return void 0;\n        });\n      } else {\n        this.setState({\n          isPending: true,\n          resolver: def.resolve,\n          group: state.group,\n          aggregates: state.aggregates\n        });\n        this.parent.trigger(dataStateChange, state);\n      }\n    } else {\n      this.setState({});\n      def.resolve(this.parent.dataSource);\n    }\n\n    return def;\n  };\n  /**\n   * Gets the columns where searching needs to be performed from the Grid.\n   *\n   * @returns {string[]} returns the searched column field names\n   */\n\n\n  Data.prototype.getSearchColumnFieldNames = function () {\n    var colFieldNames = [];\n    var columns = this.parent.getColumns();\n\n    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n      var col = columns_2[_i];\n\n      if (col.allowSearching && !isNullOrUndefined(col.field)) {\n        colFieldNames.push(col.field);\n      }\n    }\n\n    return colFieldNames;\n  };\n\n  Data.prototype.refreshFilteredCols = function () {\n    if (this.parent.allowFiltering && this.parent.filterSettings.columns.length) {\n      refreshFilteredColsUid(this.parent, this.parent.filterSettings.columns);\n    }\n  };\n\n  return Data;\n}();\n/**\n * Row\n *\n * @hidden\n */\n\n\nvar Row =\n/** @__PURE__ @class */\nfunction () {\n  function Row(options, parent) {\n    merge(this, options);\n    this.parent = parent;\n  }\n\n  Row.prototype.clone = function () {\n    var row = new Row({});\n    merge(row, this);\n    row.cells = this.cells.map(function (cell) {\n      return cell.clone();\n    });\n    return row;\n  };\n  /**\n   * Replaces the row data and grid refresh the particular row element only.\n   *\n   * @param  {Object} data - To update new data for the particular row.\n   * @returns {void}\n   */\n\n\n  Row.prototype.setRowValue = function (data) {\n    if (!this.parent) {\n      return;\n    }\n\n    var key = this.data[this.parent.getPrimaryKeyFieldNames()[0]];\n    this.parent.setRowData(key, data);\n  };\n  /**\n   * Replaces the given field value and refresh the particular cell element only.\n   *\n   * @param {string} field - Specifies the field name which you want to update.\n   * @param {string | number | boolean | Date} value - To update new value for the particular cell.\n   * @returns {void}\n   */\n\n\n  Row.prototype.setCellValue = function (field, value) {\n    if (!this.parent) {\n      return;\n    }\n\n    var isValDiff = !(this.data[field].toString() === value.toString());\n\n    if (isValDiff) {\n      var pKeyField = this.parent.getPrimaryKeyFieldNames()[0];\n      var key = this.data[pKeyField];\n      this.parent.setCellValue(key, field, value);\n      this.makechanges(pKeyField, this.data);\n    } else {\n      return;\n    }\n  };\n\n  Row.prototype.makechanges = function (key, data) {\n    if (!this.parent) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var dataManager = gObj.getDataModule().dataManager;\n    dataManager.update(key, data);\n  };\n\n  return Row;\n}();\n/**\n * Cell\n *\n * @hidden\n */\n\n\nvar Cell =\n/** @__PURE__ @class */\nfunction () {\n  function Cell(options) {\n    this.isSpanned = false;\n    this.isRowSpanned = false;\n    merge(this, options);\n  }\n\n  Cell.prototype.clone = function () {\n    var cell = new Cell({});\n    merge(cell, this);\n    return cell;\n  };\n\n  return Cell;\n}();\n/**\n * `CellMergeRender` module.\n *\n * @hidden\n */\n\n\nvar CellMergeRender =\n/** @__PURE__ @class */\nfunction () {\n  function CellMergeRender(serviceLocator, parent) {\n    this.serviceLocator = serviceLocator;\n    this.parent = parent;\n  }\n\n  CellMergeRender.prototype.render = function (cellArgs, row, i, td) {\n    var cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n    var cellRenderer = cellRendererFact.getCellRenderer(row.cells[i].cellType || CellType.Data);\n    var colSpan = row.cells[i].cellSpan ? row.cells[i].cellSpan : cellArgs.colSpan + i <= row.cells.length ? cellArgs.colSpan : row.cells.length - i;\n    var rowSpan = cellArgs.rowSpan;\n    var visible = 0;\n    var spannedCell;\n\n    if (row.index > 0) {\n      var cells = this.parent.groupSettings.columns.length > 0 && !this.parent.getRowsObject()[row.index - 1].isDataRow ? this.parent.getRowsObject()[row.index].cells : this.parent.getRowsObject()[row.index - 1].cells;\n      var targetCell_1 = row.cells[i];\n      var uid_1 = 'uid';\n      spannedCell = cells.filter(function (cell) {\n        return cell.column.uid === targetCell_1.column[uid_1];\n      })[0];\n    }\n\n    var colSpanLen = spannedCell && spannedCell.colSpanRange > 1 && spannedCell.rowSpanRange > 1 ? spannedCell.colSpanRange : colSpan;\n\n    for (var j = i + 1; j < i + colSpanLen && j < row.cells.length; j++) {\n      if (row.cells[j].visible === false) {\n        visible++;\n      } else {\n        row.cells[j].isSpanned = true;\n      }\n    }\n\n    if (visible > 0) {\n      for (var j = i + colSpan; j < i + colSpan + visible && j < row.cells.length; j++) {\n        row.cells[j].isSpanned = true;\n      }\n\n      if (i + colSpan + visible >= row.cells.length) {\n        colSpan -= i + colSpan + visible - row.cells.length;\n      }\n    }\n\n    if (row.cells[i].cellSpan) {\n      row.data[cellArgs.column.field] = row.cells[i].spanText;\n      td = cellRenderer.render(row.cells[i], row.data, {\n        'index': !isNullOrUndefined(row.index) ? row.index.toString() : ''\n      });\n    }\n\n    if (colSpan > 1) {\n      attributes(td, {\n        'colSpan': colSpan.toString(),\n        'aria-colSpan': colSpan.toString()\n      });\n    }\n\n    if (rowSpan > 1) {\n      attributes(td, {\n        'rowspan': rowSpan.toString(),\n        'aria-rowspan': rowSpan.toString()\n      });\n      row.cells[i].isRowSpanned = true;\n      row.cells[i].rowSpanRange = Number(rowSpan);\n\n      if (colSpan > 1) {\n        row.cells[i].colSpanRange = Number(colSpan);\n      }\n    }\n\n    if (row.index > 0 && spannedCell.rowSpanRange > 1) {\n      row.cells[i].isSpanned = true;\n      row.cells[i].rowSpanRange = Number(spannedCell.rowSpanRange - 1);\n      row.cells[i].colSpanRange = spannedCell.rowSpanRange > 0 ? spannedCell.colSpanRange : 1;\n    }\n\n    if (this.parent.enableColumnVirtualization && !row.cells[i].cellSpan && !this.containsKey(cellArgs.column.field, cellArgs.data[cellArgs.column.field])) {\n      this.backupMergeCells(cellArgs.column.field, cellArgs.data[cellArgs.column.field], cellArgs.colSpan);\n    }\n\n    return td;\n  };\n\n  CellMergeRender.prototype.backupMergeCells = function (fName, data, span) {\n    this.setMergeCells(this.generteKey(fName, data), span);\n  };\n\n  CellMergeRender.prototype.generteKey = function (fname, data) {\n    return fname + '__' + data.toString();\n  };\n\n  CellMergeRender.prototype.splitKey = function (key) {\n    return key.split('__');\n  };\n\n  CellMergeRender.prototype.containsKey = function (fname, data) {\n    // eslint-disable-next-line no-prototype-builtins\n    return this.getMergeCells().hasOwnProperty(this.generteKey(fname, data));\n  };\n\n  CellMergeRender.prototype.getMergeCells = function () {\n    return this.parent.mergeCells;\n  };\n\n  CellMergeRender.prototype.setMergeCells = function (key, span) {\n    this.parent.mergeCells[key] = span;\n  };\n\n  CellMergeRender.prototype.updateVirtualCells = function (rows) {\n    var mCells = this.getMergeCells();\n\n    for (var _i = 0, _a = Object.keys(mCells); _i < _a.length; _i++) {\n      var key = _a[_i];\n      var value = mCells[key];\n      var merge$$1 = this.splitKey(key);\n      var columnIndex = this.getIndexFromAllColumns(merge$$1[0]);\n      var vColumnIndices = this.parent.getColumnIndexesInView();\n      var span = value - (vColumnIndices[0] - columnIndex);\n\n      if (columnIndex < vColumnIndices[0] && span > 1) {\n        for (var _b = 0, rows_1 = rows; _b < rows_1.length; _b++) {\n          var row = rows_1[_b];\n\n          if (row.data[merge$$1[0]].toString() === merge$$1[1].toString()) {\n            row.cells[0].cellSpan = span;\n            row.cells[0].spanText = merge$$1[1];\n            break;\n          }\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  CellMergeRender.prototype.getIndexFromAllColumns = function (field) {\n    var index = iterateArrayOrObject(this.parent.getVisibleColumns(), function (item, index) {\n      if (item.field === field) {\n        return index;\n      }\n\n      return undefined;\n    })[0];\n    return index;\n  };\n\n  return CellMergeRender;\n}();\n/**\n * Specifies class names\n */\n\n/** @hidden */\n\n\nvar rowCell = 'e-rowcell';\n/** @hidden */\n\nvar gridHeader = 'e-gridheader';\n/** @hidden */\n\nvar gridContent = 'e-gridcontent';\n/** @hidden */\n\nvar gridFooter = 'e-gridfooter';\n/** @hidden */\n\nvar headerContent = 'e-headercontent';\n/** @hidden */\n\nvar movableContent = 'e-movablecontent';\n/** @hidden */\n\nvar movableHeader = 'e-movableheader';\n/** @hidden */\n\nvar frozenContent = 'e-frozencontent';\n/** @hidden */\n\nvar frozenHeader = 'e-frozenheader';\n/** @hidden */\n\nvar content = 'e-content';\n/** @hidden */\n\nvar table = 'e-table';\n/** @hidden */\n\nvar row = 'e-row';\n/** @hidden */\n\nvar gridChkBox = 'e-gridchkbox';\n/** @hidden */\n\nvar editedRow = 'e-editedrow';\n/** @hidden */\n\nvar addedRow = 'e-addedrow';\n/**\n * Specifies repeated strings\n */\n\n/** @hidden */\n\nvar changedRecords = 'changedRecords';\n/** @hidden */\n\nvar addedRecords = 'addedRecords';\n/** @hidden */\n\nvar deletedRecords = 'deletedRecords';\n/** @hidden */\n\nvar leftRight = 'Left-Right';\n/** @hidden */\n\nvar frozenRight = 'frozen-right';\n/** @hidden */\n\nvar frozenLeft = 'frozen-left';\n/** @hidden */\n\nvar dataColIndex = 'data-colindex';\n/** @hidden */\n\nvar ariaColIndex = 'aria-colindex';\n/** @hidden */\n\nvar dataRowIndex = 'data-rowindex';\n/** @hidden */\n\nvar ariaRowIndex = 'aria-rowindex';\n/** @hidden */\n\nvar tbody = 'tbody';\n/** @hidden */\n\nvar colGroup = 'colgroup';\n/** @hidden */\n\nvar open = 'open';\n/** @hidden */\n\nvar change = 'change';\n/** @hidden */\n\nvar focus = 'focus';\n/** @hidden */\n\nvar create = 'created';\n/** @hidden */\n\nvar beforeOpen = 'beforeOpen';\n/** @hidden */\n\nvar downArrow = 'downArrow';\n/** @hidden */\n\nvar upArrow = 'upArrow';\n/** @hidden */\n\nvar pageUp = 'PageUp';\n/** @hidden */\n\nvar pageDown = 'PageDown';\n/** @hidden */\n\nvar enter = 'enter';\n/** @hidden */\n\nvar shiftEnter = 'shiftEnter';\n/** @hidden */\n\nvar tab = 'tab';\n/** @hidden */\n\nvar shiftTab = 'shiftTab';\n/**\n * RowRenderer class which responsible for building row content.\n *\n * @hidden\n */\n\nvar RowRenderer =\n/** @__PURE__ @class */\nfunction () {\n  function RowRenderer(serviceLocator, cellType, parent) {\n    this.isSpan = false;\n    this.cellType = cellType;\n    this.serviceLocator = serviceLocator;\n    this.parent = parent;\n    this.element = this.parent.createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n  }\n  /* eslint-disable */\n\n  /**\n   * Function to render the row content based on Column[] and data.\n   *\n   * @param {Row<T>} row - specifies the row\n   * @param {Column[]} columns - specifies the columns\n   * @param {Object} attributes - specifies the attributes\n   * @param {string} rowTemplate - specifies the rowTemplate\n   * @param {Element} cloneNode - specifies the cloneNode\n   * @returns {Element} returns the element\n   */\n\n  /* eslint-enable */\n\n\n  RowRenderer.prototype.render = function (row$$1, columns, attributes$$1, rowTemplate, cloneNode) {\n    return this.refreshRow(row$$1, columns, attributes$$1, rowTemplate, cloneNode);\n  };\n  /* eslint-disable */\n\n  /**\n   * Function to refresh the row content based on Column[] and data.\n   *\n   * @param {Row<T>} row - specifies the row\n   * @param {Column[]} columns - specifies the column\n   * @param {boolean} isChanged - specifies isChanged\n   * @param {Object} attributes - specifies the attributes\n   * @param {string} rowTemplate - specifies the rowTemplate\n   * @returns {void}\n   */\n\n  /* eslint-enable */\n\n\n  RowRenderer.prototype.refresh = function (row$$1, columns, isChanged, attributes$$1, rowTemplate) {\n    var _this = this;\n\n    if (isChanged) {\n      row$$1.data = extendObjWithFn({}, row$$1.changes);\n      this.refreshMergeCells(row$$1);\n    }\n\n    var node = this.parent.element.querySelector('[data-uid=' + row$$1.uid + ']');\n    var tr = this.refreshRow(row$$1, columns, attributes$$1, rowTemplate, null, isChanged);\n    var cells = [].slice.call(tr.cells);\n    var tempCells = [].slice.call(node.querySelectorAll('.e-templatecell'));\n\n    if (this.parent.isReact && tempCells.length) {\n      var _loop_1 = function (col) {\n        if (col.template) {\n          setTimeout(function () {\n            _this.parent.refreshReactColumnTemplateByUid(col.uid);\n          }, 0);\n          return \"break\";\n        }\n      };\n\n      for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n        var col = columns_1[_i];\n\n        var state_1 = _loop_1(col);\n\n        if (state_1 === \"break\") break;\n      }\n    }\n\n    node.innerHTML = '';\n\n    for (var _a = 0, cells_1 = cells; _a < cells_1.length; _a++) {\n      var cell = cells_1[_a];\n      node.appendChild(cell);\n    }\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  RowRenderer.prototype.refreshRow = function (row$$1, columns, attributes$$1, rowTemplate, cloneNode, isEdit) {\n    var tr = !isNullOrUndefined(cloneNode) ? cloneNode : this.element.cloneNode();\n    var rowArgs = {\n      data: row$$1.data\n    };\n    var cellArgs = {\n      data: row$$1.data\n    };\n    var chekBoxEnable = this.parent.getColumns().filter(function (col) {\n      return col.type === 'checkbox' && col.field;\n    })[0];\n    var value = false;\n\n    if (chekBoxEnable) {\n      value = getObject(chekBoxEnable.field, rowArgs.data);\n    }\n\n    var selIndex = this.parent.getSelectedRowIndexes();\n\n    if (row$$1.isDataRow) {\n      row$$1.isSelected = selIndex.indexOf(row$$1.index) > -1 || value;\n    }\n\n    if (row$$1.isDataRow && this.parent.isCheckBoxSelection && this.parent.checkAllRows === 'Check' && this.parent.enableVirtualization) {\n      row$$1.isSelected = true;\n\n      if (selIndex.indexOf(row$$1.index) === -1) {\n        selIndex.push(row$$1.index);\n      }\n    }\n\n    this.buildAttributeFromRow(tr, row$$1);\n    attributes(tr, extend({}, attributes$$1, {}));\n    setStyleAndAttributes(tr, row$$1.attributes);\n    var cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n\n    var _loop_2 = function (i, len) {\n      var cell = row$$1.cells[i];\n      cell.isSelected = row$$1.isSelected;\n      cell.isColumnSelected = cell.column.isSelected;\n      var cellRenderer = cellRendererFact.getCellRenderer(row$$1.cells[i].cellType || CellType.Data);\n      var attrs = {\n        'index': !isNullOrUndefined(row$$1.index) ? row$$1.index.toString() : ''\n      };\n\n      if (row$$1.isExpand && row$$1.cells[i].cellType === CellType.DetailExpand) {\n        attrs['class'] = this_1.parent.isPrinting ? 'e-detailrowcollapse' : 'e-detailrowexpand';\n      }\n\n      var td = cellRenderer.render(row$$1.cells[i], row$$1.data, attrs, row$$1.isExpand, isEdit);\n\n      if (row$$1.cells[i].cellType !== CellType.Filter) {\n        if (row$$1.cells[i].cellType === CellType.Data || row$$1.cells[i].cellType === CellType.CommandColumn) {\n          this_1.parent.trigger(queryCellInfo, extend(cellArgs, {\n            cell: td,\n            column: cell.column,\n            colSpan: 1,\n            rowSpan: 1,\n            foreignKeyData: row$$1.cells[i].foreignKeyData,\n            requestType: this_1.parent.requestTypeAction\n          }));\n          var isRowSpanned = false;\n\n          if (row$$1.index > 0 && this_1.isSpan) {\n            var prevRowCells = this_1.parent.groupSettings.columns.length > 0 && !this_1.parent.getRowsObject()[row$$1.index - 1].isDataRow ? this_1.parent.getRowsObject()[row$$1.index].cells : this_1.parent.getRowsObject()[row$$1.index - 1].cells;\n            var uid_1 = 'uid';\n            var prevRowCell = prevRowCells.filter(function (cell) {\n              return cell.column.uid === row$$1.cells[i].column[uid_1];\n            })[0];\n            isRowSpanned = prevRowCell.isRowSpanned ? prevRowCell.isRowSpanned : prevRowCell.rowSpanRange > 1;\n          }\n\n          if (cellArgs.colSpan > 1 || row$$1.cells[i].cellSpan > 1 || cellArgs.rowSpan > 1 || isRowSpanned) {\n            this_1.isSpan = true;\n            var cellMerge = new CellMergeRender(this_1.serviceLocator, this_1.parent);\n            td = cellMerge.render(cellArgs, row$$1, i, td);\n          }\n        }\n\n        if (!row$$1.cells[i].isSpanned) {\n          tr.appendChild(td);\n        }\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = 0, len = row$$1.cells.length; i < len; i++) {\n      _loop_2(i, len);\n    }\n\n    var args = {\n      row: tr,\n      rowHeight: this.parent.rowHeight\n    };\n\n    if (row$$1.isDataRow) {\n      var eventArg = extend(rowArgs, args);\n      eventArg.isSelectable = true;\n      this.parent.trigger(rowDataBound, eventArg);\n      row$$1.isSelectable = eventArg.isSelectable;\n      var isDraggable = this.parent.isRowDragable();\n\n      if (this.parent.allowPaging && this.parent.selectionSettings.persistSelection) {\n        var primaryKey_1 = this.parent.getPrimaryKeyFieldNames()[0];\n        var pKey_1 = row$$1.data ? row$$1.data[primaryKey_1] : null;\n        var SelectedRecords = eventArg.isSelectable ? this.parent.partialSelectedRecords : this.parent.disableSelectedRecords;\n\n        if (!SelectedRecords.some(function (data) {\n          return data[primaryKey_1] === pKey_1;\n        })) {\n          SelectedRecords.push(row$$1.data);\n        }\n      }\n\n      if (!eventArg.isSelectable) {\n        this.parent.selectionModule.isPartialSelection = true;\n        row$$1.isSelected = false;\n        var chkBox = args.row.querySelectorAll('.e-rowcell.e-gridchkbox');\n        var isDrag = eventArg.row.querySelector('.e-rowdragdrop');\n        var cellIdx = this.parent.groupSettings.columns.length + (isDrag || this.parent.isDetail() ? 1 : 0);\n\n        for (var i = 0; i < chkBox.length; i++) {\n          chkBox[i].firstElementChild.classList.add('e-checkbox-disabled');\n          chkBox[i].querySelector('.e-frame').classList.remove('e-check');\n        }\n\n        if (row$$1.cells.length) {\n          for (var i = cellIdx; i < row$$1.cells.length; i++) {\n            var cell = eventArg.row.querySelector('.e-rowcell[data-colindex=\"' + row$$1.cells[i].index + '\"]');\n\n            if (cell) {\n              removeClass([cell], ['e-selectionbackground', 'e-active']);\n            }\n          }\n        }\n\n        if (isDrag) {\n          removeClass([isDrag], ['e-selectionbackground', 'e-active']);\n        }\n      }\n\n      if (this.parent.childGrid || isDraggable || this.parent.detailTemplate) {\n        var td = tr.querySelectorAll('.e-rowcell:not(.e-hide)')[0];\n\n        if (td) {\n          td.classList.add('e-detailrowvisible');\n        }\n      }\n    }\n\n    if (this.parent.enableVirtualization) {\n      rowArgs.rowHeight = this.parent.rowHeight;\n    }\n\n    if (rowArgs.rowHeight) {\n      tr.style.height = rowArgs.rowHeight + 'px';\n    } else if (this.parent.rowHeight && (tr.querySelector('.e-headercell') || tr.querySelector('.e-groupcaption'))) {\n      tr.style.height = this.parent.rowHeight + 'px';\n    }\n\n    if (row$$1.cssClass) {\n      tr.classList.add(row$$1.cssClass);\n    }\n\n    if (row$$1.lazyLoadCssClass) {\n      tr.classList.add(row$$1.lazyLoadCssClass);\n    }\n\n    var vFTable = this.parent.enableColumnVirtualization && this.parent.frozenColumns !== 0;\n\n    if (!vFTable && this.parent.aggregates.length && this.parent.element.scrollHeight > this.parent.height) {\n      for (var i = 0; i < this.parent.aggregates.length; i++) {\n        var property = 'properties';\n        var column = 'columns';\n\n        if (this.parent.aggregates[i][property][column][0].footerTemplate) {\n          var summarycell = [].slice.call(tr.getElementsByClassName('e-summarycell'));\n\n          if (summarycell.length) {\n            var lastSummaryCell = summarycell[summarycell.length - 1];\n            addClass([lastSummaryCell], ['e-lastsummarycell']);\n            var firstSummaryCell = summarycell[0];\n            addClass([firstSummaryCell], ['e-firstsummarycell']);\n          }\n        }\n      }\n    }\n\n    return tr;\n  };\n\n  RowRenderer.prototype.refreshMergeCells = function (row$$1) {\n    for (var _i = 0, _a = row$$1.cells; _i < _a.length; _i++) {\n      var cell = _a[_i];\n      cell.isSpanned = false;\n    }\n\n    return row$$1;\n  };\n  /* eslint-disable */\n\n  /**\n   * Function to check and add alternative row css class.\n   *\n   * @param {Element} tr - specifies the tr element\n   * @param {Row<T>} row - specifies the row\n   * @returns {void}\n   */\n\n  /* eslint-enable */\n\n\n  RowRenderer.prototype.buildAttributeFromRow = function (tr, row$$1) {\n    var attr = {};\n    var prop = {\n      'rowindex': dataRowIndex,\n      'dataUID': 'data-uid',\n      'ariaSelected': 'aria-selected'\n    };\n    var classes = [];\n\n    if (row$$1.isDataRow) {\n      classes.push(row);\n    }\n\n    if (row$$1.isAltRow) {\n      classes.push('e-altrow');\n    }\n\n    if (!isNullOrUndefined(row$$1.index)) {\n      attr[ariaRowIndex] = row$$1.index + 1;\n      attr[prop.rowindex] = row$$1.index;\n    }\n\n    if (row$$1.rowSpan) {\n      attr.rowSpan = row$$1.rowSpan;\n    }\n\n    if (row$$1.uid) {\n      attr[prop.dataUID] = row$$1.uid;\n    }\n\n    if (row$$1.isSelected) {\n      attr[prop.ariaSelected] = true;\n    }\n\n    if (row$$1.visible === false) {\n      classes.push('e-hide');\n    }\n\n    attr.class = classes;\n    setStyleAndAttributes(tr, attr);\n  };\n\n  return RowRenderer;\n}();\n/**\n * RowModelGenerator is used to generate grid data rows.\n *\n * @hidden\n */\n\n\nvar RowModelGenerator =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for header renderer module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   */\n  function RowModelGenerator(parent) {\n    this.parent = parent;\n  }\n\n  RowModelGenerator.prototype.generateRows = function (data, args) {\n    var rows = [];\n    var startIndex = this.parent.enableVirtualization && args ? args.startIndex : 0;\n    startIndex = this.parent.enableInfiniteScrolling && args ? this.getInfiniteIndex(args) : startIndex;\n\n    for (var i = 0, len = Object.keys(data).length; i < len; i++, startIndex++) {\n      rows[i] = this.generateRow(data[i], startIndex);\n    }\n\n    return rows;\n  };\n\n  RowModelGenerator.prototype.ensureColumns = function () {\n    //TODO: generate dummy column for group, detail here;\n    var cols = [];\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      var args = {};\n      this.parent.notify(detailIndentCellInfo, args);\n      cols.push(this.generateCell(args, null, CellType.DetailExpand));\n    }\n\n    if (this.parent.isRowDragable()) {\n      cols.push(this.generateCell({}, null, CellType.RowDragIcon));\n    }\n\n    return cols;\n  };\n\n  RowModelGenerator.prototype.generateRow = function (data, index, cssClass, indent, pid, tIndex, parentUid) {\n    var options = {};\n    options.foreignKeyData = {};\n    options.uid = getUid('grid-row');\n    options.data = data;\n    options.index = index;\n    options.indent = indent;\n    options.tIndex = tIndex;\n    options.isDataRow = true;\n    options.parentGid = pid;\n    options.parentUid = parentUid;\n\n    if (this.parent.isPrinting) {\n      if (this.parent.hierarchyPrintMode === 'All') {\n        options.isExpand = true;\n      } else if (this.parent.hierarchyPrintMode === 'Expanded' && this.parent.expandedRows && this.parent.expandedRows[index]) {\n        options.isExpand = this.parent.expandedRows[index].isExpand;\n      }\n    }\n\n    options.cssClass = cssClass;\n    options.isAltRow = this.parent.enableAltRow ? index % 2 !== 0 : false;\n    options.isAltRow = this.parent.enableAltRow ? index % 2 !== 0 : false;\n    options.isSelected = this.parent.getSelectedRowIndexes().indexOf(index) > -1;\n    this.refreshForeignKeyRow(options);\n    var cells = this.ensureColumns();\n    var row = new Row(options, this.parent);\n    row.cells = this.parent.getFrozenMode() === 'Right' ? this.generateCells(options).concat(cells) : cells.concat(this.generateCells(options));\n    return row;\n  };\n\n  RowModelGenerator.prototype.refreshForeignKeyRow = function (options) {\n    var foreignKeyColumns = this.parent.getForeignKeyColumns();\n\n    for (var i = 0; i < foreignKeyColumns.length; i++) {\n      setValue(foreignKeyColumns[i].field, getForeignData(foreignKeyColumns[i], options.data), options.foreignKeyData);\n    }\n  };\n\n  RowModelGenerator.prototype.generateCells = function (options) {\n    var dummies = this.parent.getColumns();\n    var tmp = [];\n\n    for (var i = 0; i < dummies.length; i++) {\n      tmp.push(this.generateCell(dummies[i], options.uid, isNullOrUndefined(dummies[i].commands) ? undefined : CellType.CommandColumn, null, i, options.foreignKeyData));\n    }\n\n    return tmp;\n  };\n  /**\n   *\n   * @param {Column} column - Defines column details\n   * @param {string} rowId - Defines row id\n   * @param {CellType} cellType  - Defines cell type\n   * @param {number} colSpan - Defines colSpan\n   * @param {number} oIndex - Defines index\n   * @param {Object} foreignKeyData - Defines foreign key data\n   * @returns {Cell<Column>} returns cell model\n   * @hidden\n   */\n\n\n  RowModelGenerator.prototype.generateCell = function (column, rowId, cellType, colSpan, oIndex, foreignKeyData$$1) {\n    var opt = {\n      'visible': column.visible,\n      'isDataCell': !isNullOrUndefined(column.field || column.template),\n      'isTemplate': !isNullOrUndefined(column.template),\n      'rowID': rowId,\n      'column': column,\n      'cellType': !isNullOrUndefined(cellType) ? cellType : CellType.Data,\n      'colSpan': colSpan,\n      'commands': column.commands,\n      'isForeignKey': column.isForeignColumn && column.isForeignColumn(),\n      'foreignKeyData': column.isForeignColumn && column.isForeignColumn() && getValue(column.field, foreignKeyData$$1)\n    };\n\n    if (opt.isDataCell || opt.column.type === 'checkbox' || opt.commands) {\n      opt.index = oIndex;\n    }\n\n    return new Cell(opt);\n  };\n\n  RowModelGenerator.prototype.refreshRows = function (input) {\n    for (var i = 0; i < input.length; i++) {\n      this.refreshForeignKeyRow(input[i]);\n      input[i].cells = this.generateCells(input[i]);\n    }\n\n    return input;\n  };\n\n  RowModelGenerator.prototype.getInfiniteIndex = function (args) {\n    return args.requestType === 'infiniteScroll' || args.requestType === 'delete' || args.action === 'add' ? args.startIndex : 0;\n  };\n\n  return RowModelGenerator;\n}();\n\nvar __extends$3 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Summary row model generator\n *\n * @hidden\n */\n\n\nvar SummaryModelGenerator =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for Summary row model generator\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   */\n  function SummaryModelGenerator(parent) {\n    this.parent = parent;\n  }\n\n  SummaryModelGenerator.prototype.getData = function () {\n    var _this = this;\n\n    var rows = [];\n    var row = this.parent.aggregates.slice();\n\n    for (var i = 0; i < row.length; i++) {\n      var columns = row[i].columns.filter(function (column) {\n        return !(column.footerTemplate || column.groupFooterTemplate || column.groupCaptionTemplate) || _this.columnSelector(column);\n      });\n\n      if (columns.length) {\n        rows.push({\n          columns: columns\n        });\n      }\n    }\n\n    return rows;\n  };\n\n  SummaryModelGenerator.prototype.columnSelector = function (column) {\n    return column.footerTemplate !== undefined;\n  };\n\n  SummaryModelGenerator.prototype.getColumns = function (start, end) {\n    var columns = [];\n\n    if (this.parent.allowGrouping) {\n      for (var i = 0; i < this.parent.groupSettings.columns.length; i++) {\n        columns.push(new Column({}));\n      }\n    }\n\n    if (this.parent.detailTemplate || !isNullOrUndefined(this.parent.childGrid)) {\n      columns.push(new Column({}));\n    }\n\n    if (this.parent.isRowDragable() && !start) {\n      columns.push(new Column({}));\n    }\n\n    columns.push.apply(columns, this.parent.getColumns());\n    end = end && !start ? end + this.parent.getIndentCount() : end;\n    return isNullOrUndefined(start) ? columns : columns.slice(start, end);\n  };\n\n  SummaryModelGenerator.prototype.generateRows = function (input, args, start, end, columns) {\n    if (input.length === 0) {\n      if (args === undefined || !args.count) {\n        return [];\n      }\n    }\n\n    var data = this.buildSummaryData(input, args);\n    var rows = [];\n    var row = this.getData();\n\n    for (var i = 0; i < row.length; i++) {\n      rows.push(this.getGeneratedRow(row[i], data[i], args ? args.level : undefined, start, end, args ? args.parentUid : undefined, columns));\n    }\n\n    return rows;\n  };\n\n  SummaryModelGenerator.prototype.getGeneratedRow = function (summaryRow, data, raw, start, end, parentUid, columns) {\n    var tmp = [];\n    var indents = this.getIndentByLevel();\n    var isDetailGridAlone = !isNullOrUndefined(this.parent.childGrid);\n    var indentLength = !start ? this.parent.getIndentCount() : 0;\n\n    if (this.parent.isRowDragable() && !start) {\n      indents = ['e-indentcelltop'];\n    }\n\n    var values = columns ? columns : this.getColumns(start, end);\n\n    for (var i = 0; i < values.length; i++) {\n      tmp.push(this.getGeneratedCell(values[i], summaryRow, i >= indentLength ? this.getCellType() : i < this.parent.groupSettings.columns.length ? CellType.Indent : CellType.DetailFooterIntent, indents[i], isDetailGridAlone));\n    }\n\n    var row = new Row({\n      data: data,\n      attributes: {\n        class: 'e-summaryrow'\n      }\n    });\n    row.cells = tmp;\n    row.uid = getUid('grid-row');\n    row.parentUid = parentUid;\n    row.isAggregateRow = true;\n    row.visible = tmp.some(function (cell) {\n      return cell.isDataCell && cell.visible;\n    });\n    return row;\n  };\n\n  SummaryModelGenerator.prototype.getGeneratedCell = function (column, summaryRow, cellType, indent, isDetailGridAlone) {\n    //Get the summary column by display\n    var sColumn = summaryRow.columns.filter(function (scolumn) {\n      return scolumn.columnName === column.field;\n    })[0];\n    var attrs = {\n      'style': {\n        'textAlign': column.textAlign\n      },\n      'e-mappinguid': column.uid,\n      index: column.index\n    };\n\n    if (indent) {\n      attrs.class = indent;\n    }\n\n    if (isNullOrUndefined(indent) && isDetailGridAlone) {\n      attrs.class = 'e-detailindentcelltop';\n    }\n\n    var opt = {\n      'visible': column.visible,\n      'isDataCell': !isNullOrUndefined(sColumn),\n      'isTemplate': sColumn && !isNullOrUndefined(sColumn.footerTemplate || sColumn.groupFooterTemplate || sColumn.groupCaptionTemplate),\n      'column': sColumn || {},\n      'attributes': attrs,\n      'cellType': cellType\n    };\n    opt.column.headerText = column.headerText;\n    return new Cell(opt);\n  };\n\n  SummaryModelGenerator.prototype.buildSummaryData = function (data, args) {\n    var dummy = [];\n    var summaryRows = this.getData();\n    var single = {};\n\n    for (var i = 0; i < summaryRows.length; i++) {\n      single = {};\n      var column = summaryRows[i].columns;\n\n      for (var j = 0; j < column.length; j++) {\n        single = this.setTemplate(column[j], args && args.aggregates ? args : data, single);\n      }\n\n      dummy.push(single);\n    }\n\n    return dummy;\n  };\n\n  SummaryModelGenerator.prototype.getIndentByLevel = function () {\n    return this.parent.groupSettings.columns.map(function () {\n      return 'e-indentcelltop';\n    });\n  };\n\n  SummaryModelGenerator.prototype.setTemplate = function (column, data, single) {\n    var types = column.type;\n    var helper = {};\n\n    var formatFn = column.getFormatter() || function () {\n      return function (a) {\n        return a;\n      };\n    }();\n\n    var group = data;\n\n    if (!(types instanceof Array)) {\n      types = [column.type];\n    }\n\n    for (var i = 0; i < types.length; i++) {\n      var key = column.field + ' - ' + types[i].toLowerCase();\n      var disp = column.columnName;\n      var val = types[i] !== 'Custom' && group.aggregates && key in group.aggregates ? group.aggregates[key] : calculateAggregate(types[i], group.aggregates ? group : data, column, this.parent);\n      single[disp] = single[disp] || {};\n      single[disp][key] = val;\n      single[disp][types[i]] = !isNullOrUndefined(val) ? formatFn(val) : ' ';\n\n      if (group.field) {\n        single[disp].field = group.field;\n        single[disp].key = group.key;\n      }\n    }\n\n    helper.format = column.getFormatter();\n    column.setTemplate(helper);\n    return single;\n  };\n\n  SummaryModelGenerator.prototype.getCellType = function () {\n    return CellType.Summary;\n  };\n\n  return SummaryModelGenerator;\n}();\n\nvar GroupSummaryModelGenerator =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$3(GroupSummaryModelGenerator, _super);\n\n  function GroupSummaryModelGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GroupSummaryModelGenerator.prototype.columnSelector = function (column) {\n    return column.groupFooterTemplate !== undefined;\n  };\n\n  GroupSummaryModelGenerator.prototype.getIndentByLevel = function (level) {\n    if (level === void 0) {\n      level = this.parent.groupSettings.columns.length;\n    }\n\n    return this.parent.groupSettings.columns.map(function (v, indx) {\n      return indx <= level - 1 ? '' : 'e-indentcelltop';\n    });\n  };\n\n  GroupSummaryModelGenerator.prototype.getCellType = function () {\n    return CellType.GroupSummary;\n  };\n\n  return GroupSummaryModelGenerator;\n}(SummaryModelGenerator);\n\nvar CaptionSummaryModelGenerator =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$3(CaptionSummaryModelGenerator, _super);\n\n  function CaptionSummaryModelGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CaptionSummaryModelGenerator.prototype.columnSelector = function (column) {\n    return column.groupCaptionTemplate !== undefined;\n  };\n\n  CaptionSummaryModelGenerator.prototype.getData = function () {\n    var initVal = {\n      columns: []\n    };\n    return [_super.prototype.getData.call(this).reduce(function (prev, cur) {\n      prev.columns = prev.columns.concat(cur.columns);\n      return prev;\n    }, initVal)];\n  };\n\n  CaptionSummaryModelGenerator.prototype.isEmpty = function () {\n    return (this.getData()[0].columns || []).length === 0;\n  };\n\n  CaptionSummaryModelGenerator.prototype.getCellType = function () {\n    return CellType.CaptionSummary;\n  };\n\n  return CaptionSummaryModelGenerator;\n}(SummaryModelGenerator);\n\nvar __extends$2 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * GroupModelGenerator is used to generate group caption rows and data rows.\n *\n * @hidden\n */\n\n\nvar GroupModelGenerator =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$2(GroupModelGenerator, _super);\n\n  function GroupModelGenerator(parent) {\n    var _this = _super.call(this, parent) || this;\n\n    _this.rows = [];\n    /** @hidden */\n\n    _this.index = 0;\n    _this.infiniteChildCount = 0;\n    _this.renderInfiniteAgg = true;\n    _this.parent = parent;\n    _this.summaryModelGen = new GroupSummaryModelGenerator(parent);\n    _this.captionModelGen = new CaptionSummaryModelGenerator(parent);\n    return _this;\n  }\n\n  GroupModelGenerator.prototype.generateRows = function (data, args) {\n    if (this.parent.groupSettings.columns.length === 0) {\n      return _super.prototype.generateRows.call(this, data, args);\n    }\n\n    this.isInfiniteScroll = args.requestType === 'infiniteScroll';\n    this.rows = [];\n    this.index = this.parent.enableVirtualization || this.isInfiniteScroll ? args.startIndex : 0;\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      this.infiniteChildCount = 0;\n      this.renderInfiniteAgg = true;\n      this.getGroupedRecords(0, data[i], data.level, i, undefined, this.rows.length);\n    }\n\n    this.index = 0;\n\n    if (this.parent.isCollapseStateEnabled()) {\n      this.ensureRowVisibility();\n    }\n\n    return this.rows;\n  };\n\n  GroupModelGenerator.prototype.getGroupedRecords = function (index, data, raw, parentid, childId, tIndex, parentUid) {\n    var _a;\n\n    var level = raw;\n\n    if (isNullOrUndefined(data.items)) {\n      if (isNullOrUndefined(data.GroupGuid)) {\n        this.rows = this.rows.concat(this.generateDataRows(data, index, parentid, this.rows.length, parentUid));\n      } else {\n        for (var j = 0, len = data.length; j < len; j++) {\n          this.getGroupedRecords(index, data[j], data.level, parentid, index, this.rows.length, parentUid);\n        }\n      }\n    } else {\n      var preCaption = void 0;\n      var captionRow = this.generateCaptionRow(data, index, parentid, childId, tIndex, parentUid);\n\n      if (this.isInfiniteScroll) {\n        preCaption = this.getPreCaption(index, captionRow.data.key);\n      }\n\n      if (!preCaption) {\n        this.rows = this.rows.concat(captionRow);\n      } else {\n        captionRow.uid = preCaption.uid;\n      }\n\n      if (data.items && data.items.length) {\n        this.getGroupedRecords(index + 1, data.items, data.items.level, parentid, index + 1, this.rows.length, captionRow.uid);\n      }\n\n      if (this.parent.aggregates.length && this.isRenderAggregate(captionRow)) {\n        var rowCnt = this.rows.length;\n\n        (_a = this.rows).push.apply(_a, this.summaryModelGen.generateRows(data, {\n          level: level,\n          parentUid: captionRow.uid\n        }));\n\n        for (var i = rowCnt - 1; i >= 0; i--) {\n          if (this.rows[i].isCaptionRow) {\n            this.rows[i].aggregatesCount = this.rows.length - rowCnt;\n          } else if (!this.rows[i].isCaptionRow && !this.rows[i].isDataRow) {\n            break;\n          }\n        }\n      }\n\n      if (preCaption) {\n        this.setInfiniteRowVisibility(preCaption);\n      }\n    }\n  };\n\n  GroupModelGenerator.prototype.isRenderAggregate = function (data) {\n    if (this.parent.enableInfiniteScrolling) {\n      if (!this.renderInfiniteAgg) {\n        return false;\n      }\n\n      this.getPreCaption(data.indent, data.data.key);\n      this.renderInfiniteAgg = data.data.count === this.infiniteChildCount;\n      return this.renderInfiniteAgg;\n    }\n\n    return !this.parent.enableInfiniteScrolling;\n  };\n\n  GroupModelGenerator.prototype.getPreCaption = function (indent, key) {\n    var rowObj = this.parent.getRowsObject().concat(this.rows);\n    var preCap;\n    this.infiniteChildCount = 0;\n    var i = rowObj.length;\n\n    while (i--) {\n      if (rowObj[i].isCaptionRow && rowObj[i].indent === indent && rowObj[i].data.key === key) {\n        preCap = rowObj[i];\n      }\n\n      if (rowObj[i].indent === indent || rowObj[i].indent < indent) {\n        break;\n      }\n\n      if (rowObj[i].indent === indent + 1) {\n        this.infiniteChildCount++;\n      }\n    }\n\n    return preCap;\n  };\n\n  GroupModelGenerator.prototype.getCaptionRowCells = function (field, indent, data) {\n    var cells = [];\n    var visibles = [];\n    var column = this.parent.getColumnByField(field);\n    var indexes = this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization) {\n      column = this.parent.columns.filter(function (c) {\n        return c.field === field;\n      })[0];\n    }\n\n    var groupedLen = this.parent.groupSettings.columns.length;\n    var gObj = this.parent;\n\n    if (!this.parent.enableColumnVirtualization || indexes.indexOf(indent) !== -1) {\n      for (var i = 0; i < indent; i++) {\n        cells.push(this.generateIndentCell());\n      }\n\n      cells.push(this.generateCell({}, null, CellType.Expand));\n    }\n\n    indent = this.parent.enableColumnVirtualization ? 1 : this.parent.getVisibleColumns().length + groupedLen + (gObj.detailTemplate || gObj.childGrid ? 1 : 0) - indent + (this.parent.getVisibleColumns().length ? -1 : 0); //Captionsummary cells will be added here.\n\n    if (this.parent.aggregates.length && !this.captionModelGen.isEmpty()) {\n      var captionCells = this.captionModelGen.generateRows(data)[0];\n      extend(data, captionCells.data);\n      var cIndex_1 = 0;\n      captionCells.cells.some(function (cell, index) {\n        cIndex_1 = index;\n        return cell.visible && cell.isDataCell;\n      });\n      visibles = captionCells.cells.slice(cIndex_1).filter(function (cell) {\n        return cell.visible;\n      });\n\n      if (captionCells.visible && visibles[0].column.field === this.parent.getVisibleColumns()[0].field) {\n        visibles = visibles.slice(1);\n      }\n\n      if (this.parent.getVisibleColumns().length === 1) {\n        visibles = [];\n      }\n\n      indent = indent - visibles.length;\n    }\n\n    var cols = !this.parent.enableColumnVirtualization ? [column] : this.parent.getColumns();\n    var wFlag = true;\n\n    for (var j = 0; j < cols.length; j++) {\n      var tmpFlag = wFlag && indexes.indexOf(indent) !== -1;\n\n      if (tmpFlag) {\n        wFlag = false;\n      }\n\n      var cellType = !this.parent.enableColumnVirtualization || tmpFlag ? CellType.GroupCaption : CellType.GroupCaptionEmpty;\n      indent = this.parent.enableColumnVirtualization && cellType === CellType.GroupCaption ? indent + groupedLen : indent;\n\n      if (gObj.isRowDragable()) {\n        indent++;\n      }\n\n      cells.push(this.generateCell(column, null, cellType, indent));\n    }\n\n    cells.push.apply(cells, visibles);\n    return cells;\n  };\n  /**\n   * @param {GroupedData} data - specifies the data\n   * @param {number} indent - specifies the indent\n   * @param {number} parentID - specifies the parentID\n   * @param {number} childID - specifies the childID\n   * @param {number} tIndex - specifies the TIndex\n   * @param {string} parentUid - specifies the ParentUid\n   * @returns {Row<Column>} returns the Row object\n   * @hidden\n   */\n\n\n  GroupModelGenerator.prototype.generateCaptionRow = function (data, indent, parentID, childID, tIndex, parentUid) {\n    var options = {};\n    var records = 'records';\n    var col = this.parent.getColumnByField(data.field);\n    options.data = extend({}, data);\n\n    if (col) {\n      options.data.field = data.field;\n    }\n\n    options.isDataRow = false;\n    options.isExpand = !this.parent.groupSettings.enableLazyLoading && !this.parent.isCollapseStateEnabled();\n    options.parentGid = parentID;\n    options.childGid = childID;\n    options.tIndex = tIndex;\n    options.isCaptionRow = true;\n    options.parentUid = parentUid;\n    options.gSummary = !isNullOrUndefined(data.items[records]) ? data.items[records].length : data.items.length;\n    options.uid = getUid('grid-row');\n    var row = new Row(options);\n    row.indent = indent;\n    this.getForeignKeyData(row);\n    row.cells = this.getCaptionRowCells(data.field, indent, row.data);\n    return row;\n  };\n\n  GroupModelGenerator.prototype.getForeignKeyData = function (row) {\n    var data = row.data;\n    var col = this.parent.getColumnByField(data.field);\n\n    if (col && col.isForeignColumn && col.isForeignColumn()) {\n      var fkValue = isNullOrUndefined(data.key) ? '' : col.valueAccessor(col.foreignKeyValue, getForeignData(col, {}, data.key)[0], col);\n      setValue('foreignKey', fkValue, row.data);\n    }\n  };\n  /**\n   * @param {Object[]} data - specifies the data\n   * @param {number} indent - specifies the indent\n   * @param {number} childID - specifies the childID\n   * @param {number} tIndex - specifies the tIndex\n   * @param {string} parentUid - specifies the ParentUid\n   * @returns {Row<Column>[]} returns the row object\n   * @hidden\n   */\n\n\n  GroupModelGenerator.prototype.generateDataRows = function (data, indent, childID, tIndex, parentUid) {\n    var rows = [];\n    var indexes = this.parent.getColumnIndexesInView();\n\n    for (var i = 0, len = data.length; i < len; i++, tIndex++) {\n      rows[i] = this.generateRow(data[i], this.index, i ? undefined : 'e-firstchildrow', indent, childID, tIndex, parentUid);\n\n      for (var j = 0; j < indent; j++) {\n        if (this.parent.enableColumnVirtualization && indexes.indexOf(indent) === -1) {\n          continue;\n        }\n\n        rows[i].cells.unshift(this.generateIndentCell());\n      }\n\n      this.index++;\n    }\n\n    return rows;\n  };\n\n  GroupModelGenerator.prototype.generateIndentCell = function () {\n    return this.generateCell({}, null, CellType.Indent);\n  };\n\n  GroupModelGenerator.prototype.refreshRows = function (input) {\n    var indexes = this.parent.getColumnIndexesInView();\n\n    for (var i = 0; i < input.length; i++) {\n      if (input[i].isDataRow) {\n        input[i].cells = this.generateCells(input[i]);\n\n        for (var j = 0; j < input[i].indent; j++) {\n          if (this.parent.enableColumnVirtualization && indexes.indexOf(input[i].indent) === -1) {\n            continue;\n          }\n\n          input[i].cells.unshift(this.generateIndentCell());\n        }\n      } else {\n        var cRow = this.generateCaptionRow(input[i].data, input[i].indent);\n        input[i].cells = cRow.cells;\n      }\n    }\n\n    return input;\n  };\n\n  GroupModelGenerator.prototype.setInfiniteRowVisibility = function (caption) {\n    if (!caption.isExpand || caption.visible === false) {\n      for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {\n        var row = _a[_i];\n\n        if (row.parentUid === caption.uid) {\n          row.visible = false;\n\n          if (row.isCaptionRow) {\n            this.setInfiniteRowVisibility(row);\n          }\n        }\n      }\n    }\n  };\n\n  GroupModelGenerator.prototype.ensureRowVisibility = function () {\n    for (var i = 0; i < this.rows.length; i++) {\n      var row = this.rows[i];\n\n      if (!row.isCaptionRow) {\n        continue;\n      }\n\n      for (var j = i + 1; j < this.rows.length; j++) {\n        var childRow = this.rows[j];\n\n        if (row.uid === childRow.parentUid) {\n          this.rows[j].visible = row.isExpand;\n        }\n      }\n    }\n  };\n\n  return GroupModelGenerator;\n}(RowModelGenerator); // eslint-disable-next-line valid-jsdoc\n\n/**\n * Content module is used to render grid content\n *\n * @hidden\n */\n\n\nvar ContentRender =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for content renderer module\n   *\n   * @param {IGrid} parent - specifies the Igrid\n   * @param {ServiceLocator} serviceLocator - specifies the service locator\n   */\n  function ContentRender(parent, serviceLocator) {\n    var _this = this;\n\n    this.rows = [];\n    this.freezeRows = [];\n    this.movableRows = [];\n    this.freezeRowElements = [];\n    /** @hidden */\n\n    this.currentInfo = {};\n    /** @hidden */\n\n    this.prevCurrentView = [];\n    this.isLoaded = true;\n    this.viewColIndexes = [];\n\n    this.drop = function (e) {\n      _this.parent.notify(columnDrop, {\n        target: e.target,\n        droppedElement: e.droppedElement\n      });\n\n      remove(e.droppedElement);\n    };\n\n    this.infiniteCache = {};\n    this.isRemove = false;\n    /** @hidden */\n\n    this.visibleRows = [];\n    this.visibleFrozenRows = [];\n    this.rightFreezeRows = [];\n    this.isAddRows = false;\n    this.isInfiniteFreeze = false;\n    this.useGroupCache = false;\n\n    this.rafCallback = function (args) {\n      var arg = args;\n      return function () {\n        if (_this.parent.isFrozenGrid() && _this.parent.enableVirtualization) {\n          var tableName = args.tableName;\n          _this.isLoaded = _this.parent.getFrozenMode() === leftRight ? tableName === 'frozen-right' : tableName === 'movable';\n\n          if (_this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll' && _this.isLoaded) {\n            var mHdr = [].slice.call(_this.parent.getMovableVirtualHeader().getElementsByClassName(row));\n            var fHdr = [].slice.call(_this.parent.getFrozenVirtualHeader().getElementsByClassName(row));\n            _this.isLoaded = mHdr.length === fHdr.length;\n          }\n        }\n\n        _this.ariaService.setBusy(_this.getPanel().querySelector('.' + content), false);\n\n        if (_this.parent.isDestroyed) {\n          return;\n        }\n\n        var rows = _this.rows.slice(0);\n\n        if (_this.parent.enableInfiniteScrolling) {\n          if (_this.parent.groupSettings.enableLazyLoading) {\n            for (var i = 0; i < _this.visibleRows.length; i++) {\n              _this.setRowsInLazyGroup(_this.visibleRows[i], i);\n            }\n          }\n\n          rows = _this.parent.getRowsObject();\n          var prevPage = arg.prevPage;\n\n          if (_this.parent.infiniteScrollSettings.enableCache && prevPage) {\n            var maxBlock = _this.parent.infiniteScrollSettings.maxBlocks;\n            rows = [];\n            var rowIdx = parseInt(_this.rowElements[0].getAttribute('data-rowindex'), 10) + 1;\n            var startIdx = Math.ceil(rowIdx / _this.parent.pageSettings.pageSize);\n\n            for (var i = 0, count = startIdx; i < maxBlock; i++, count++) {\n              if (_this.infiniteCache[count]) {\n                rows = rows.concat(_this.infiniteCache[count]);\n              }\n            }\n          }\n        }\n\n        if (_this.parent.isFrozenGrid()) {\n          rows = args.isFrozen ? _this.freezeRows : args.renderFrozenRightContent ? _this.parent.getFrozenRightRowsObject() : _this.movableRows;\n        }\n\n        _this.parent.notify(contentReady, {\n          rows: rows,\n          args: arg\n        });\n\n        if (_this.isLoaded) {\n          _this.parent.isManualRefresh = false;\n\n          if (_this.parent.enableInfiniteScrolling && _this.parent.groupSettings.enableLazyLoading && args.requestType === 'sorting') {\n            _this.parent.infiniteScrollModule['groupCaptionAction'] = undefined;\n          }\n\n          _this.parent.trigger(dataBound, {}, function () {\n            if (_this.parent.allowTextWrap) {\n              _this.parent.notify(freezeRender, {\n                case: 'textwrap'\n              });\n            }\n          });\n        }\n\n        if (arg) {\n          var action = (arg.requestType || '').toLowerCase() + '-complete';\n\n          _this.parent.notify(action, arg);\n\n          if (args.requestType === 'batchsave') {\n            args.cancel = false;\n\n            _this.parent.trigger(actionComplete, args);\n          }\n        }\n\n        if (_this.isLoaded) {\n          _this.parent.hideSpinner();\n        }\n      };\n    };\n\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.ariaService = this.serviceLocator.getService('ariaService');\n    this.parent.enableDeepCompare = this.parent.getDataModule().isRemote();\n    this.generator = this.getModelGenerator();\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (!this.parent.enableColumnVirtualization && !this.parent.enableVirtualization && !this.parent.groupSettings.enableLazyLoading) {\n      this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    }\n\n    this.parent.on(colGroupRefresh, this.colGroupRefresh, this);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(refreshInfiniteModeBlocks, this.refreshContentRows, this);\n    this.parent.on(beforeCellFocused, this.beforeCellFocused, this);\n    this.parent.on(destroy, this.droppableDestroy, this);\n  }\n\n  ContentRender.prototype.beforeCellFocused = function (e) {\n    if (e.byKey && (e.keyArgs.action === 'upArrow' || e.keyArgs.action === 'downArrow')) {\n      this.pressedKey = e.keyArgs.action;\n    } else {\n      this.pressedKey = undefined;\n    }\n  };\n  /**\n   * The function is used to render grid content div\n   *\n   * @returns {void}\n   */\n\n\n  ContentRender.prototype.renderPanel = function () {\n    var gObj = this.parent;\n    var div = this.parent.element.querySelector('.' + gridContent);\n\n    if (div) {\n      this.ariaService.setOptions(this.parent.element.querySelector('.' + content), {\n        busy: false\n      });\n      this.setPanel(div);\n      return;\n    }\n\n    div = this.parent.createElement('div', {\n      className: gridContent\n    });\n    var innerDiv = this.parent.createElement('div', {\n      className: content\n    });\n    this.ariaService.setOptions(innerDiv, {\n      busy: false\n    });\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n    gObj.element.appendChild(div);\n  };\n  /**\n   * The function is used to render grid content table\n   *\n   * @returns {void}\n   */\n\n\n  ContentRender.prototype.renderTable = function () {\n    var contentDiv = this.getPanel();\n    var virtualTable = contentDiv.querySelector('.e-virtualtable');\n    var virtualTrack = contentDiv.querySelector('.e-virtualtrack');\n\n    if (this.parent.enableVirtualization && !isNullOrUndefined(virtualTable) && !isNullOrUndefined(virtualTrack)) {\n      remove(virtualTable);\n      remove(virtualTrack);\n    }\n\n    contentDiv.appendChild(this.createContentTable('_content_table'));\n    this.setTable(contentDiv.querySelector('.' + table));\n    this.ariaService.setOptions(this.getTable(), {\n      multiselectable: this.parent.selectionSettings.type === 'Multiple'\n    });\n    this.initializeContentDrop();\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n    }\n  };\n  /**\n   * The function is used to create content table elements\n   *\n   * @param {string} id - specifies the id\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  ContentRender.prototype.createContentTable = function (id) {\n    var innerDiv = this.getPanel().firstElementChild;\n\n    if (this.getTable()) {\n      remove(this.getTable());\n    }\n\n    var table$$1 = innerDiv.querySelector('.' + table) ? innerDiv.querySelector('.' + table) : this.parent.createElement('table', {\n      className: table,\n      attrs: {\n        cellspacing: '0.25px',\n        role: 'grid',\n        id: this.parent.element.id + id\n      }\n    });\n    this.setColGroup(this.parent.getHeaderTable().querySelector(colGroup).cloneNode(true));\n    table$$1.appendChild(this.getColGroup());\n    table$$1.appendChild(this.parent.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    }));\n    innerDiv.appendChild(table$$1);\n    return innerDiv;\n  };\n  /**\n   * Refresh the content of the Grid.\n   *\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  ContentRender.prototype.refreshContentRows = function (args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = {};\n    }\n\n    var gObj = this.parent;\n\n    if (gObj.currentViewData.length === 0) {\n      return;\n    }\n\n    var dataSource = this.currentMovableRows || gObj.currentViewData;\n    var contentModule = this.parent.contentModule;\n    var isReact = gObj.isReact && !isNullOrUndefined(gObj.rowTemplate);\n    var frag = isReact ? gObj.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    }) : document.createDocumentFragment();\n\n    if (!this.initialPageRecords) {\n      this.initialPageRecords = extend([], dataSource);\n    }\n\n    var hdrfrag = isReact ? gObj.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    }) : document.createDocumentFragment();\n    var columns = gObj.getColumns();\n    var tr;\n    var hdrTbody;\n    var frzCols = gObj.getFrozenColumns();\n    var isFrozenGrid = this.parent.isFrozenGrid();\n    var trElement;\n    var row$$1 = new RowRenderer(this.serviceLocator, null, this.parent);\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && args.requestType === 'infiniteScroll';\n    gObj.notify(destroyChildGrid, {});\n    this.rowElements = [];\n    this.rows = [];\n    var fCont = this.getPanel().querySelector('.' + frozenContent);\n    var mCont = this.getPanel().querySelector('.' + movableContent);\n    var cont = this.getPanel().querySelector('.' + content);\n    var tbdy;\n    var tableName;\n\n    if (isGroupAdaptive(gObj)) {\n      if (['sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder'].some(function (value) {\n        return args.requestType === value;\n      })) {\n        this.emptyVcRows();\n      }\n    }\n\n    var modelData;\n\n    if (this.parent.enableVirtualization && this.parent.isFrozenGrid()) {\n      if (this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo.axis === 'X') {\n        modelData = this.parent.contentModule.generateRows(dataSource, args);\n        args.renderMovableContent = true;\n      }\n\n      modelData = this.parent.contentModule.generateRows(dataSource, args);\n    } else {\n      modelData = this.checkCache(modelData, args);\n\n      if (!this.isAddRows && !this.useGroupCache) {\n        modelData = this.generator.generateRows(dataSource, args);\n      }\n    }\n\n    this.setGroupCache(modelData, args);\n    this.parent.notify(setInfiniteCache, {\n      isInfiniteScroll: isInfiniteScroll,\n      modelData: modelData,\n      args: args\n    });\n    var idx = modelData[0].cells[0].index;\n\n    if (isFrozenGrid) {\n      tableName = contentModule.setTbody(modelData, args);\n      tbdy = contentModule.getTbody(tableName);\n    }\n\n    var isFrozenLeft = this.parent.getFrozenMode() === leftRight && tableName === frozenRight;\n    /* eslint-disable */\n\n    if (args.requestType !== 'infiniteScroll' && this.parent.registeredTemplate && this.parent.registeredTemplate.template && !args.isFrozen && !isFrozenLeft) {\n      var templatetoclear = [];\n\n      for (var i = 0; i < this.parent.registeredTemplate.template.length; i++) {\n        for (var j = 0; j < this.parent.registeredTemplate.template[i].rootNodes.length; j++) {\n          if (isNullOrUndefined(this.parent.registeredTemplate.template[i].rootNodes[j].parentNode)) {\n            templatetoclear.push(this.parent.registeredTemplate.template[i]);\n            /* eslint-enable */\n          }\n        }\n      }\n\n      this.parent.destroyTemplate(['template'], templatetoclear);\n    }\n\n    if ((this.parent.isReact || this.parent.isVue) && args.requestType !== 'infiniteScroll' && !args.isFrozen) {\n      var templates = [this.parent.isVue ? 'template' : 'columnTemplate', 'rowTemplate', 'detailTemplate', 'captionTemplate', 'commandsTemplate', 'groupFooterTemplate', 'groupCaptionTemplate'];\n      clearReactVueTemplates(this.parent, templates);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      var cellMerge = new CellMergeRender(this.serviceLocator, this.parent);\n      cellMerge.updateVirtualCells(modelData);\n    }\n\n    if (!isFrozenGrid) {\n      this.tbody = this.getTable().querySelector(tbody);\n    }\n\n    var startIndex = 0;\n    var blockLoad = true;\n\n    if (isGroupAdaptive(gObj) && gObj.vcRows.length) {\n      var top_1 = 'top';\n      var scrollTop = !isNullOrUndefined(args.virtualInfo.offsets) ? args.virtualInfo.offsets.top : !isNullOrUndefined(args.scrollTop) ? args.scrollTop[top_1] : 0;\n\n      if (scrollTop !== 0) {\n        var offsets_1 = gObj.vGroupOffsets;\n        var bSize = gObj.pageSettings.pageSize / 2;\n        var values = Object.keys(offsets_1).map(function (key) {\n          return offsets_1[key];\n        });\n\n        for (var m = 0; m < values.length; m++) {\n          if (scrollTop < values[m]) {\n            if (!isNullOrUndefined(args.virtualInfo) && args.virtualInfo.direction === 'up') {\n              startIndex = m > 0 ? (m - 1) * bSize : m * bSize;\n              break;\n            } else {\n              startIndex = m * bSize;\n\n              if (this.parent.contentModule.isEndBlock(m) || this.parent.contentModule.isEndBlock(m + 1)) {\n                args.virtualInfo.blockIndexes = [m, m + 1];\n              }\n\n              break;\n            }\n          }\n        }\n\n        if (Math.round(scrollTop + this.contentPanel.firstElementChild.offsetHeight) >= this.contentPanel.firstElementChild.scrollHeight && !args.rowObject) {\n          blockLoad = false;\n        }\n      }\n    }\n\n    var isVFFrozenOnly = gObj.frozenRows && !gObj.isFrozenGrid() && this.parent.enableVirtualization && args.requestType === 'reorder';\n\n    if (gObj.frozenRows && args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo.axis === 'X' || isVFFrozenOnly) {\n      var bIndex = args.virtualInfo.blockIndexes;\n      var page = args.virtualInfo.page;\n      args.virtualInfo.blockIndexes = [1, 2];\n\n      if (isVFFrozenOnly) {\n        args.virtualInfo.page = 1;\n      }\n\n      var data = isVFFrozenOnly ? this.initialPageRecords : dataSource;\n      var mhdrData = this.vgenerator.generateRows(data, args);\n      mhdrData.splice(this.parent.frozenRows);\n\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        mhdrData[i].cells.splice(0, this.parent.getFrozenColumns());\n        tr = row$$1.render(mhdrData[i], columns);\n        hdrfrag.appendChild(tr);\n      }\n\n      args.virtualInfo.blockIndexes = bIndex;\n      args.virtualInfo.page = page;\n\n      if (isVFFrozenOnly && args.virtualInfo.page === 1) {\n        modelData.splice(0, this.parent.frozenRows);\n      }\n    }\n\n    this.virtualFrozenHdrRefresh(hdrfrag, modelData, row$$1, args, dataSource, columns);\n\n    if (this.parent.groupSettings.enableLazyLoading && !this.useGroupCache && this.parent.groupSettings.columns.length) {\n      this.parent.contentModule.refRowsObj[this.parent.pageSettings.currentPage] = [];\n    }\n\n    if (this.parent.enableInfiniteScrolling && this.parent.groupSettings.enableLazyLoading && args.requestType === 'delete') {\n      //  || (this.parent.infiniteScrollSettings && this.parent.infiniteScrollSettings.enableCache))\n      this.visibleRows = [];\n    }\n\n    for (var i = startIndex, len = modelData.length; i < len; i++) {\n      this.rows.push(modelData[i]);\n\n      if (this.parent.groupSettings.enableLazyLoading && !this.useGroupCache && this.parent.groupSettings.columns.length) {\n        this.parent.contentModule.refRowsObj[this.parent.pageSettings.currentPage].push(modelData[i]);\n        this.setRowsInLazyGroup(modelData[i], i);\n\n        if (isNullOrUndefined(modelData[i].indent)) {\n          continue;\n        }\n      }\n\n      this.setInfiniteVisibleRows(args, modelData[i], tableName);\n\n      if (isGroupAdaptive(gObj) && args.virtualInfo && args.virtualInfo.blockIndexes && this.rowElements.length >= args.virtualInfo.blockIndexes.length * this.parent.contentModule.getBlockSize() && blockLoad) {\n        this.parent.currentViewData['records'] = this.rows.map(function (m) {\n          return m.data;\n        });\n        break;\n      }\n\n      if (!gObj.rowTemplate) {\n        tr = row$$1.render(modelData[i], columns);\n        var isVFreorder = this.ensureFrozenHeaderRender(args);\n\n        if (gObj.frozenRows && i < gObj.frozenRows && !isInfiniteScroll && args.requestType !== 'virtualscroll' && isVFreorder && this.ensureVirtualFrozenHeaderRender(args)) {\n          hdrfrag.appendChild(tr);\n        } else {\n          frag.appendChild(tr);\n        }\n\n        if (modelData[i].isExpand) {\n          gObj.notify(expandChildGrid, tr.cells[gObj.groupSettings.columns.length]);\n        }\n      } else {\n        var rowTemplateID = gObj.element.id + 'rowTemplate';\n        var elements = void 0;\n\n        if (gObj.isReact) {\n          var isHeader = gObj.frozenRows && i < gObj.frozenRows;\n          var copied = extend({\n            index: i\n          }, dataSource[i]);\n          gObj.getRowTemplate()(copied, gObj, 'rowTemplate', rowTemplateID, null, null, isHeader ? hdrfrag : frag);\n          gObj.renderTemplates();\n        } else {\n          elements = gObj.getRowTemplate()(extend({\n            index: i\n          }, dataSource[i]), gObj, 'rowTemplate', rowTemplateID, undefined, undefined, undefined, this.parent['root']);\n        }\n\n        if (!gObj.isReact && elements[0].tagName === 'TBODY') {\n          for (var j = 0; j < elements.length; j++) {\n            var isTR = elements[j].nodeName.toLowerCase() === 'tr';\n\n            if (isTR || elements[j].querySelectorAll && elements[j].querySelectorAll('tr').length) {\n              tr = isTR ? elements[j] : elements[j].querySelector('tr');\n            }\n          }\n\n          if (gObj.frozenRows && i < gObj.frozenRows) {\n            hdrfrag.appendChild(tr);\n          } else {\n            frag.appendChild(tr);\n          }\n        } else {\n          if (gObj.frozenRows && i < gObj.frozenRows) {\n            tr = !gObj.isReact ? appendChildren(hdrfrag, elements) : hdrfrag.lastElementChild;\n          } else {\n            // frag.appendChild(tr);\n            if (!gObj.isReact) {\n              tr = appendChildren(frag, elements);\n            }\n\n            trElement = gObj.isReact ? frag.lastElementChild : tr.lastElementChild;\n          }\n        }\n\n        var arg = {\n          data: modelData[i].data,\n          row: trElement ? trElement : tr\n        };\n        this.parent.trigger(rowDataBound, arg);\n      }\n\n      if (modelData[i].isDataRow) {\n        this.rowElements.push(tr);\n      }\n\n      this.ariaService.setOptions(this.getTable(), {\n        colcount: gObj.getColumns().length.toString()\n      });\n    }\n\n    if (this.parent.enableInfiniteScrolling && this.parent.groupSettings.enableLazyLoading) {\n      this.parent.contentModule.refRowsObj[this.parent.pageSettings.currentPage] = this.parent.contentModule['groupCache'][this.parent.pageSettings.currentPage];\n    }\n\n    if (this.parent.groupSettings.enableLazyLoading && !this.useGroupCache && this.parent.groupSettings.columns.length) {\n      this.parent.notify(refreshExpandandCollapse, {\n        rows: this.parent.contentModule.refRowsObj[this.parent.pageSettings.currentPage]\n      });\n    }\n\n    if (isFrozenGrid) {\n      contentModule.splitRows(tableName);\n    }\n\n    gObj.removeMaskRow();\n\n    if (gObj.frozenRows && args.requestType !== 'virtualscroll' && !isInfiniteScroll && this.ensureVirtualFrozenHeaderRender(args) || args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo && args.virtualInfo.sentinelInfo.axis === 'X') {\n      hdrTbody = isFrozenGrid ? contentModule.getFrozenHeader(tableName) : gObj.getHeaderTable().querySelector(tbody);\n\n      if (isReact) {\n        var parentTable = hdrTbody.parentElement;\n        remove(hdrTbody);\n        parentTable.appendChild(hdrfrag);\n      } else {\n        hdrTbody.innerHTML = '';\n        hdrTbody.appendChild(hdrfrag);\n      }\n    }\n\n    if (!gObj.enableVirtualization && gObj.frozenRows && idx === 0 && cont.offsetHeight === Number(gObj.height)) {\n      cont.style.height = cont.offsetHeight - hdrTbody.offsetHeight + 'px';\n    }\n\n    args.rows = this.rows.slice(0);\n\n    if (isFrozenGrid) {\n      contentModule.setIsFrozen(args, tableName);\n    }\n\n    this.index = idx;\n    getUpdateUsingRaf(function () {\n      _this.parent.notify(beforeFragAppend, args);\n\n      var isVFTable = _this.parent.enableVirtualization && _this.parent.isFrozenGrid();\n\n      if (!_this.parent.enableVirtualization && !isInfiniteScroll) {\n        if (_this.parent.isFrozenGrid()) {\n          remove(contentModule.getTbody(tableName));\n          tbdy = _this.parent.createElement(tbody, {\n            attrs: {\n              role: 'rowgroup'\n            }\n          });\n        } else {\n          _this.tbody.innerHTML = '';\n          remove(_this.tbody);\n          _this.tbody = _this.parent.createElement(tbody, {\n            attrs: {\n              role: 'rowgroup'\n            }\n          });\n        }\n      }\n\n      if (isFrozenGrid && !isVFTable && !_this.parent.enableInfiniteScrolling) {\n        _this.appendContent(tbdy, frag, args, tableName);\n      } else {\n        if (gObj.rowTemplate) {\n          updateBlazorTemplate(gObj.element.id + 'rowTemplate', 'RowTemplate', gObj);\n        }\n\n        if (isVFTable) {\n          if (args.renderFrozenRightContent) {\n            var frCont = gObj.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n\n            _this.appendContent(frCont, frag, args);\n          } else if (!args.renderMovableContent) {\n            _this.appendContent(fCont.querySelector(tbody), frag, args);\n          } else {\n            _this.appendContent(mCont.querySelector(tbody), frag, args);\n\n            args.renderMovableContent = false;\n          }\n\n          if (!_this.parent.getFrozenColumns()) {\n            contentModule.renderNextFrozentPart(args, tableName);\n          }\n        } else {\n          if (!isNullOrUndefined(_this.parent.infiniteScrollModule) && _this.parent.enableInfiniteScrolling) {\n            _this.isAddRows = false;\n\n            _this.parent.notify(removeInfiniteRows, {\n              args: args\n            });\n\n            _this.parent.notify(appendInfiniteContent, {\n              tbody: tbdy ? tbdy : _this.tbody,\n              frag: frag,\n              args: args,\n              rows: _this.rows,\n              rowElements: _this.rowElements,\n              visibleRows: _this.visibleRows,\n              tableName: tableName\n            });\n\n            if (!frzCols && isFrozenGrid) {\n              if (gObj.getFrozenMode() !== leftRight && (tableName === frozenLeft || tableName === frozenRight) || gObj.getFrozenMode() === leftRight && (tableName === frozenLeft || tableName === 'movable')) {\n                _this.refreshContentRows(extend({}, args));\n              }\n            }\n          } else {\n            _this.useGroupCache = false;\n\n            _this.appendContent(_this.tbody, frag, args);\n          }\n        }\n      }\n\n      if (frzCols) {\n        contentModule.renderNextFrozentPart(args, tableName);\n      }\n\n      frag = null;\n    }, this.rafCallback(extend({}, args)));\n  };\n\n  ContentRender.prototype.emptyVcRows = function () {\n    this.parent.vcRows = [];\n    this.parent.vRows = [];\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ContentRender.prototype.appendContent = function (tbody$$1, frag, args, tableName) {\n    var isReact = this.parent.isReact && !isNullOrUndefined(this.parent.rowTemplate);\n\n    if (isReact) {\n      this.getTable().appendChild(frag);\n    } else {\n      tbody$$1.appendChild(frag);\n      this.getTable().appendChild(tbody$$1);\n    }\n  };\n\n  ContentRender.prototype.setRowsInLazyGroup = function (row$$1, index) {\n    if (this.parent.groupSettings.enableLazyLoading && !this.useGroupCache && this.parent.groupSettings.columns.length) {\n      this.parent.contentModule.maintainRows(row$$1, index);\n    }\n  };\n\n  ContentRender.prototype.setGroupCache = function (data, args) {\n    if (!this.useGroupCache && this.parent.groupSettings.enableLazyLoading) {\n      this.parent.notify(setGroupCache, {\n        args: args,\n        data: data\n      });\n    }\n  };\n\n  ContentRender.prototype.ensureFrozenHeaderRender = function (args) {\n    return !(this.parent.enableVirtualization && (args.requestType === 'reorder' || args.requestType === 'refresh') || this.parent.infiniteScrollSettings.enableCache && this.parent.frozenRows && this.parent.infiniteScrollModule.requestType === 'delete' && this.parent.pageSettings.currentPage !== 1);\n  };\n\n  ContentRender.prototype.ensureVirtualFrozenHeaderRender = function (args) {\n    return !(this.parent.enableVirtualization && args.requestType === 'delete');\n  };\n\n  ContentRender.prototype.checkCache = function (modelData, args) {\n    if (this.parent.infiniteScrollSettings.enableCache && args.requestType === 'infiniteScroll') {\n      var index = args.isFrozen ? 1 : 0;\n      var frozenCols = this.parent.isFrozenGrid();\n      this.isAddRows = !isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage]);\n\n      if (frozenCols && !isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage])) {\n        this.isAddRows = this.infiniteCache[this.parent.pageSettings.currentPage][index].length !== 0;\n      }\n\n      if (this.isAddRows) {\n        var data = !frozenCols ? this.infiniteCache[this.parent.pageSettings.currentPage] : this.infiniteCache[this.parent.pageSettings.currentPage][index];\n        modelData = this.parent.pageSettings.currentPage === 1 ? data.slice(this.parent.frozenRows) : data;\n      }\n\n      return modelData;\n    }\n\n    if (this.parent.groupSettings.enableLazyLoading && this.parent.groupSettings.columns.length && (args.requestType === 'paging' || args.requestType === 'columnstate' || args.requestType === 'reorder') && this.parent.contentModule.getGroupCache()[this.parent.pageSettings.currentPage]) {\n      this.useGroupCache = true;\n      return this.parent.contentModule.initialGroupRows(args.requestType === 'reorder');\n    }\n\n    return null;\n  };\n\n  ContentRender.prototype.setInfiniteVisibleRows = function (args, data, tableName) {\n    var frozenCols = this.parent.isFrozenGrid();\n\n    if (this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache) {\n      if (frozenCols) {\n        if (tableName === frozenLeft || this.parent.getFrozenMode() === 'Right' && tableName === frozenRight) {\n          this.visibleFrozenRows.push(data);\n        } else if (tableName === 'movable') {\n          this.visibleRows.push(data);\n        } else {\n          this.rightFreezeRows.push(data);\n        }\n      } else if (!this.parent.infiniteScrollSettings.enableCache) {\n        this.visibleRows.push(data);\n      }\n    }\n  };\n\n  ContentRender.prototype.getCurrentBlockInfiniteRecords = function (isFreeze) {\n    var data = [];\n\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      if (!Object.keys(this.infiniteCache).length) {\n        return [];\n      }\n\n      var frozenCols = this.parent.isFrozenGrid();\n      var rows = this.parent.getRows();\n      var index = parseInt(rows[this.parent.frozenRows].getAttribute(dataRowIndex), 10);\n      var first = Math.ceil((index + 1) / this.parent.pageSettings.pageSize);\n      index = parseInt(rows[rows.length - 1].getAttribute(dataRowIndex), 10);\n      var last = Math.ceil(index / this.parent.pageSettings.pageSize);\n\n      if (frozenCols) {\n        var idx = isFreeze ? 0 : 1;\n\n        for (var i = first; i <= last; i++) {\n          data = !data.length ? this.infiniteCache[i][idx] : data.concat(this.infiniteCache[i][idx]);\n        }\n\n        if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n          data = this.infiniteCache[1][idx].slice(0, this.parent.frozenRows).concat(data);\n        }\n      } else {\n        for (var i = first; i <= last; i++) {\n          data = !data.length ? this.infiniteCache[i] : data.concat(this.infiniteCache[i]);\n        }\n\n        if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n          data = this.infiniteCache[1].slice(0, this.parent.frozenRows).concat(data);\n        }\n      }\n    }\n\n    return data;\n  };\n\n  ContentRender.prototype.getReorderedVFRows = function (args) {\n    return this.parent.contentModule.getReorderedFrozenRows(args);\n  };\n\n  ContentRender.prototype.getReorderedRows = function (args) {\n    return this.parent.contentModule.getReorderedFrozenRows(args);\n  };\n\n  ContentRender.prototype.virtualFrozenHdrRefresh = function (hdrfrag, modelData, row$$1, args, dataSource, columns) {\n    if (this.parent.frozenRows && this.parent.enableVirtualization && (args.requestType === 'reorder' || args.requestType === 'refresh')) {\n      var tr = void 0;\n      var fhdrData = [];\n\n      if (this.parent.isFrozenGrid()) {\n        this.currentMovableRows = dataSource;\n        fhdrData = this.getReorderedVFRows(args);\n      } else {\n        fhdrData = this.getReorderedRows(args);\n      }\n\n      for (var i = 0; i < fhdrData.length; i++) {\n        tr = row$$1.render(fhdrData[i], columns);\n        hdrfrag.appendChild(tr);\n      }\n\n      if (args.virtualInfo.page === 1) {\n        modelData.splice(0, this.parent.frozenRows);\n      }\n\n      if (args.renderMovableContent) {\n        this.parent.currentViewData = this.currentMovableRows;\n        this.currentMovableRows = null;\n      }\n    }\n  };\n\n  ContentRender.prototype.getInfiniteRows = function () {\n    var rows = [];\n    var frozenCols = this.parent.isFrozenGrid();\n\n    if (this.parent.enableInfiniteScrolling) {\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        var keys = Object.keys(this.infiniteCache);\n\n        for (var i = 0; i < keys.length; i++) {\n          rows = !frozenCols ? rows.concat(this.infiniteCache[keys[i]]) : rows.concat(this.infiniteCache[keys[i]][0]);\n        }\n      } else {\n        rows = frozenCols ? this.visibleFrozenRows : this.visibleRows;\n      }\n    }\n\n    return rows;\n  };\n\n  ContentRender.prototype.getInfiniteMovableRows = function () {\n    var infiniteCacheRows = this.getCurrentBlockInfiniteRecords();\n    var infiniteRows = this.parent.enableInfiniteScrolling ? infiniteCacheRows.length ? infiniteCacheRows : this.visibleRows : [];\n    return infiniteRows;\n  };\n  /**\n   * Get the content div element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ContentRender.prototype.getPanel = function () {\n    return this.contentPanel;\n  };\n  /**\n   * Set the content div element of grid\n   *\n   * @param  {Element} panel - specifies the panel\n   * @returns {void}\n   */\n\n\n  ContentRender.prototype.setPanel = function (panel) {\n    this.contentPanel = panel;\n  };\n  /**\n   * Get the content table element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ContentRender.prototype.getTable = function () {\n    return this.contentTable;\n  };\n  /**\n   * Set the content table element of grid\n   *\n   * @param  {Element} table - specifies the table\n   * @returns {void}\n   */\n\n\n  ContentRender.prototype.setTable = function (table$$1) {\n    this.contentTable = table$$1;\n  };\n  /**\n   * Get the Movable Row collection in the Freeze pane Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row\n   */\n\n\n  ContentRender.prototype.getRows = function () {\n    var infiniteRows = this.getInfiniteRows();\n    return infiniteRows.length ? infiniteRows : this.parent.getFrozenColumns() ? this.freezeRows : this.rows;\n  };\n  /**\n   * Get the Movable Row collection in the Freeze pane Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row\n   */\n\n\n  ContentRender.prototype.getMovableRows = function () {\n    var infiniteRows = this.getInfiniteMovableRows();\n    return infiniteRows.length ? infiniteRows : this.movableRows;\n  };\n  /**\n   * Get the content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ContentRender.prototype.getRowElements = function () {\n    return this.parent.getFrozenColumns() ? this.freezeRowElements : this.rowElements;\n  };\n  /**\n   * Get the Freeze pane movable content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ContentRender.prototype.getMovableRowElements = function () {\n    return this.rowElements;\n  };\n  /**\n   * Get the content table data row elements\n   *\n   * @param {Element[]} elements - specifies the elements\n   * @returns {void}\n   */\n\n\n  ContentRender.prototype.setRowElements = function (elements) {\n    this.rowElements = elements;\n  };\n  /**\n   * Get the header colgroup element\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ContentRender.prototype.getColGroup = function () {\n    return this.colgroup;\n  };\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} returns the element\n   */\n\n\n  ContentRender.prototype.setColGroup = function (colGroup$$1) {\n    if (!isNullOrUndefined(colGroup$$1)) {\n      colGroup$$1.id = 'content-' + colGroup$$1.id;\n    }\n\n    return this.colgroup = colGroup$$1;\n  };\n  /**\n   * Function to hide content table column based on visible property\n   *\n   * @param {Column[]} columns - specifies the column\n   * @returns {void}\n   */\n\n\n  ContentRender.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var isFrozenGrid = this.parent.isFrozenGrid();\n    var frzCols = gObj.getFrozenColumns();\n    var rows = [];\n\n    if (isFrozenGrid) {\n      var fRows = this.freezeRows;\n      var mRows = this.movableRows;\n      var rowLen = fRows.length;\n      var cellLen = void 0;\n      var rightRows = [];\n\n      if (gObj.getFrozenMode() === leftRight) {\n        rightRows = gObj.getFrozenRightRowsObject();\n      }\n\n      for (var i = 0, row$$1 = void 0; i < rowLen; i++) {\n        cellLen = mRows[i].cells.length;\n        var rightLen = rightRows.length ? rightRows[i].cells.length : 0;\n        row$$1 = fRows[i].clone();\n\n        for (var j = 0; j < cellLen; j++) {\n          row$$1.cells.push(mRows[i].cells[j]);\n        }\n\n        for (var k = 0; k < rightLen; k++) {\n          row$$1.cells.push(rightRows[i].cells[k]);\n        }\n\n        rows.push(row$$1);\n      }\n    } else {\n      rows = this.getRows();\n    }\n\n    var testRow;\n    rows.some(function (r) {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    var needFullRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      needFullRefresh = false;\n    }\n\n    var tr = gObj.getDataRows();\n    var args = {};\n    var infiniteData = this.infiniteRowVisibility();\n    var contentrows = infiniteData ? infiniteData : this.rows.filter(function (row$$1) {\n      return !row$$1.isDetailRow;\n    });\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      var idx = this.parent.getNormalizedColumnIndex(column.uid);\n      var colIdx = this.parent.getColumnIndexByUid(column.uid);\n      var displayVal = column.visible === true ? '' : 'none';\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        if (isFrozenGrid) {\n          if (column.getFreezeTableName() !== 'movable') {\n            if (column.getFreezeTableName() === frozenRight) {\n              var left = this.parent.getFrozenLeftColumnsCount();\n              var movable = this.parent.getMovableColumnsCount();\n              colIdx = idx = idx - (left + movable);\n              var colG = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(colGroup);\n              setStyleAttribute(colG.childNodes[idx], {\n                'display': displayVal\n              });\n              contentrows = gObj.getFrozenRightRowsObject();\n              tr = gObj.getFrozenRightDataRows();\n            } else {\n              setStyleAttribute(this.getColGroup().childNodes[idx], {\n                'display': displayVal\n              });\n              var infiniteFreezeData = this.infiniteRowVisibility(true);\n              contentrows = infiniteFreezeData ? infiniteFreezeData : this.freezeRows;\n              tr = gObj.getDataRows();\n            }\n          } else {\n            var mTable = gObj.getContent().querySelector('.' + movableContent).querySelector(colGroup);\n            colIdx = idx = idx - frzCols - this.parent.getFrozenLeftColumnsCount();\n            setStyleAttribute(mTable.childNodes[idx], {\n              'display': displayVal\n            });\n            tr = gObj.getMovableDataRows();\n            var infiniteMovableData = this.infiniteRowVisibility();\n            contentrows = infiniteMovableData ? infiniteMovableData : this.movableRows;\n          }\n        } else {\n          setStyleAttribute(this.getColGroup().childNodes[idx], {\n            'display': displayVal\n          });\n        }\n      }\n\n      if (!needFullRefresh) {\n        this.setDisplayNone(tr, colIdx, displayVal, contentrows);\n\n        if (isFrozenGrid) {\n          this.parent.notify(freezeRender, {\n            case: 'refreshHeight',\n            isModeChg: true\n          });\n        }\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (needFullRefresh) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      if (!this.parent.getFrozenColumns()) {\n        this.parent.notify(partialRefresh, {\n          rows: contentrows,\n          args: args\n        });\n      } else {\n        this.parent.notify(partialRefresh, {\n          rows: this.freezeRows,\n          args: {\n            isFrozen: true,\n            rows: this.freezeRows\n          }\n        });\n        this.parent.notify(partialRefresh, {\n          rows: this.movableRows,\n          args: {\n            isFrozen: false,\n            rows: this.movableRows\n          }\n        });\n      }\n    }\n  };\n  /**\n   * @param {Object} tr - specifies the trr\n   * @param {number} idx - specifies the idx\n   * @param {string} displayVal - specifies the displayval\n   * @param {Row<Column>} rows - specifies the rows\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ContentRender.prototype.setDisplayNone = function (tr, idx, displayVal, rows) {\n    setDisplayValue(tr, idx, displayVal, rows, this.parent, this.parent.isRowDragable());\n    this.parent.notify(infiniteShowHide, {\n      visible: displayVal,\n      index: idx,\n      isFreeze: this.isInfiniteFreeze\n    });\n  };\n\n  ContentRender.prototype.infiniteRowVisibility = function (isFreeze) {\n    var infiniteData;\n\n    if (this.parent.enableInfiniteScrolling) {\n      this.isInfiniteFreeze = isFreeze;\n\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        infiniteData = isFreeze ? this.getCurrentBlockInfiniteRecords(true) : this.getCurrentBlockInfiniteRecords();\n      } else {\n        infiniteData = isFreeze ? this.visibleFrozenRows : this.visibleRows;\n      }\n    }\n\n    return infiniteData;\n  };\n\n  ContentRender.prototype.colGroupRefresh = function () {\n    if (this.getColGroup()) {\n      var colGroup$$1 = void 0;\n\n      if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && this.parent.contentModule.isXaxis()) {\n        colGroup$$1 = this.parent.getMovableVirtualHeader().querySelector(colGroup + ':not(.e-masked-colgroup)').cloneNode(true);\n      } else {\n        colGroup$$1 = this.getHeaderColGroup();\n      }\n\n      this.getTable().replaceChild(colGroup$$1, this.getColGroup());\n      this.setColGroup(colGroup$$1);\n    }\n  };\n\n  ContentRender.prototype.getHeaderColGroup = function () {\n    return this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup + ':not(.e-masked-colgroup)').cloneNode(true);\n  };\n\n  ContentRender.prototype.initializeContentDrop = function () {\n    var gObj = this.parent;\n    this.droppable = new Droppable(gObj.element, {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  };\n\n  ContentRender.prototype.droppableDestroy = function () {\n    if (this.droppable && !this.droppable.isDestroyed) {\n      this.droppable.destroy();\n    }\n  };\n\n  ContentRender.prototype.canSkip = function (column, row$$1, index) {\n    /**\n     * Skip the toggle visiblity operation when one of the following success\n     * 1. Grid has empty records\n     * 2. column visible property is unchanged\n     * 3. cell`s isVisible property is same as column`s visible property.\n     */\n    return isNullOrUndefined(row$$1) || //(1)\n    isNullOrUndefined(column.visible) || //(2)\n    row$$1.cells[index].visible === column.visible; //(3)\n  };\n\n  ContentRender.prototype.getModelGenerator = function () {\n    return this.generator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  };\n\n  ContentRender.prototype.renderEmpty = function (tbody$$1) {\n    this.getTable().appendChild(tbody$$1);\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector(tbody).innerHTML = '';\n    }\n  };\n\n  ContentRender.prototype.setSelection = function (uid, set, clearAll) {\n    this.parent.notify(setFreezeSelection, {\n      uid: uid,\n      set: set,\n      clearAll: clearAll\n    });\n    var isFrozen = this.parent.isFrozenGrid();\n\n    if (isFrozen && this.parent.enableVirtualization) {\n      return;\n    }\n\n    if (isFrozen) {\n      var rows = this.getMovableRows().filter(function (row$$1) {\n        return clearAll || uid === row$$1.uid;\n      });\n\n      for (var i = 0; i < rows.length; i++) {\n        rows[i].isSelected = set;\n      }\n    }\n\n    var row$$1 = this.getRows().filter(function (row$$1) {\n      return clearAll || uid === row$$1.uid;\n    });\n\n    for (var j = 0; j < row$$1.length; j++) {\n      row$$1[j].isSelected = set;\n      var cells = row$$1[j].cells;\n\n      for (var k = 0; k < cells.length; k++) {\n        cells[k].isSelected = set;\n      }\n    }\n  };\n\n  ContentRender.prototype.getRowByIndex = function (index) {\n    index = this.getInfiniteRowIndex(index);\n    return this.parent.getDataRows()[index];\n  };\n\n  ContentRender.prototype.getInfiniteRowIndex = function (index) {\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      var fRows = this.parent.frozenRows;\n      var idx = fRows > index ? 0 : fRows;\n      var firstRowIndex = parseInt(this.parent.getRows()[idx].getAttribute(dataRowIndex), 10);\n      index = fRows > index ? index : index - firstRowIndex + fRows;\n    }\n\n    return index;\n  };\n\n  ContentRender.prototype.getVirtualRowIndex = function (index) {\n    return index;\n  };\n\n  ContentRender.prototype.getMovableRowByIndex = function (index) {\n    index = this.getInfiniteRowIndex(index);\n    return this.parent.getMovableDataRows()[index];\n  };\n\n  ContentRender.prototype.enableAfterRender = function (e) {\n    if (e.module === 'group' && e.enable) {\n      this.generator = this.getModelGenerator();\n    }\n  };\n\n  ContentRender.prototype.setRowObjects = function (rows) {\n    this.rows = rows;\n  };\n  /**\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ContentRender.prototype.immutableModeRendering = function (args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = {};\n    }\n\n    var gObj = this.parent;\n    gObj.hideSpinner();\n    var key = gObj.getPrimaryKeyFieldNames()[0];\n    var oldKeys = {};\n    var newKeys = {};\n    var newRowObjs = [];\n    var oldIndexes = {};\n    var oldRowObjs = gObj.getRowsObject().slice();\n    var batchChangeKeys = this.getBatchEditedRecords(key, oldRowObjs);\n    var newIndexes = {};\n    var hasBatch = Object.keys(batchChangeKeys).length !== 0;\n\n    if (gObj.getContent().querySelector('.e-emptyrow') || args.requestType === 'reorder' || this.parent.groupSettings.columns.length) {\n      this.refreshContentRows(args);\n    } else {\n      if (gObj.currentViewData.length === 0) {\n        return;\n      }\n\n      var oldRowElements = {};\n      var tbody$$1 = gObj.createElement(tbody, {\n        attrs: {\n          role: 'rowgroup'\n        }\n      });\n      var dataSource = gObj.currentViewData;\n      var trs = [].slice.call(this.getTable().querySelector(tbody).children);\n\n      if (this.prevCurrentView.length) {\n        var prevLen = this.prevCurrentView.length;\n        var currentLen = dataSource.length;\n\n        if (prevLen === currentLen) {\n          for (var i = 0; i < currentLen; i++) {\n            if (this.parent.editSettings.mode === 'Batch' && trs[i].classList.contains('e-insertedrow')) {\n              trs.splice(i, 1);\n              --i;\n              continue;\n            }\n\n            newKeys[dataSource[i][key]] = oldKeys[this.prevCurrentView[i][key]] = i;\n            newIndexes[i] = dataSource[i][key];\n            oldRowElements[oldRowObjs[i].uid] = trs[i];\n            oldIndexes[i] = this.prevCurrentView[i][key];\n          }\n        } else {\n          for (var i = 0; i < currentLen; i++) {\n            newKeys[dataSource[i][key]] = i;\n            newIndexes[i] = dataSource[i][key];\n          }\n\n          for (var i = 0; i < prevLen; i++) {\n            if (this.parent.editSettings.mode === 'Batch' && trs[i].classList.contains('e-insertedrow')) {\n              trs.splice(i, 1);\n              --i;\n              continue;\n            }\n\n            oldRowElements[oldRowObjs[i].uid] = trs[i];\n            oldKeys[this.prevCurrentView[i][key]] = i;\n            oldIndexes[i] = this.prevCurrentView[i][key];\n          }\n        }\n      }\n\n      for (var i = 0; i < dataSource.length; i++) {\n        var oldIndex = oldKeys[dataSource[i][key]];\n\n        if (!isNullOrUndefined(oldIndex)) {\n          var isEqual = false;\n\n          if (this.parent.enableDeepCompare) {\n            isEqual = this.objectEqualityChecker(this.prevCurrentView[oldIndex], dataSource[i]);\n          }\n\n          var tr = oldRowElements[oldRowObjs[oldIndex].uid];\n          newRowObjs.push(oldRowObjs[oldIndex]);\n\n          if (this.rowElements[oldIndex] && this.rowElements[oldIndex].getAttribute('data-uid') === newRowObjs[i].uid && (hasBatch && isNullOrUndefined(batchChangeKeys[newIndexes[i]]) || !hasBatch && (isEqual || this.prevCurrentView[oldIndex] === dataSource[i]))) {\n            if (oldIndex !== i) {\n              this.refreshImmutableContent(i, tr, newRowObjs[i]);\n            }\n\n            tbody$$1.appendChild(tr);\n            continue;\n          }\n\n          if (hasBatch && !isNullOrUndefined(batchChangeKeys[newIndexes[i]]) || !this.parent.enableDeepCompare && dataSource[i] !== this.prevCurrentView[oldIndex] || this.parent.enableDeepCompare && !isEqual) {\n            oldRowObjs[oldIndex].setRowValue(dataSource[i]);\n          }\n\n          tbody$$1.appendChild(tr);\n          this.refreshImmutableContent(i, tr, newRowObjs[i]);\n        } else {\n          var row$$1 = new RowRenderer(this.serviceLocator, null, gObj);\n          var modelData = this.generator.generateRows([dataSource[i]]);\n          newRowObjs.push(modelData[0]);\n          var tr = row$$1.render(modelData[0], gObj.getColumns());\n          tbody$$1.appendChild(tr);\n          this.refreshImmutableContent(i, tr, newRowObjs[i]);\n        }\n      }\n\n      this.rows = newRowObjs;\n      this.rowElements = [].slice.call(tbody$$1.children);\n      remove(this.getTable().querySelector(tbody));\n      this.getTable().appendChild(tbody$$1);\n      this.parent.trigger(dataBound, {}, function () {\n        if (_this.parent.allowTextWrap) {\n          _this.parent.notify(freezeRender, {\n            case: 'textwrap'\n          });\n        }\n      });\n\n      if (args) {\n        var action = (args.requestType || '').toLowerCase() + '-complete';\n        this.parent.notify(action, args);\n      }\n    }\n  };\n\n  ContentRender.prototype.objectEqualityChecker = function (old, next) {\n    var keys = Object.keys(old);\n    var isEqual = true;\n\n    for (var i = 0; i < keys.length; i++) {\n      if (old[keys[i]] !== next[keys[i]]) {\n        var isDate = old[keys[i]] instanceof Date && next[keys[i]] instanceof Date;\n\n        if (!isDate || old[keys[i]].getTime() !== next[keys[i]].getTime()) {\n          isEqual = false;\n          break;\n        }\n      }\n    }\n\n    return isEqual;\n  };\n\n  ContentRender.prototype.getBatchEditedRecords = function (primaryKey, rows) {\n    var keys = {};\n    var changes = this.parent.getBatchChanges();\n    var changedRecords$$1 = [];\n    var addedRecords$$1 = [];\n\n    if (Object.keys(changes).length) {\n      changedRecords$$1 = changes.changedRecords;\n      addedRecords$$1 = changes.addedRecords;\n    }\n\n    var args = {\n      cancel: false\n    };\n    this.parent.notify(immutableBatchCancel, {\n      rows: rows,\n      args: args\n    });\n\n    if (addedRecords$$1.length) {\n      if (this.parent.editSettings.newRowPosition === 'Bottom') {\n        rows.splice(rows.length - 1, addedRecords$$1.length);\n      } else {\n        if (!args.cancel) {\n          rows.splice(0, addedRecords$$1.length);\n        }\n      }\n    }\n\n    for (var i = 0; i < changedRecords$$1.length; i++) {\n      keys[changedRecords$$1[i][primaryKey]] = i;\n    }\n\n    return keys;\n  };\n\n  ContentRender.prototype.refreshImmutableContent = function (index, tr, row$$1) {\n    row$$1.isAltRow = this.parent.enableAltRow ? index % 2 !== 0 : false;\n\n    if (row$$1.isAltRow) {\n      tr.classList.add('e-altrow');\n    } else {\n      tr.classList.remove('e-altrow');\n    }\n\n    row$$1.index = index;\n    row$$1.edit = undefined;\n    row$$1.isDirty = false;\n    tr.setAttribute(dataRowIndex, index.toString());\n    tr.setAttribute(ariaRowIndex, (index + 1).toString());\n    this.updateCellIndex(tr, index);\n  };\n\n  ContentRender.prototype.updateCellIndex = function (rowEle, index) {\n    for (var i = 0; i < rowEle.cells.length; i++) {\n      rowEle.cells[i].setAttribute('index', index.toString());\n    }\n  };\n\n  return ContentRender;\n}(); // eslint-disable-next-line valid-jsdoc\n\n/**\n * Content module is used to render grid content\n *\n * @hidden\n */\n\n\nvar HeaderRender =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for header renderer module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   */\n  function HeaderRender(parent, serviceLocator) {\n    var _this = this;\n\n    this.frzIdx = 0;\n    this.notfrzIdx = 0;\n    this.isFirstCol = false;\n    this.isReplaceDragEle = true; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this.helper = function (e) {\n      var gObj = _this.parent;\n      var target = _this.draggable.currentStateTarget;\n      var parentEle = parentsUntil(target, 'e-headercell');\n\n      if (!(gObj.allowReordering || gObj.allowGrouping) || !isNullOrUndefined(parentEle) && parentEle.getElementsByClassName('e-checkselectall').length > 0) {\n        return false;\n      }\n\n      var visualElement = _this.parent.createElement('div', {\n        className: 'e-cloneproperties e-dragclone e-headerclone'\n      });\n\n      var element = target.classList.contains('e-headercell') ? target : parentEle;\n\n      if (!element || !gObj.allowReordering && element.classList.contains('e-stackedheadercell')) {\n        return false;\n      }\n\n      var height = element.offsetHeight;\n      var headercelldiv = element.querySelector('.e-headercelldiv') || element.querySelector('.e-stackedheadercelldiv');\n      var col;\n\n      if (headercelldiv) {\n        if (element.querySelector('.e-stackedheadercelldiv')) {\n          col = gObj.getStackedHeaderColumnByHeaderText(headercelldiv.innerText.trim(), gObj.columns);\n        } else {\n          col = gObj.getColumnByUid(headercelldiv.getAttribute('e-mappinguid'));\n        }\n\n        _this.column = col;\n\n        if (_this.column.lockColumn) {\n          return false;\n        }\n\n        visualElement.setAttribute('e-mappinguid', _this.column.uid);\n      }\n\n      if (col && !isNullOrUndefined(col.headerTemplate)) {\n        if (!isNullOrUndefined(col.headerTemplate)) {\n          var colIndex = gObj.getColumnIndexByField(col.field);\n          var result = col.getHeaderTemplate()(extend({\n            'index': colIndex\n          }, col), gObj, 'headerTemplate');\n          appendChildren(visualElement, result);\n        } else {\n          visualElement.innerHTML = col.headerTemplate;\n        }\n      } else {\n        visualElement.innerHTML = headercelldiv ? col.headerText : element.firstElementChild.innerHTML;\n      }\n\n      visualElement.style.width = element.offsetWidth + 'px';\n      visualElement.style.height = element.offsetHeight + 'px';\n      visualElement.style.lineHeight = (height - 6).toString() + 'px';\n      gObj.element.appendChild(visualElement);\n      return visualElement;\n    };\n\n    this.dragStart = function (e) {\n      var gObj = _this.parent;\n      gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n      gObj.notify(columnDragStart, {\n        target: _this.draggable.currentStateTarget,\n        column: _this.column,\n        event: e.event\n      });\n    };\n\n    this.drag = function (e) {\n      var gObj = _this.parent;\n      var target = e.target;\n\n      if (target) {\n        var closest$$1 = closest(target, '.e-grid');\n\n        var cloneElement = _this.parent.element.querySelector('.e-cloneproperties');\n\n        if (!closest$$1 || closest$$1.getAttribute('id') !== gObj.element.getAttribute('id')) {\n          classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n\n          if (gObj.allowReordering) {\n            gObj.element.querySelector('.e-reorderuparrow').style.display = 'none';\n            gObj.element.querySelector('.e-reorderdownarrow').style.display = 'none';\n          }\n\n          if (!gObj.groupSettings.allowReordering) {\n            return;\n          }\n        }\n\n        gObj.notify(columnDrag, {\n          target: e.target,\n          column: _this.column,\n          event: e.event\n        });\n      }\n    };\n\n    this.dragStop = function (e) {\n      var gObj = _this.parent;\n      var cancel;\n      gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n\n      if (!parentsUntil(e.target, 'e-headercell') && !parentsUntil(e.target, 'e-groupdroparea') || !gObj.allowReordering && parentsUntil(e.target, 'e-headercell') || !e.helper.getAttribute('e-mappinguid') && parentsUntil(e.target, 'e-groupdroparea')) {\n        remove(e.helper);\n        cancel = true;\n      }\n\n      gObj.notify(columnDragStop, {\n        target: e.target,\n        event: e.event,\n        column: _this.column,\n        cancel: cancel\n      });\n    };\n\n    this.drop = function (e) {\n      var gObj = _this.parent;\n      var uid = e.droppedElement.getAttribute('e-mappinguid');\n      var closest$$1 = closest(e.target, '.e-grid');\n      remove(e.droppedElement);\n\n      if (closest$$1 && closest$$1.getAttribute('id') !== gObj.element.getAttribute('id') || !(gObj.allowReordering || gObj.allowGrouping)) {\n        return;\n      }\n\n      gObj.notify(headerDrop, {\n        target: e.target,\n        uid: uid,\n        droppedElement: e.droppedElement\n      });\n    };\n\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.ariaService = this.serviceLocator.getService('ariaService');\n    this.widthService = this.serviceLocator.getService('widthService');\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (!this.parent.enableColumnVirtualization && !this.parent.getFrozenLeftColumnsCount() && !this.parent.getFrozenRightColumnsCount()) {\n      this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    }\n\n    this.parent.on(columnPositionChanged, this.colPosRefresh, this);\n    this.parent.on(initialEnd, this.renderCustomToolbar, this);\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      this.parent.on(uiUpdate, this.updateCustomResponsiveToolbar, this);\n    }\n  }\n  /**\n   * The function is used to render grid header div\n   *\n   * @returns {void}\n   */\n\n\n  HeaderRender.prototype.renderPanel = function () {\n    var div = this.parent.element.querySelector('.' + gridHeader);\n    var isRendered = div != null;\n    div = isRendered ? div : this.parent.createElement('div', {\n      className: 'e-gridheader'\n    });\n    var innerDiv = isRendered ? div.querySelector('.' + headerContent) : this.parent.createElement('div', {\n      className: headerContent\n    });\n    this.toggleStackClass(div);\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n\n    if (!isRendered) {\n      this.parent.element.appendChild(div);\n    }\n  };\n  /**\n   * The function is used to render grid header div\n   *\n   * @returns {void}\n   */\n\n\n  HeaderRender.prototype.renderTable = function () {\n    var headerDiv = this.getPanel();\n    headerDiv.appendChild(this.createHeaderTable());\n    this.setTable(headerDiv.querySelector('.' + table));\n\n    if (!this.parent.getFrozenColumns() && !this.parent.getFrozenRightColumnsCount() && !this.parent.getFrozenLeftColumnsCount()) {\n      this.initializeHeaderDrag();\n      this.initializeHeaderDrop();\n    }\n\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: this.parent.isFrozenGrid()\n      }\n    });\n  };\n  /**\n   * Get the header content div element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  HeaderRender.prototype.getPanel = function () {\n    return this.headerPanel;\n  };\n  /**\n   * Set the header content div element of grid\n   *\n   * @param  {Element} panel - specifies the panel element\n   * @returns {void}\n   */\n\n\n  HeaderRender.prototype.setPanel = function (panel) {\n    this.headerPanel = panel;\n  };\n  /**\n   * Get the header table element of grid\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  HeaderRender.prototype.getTable = function () {\n    return this.headerTable;\n  };\n  /**\n   * Set the header table element of grid\n   *\n   * @param  {Element} table - specifies the table element\n   * @returns {void}\n   */\n\n\n  HeaderRender.prototype.setTable = function (table$$1) {\n    this.headerTable = table$$1;\n  };\n  /**\n   * Get the header colgroup element\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  HeaderRender.prototype.getColGroup = function () {\n    return this.colgroup;\n  };\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} returns the element\n   */\n\n\n  HeaderRender.prototype.setColGroup = function (colGroup$$1) {\n    return this.colgroup = colGroup$$1;\n  };\n  /**\n   * Get the header row element collection.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  HeaderRender.prototype.getRows = function () {\n    var table$$1 = this.getTable();\n    return table$$1.tHead.rows;\n  };\n  /**\n   * The function is used to create header table elements\n   *\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  HeaderRender.prototype.createHeaderTable = function () {\n    var table$$1 = this.createTable();\n    var innerDiv = this.getPanel().querySelector('.' + headerContent);\n    innerDiv.appendChild(table$$1);\n    return innerDiv;\n  };\n  /**\n   * The function is used to create header table elements\n   *\n   * @param {Element} tableEle - specifies the table Element\n   * @param {freezeTable} tableName - specifies the table name\n   * @returns {Element} returns the element\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  HeaderRender.prototype.createHeader = function (tableEle, tableName) {\n    if (tableEle === void 0) {\n      tableEle = null;\n    }\n\n    var gObj = this.parent;\n    var isFrozen = gObj.isFrozenGrid();\n\n    if (this.getTable() && !isFrozen) {\n      remove(this.getTable());\n    }\n\n    var table$$1 = this.parent.createElement('table', {\n      className: table,\n      attrs: {\n        cellspacing: '0.25px',\n        role: 'grid'\n      }\n    });\n    var tblName = tableName ? tableName : gObj.getFrozenLeftCount() ? 'frozen-left' : 'frozen-right';\n    var findHeaderRow = this.createHeaderContent(tblName);\n    var thead = findHeaderRow.thead;\n    var tbody$$1 = this.parent.createElement(tbody, {\n      className: this.parent.frozenRows ? '' : 'e-hide',\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    this.caption = this.parent.createElement('caption', {\n      innerHTML: this.parent.element.id + '_header_table',\n      className: 'e-hide'\n    });\n    var colGroup$$1 = this.parent.createElement(colGroup);\n    var rowBody = this.parent.createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    var bodyCell;\n    var rows = this.rows = findHeaderRow.rows;\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      for (var j = 0, len_1 = rows[i].cells.length; j < len_1; j++) {\n        bodyCell = this.parent.createElement('td');\n        rowBody.appendChild(bodyCell);\n      }\n    }\n\n    if (gObj.allowFiltering || gObj.allowSorting || gObj.allowGrouping) {\n      table$$1.classList.add('e-sortfilter');\n    }\n\n    this.updateColGroup(colGroup$$1);\n    tbody$$1.appendChild(rowBody);\n    table$$1.appendChild(this.setColGroup(colGroup$$1));\n    table$$1.appendChild(thead);\n    table$$1.appendChild(tbody$$1);\n    table$$1.appendChild(this.caption);\n    this.ariaService.setOptions(table$$1, {\n      colcount: gObj.getColumns().length.toString()\n    });\n    return table$$1;\n  };\n  /**\n   * @param {Element} tableEle - specifies the column\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  HeaderRender.prototype.createTable = function (tableEle) {\n    if (tableEle === void 0) {\n      tableEle = null;\n    }\n\n    return this.createHeader(tableEle);\n  };\n\n  HeaderRender.prototype.createHeaderContent = function (tableName) {\n    var gObj = this.parent;\n    var index = 1;\n    var frozenMode = gObj.getFrozenMode();\n    var columns = gObj.getColumns();\n    var thead = this.parent.createElement('thead', {\n      attrs: {\n        'role': 'rowgroup'\n      }\n    });\n    var colHeader = this.parent.createElement('tr', {\n      className: 'e-columnheader',\n      attrs: {\n        role: 'row'\n      }\n    });\n    var rowRenderer = new RowRenderer(this.serviceLocator, CellType.Header, gObj);\n    rowRenderer.element = colHeader;\n    var rows = [];\n    var headerRow;\n    this.colDepth = measureColumnDepth(gObj.columns);\n\n    for (var i = 0, len = this.colDepth; i < len; i++) {\n      rows[i] = this.generateRow(i);\n      rows[i].cells = [];\n    }\n\n    if (frozenMode !== 'Right') {\n      rows = this.ensureColumns(rows);\n    }\n\n    rows = this.getHeaderCells(rows, tableName);\n\n    if (frozenMode === 'Right') {\n      index = 0;\n      rows = this.ensureColumns(rows);\n    }\n\n    var frzCols = this.parent.getFrozenColumns();\n\n    if (this.parent.isRowDragable() && this.parent.isFrozenGrid() && rows[0].cells[index]) {\n      var colFreezeMode = rows[0].cells[index].column.getFreezeTableName();\n\n      if (colFreezeMode === 'movable' || frozenMode === leftRight && colFreezeMode === frozenRight) {\n        if (frozenMode === 'Right') {\n          rows[0].cells.pop();\n        } else {\n          rows[0].cells.shift();\n        }\n      } else if (!frzCols && colFreezeMode === frozenLeft) {\n        rows[0].cells[0].column.freeze = colFreezeMode === frozenLeft ? 'Left' : 'Right';\n      } else if (frozenMode === 'Right' && colFreezeMode === frozenRight) {\n        rows[0].cells[rows[0].cells.length - 1].column.freeze = 'Right';\n      }\n    }\n\n    for (var i = 0, len = this.colDepth; i < len; i++) {\n      headerRow = rowRenderer.render(rows[i], columns);\n\n      if (this.parent.rowHeight && headerRow.querySelector('.e-headercell')) {\n        headerRow.style.height = this.parent.rowHeight + 'px';\n      }\n\n      thead.appendChild(headerRow);\n    }\n\n    var findHeaderRow = {\n      thead: thead,\n      rows: rows\n    };\n    return findHeaderRow;\n  };\n\n  HeaderRender.prototype.updateColGroup = function (colGroup$$1) {\n    var cols = this.parent.getColumns();\n    var col;\n    var indexes = this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && this.parent.contentModule.isXaxis()) {\n      cols = extend([], this.parent.getColumns());\n      cols.splice(0, this.parent.getFrozenColumns());\n    }\n\n    colGroup$$1.id = this.parent.element.id + colGroup;\n\n    if (this.parent.allowGrouping) {\n      for (var i = 0, len = this.parent.groupSettings.columns.length; i < len; i++) {\n        if (this.parent.enableColumnVirtualization && indexes.indexOf(i) === -1) {\n          continue;\n        }\n\n        col = this.parent.createElement('col', {\n          className: 'e-group-intent'\n        });\n        colGroup$$1.appendChild(col);\n      }\n    }\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      col = this.parent.createElement('col', {\n        className: 'e-detail-intent'\n      });\n      colGroup$$1.appendChild(col);\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() !== 'Right') {\n      col = this.parent.createElement('col', {\n        className: 'e-drag-intent'\n      });\n      colGroup$$1.appendChild(col);\n    }\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      col = this.parent.createElement('col');\n\n      if (cols[i].visible === false) {\n        setStyleAttribute(col, {\n          'display': 'none'\n        });\n      }\n\n      colGroup$$1.appendChild(col);\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() === 'Right') {\n      col = this.parent.createElement('col', {\n        className: 'e-drag-intent'\n      });\n      colGroup$$1.appendChild(col);\n    }\n\n    return colGroup$$1;\n  };\n\n  HeaderRender.prototype.ensureColumns = function (rows) {\n    //TODO: generate dummy column for group, detail, stacked row here; ensureColumns here\n    var gObj = this.parent;\n    var indexes = this.parent.getColumnIndexesInView();\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      if (gObj.allowGrouping) {\n        for (var c = 0, len_2 = gObj.groupSettings.columns.length; c < len_2; c++) {\n          if (this.parent.enableColumnVirtualization && indexes.indexOf(c) === -1) {\n            continue;\n          }\n\n          rows[i].cells.push(this.generateCell({}, CellType.HeaderIndent));\n        }\n      }\n\n      if (gObj.detailTemplate || gObj.childGrid) {\n        var args = {};\n        this.parent.notify(detailIndentCellInfo, args);\n        rows[i].cells.push(this.generateCell(args, CellType.DetailHeader));\n      }\n\n      if (gObj.isRowDragable()) {\n        rows[i].cells.push(this.generateCell({}, CellType.RowDragHIcon));\n      }\n    }\n\n    return rows;\n  };\n\n  HeaderRender.prototype.getHeaderCells = function (rows, tableName) {\n    var thead = this.parent.getHeaderTable() && this.parent.getHeaderTable().querySelector('thead');\n    var cols = this.parent.enableColumnVirtualization ? this.parent.getColumns(this.parent.enablePersistence) : this.parent.columns;\n    this.frzIdx = 0;\n    this.notfrzIdx = 0;\n\n    if (this.parent.lockcolPositionCount) {\n      for (var i = 0; i < cols.length; i++) {\n        this.lockColsRendered = false;\n        rows = this.appendCells(cols[i], rows, 0, i === 0, false, i === cols.length - 1, thead, tableName, false);\n      }\n    }\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      this.notfrzIdx = 0;\n      this.lockColsRendered = true;\n      rows = this.appendCells(cols[i], rows, 0, i === 0, false, i === len - 1, thead, tableName, false);\n    }\n\n    return rows;\n  };\n\n  HeaderRender.prototype.appendCells = function (cols, rows, index, isFirstObj, isFirstCol, isLastCol, isMovable, tableName, isStackLastCol) {\n    var lastCol = isLastCol ? isStackLastCol ? 'e-laststackcell' : 'e-lastcell' : '';\n    var isFrozen = this.parent.isFrozenGrid();\n    var isLockColumn = !this.parent.lockcolPositionCount || cols.lockColumn && !this.lockColsRendered || !cols.lockColumn && this.lockColsRendered;\n    var isFrozenLockColumn = !this.parent.lockcolPositionCount || cols.lockColumn && !this.lockColsRendered || !cols.lockColumn && this.lockColsRendered;\n    var scrollbar = this.parent.getContent().querySelector('.e-movablescrollbar');\n    var left;\n\n    if (isFrozen && scrollbar && this.parent.enableColumnVirtualization) {\n      left = scrollbar.scrollLeft;\n    }\n\n    if (!cols.columns) {\n      if (left && left > 0 && this.parent.contentModule.isXaxis() && this.parent.inViewIndexes[0] !== 0 && cols.getFreezeTableName() === 'movable') {\n        rows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, (isFirstObj ? '' : isFirstCol ? 'e-firstcell' : '') + lastCol, index, this.parent.getColumnIndexByUid(cols.uid)));\n      } else {\n        if (!isFrozen && isLockColumn || isFrozen && cols.getFreezeTableName() === tableName && isFrozenLockColumn) {\n          rows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, (isFirstObj ? '' : isFirstCol ? 'e-firstcell' : '') + lastCol, index, this.parent.getColumnIndexByUid(cols.uid)));\n        }\n      }\n\n      if (this.parent.lockcolPositionCount) {\n        if (this.frzIdx + this.notfrzIdx < this.parent.frozenColumns && (cols.lockColumn && !this.lockColsRendered || !cols.lockColumn && this.lockColsRendered)) {\n          this.frzIdx++;\n        } else {\n          this.notfrzIdx++;\n        }\n      } else {\n        this.frzIdx++;\n      }\n    } else {\n      this.isFirstCol = false;\n      var colSpan = this.getCellCnt(cols, 0);\n\n      if (colSpan) {\n        var stackedLockColsCount = this.getStackedLockColsCount(cols, 0);\n        var isStackedLockColumn = this.parent.lockcolPositionCount === 0 || !this.lockColsRendered && stackedLockColsCount !== 0 || this.lockColsRendered && colSpan - stackedLockColsCount !== 0;\n        var isFrozenStack = isFrozen && this.ensureStackedFrozen(cols.columns, tableName, false);\n\n        if (!isFrozen && isStackedLockColumn || isFrozenStack) {\n          rows[index].cells.push(new Cell({\n            cellType: CellType.StackedHeader,\n            column: cols,\n            colSpan: this.getColSpan(colSpan, stackedLockColsCount, cols.columns, tableName, isFrozen),\n            className: isFirstObj ? '' : isFirstCol ? 'e-firstcell' : ''\n          }));\n        }\n      }\n\n      if (this.parent.lockcolPositionCount && !this.lockColsRendered) {\n        for (var i = 0; i < cols.columns.length; i++) {\n          rows = this.appendCells(cols.columns[i], rows, index + 1, isFirstObj, i === 0, i === cols.columns.length - 1 && isLastCol, isMovable, tableName, false);\n        }\n      }\n\n      if (this.lockColsRendered) {\n        for (var i = 0, len = cols.columns.length; i < len; i++) {\n          isFirstObj = isFirstObj && i === 0;\n          var isFirstCol_1 = this.isFirstCol = cols.columns[i].visible && !isFirstObj;\n          var isLaststackedCol = i === len - 1 && isLastCol;\n          rows = this.appendCells(cols.columns[i], rows, index + 1, isFirstObj, isFirstCol_1 && !isLaststackedCol, isLaststackedCol, isMovable, tableName, true);\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  HeaderRender.prototype.ensureStackedFrozen = function (columns, tableName, isTrue) {\n    var length = columns.length;\n\n    for (var i = 0; i < length; i++) {\n      if (columns[i].columns) {\n        isTrue = this.ensureStackedFrozen(columns[i].columns, tableName, isTrue);\n      } else if (columns[i].getFreezeTableName() === tableName) {\n        isTrue = true;\n        break;\n      }\n    }\n\n    return isTrue;\n  };\n\n  HeaderRender.prototype.getStackedLockColsCount = function (col, lockColsCount) {\n    if (col.columns) {\n      for (var i = 0; i < col.columns.length; i++) {\n        lockColsCount = this.getStackedLockColsCount(col.columns[i], lockColsCount);\n      }\n    } else if (col.lockColumn) {\n      lockColsCount++;\n    }\n\n    return lockColsCount;\n  };\n\n  HeaderRender.prototype.getColSpan = function (colSpan, stackedLockColsCount, columns, tableName, isFrozen) {\n    if (isFrozen) {\n      colSpan = this.getFrozenColSpan(columns, tableName, 0);\n    } else if (this.parent.lockcolPositionCount) {\n      colSpan = !this.lockColsRendered ? stackedLockColsCount : colSpan - stackedLockColsCount;\n    }\n\n    return colSpan;\n  };\n\n  HeaderRender.prototype.getFrozenColSpan = function (columns, tableName, count) {\n    var length = columns.length;\n\n    for (var i = 0; i < length; i++) {\n      if (columns[i].columns) {\n        count = this.getFrozenColSpan(columns[i].columns, tableName, count);\n      } else if (columns[i].getFreezeTableName() === tableName && columns[i].visible) {\n        count++;\n      }\n    }\n\n    return count;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  HeaderRender.prototype.generateRow = function (index) {\n    return new Row({});\n  };\n\n  HeaderRender.prototype.generateCell = function (column, cellType, rowSpan, className, rowIndex, colIndex) {\n    var opt = {\n      'visible': column.visible,\n      'isDataCell': false,\n      'isTemplate': !isNullOrUndefined(column.headerTemplate),\n      'rowID': '',\n      'column': column,\n      'cellType': cellType,\n      'rowSpan': rowSpan,\n      'className': className,\n      'index': rowIndex,\n      'colIndex': colIndex\n    };\n\n    if (!opt.rowSpan || opt.rowSpan < 2) {\n      delete opt.rowSpan;\n    }\n\n    return new Cell(opt);\n  };\n  /**\n   * Function to hide header table column based on visible property\n   *\n   * @param {Column[]} columns - specifies the column\n   * @returns {void}\n   */\n\n\n  HeaderRender.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var displayVal;\n    var idx;\n    var frzCols = gObj.getFrozenColumns();\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n\n      if (frzCols) {\n        var normalizedfrzCols = this.parent.isRowDragable() ? frzCols + 1 : frzCols;\n\n        if (idx < normalizedfrzCols) {\n          setStyleAttribute(this.getColGroup().children[idx], {\n            'display': displayVal\n          });\n        } else {\n          var mTblColGrp = gObj.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup);\n          setStyleAttribute(mTblColGrp.children[idx - normalizedfrzCols], {\n            'display': displayVal\n          });\n        }\n      } else {\n        setStyleAttribute(this.getColGroup().children[idx], {\n          'display': displayVal\n        });\n      }\n    }\n\n    this.refreshUI();\n  };\n\n  HeaderRender.prototype.colPosRefresh = function () {\n    this.refreshUI();\n  };\n  /**\n   * Refresh the header of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  HeaderRender.prototype.refreshUI = function () {\n    var frzCols = this.parent.isFrozenGrid();\n    var isVFTable = this.parent.enableColumnVirtualization && frzCols;\n    var headerDiv = this.getPanel();\n    this.toggleStackClass(headerDiv);\n    var table$$1 = this.freezeReorder ? this.headerPanel.querySelector('.' + movableHeader).querySelector('.' + table) : this.getTable();\n    var tableName = this.parent.isFrozenGrid() ? this.parent.getFrozenLeftCount() ? 'frozen-left' : 'frozen-right' : undefined;\n\n    if (isVFTable) {\n      table$$1 = this.parent.contentModule.getVirtualFreezeHeader();\n      tableName = this.parent.contentModule.isXaxis() ? 'movable' : tableName;\n    }\n\n    if (table$$1) {\n      remove(table$$1);\n      table$$1.removeChild(table$$1.firstChild);\n      table$$1.removeChild(table$$1.childNodes[0]);\n      var colGroup$$1 = this.parent.createElement(colGroup);\n      var findHeaderRow = this.createHeaderContent(tableName);\n      this.rows = findHeaderRow.rows;\n      table$$1.insertBefore(findHeaderRow.thead, table$$1.firstChild);\n      this.updateColGroup(colGroup$$1);\n      table$$1.insertBefore(this.setColGroup(colGroup$$1), table$$1.firstChild);\n\n      if (!isVFTable) {\n        this.setTable(table$$1);\n      }\n\n      this.appendContent(table$$1);\n      this.parent.notify(colGroupRefresh, {});\n      this.widthService.setWidthToColumns();\n      this.parent.updateDefaultCursor();\n\n      if (!frzCols || this.parent.enableColumnVirtualization && frzCols) {\n        this.initializeHeaderDrag();\n      }\n\n      var rows = [].slice.call(headerDiv.querySelectorAll('tr.e-columnheader'));\n\n      for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n        var row$$1 = rows_1[_i];\n        var gCells = [].slice.call(row$$1.getElementsByClassName('e-grouptopleftcell'));\n\n        if (gCells.length) {\n          gCells[gCells.length - 1].classList.add('e-lastgrouptopleftcell');\n        }\n      }\n\n      if (!frzCols) {\n        this.parent.notify(headerRefreshed, {\n          rows: this.rows,\n          args: {\n            isFrozen: frzCols\n          }\n        });\n      }\n\n      if (this.parent.enableColumnVirtualization && parentsUntil(table$$1, movableHeader)) {\n        this.parent.notify(headerRefreshed, {\n          rows: this.rows,\n          args: {\n            isFrozen: false,\n            isXaxis: true\n          }\n        });\n      }\n\n      if (this.parent.allowTextWrap && this.parent.textWrapSettings.wrapMode === 'Header') {\n        wrap(rows, true);\n      }\n    }\n  };\n\n  HeaderRender.prototype.toggleStackClass = function (div) {\n    var column = this.parent.columns;\n    var stackedHdr = column.some(function (column) {\n      return !isNullOrUndefined(column.columns);\n    });\n\n    if (stackedHdr) {\n      div.classList.add('e-stackedheader');\n    } else {\n      div.classList.remove('e-stackedheader');\n    }\n  };\n\n  HeaderRender.prototype.appendContent = function (table$$1) {\n    this.getPanel().querySelector('.' + headerContent).appendChild(table$$1);\n  };\n\n  HeaderRender.prototype.getCellCnt = function (col, cnt) {\n    if (col.columns) {\n      for (var i = 0, len = col.columns.length; i < len; i++) {\n        cnt = this.getCellCnt(col.columns[i], cnt);\n      }\n    } else {\n      if (col.visible) {\n        cnt++;\n      }\n    }\n\n    return cnt;\n  };\n\n  HeaderRender.prototype.initializeHeaderDrag = function () {\n    var gObj = this.parent;\n\n    if (!(this.parent.allowReordering || this.parent.allowGrouping && this.parent.groupSettings.showDropArea)) {\n      return;\n    }\n\n    this.draggable = new Draggable(gObj.getHeaderContent(), {\n      dragTarget: '.e-headercell',\n      distance: 5,\n      helper: this.helper,\n      dragStart: this.dragStart,\n      drag: this.drag,\n      dragStop: this.dragStop,\n      abort: '.e-rhandler',\n      isReplaceDragEle: this.isReplaceDragEle\n    });\n  };\n\n  HeaderRender.prototype.initializeHeaderDrop = function () {\n    var gObj = this.parent; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    var drop = new Droppable(gObj.getHeaderContent(), {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  };\n\n  HeaderRender.prototype.renderCustomToolbar = function () {\n    var _this = this;\n\n    var gObj = this.parent;\n\n    if (gObj.rowRenderingMode === 'Vertical' && !gObj.toolbar && (gObj.allowSorting || gObj.allowFiltering && gObj.filterSettings.type !== 'FilterBar')) {\n      var div = gObj.createElement('div', {\n        className: 'e-res-toolbar e-toolbar'\n      });\n      var toolbarItems = gObj.createElement('div', {\n        className: 'e-toolbar-items'\n      });\n      var toolbarLeft = gObj.createElement('div', {\n        className: 'e-toolbar-left'\n      });\n      var count = this.parent.allowFiltering && this.parent.allowSorting ? 2 : 1;\n\n      for (var i = 0; i < count; i++) {\n        var toolbarItem = gObj.createElement('div', {\n          className: 'e-toolbar-item e-gridresponsiveicons e-icons e-tbtn-align'\n        });\n        var cls = count === 1 ? this.parent.allowSorting ? 'sort' : 'filter' : i === 1 ? 'sort' : 'filter';\n        var button = gObj.createElement('button', {\n          className: 'e-tbar-btn e-control e-btn e-lib e-icon-btn'\n        });\n        var span = gObj.createElement('span', {\n          className: 'e-btn-icon e-res' + cls + '-icon e-icons'\n        });\n        button.appendChild(span);\n        var btnObj = new Button({\n          cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n        });\n        btnObj.appendTo(button);\n\n        button.onclick = function (e) {\n          if (e.target.classList.contains('e-ressort-btn') || e.target.classList.contains('e-ressort-icon')) {\n            _this.parent.showResponsiveCustomSort();\n          } else {\n            _this.parent.showResponsiveCustomFilter();\n          }\n        };\n\n        toolbarItem.appendChild(button);\n        toolbarLeft.appendChild(toolbarItem);\n      }\n\n      toolbarItems.appendChild(toolbarLeft);\n      div.appendChild(toolbarItems);\n      gObj.element.insertBefore(div, this.parent.element.querySelector('.' + gridHeader));\n    } else {\n      if (gObj.enableAdaptiveUI && !gObj.toolbar) {\n        gObj.getContent().classList.add('e-responsive-header');\n      }\n    }\n  };\n\n  HeaderRender.prototype.updateCustomResponsiveToolbar = function (args) {\n    var resToolbar = this.parent.element.querySelector('.e-responsive-toolbar');\n\n    if (args.module === 'toolbar') {\n      if (resToolbar) {\n        remove(resToolbar);\n      } else {\n        this.renderCustomToolbar();\n      }\n    }\n  };\n\n  return HeaderRender;\n}();\n/**\n * CellRenderer class which responsible for building cell content.\n *\n * @hidden\n */\n\n\nvar CellRenderer =\n/** @__PURE__ @class */\nfunction () {\n  function CellRenderer(parent, locator) {\n    this.localizer = locator.getService('localization');\n    this.formatter = locator.getService('valueFormatter');\n    this.parent = parent;\n    this.element = this.parent.createElement('TD', {\n      className: rowCell,\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    this.rowChkBox = this.parent.createElement('input', {\n      className: 'e-checkselect',\n      attrs: {\n        'type': 'checkbox',\n        'aria-label': this.localizer.getConstant('CheckBoxLabel')\n      }\n    });\n  }\n  /**\n   * Function to return the wrapper for the TD content\n   *\n   * @returns {string | Element} returns the string\n   */\n\n\n  CellRenderer.prototype.getGui = function () {\n    return '';\n  };\n  /**\n   * Function to format the cell value.\n   *\n   * @param  {Column} column - specifies the column\n   * @param  {Object} value - specifies the value\n   * @param  {Object} data - specifies the data\n   * @returns {string} returns the format\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  CellRenderer.prototype.format = function (column, value, data) {\n    if (!isNullOrUndefined(column.format)) {\n      if (column.type === 'number' && isNaN(parseInt(value, 10))) {\n        value = null;\n      }\n\n      value = this.formatter.toView(value, column.getFormatter());\n    }\n\n    return isNullOrUndefined(value) ? '' : value.toString();\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  CellRenderer.prototype.evaluate = function (node, cell, data, attributes$$1, fData, isEdit) {\n    var _a;\n\n    var result;\n\n    if (cell.column.template) {\n      var isReactCompiler = this.parent.isReact && typeof cell.column.template !== 'string';\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n      var literals_1 = ['index'];\n      var dummyData = extendObjWithFn({}, data, (_a = {}, _a[foreignKeyData] = fData, _a.column = cell.column, _a));\n      var templateID = this.parent.element.id + cell.column.uid;\n      var str = 'isStringTemplate';\n\n      if (isReactCompiler || isReactChild) {\n        var copied = {\n          'index': attributes$$1[literals_1[0]]\n        };\n        cell.column.getColumnTemplate()(extend(copied, dummyData), this.parent, 'columnTemplate', templateID, this.parent[str], null, node);\n        this.parent.renderTemplates();\n      } else {\n        result = cell.column.getColumnTemplate()(extend({\n          'index': attributes$$1[literals_1[0]]\n        }, dummyData), this.parent, 'template', templateID, this.parent[str], undefined, undefined, this.parent['root']);\n      }\n\n      if (!isReactCompiler && !isReactChild) {\n        appendChildren(node, result);\n      }\n\n      this.parent.notify('template-result', {\n        template: result\n      });\n      result = null;\n      node.setAttribute('aria-label', node.innerText + this.localizer.getConstant('TemplateCell') + this.localizer.getConstant('ColumnHeader') + cell.column.headerText);\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Function to invoke the custom formatter available in the column object.\n   *\n   * @param  {Column} column - specifies the column\n   * @param  {Object} value - specifies the value\n   * @param  {Object} data - specifies the data\n   * @returns {Object} returns the object\n   */\n\n\n  CellRenderer.prototype.invokeFormatter = function (column, value, data) {\n    if (!isNullOrUndefined(column.formatter)) {\n      if (doesImplementInterface(column.formatter, 'getValue')) {\n        var formatter = column.formatter;\n        value = new formatter().getValue(column, data);\n      } else if (typeof column.formatter === 'function') {\n        value = column.formatter(column, data);\n      } else {\n        value = column.formatter.getValue(column, data);\n      }\n    }\n\n    return value;\n  };\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attributes\n   * @param {boolean} isExpand - specifies the boolean for expand\n   * @param {boolean} isEdit - specifies the boolean for edit\n   * @returns {Element} returns the element\n   */\n\n\n  CellRenderer.prototype.render = function (cell, data, attributes$$1, isExpand, isEdit) {\n    return this.refreshCell(cell, data, attributes$$1, isEdit);\n  };\n  /**\n   * Function to refresh the cell content based on Column object.\n   *\n   * @param {Element} td - specifies the element\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attribute\n   * @returns {void}\n   */\n\n\n  CellRenderer.prototype.refreshTD = function (td, cell, data, attributes$$1) {\n    var isEdit = this.parent.editSettings.mode === 'Batch' && td.classList.contains('e-editedbatchcell');\n\n    if (this.parent.isReact) {\n      td.innerHTML = '';\n      var cellIndex = td.cellIndex;\n      var parentRow = td.parentElement;\n      remove(td);\n      var newTD = this.refreshCell(cell, data, attributes$$1, isEdit);\n      this.cloneAttributes(newTD, td);\n\n      if (parentRow.cells.length !== cellIndex - 1) {\n        parentRow.insertBefore(newTD, parentRow.cells[cellIndex]);\n      } else {\n        parentRow.appendChild(newTD);\n      }\n    } else {\n      var node = this.refreshCell(cell, data, attributes$$1, isEdit);\n      td.innerHTML = '';\n      td.setAttribute('aria-label', node.getAttribute('aria-label'));\n      var elements = [].slice.call(node.childNodes);\n\n      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n        var elem = elements_1[_i];\n        td.appendChild(elem);\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  CellRenderer.prototype.cloneAttributes = function (target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var attrs = source.attributes; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var i = attrs.length; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var attr;\n\n    while (i--) {\n      attr = attrs[i];\n      target.setAttribute(attr.name, attr.value);\n    }\n  };\n\n  CellRenderer.prototype.refreshCell = function (cell, data, attributes$$1, isEdit) {\n    var _a;\n\n    var node = this.element.cloneNode();\n    var column = cell.column;\n    var fData;\n\n    if (cell.isForeignKey) {\n      fData = cell.foreignKeyData[0] || (_a = {}, _a[column.foreignKeyValue] = column.format ? null : '', _a);\n    } //Prepare innerHtml\n\n\n    var innerHtml = this.getGui();\n    var value = cell.isForeignKey ? this.getValue(column.foreignKeyValue, fData, column) : this.getValue(column.field, data, column);\n\n    if ((column.type === 'date' || column.type === 'datetime') && !isNullOrUndefined(value)) {\n      value = new Date(value);\n    }\n\n    value = this.format(column, value, data);\n    innerHtml = value.toString();\n\n    if (column.type === 'boolean' && !column.displayAsCheckBox) {\n      var localeStr = value !== 'true' && value !== 'false' ? null : value === 'true' ? 'True' : 'False';\n      innerHtml = localeStr ? this.localizer.getConstant(localeStr) : innerHtml;\n    }\n\n    var fromFormatter = this.invokeFormatter(column, value, data);\n    innerHtml = !isNullOrUndefined(column.formatter) ? isNullOrUndefined(fromFormatter) ? '' : fromFormatter.toString() : innerHtml;\n    node.setAttribute('aria-label', innerHtml + this.localizer.getConstant('ColumnHeader') + cell.column.headerText);\n\n    if (this.evaluate(node, cell, data, attributes$$1, fData, isEdit) && column.type !== 'checkbox') {\n      this.appendHtml(node, innerHtml, column.getDomSetter ? column.getDomSetter() : 'innerHTML');\n    } else if (column.type === 'checkbox') {\n      node.classList.add(gridChkBox);\n      node.setAttribute('aria-label', this.localizer.getConstant('CheckBoxLabel'));\n\n      if (this.parent.selectionSettings.persistSelection) {\n        value = value === 'true';\n      } else {\n        value = false;\n      }\n\n      var checkWrap = createCheckBox(this.parent.createElement, false, {\n        checked: value,\n        label: ' '\n      });\n\n      if (this.parent.cssClass) {\n        addClass([checkWrap], [this.parent.cssClass]);\n      }\n\n      this.rowChkBox.id = 'checkbox-' + cell.rowID;\n      checkWrap.insertBefore(this.rowChkBox.cloneNode(), checkWrap.firstChild);\n      node.appendChild(checkWrap);\n    }\n\n    if (this.parent.checkAllRows === 'Check' && this.parent.enableVirtualization) {\n      cell.isSelected = true;\n    }\n\n    this.setAttributes(node, cell, attributes$$1);\n\n    if (column.type === 'boolean' && column.displayAsCheckBox) {\n      var checked = isNaN(parseInt(value.toString(), 10)) ? value === 'true' : parseInt(value.toString(), 10) > 0;\n      var checkWrap = createCheckBox(this.parent.createElement, false, {\n        checked: checked,\n        label: ' '\n      });\n      node.innerHTML = '';\n      checkWrap.classList.add('e-checkbox-disabled');\n\n      if (this.parent.cssClass) {\n        addClass([checkWrap], [this.parent.cssClass]);\n      }\n\n      node.appendChild(checkWrap);\n      node.setAttribute('aria-label', checked + this.localizer.getConstant('ColumnHeader') + cell.column.headerText);\n    }\n\n    return node;\n  };\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   *\n   * @param {Element} node - specifies the node\n   * @param {string|Element} innerHtml - specifies the innerHTML\n   * @param {string} property - specifies the element\n   * @returns {Element} returns the element\n   */\n\n\n  CellRenderer.prototype.appendHtml = function (node, innerHtml, property) {\n    if (property === void 0) {\n      property = 'innerHTML';\n    }\n\n    node[property] = innerHtml;\n    return node;\n  };\n  /**\n   * @param {HTMLElement} node - specifies the node\n   * @param {cell<Column>} cell - specifies the cell\n   * @param {Object} attributes - specifies the attributes\n   * @returns {void}\n   * @hidden\n   */\n\n\n  CellRenderer.prototype.setAttributes = function (node, cell, attributes$$1) {\n    var column = cell.column;\n    this.buildAttributeFromCell(node, cell, column.type === 'checkbox');\n    setStyleAndAttributes(node, attributes$$1);\n    setStyleAndAttributes(node, cell.attributes);\n\n    if (column.customAttributes) {\n      setStyleAndAttributes(node, column.customAttributes);\n    }\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      setStyleAndAttributes(node, {\n        'data-cell': column.headerText\n      });\n    }\n\n    if (column.textAlign) {\n      node.style.textAlign = column.textAlign;\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      if (column.type !== 'checkbox') {\n        node.classList.add('e-ellipsistooltip');\n      }\n    }\n  };\n\n  CellRenderer.prototype.buildAttributeFromCell = function (node, cell, isCheckBoxType) {\n    var attr = {};\n    var prop = {\n      'colindex': dataColIndex\n    };\n    var classes = [];\n\n    if (cell.colSpan) {\n      attr.colSpan = cell.colSpan;\n    }\n\n    if (cell.rowSpan) {\n      attr.rowSpan = cell.rowSpan;\n    }\n\n    if (cell.isTemplate) {\n      classes.push('e-templatecell');\n    }\n\n    if (cell.isSelected) {\n      classes.push.apply(classes, ['e-selectionbackground', 'e-active']);\n\n      if (isCheckBoxType) {\n        node.querySelector('.e-frame').classList.add('e-check');\n      }\n    }\n\n    if (cell.isColumnSelected) {\n      classes.push.apply(classes, ['e-columnselection']);\n    }\n\n    if (cell.cellType === CellType.Header) {\n      attr[prop.colindex] = cell.colIndex;\n      attr[ariaColIndex] = cell.colIndex + 1;\n    } else if (!isNullOrUndefined(cell.index)) {\n      attr[prop.colindex] = cell.index;\n      attr[ariaColIndex] = cell.index + 1;\n    }\n\n    if (!cell.visible) {\n      classes.push('e-hide');\n    }\n\n    attr.class = classes;\n    setStyleAndAttributes(node, attr);\n  };\n\n  CellRenderer.prototype.getValue = function (field, data, column) {\n    return column.valueAccessor(field, data, column);\n  };\n\n  return CellRenderer;\n}();\n/**\n * AriaService\n *\n * @hidden\n */\n\n\nvar AriaService =\n/** @__PURE__ @class */\nfunction () {\n  function AriaService() {}\n\n  AriaService.prototype.setOptions = function (target, options) {\n    var props = Object.keys(options);\n\n    for (var i = 0; i < props.length; i++) {\n      setStateAndProperties(target, config[props[i]], options[props[i]]);\n    }\n  };\n\n  AriaService.prototype.setExpand = function (target, expand) {\n    setStateAndProperties(target, config.expand, expand);\n  };\n\n  AriaService.prototype.setSort = function (target, direction) {\n    setStateAndProperties(target, config.sort, direction, typeof direction === 'boolean');\n  };\n\n  AriaService.prototype.setBusy = function (target, isBusy) {\n    setStateAndProperties(target, config.busy, isBusy);\n    setStateAndProperties(target, config.invalid, null, true);\n  };\n\n  AriaService.prototype.setGrabbed = function (target, isGrabbed, remove$$1) {\n    setStateAndProperties(target, config.grabbed, isGrabbed, remove$$1);\n  };\n\n  AriaService.prototype.setDropTarget = function (target, isTarget) {\n    setStateAndProperties(target, config.dropeffect, 'copy', !isTarget);\n  };\n\n  return AriaService;\n}();\n/**\n * @param {HTMLElement} target - specifies the target\n * @param {string} attribute - specifies the attribute\n * @param {ValueType} value - specifies the value\n * @param {boolean} remove - specifies the boolean for remove\n * @returns {void}\n * @hidden\n */\n\n\nfunction setStateAndProperties(target, attribute, value, remove$$1) {\n  if (remove$$1 && target) {\n    target.removeAttribute(attribute);\n    return;\n  }\n\n  if (target) {\n    target.setAttribute(attribute, value);\n  }\n}\n\nvar config = {\n  expand: 'aria-expanded',\n  role: 'role',\n  datarole: 'data-role',\n  selected: 'aria-selected',\n  multiselectable: 'aria-multiselectable',\n  sort: 'aria-sort',\n  busy: 'aria-busy',\n  invalid: 'aria-invalid',\n  grabbed: 'aria-grabbed',\n  dropeffect: 'aria-dropeffect',\n  haspopup: 'aria-haspopup',\n  level: 'aria-level',\n  colcount: 'aria-colcount',\n  rowcount: 'aria-rowcount'\n};\n\nvar __extends$4 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * HeaderCellRenderer class which responsible for building header cell content.\n *\n * @hidden\n */\n\n\nvar HeaderCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$4(HeaderCellRenderer, _super);\n\n  function HeaderCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TH', {\n      className: 'e-headercell',\n      attrs: {\n        role: 'columnheader',\n        tabindex: '-1'\n      }\n    });\n    _this.ariaService = new AriaService();\n    _this.hTxtEle = _this.parent.createElement('span', {\n      className: 'e-headertext'\n    });\n    _this.sortEle = _this.parent.createElement('div', {\n      className: 'e-sortfilterdiv e-icons',\n      attrs: {\n        'aria-hidden': 'true'\n      }\n    });\n    _this.gui = _this.parent.createElement('div');\n    _this.chkAllBox = _this.parent.createElement('input', {\n      className: 'e-checkselectall',\n      attrs: {\n        'type': 'checkbox',\n        'aria-label': _this.localizer.getConstant('CheckBoxLabel')\n      }\n    });\n    return _this;\n  }\n  /**\n   * Function to return the wrapper for the TH content.\n   *\n   * @returns {string | Element} returns the element\n   */\n\n\n  HeaderCellRenderer.prototype.getGui = function () {\n    return this.gui.cloneNode();\n  };\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell} cell - specifies the column\n   * @param {Object} data - specifies the data\n   * @param {object} attributes - specifies the aattributes\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  HeaderCellRenderer.prototype.render = function (cell, data, attributes$$1) {\n    var node = this.element.cloneNode();\n    var fltrMenuEle = this.parent.createElement('div', {\n      className: 'e-filtermenudiv e-icons e-icon-filter',\n      attrs: {\n        'aria-hidden': 'true'\n      }\n    });\n    return this.prepareHeader(cell, node, fltrMenuEle);\n  };\n  /**\n   * Function to refresh the cell content based on Column object.\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Element} node - specifies the noe\n   * @returns {Element} returns the element\n   */\n\n\n  HeaderCellRenderer.prototype.refresh = function (cell, node) {\n    this.clean(node);\n    var fltrMenuEle = this.parent.createElement('div', {\n      className: 'e-filtermenudiv e-icons e-icon-filter',\n      attrs: {\n        'aria-hidden': 'true'\n      }\n    });\n    return this.prepareHeader(cell, node, fltrMenuEle);\n  };\n\n  HeaderCellRenderer.prototype.clean = function (node) {\n    node.innerHTML = '';\n  };\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  HeaderCellRenderer.prototype.prepareHeader = function (cell, node, fltrMenuEle) {\n    var column = cell.column;\n    var ariaAttr = {};\n    var elementDesc = ''; //Prepare innerHtml\n\n    var innerDIV = this.getGui();\n    var hValueAccer;\n    attributes(innerDIV, {\n      'e-mappinguid': column.uid,\n      'class': 'e-headercelldiv'\n    });\n\n    if (!isNullOrUndefined(column.headerValueAccessor)) {\n      hValueAccer = this.getValue(column.headerText, column);\n    }\n\n    if (column.type !== 'checkbox') {\n      var value = column.headerText;\n\n      if (!isNullOrUndefined(hValueAccer)) {\n        value = hValueAccer;\n      }\n\n      var headerText = this.hTxtEle.cloneNode();\n      headerText[column.getDomSetter()] = value;\n      innerDIV.appendChild(headerText);\n    } else {\n      column.editType = 'booleanedit';\n      var checkAllWrap = createCheckBox(this.parent.createElement, false, {\n        checked: false,\n        label: ' '\n      });\n      this.chkAllBox.id = 'checkbox-' + column.uid;\n      checkAllWrap.insertBefore(this.chkAllBox.cloneNode(), checkAllWrap.firstChild);\n\n      if (this.parent.cssClass) {\n        addClass([checkAllWrap], [this.parent.cssClass]);\n      }\n\n      innerDIV.appendChild(checkAllWrap);\n      innerDIV.classList.add('e-headerchkcelldiv');\n    }\n\n    this.buildAttributeFromCell(node, cell);\n    this.appendHtml(node, innerDIV);\n    node.appendChild(this.sortEle.cloneNode());\n\n    if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar' && column.allowFiltering && !isNullOrUndefined(column.field) && !(this.parent.showColumnMenu && column.showColumnMenu)) {\n      attributes(fltrMenuEle, {\n        'e-mappinguid': 'e-flmenu-' + column.uid\n      });\n      elementDesc = elementDesc.length ? elementDesc + '. ' + this.localizer.getConstant('FilterDescription') : this.localizer.getConstant('FilterDescription');\n      node.classList.add('e-fltr-icon');\n      var matchFlColumns = [];\n\n      if (this.parent.filterSettings.columns.length && this.parent.filterSettings.columns.length !== matchFlColumns.length) {\n        var foreignColumn = this.parent.getForeignKeyColumns();\n\n        for (var index = 0; index < this.parent.columns.length; index++) {\n          for (var count = 0; count < this.parent.filterSettings.columns.length; count++) {\n            if (this.parent.filterSettings.columns[count].field === column.field || foreignColumn.length && column.foreignKeyValue === this.parent.filterSettings.columns[count].field) {\n              fltrMenuEle.classList.add('e-filtered');\n              matchFlColumns.push(column.field);\n              break;\n            }\n          }\n        }\n      }\n\n      node.appendChild(fltrMenuEle.cloneNode());\n    }\n\n    if (cell.className) {\n      node.classList.add(cell.className);\n    }\n\n    if (column.customAttributes) {\n      setStyleAndAttributes(node, column.customAttributes);\n    }\n\n    if (this.parent.allowSorting && column.allowSorting) {\n      ariaAttr.sort = 'none';\n      elementDesc = elementDesc.length ? elementDesc + '. ' + this.localizer.getConstant('SortDescription') : this.localizer.getConstant('SortDescription');\n    }\n\n    if (this.parent.allowGrouping && column.allowGrouping || this.parent.allowReordering && column.allowReordering) {\n      ariaAttr.grabbed = false;\n      elementDesc = elementDesc.length ? elementDesc + '. ' + this.localizer.getConstant('GroupDescription') : this.localizer.getConstant('GroupDescription');\n    }\n\n    if (this.parent.showColumnMenu) {\n      elementDesc = elementDesc.length ? elementDesc + '. ' + this.localizer.getConstant('ColumnMenuDescription') : this.localizer.getConstant('ColumnMenuDescription');\n    }\n\n    node = this.extendPrepareHeader(column, node);\n    var result;\n    var gridObj = this.parent;\n    var colIndex = gridObj.getColumnIndexByField(column.field);\n\n    if (!isNullOrUndefined(column.headerTemplate)) {\n      //need to pass the template id for blazor headertemplate\n      var headerTempID = gridObj.element.id + column.uid + 'headerTemplate';\n      var str = 'isStringTemplate';\n      var col = column;\n      var isReactCompiler = this.parent.isReact && typeof column.headerTemplate !== 'string';\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n\n      if (isReactCompiler || isReactChild) {\n        var copied = {\n          'index': colIndex\n        };\n        node.firstElementChild.innerHTML = '';\n        column.getHeaderTemplate()(extend(copied, col), gridObj, 'headerTemplate', headerTempID, this.parent[str], null, node.firstElementChild);\n        this.parent.renderTemplates();\n      } else {\n        result = column.getHeaderTemplate()(extend({\n          'index': colIndex\n        }, col), gridObj, 'headerTemplate', headerTempID, this.parent[str], undefined, undefined, this.parent['root']);\n        node.firstElementChild.innerHTML = '';\n        appendChildren(node.firstElementChild, result);\n      }\n    }\n\n    this.ariaService.setOptions(node, ariaAttr);\n\n    if (!isNullOrUndefined(column.headerTextAlign) || !isNullOrUndefined(column.textAlign)) {\n      var alignment = column.headerTextAlign || column.textAlign;\n      innerDIV.style.textAlign = alignment;\n\n      if (alignment === 'Right' || alignment === 'Left') {\n        node.classList.add(alignment === 'Right' ? 'e-rightalign' : 'e-leftalign');\n      } else if (alignment === 'Center') {\n        node.classList.add('e-centeralign');\n      }\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      if (column.type !== 'checkbox') {\n        node.classList.add('e-ellipsistooltip');\n      }\n    }\n\n    if (elementDesc) {\n      node.setAttribute('aria-description', elementDesc);\n    }\n\n    node.setAttribute('aria-rowspan', (!isNullOrUndefined(cell.rowSpan) ? cell.rowSpan : 1).toString());\n    node.setAttribute('aria-colspan', '1');\n    this.parent.trigger(headerCellInfo, {\n      cell: cell,\n      node: node\n    });\n    return node;\n  };\n\n  HeaderCellRenderer.prototype.getValue = function (field, column) {\n    return column.headerValueAccessor(field, column);\n  };\n\n  HeaderCellRenderer.prototype.extendPrepareHeader = function (column, node) {\n    if (this.parent.showColumnMenu && column.showColumnMenu && !isNullOrUndefined(column.field)) {\n      var element = this.parent.createElement('div', {\n        className: 'e-icons e-columnmenu',\n        attrs: {\n          'aria-hidden': 'true'\n        }\n      });\n      var matchFilteredColumns = [];\n\n      if (this.parent.filterSettings.columns.length && this.parent.filterSettings.columns.length !== matchFilteredColumns.length) {\n        for (var i = 0; i < this.parent.columns.length; i++) {\n          for (var j = 0; j < this.parent.filterSettings.columns.length; j++) {\n            if (this.parent.filterSettings.columns[j].field === column.field) {\n              element.classList.add('e-filtered');\n              matchFilteredColumns.push(column.field);\n              break;\n            }\n          }\n        }\n      }\n\n      node.classList.add('e-fltr-icon');\n      node.appendChild(element);\n    }\n\n    if (this.parent.allowResizing) {\n      var handler = this.parent.createElement('div');\n      handler.className = column.allowResizing ? 'e-rhandler e-rcursor' : 'e-rsuppress';\n      node.appendChild(handler);\n    }\n\n    return node;\n  };\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   *\n   * @param  {Element} node - specifies the node\n   * @param  {string|Element} innerHtml - specifies the innerHtml\n   * @returns {Element} returns the element\n   */\n\n\n  HeaderCellRenderer.prototype.appendHtml = function (node, innerHtml) {\n    node.appendChild(innerHtml);\n    return node;\n  };\n\n  return HeaderCellRenderer;\n}(CellRenderer);\n\nvar __extends$5 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * StackedHeaderCellRenderer class which responsible for building stacked header cell content.\n *\n * @hidden\n */\n\n\nvar StackedHeaderCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$5(StackedHeaderCellRenderer, _super);\n\n  function StackedHeaderCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TH', {\n      className: 'e-headercell e-stackedheadercell',\n      attrs: {\n        role: 'columnheader',\n        tabindex: '-1'\n      }\n    });\n    return _this;\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {object} attributes - specifies the attributes\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  StackedHeaderCellRenderer.prototype.render = function (cell, data, attributes$$1) {\n    var node = this.element.cloneNode();\n    var div = this.parent.createElement('div', {\n      className: 'e-stackedheadercelldiv',\n      attrs: {\n        'e-mappinguid': cell.column.uid\n      }\n    });\n    var column = cell.column;\n    node.appendChild(div);\n\n    if (!isNullOrUndefined(column.headerTemplate)) {\n      appendChildren(div, column.getHeaderTemplate()(column, this.parent, 'headerTemplate'));\n    } else {\n      this.appendHtml(div, column.headerText, column.getDomSetter());\n    }\n\n    if (cell.column.toolTip) {\n      node.setAttribute('title', cell.column.toolTip);\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      node.classList.add('e-ellipsistooltip');\n    }\n\n    if (!isNullOrUndefined(cell.column.textAlign)) {\n      div.style.textAlign = cell.column.textAlign;\n    }\n\n    if (cell.column.customAttributes) {\n      setStyleAndAttributes(node, cell.column.customAttributes);\n    }\n\n    node.setAttribute('colspan', cell.colSpan.toString());\n    node.setAttribute('aria-colspan', cell.colSpan.toString());\n    node.setAttribute('aria-rowspan', '1');\n\n    if (this.parent.allowResizing) {\n      var handler = this.parent.createElement('div');\n      handler.className = cell.column.allowResizing ? 'e-rhandler e-rcursor' : 'e-rsuppress';\n      node.appendChild(handler);\n    }\n\n    if (cell.className) {\n      node.classList.add(cell.className);\n    }\n\n    this.parent.trigger(headerCellInfo, {\n      cell: cell,\n      node: node\n    });\n    return node;\n  };\n\n  return StackedHeaderCellRenderer;\n}(CellRenderer);\n\nvar __extends$6 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * IndentCellRenderer class which responsible for building group indent cell.\n *\n * @hidden\n */\n\n\nvar IndentCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$6(IndentCellRenderer, _super);\n\n  function IndentCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-indentcell'\n    });\n    return _this;\n  }\n  /**\n   * Function to render the indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  IndentCellRenderer.prototype.render = function (cell, data) {\n    var node = this.element.cloneNode();\n    setStyleAndAttributes(node, cell.attributes);\n    return node;\n  };\n\n  return IndentCellRenderer;\n}(CellRenderer);\n\nvar __extends$7 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * GroupCaptionCellRenderer class which responsible for building group caption cell.\n *\n * @hidden\n */\n\n\nvar GroupCaptionCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$7(GroupCaptionCellRenderer, _super);\n\n  function GroupCaptionCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellUid = 0;\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-groupcaption',\n      attrs: {\n        id: _this.parent.element.id + 'captioncell',\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    return _this;\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the GroupedData\n   * @returns {Element} returns the element\n   */\n\n\n  GroupCaptionCellRenderer.prototype.render = function (cell, data) {\n    this.element.id = this.parent.element.id + 'captioncell' + this.cellUid++;\n    var node = this.element.cloneNode();\n    var gObj = this.parent;\n    var result;\n    var fKeyValue;\n    var gTemplateValue;\n    data.headerText = cell.column.headerText;\n\n    if (cell.isForeignKey) {\n      fKeyValue = this.format(cell.column, cell.column.valueAccessor('foreignKey', data, cell.column));\n    }\n\n    var value = cell.isForeignKey ? fKeyValue : cell.column.enableGroupByFormat ? data.key : this.format(cell.column, cell.column.valueAccessor('key', data, cell.column));\n\n    for (var j = 0; j < gObj.aggregates.length; j++) {\n      for (var i = 0; i < gObj.aggregates[j].columns.length; i++) {\n        if (gObj.getVisibleColumns()[0].field === gObj.aggregates[j].columns[i].field && gObj.aggregates[j].columns[i].groupCaptionTemplate) {\n          if (gObj.aggregates[j].columns[i].groupCaptionTemplate.includes('$')) {\n            gTemplateValue = gObj.aggregates[j].columns[i].groupCaptionTemplate.split('$')[0] + data[gObj.getVisibleColumns()[0].field][gObj.aggregates[j].columns[i].type] + gObj.aggregates[j].columns[i].groupCaptionTemplate.split('}')[1];\n          } else {\n            gTemplateValue = gObj.aggregates[j].columns[i].groupCaptionTemplate;\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (!isNullOrUndefined(gObj.groupSettings.captionTemplate)) {\n      var isReactCompiler = this.parent.isReact && typeof gObj.groupSettings.captionTemplate !== 'string';\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n\n      if (isReactCompiler || isReactChild) {\n        var tempID = gObj.element.id + 'captionTemplate';\n        templateCompiler(gObj.groupSettings.captionTemplate)(data, this.parent, 'captionTemplate', tempID, null, null, node);\n        this.parent.renderTemplates();\n      } else if (this.parent.isVue) {\n        result = templateCompiler(gObj.groupSettings.captionTemplate)(data, this.parent);\n      } else {\n        result = templateCompiler(gObj.groupSettings.captionTemplate)(data);\n      }\n\n      if (!isReactCompiler && !isReactChild) {\n        appendChildren(node, result);\n      }\n    } else {\n      if (gObj.groupSettings.enableLazyLoading) {\n        node.innerHTML = cell.column.headerText + ': ' + value + (gTemplateValue ? '   ' + gTemplateValue : '');\n      } else {\n        node.innerHTML = cell.column.headerText + ': ' + value + ' - ' + data.count + ' ' + (data.count < 2 ? this.localizer.getConstant('Item') : this.localizer.getConstant('Items')) + (gTemplateValue ? '   ' + gTemplateValue : '');\n      }\n    }\n\n    node.setAttribute('colspan', cell.colSpan.toString());\n    node.setAttribute('aria-label', node.innerHTML + this.localizer.getConstant('GroupCaption'));\n    node.setAttribute('title', node.innerHTML);\n    return node;\n  };\n\n  return GroupCaptionCellRenderer;\n}(CellRenderer);\n/**\n * GroupCaptionEmptyCellRenderer class which responsible for building group caption empty cell.\n *\n * @hidden\n */\n\n\nvar GroupCaptionEmptyCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$7(GroupCaptionEmptyCellRenderer, _super);\n\n  function GroupCaptionEmptyCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-groupcaption'\n    });\n    return _this;\n  }\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {Cell} cell - specifies the cell\n   * @param {Object} data - specifies the Object\n   * @param {string} data.field - Defines the field\n   * @param {string} data.key - Defines the key\n   * @param {number} data.count - Defines the count\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  GroupCaptionEmptyCellRenderer.prototype.render = function (cell, data) {\n    var node = this.element.cloneNode();\n    node.innerHTML = '&nbsp;';\n    node.setAttribute('colspan', cell.colSpan.toString());\n    return node;\n  };\n\n  return GroupCaptionEmptyCellRenderer;\n}(CellRenderer);\n\nvar __extends$8 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * ExpandCellRenderer class which responsible for building group expand cell.\n *\n * @hidden\n */\n\n\nvar ExpandCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$8(ExpandCellRenderer, _super);\n\n  function ExpandCellRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Function to render the expand cell\n   *\n   * @param {Cell} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {string} data.field - Defines the field\n   * @param {string} data.key - Defines the key\n   * @param {Object} attr - specifies the attribute\n   * @param {boolean} isExpand - specifies isexpand\n   * @returns {Element} returns the element\n   */\n\n\n  ExpandCellRenderer.prototype.render = function (cell, data, attr, isExpand) {\n    var node = this.element.cloneNode();\n    node.setAttribute('ej-mappingname', data.field);\n    node.setAttribute('ej-mappingvalue', data.key);\n    node.setAttribute('aria-expanded', isExpand ? 'true' : 'false');\n    node.setAttribute('tabindex', '-1');\n\n    if (this.parent.infiniteScrollSettings && this.parent.infiniteScrollSettings.enableCache) {\n      cell.cellType = CellType.Indent;\n      node.className = isExpand ? 'e-recordplusexpand e-disablepointer' : 'e-recordpluscollapse e-disablepointer';\n    } else {\n      node.className = isExpand ? 'e-recordplusexpand' : 'e-recordpluscollapse';\n      node.appendChild(this.parent.createElement('a', {\n        className: isExpand ? 'e-icons e-gdiagonaldown e-icon-gdownarrow' : 'e-icons e-gnextforward e-icon-grightarrow',\n        attrs: {\n          href: 'javascript:void(0);',\n          'title': isExpand ? 'expanded' : 'collapsed'\n        }\n      }));\n    }\n\n    return node;\n  };\n\n  return ExpandCellRenderer;\n}(IndentCellRenderer);\n\nvar __extends$9 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * HeaderIndentCellRenderer class which responsible for building header indent cell.\n *\n * @hidden\n */\n\n\nvar HeaderIndentCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$9(HeaderIndentCellRenderer, _super);\n\n  function HeaderIndentCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TH', {\n      className: 'e-grouptopleftcell'\n    });\n    return _this;\n  }\n  /**\n   * Function to render the indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  HeaderIndentCellRenderer.prototype.render = function (cell, data) {\n    var node = this.element.cloneNode();\n    node.appendChild(this.parent.createElement('div', {\n      className: 'e-headercelldiv e-emptycell',\n      innerHTML: ''\n    }));\n    return node;\n  };\n\n  return HeaderIndentCellRenderer;\n}(CellRenderer);\n\nvar __extends$10 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * DetailHeaderIndentCellRenderer class which responsible for building detail header indent cell.\n *\n * @hidden\n */\n\n\nvar DetailHeaderIndentCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$10(DetailHeaderIndentCellRenderer, _super);\n\n  function DetailHeaderIndentCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TH', {\n      className: 'e-detailheadercell'\n    });\n    return _this;\n  }\n  /**\n   * Function to render the detail indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  DetailHeaderIndentCellRenderer.prototype.render = function (cell, data) {\n    var node = this.element.cloneNode();\n    node.appendChild(this.parent.createElement('div', {\n      className: 'e-emptycell'\n    }));\n    return node;\n  };\n\n  return DetailHeaderIndentCellRenderer;\n}(CellRenderer);\n\nvar __extends$11 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * ExpandCellRenderer class which responsible for building group expand cell.\n *\n * @hidden\n */\n\n\nvar DetailExpandCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$11(DetailExpandCellRenderer, _super);\n\n  function DetailExpandCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-detailrowcollapse',\n      attrs: {\n        'aria-expanded': 'false',\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    return _this;\n  }\n  /**\n   * Function to render the detail expand cell\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attributes\n   * @returns {Element} returns the element\n   */\n\n\n  DetailExpandCellRenderer.prototype.render = function (cell, data, attributes$$1) {\n    var node = this.element.cloneNode();\n\n    if (attributes$$1 && !isNullOrUndefined(attributes$$1['class'])) {\n      node.className = '';\n      node.className = attributes$$1['class'];\n      node.appendChild(this.parent.createElement('a', {\n        className: 'e-icons e-dtdiagonaldown e-icon-gdownarrow',\n        attrs: {\n          href: 'javascript:void(0);',\n          'title': 'expanded'\n        }\n      }));\n    } else {\n      node.appendChild(this.parent.createElement('a', {\n        className: 'e-icons e-dtdiagonalright e-icon-grightarrow',\n        attrs: {\n          href: 'javascript:void(0);',\n          'title': 'collapsed'\n        }\n      }));\n    }\n\n    return node;\n  };\n\n  return DetailExpandCellRenderer;\n}(CellRenderer);\n\nvar __extends$12 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * ExpandCellRenderer class which responsible for building group expand cell.\n *\n * @hidden\n */\n\n\nvar RowDragDropRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$12(RowDragDropRenderer, _super);\n\n  function RowDragDropRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-rowdragdrop e-rowdragdropcell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    return _this;\n  }\n  /**\n   * Function to render the detail expand cell\n   *\n   * @param {Cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  RowDragDropRenderer.prototype.render = function (cell, data) {\n    var nodeElement = this.element.cloneNode();\n    nodeElement.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-rowcelldrag e-dtdiagonalright e-icon-rowdragicon',\n      attrs: {\n        'aria-hidden': 'true'\n      }\n    }));\n\n    if (cell.isSelected) {\n      nodeElement.classList.add('e-selectionbackground');\n      nodeElement.classList.add('e-active');\n    }\n\n    return nodeElement;\n  };\n\n  return RowDragDropRenderer;\n}(CellRenderer);\n\nvar __extends$13 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * DetailHeaderIndentCellRenderer class which responsible for building detail header indent cell.\n *\n * @hidden\n */\n\n\nvar RowDragDropHeaderRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$13(RowDragDropHeaderRenderer, _super);\n\n  function RowDragDropHeaderRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TH', {\n      className: 'e-rowdragheader'\n    });\n    return _this;\n  }\n  /**\n   * Function to render the detail indent cell\n   *\n   * @param  {Cell} cell - specifies the cell\n   * @param  {Object} data - specifies the data\n   * @returns {Element} returns the element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  RowDragDropHeaderRenderer.prototype.render = function (cell, data) {\n    var node = this.element.cloneNode();\n    node.appendChild(createElement('div', {\n      className: 'e-emptycell'\n    }));\n    return node;\n  };\n\n  return RowDragDropHeaderRenderer;\n}(CellRenderer);\n/**\n * Content module is used to render grid content\n *\n * @hidden\n */\n\n\nvar Render =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} locator - specifies the serviceLocator\n   */\n  function Render(parent, locator) {\n    this.emptyGrid = false;\n    this.counter = 0;\n    this.parent = parent;\n    this.locator = locator;\n    this.data = new Data(parent, locator);\n    this.l10n = locator.getService('localization');\n    this.ariaService = this.locator.getService('ariaService');\n    this.renderer = this.locator.getService('rendererFactory');\n    this.addEventListener();\n  }\n  /**\n   * To initialize grid header, content and footer rendering\n   *\n   * @returns {void}\n   */\n\n\n  Render.prototype.render = function () {\n    var gObj = this.parent;\n    this.headerRenderer = this.renderer.getRenderer(RenderType.Header);\n    this.contentRenderer = this.renderer.getRenderer(RenderType.Content);\n    this.headerRenderer.renderPanel();\n    this.contentRenderer.renderPanel();\n\n    if (gObj.getColumns().length) {\n      this.isLayoutRendered = true;\n      this.headerRenderer.renderTable();\n      this.contentRenderer.renderTable();\n      this.emptyRow(false);\n    }\n\n    this.parent.scrollModule.setWidth();\n    this.parent.scrollModule.setHeight();\n\n    if (this.parent.height !== 'auto') {\n      this.parent.scrollModule.setPadding();\n    }\n\n    this.refreshDataManager();\n  };\n  /**\n   * Refresh the entire Grid.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   */\n\n\n  Render.prototype.refresh = function (e) {\n    var _this = this;\n\n    if (e === void 0) {\n      e = {\n        requestType: 'refresh'\n      };\n    }\n\n    var gObj = this.parent;\n    gObj.notify(e.requestType + \"-begin\", e);\n    gObj.trigger(actionBegin, e, function (args) {\n      if (args === void 0) {\n        args = {\n          requestType: 'refresh'\n        };\n      }\n\n      if (args.cancel) {\n        gObj.notify(cancelBegin, args);\n        return;\n      }\n\n      if (args.requestType === 'delete' && gObj.allowPaging) {\n        var dataLength = args.data.length;\n        var count = gObj.pageSettings.totalRecordsCount - dataLength;\n        var currentViewData = gObj.getCurrentViewRecords().length; // eslint-disable-next-line max-len\n\n        if (!(currentViewData - dataLength) && count && (gObj.pageSettings.currentPage - 1) * gObj.pageSettings.pageSize === count) {\n          gObj.prevPageMoving = true;\n          gObj.setProperties({\n            pageSettings: {\n              totalRecordsCount: count,\n              currentPage: Math.ceil(count / gObj.pageSettings.pageSize)\n            }\n          }, true);\n          gObj.pagerModule.pagerObj.totalRecordsCount = count;\n        }\n      }\n\n      if (args.requestType === 'reorder' && _this.parent.dataSource && 'result' in _this.parent.dataSource) {\n        _this.contentRenderer.refreshContentRows(args);\n      } else if ((args.requestType === 'paging' || args.requestType === 'columnstate' || args.requestType === 'reorder') && _this.parent.groupSettings.enableLazyLoading && _this.parent.groupSettings.columns.length && _this.parent.contentModule.getGroupCache()[_this.parent.pageSettings.currentPage]) {\n        _this.contentRenderer.refreshContentRows(args);\n      } else {\n        _this.refreshDataManager(args);\n      }\n    });\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Render.prototype.resetTemplates = function () {\n    var gObj = this.parent;\n    var gridColumns = gObj.getColumns();\n\n    if (gObj.detailTemplate) {\n      var detailTemplateID = gObj.element.id + 'detailTemplate';\n      blazorTemplates[detailTemplateID] = [];\n      resetBlazorTemplate(detailTemplateID, 'DetailTemplate');\n    }\n\n    if (gObj.groupSettings.captionTemplate) {\n      resetBlazorTemplate(gObj.element.id + 'captionTemplate', 'CaptionTemplate');\n    }\n\n    if (gObj.rowTemplate) {\n      resetBlazorTemplate(gObj.element.id + 'rowTemplate', 'RowTemplate');\n    }\n\n    if (gObj.toolbarTemplate) {\n      resetBlazorTemplate(gObj.element.id + 'toolbarTemplate', 'ToolbarTemplate');\n    }\n\n    if (gObj.pageSettings.template) {\n      resetBlazorTemplate(gObj.element.id + '_template', 'pageSettings');\n    }\n\n    for (var i = 0; i < gridColumns.length; i++) {\n      if (gridColumns[i].template) {\n        blazorTemplates[gObj.element.id + gridColumns[i].uid] = [];\n        resetBlazorTemplate(gObj.element.id + gridColumns[i].uid, 'Template');\n      }\n\n      if (gridColumns[i].headerTemplate) {\n        resetBlazorTemplate(gObj.element.id + gridColumns[i].uid + 'headerTemplate', 'HeaderTemplate');\n      }\n\n      if (gridColumns[i].filterTemplate) {\n        resetBlazorTemplate(gObj.element.id + gridColumns[i].uid + 'filterTemplate', 'FilterTemplate');\n      }\n    }\n\n    var guid = 'guid';\n\n    for (var k = 0; k < gObj.aggregates.length; k++) {\n      for (var j = 0; j < gObj.aggregates[k].columns.length; j++) {\n        if (gObj.aggregates[k].columns[j].footerTemplate) {\n          var tempID = gObj.element.id + gObj.aggregates[k].columns[j][guid] + 'footerTemplate';\n          resetBlazorTemplate(tempID, 'FooterTemplate');\n        }\n\n        if (gObj.aggregates[k].columns[j].groupFooterTemplate) {\n          var tempID = gObj.element.id + gObj.aggregates[k].columns[j][guid] + 'groupFooterTemplate';\n          resetBlazorTemplate(tempID, 'GroupFooterTemplate');\n        }\n\n        if (gObj.aggregates[k].columns[j].groupCaptionTemplate) {\n          var tempID = gObj.element.id + gObj.aggregates[k].columns[j][guid] + 'groupCaptionTemplate';\n          resetBlazorTemplate(tempID, 'GroupCaptionTemplate');\n        }\n      }\n    }\n  };\n\n  Render.prototype.refreshComplete = function (e) {\n    this.parent.trigger(actionComplete, e);\n  };\n  /**\n   * The function is used to refresh the dataManager\n   *\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   */\n\n\n  Render.prototype.refreshDataManager = function (args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = {};\n    }\n\n    var gObj = this.parent;\n    var maskRow = gObj.loadingIndicator.indicatorType === 'Shimmer' && args.requestType !== 'virtualscroll' && args.requestType !== 'infiniteScroll' || (args.requestType === 'virtualscroll' || args.requestType === 'infiniteScroll') && gObj.enableVirtualMaskRow;\n\n    if (args.requestType !== 'virtualscroll' && !args.isCaptionCollapse && !maskRow) {\n      this.parent.showSpinner();\n    }\n\n    if (maskRow) {\n      gObj.showMaskRow(args.requestType === 'virtualscroll' ? args.virtualInfo.sentinelInfo.axis : args.requestType === 'infiniteScroll' ? args.direction : undefined);\n    }\n\n    this.parent.notify(resetInfiniteBlocks, args);\n    this.emptyGrid = false;\n    var dataManager;\n    var isFActon = this.isNeedForeignAction();\n    this.ariaService.setBusy(this.parent.getContent().querySelector('.' + content), true);\n\n    if (isFActon) {\n      var deffered = new Deferred();\n      dataManager = this.getFData(deffered, args);\n    }\n\n    if (!dataManager) {\n      dataManager = this.data.getData(args, this.data.generateQuery().requiresCount());\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      dataManager = dataManager.then(function (e) {\n        var query = _this.data.generateQuery().requiresCount();\n\n        if (_this.emptyGrid) {\n          var def = new Deferred();\n          def.resolve({\n            result: [],\n            count: 0\n          });\n          return def.promise;\n        }\n\n        return _this.data.getData(args, query);\n      });\n    }\n\n    if (this.parent.getForeignKeyColumns().length && (!isFActon || this.parent.searchSettings.key.length)) {\n      var deffered_1 = new Deferred();\n      dataManager = dataManager.then(function (e) {\n        _this.parent.notify(getForeignKeyData, {\n          dataManager: dataManager,\n          result: e,\n          promise: deffered_1,\n          action: args\n        });\n\n        return deffered_1.promise;\n      });\n    }\n\n    if (this.parent.groupSettings.disablePageWiseAggregates && this.parent.groupSettings.columns.length) {\n      dataManager = dataManager.then(function (e) {\n        return _this.validateGroupRecords(e);\n      });\n    }\n\n    dataManager.then(function (e) {\n      return _this.dataManagerSuccess(e, args);\n    }).catch(function (e) {\n      return _this.dataManagerFailure(e, args);\n    });\n  };\n\n  Render.prototype.getFData = function (deferred, args) {\n    this.parent.notify(getForeignKeyData, {\n      isComplex: true,\n      promise: deferred,\n      action: args\n    });\n    return deferred.promise;\n  };\n\n  Render.prototype.isNeedForeignAction = function () {\n    var gObj = this.parent;\n    return !!(gObj.allowFiltering && gObj.filterSettings.columns.length || gObj.searchSettings.key.length) && this.foreignKey(this.parent.getForeignKeyColumns());\n  };\n\n  Render.prototype.foreignKey = function (columns) {\n    var _this = this;\n\n    return columns.some(function (col) {\n      var fbool = false;\n      fbool = _this.parent.filterSettings.columns.some(function (value) {\n        return col.uid === value.uid;\n      });\n      return !!(fbool || _this.parent.searchSettings.key.length);\n    });\n  };\n\n  Render.prototype.sendBulkRequest = function (args) {\n    var _this = this;\n\n    args.requestType = 'batchsave';\n    var promise = this.data.saveChanges(args.changes, this.parent.getPrimaryKeyFieldNames()[0], args.original);\n    var query = this.data.generateQuery().requiresCount();\n\n    if (this.data.dataManager.dataSource.offline) {\n      this.refreshDataManager({\n        requestType: 'batchsave'\n      });\n      return;\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      promise.then(function (e) {\n        _this.data.getData(args, query).then(function (e) {\n          return _this.dmSuccess(e, args);\n        }).catch(function (e) {\n          return _this.dmFailure(e, args);\n        });\n      }).catch(function (e) {\n        return _this.dmFailure(e, args);\n      });\n    }\n  };\n\n  Render.prototype.dmSuccess = function (e, args) {\n    this.dataManagerSuccess(e, args);\n  };\n\n  Render.prototype.dmFailure = function (e, args) {\n    this.dataManagerFailure(e, args);\n  };\n  /**\n   * Render empty row to Grid which is used at the time to represent to no records.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Render.prototype.renderEmptyRow = function () {\n    this.emptyRow(true);\n  };\n\n  Render.prototype.emptyRow = function (isTrigger) {\n    var gObj = this.parent;\n    var tbody$$1 = this.contentRenderer.getTable().querySelector(tbody);\n\n    if (!isNullOrUndefined(tbody$$1)) {\n      remove(tbody$$1);\n    }\n\n    tbody$$1 = this.parent.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    var spanCount = 0;\n\n    if (gObj.detailTemplate || gObj.childGrid) {\n      ++spanCount;\n    }\n\n    var tr = this.parent.createElement('tr', {\n      className: 'e-emptyrow',\n      attrs: {\n        role: 'row'\n      }\n    });\n    tr.appendChild(this.parent.createElement('td', {\n      innerHTML: this.l10n.getConstant('EmptyRecord'),\n      attrs: {\n        colspan: (gObj.getVisibleColumns().length + spanCount + gObj.groupSettings.columns.length).toString()\n      }\n    }));\n    tbody$$1.appendChild(tr);\n    this.contentRenderer.renderEmpty(tbody$$1);\n\n    if (isTrigger) {\n      this.parent.trigger(dataBound, {});\n      this.parent.notify(onEmpty, {\n        rows: [new Row({\n          isDataRow: true,\n          cells: [new Cell({\n            isDataCell: true,\n            visible: true\n          })]\n        })]\n      });\n    }\n  };\n\n  Render.prototype.dynamicColumnChange = function () {\n    if (this.parent.getCurrentViewRecords().length) {\n      this.updateColumnType(this.parent.getCurrentViewRecords()[0]);\n    }\n  };\n\n  Render.prototype.updateColumnType = function (record) {\n    var columns = this.parent.getColumns();\n    var value;\n    var cFormat = 'customFormat';\n    var equalTo = 'equalTo';\n    var data = record && record.items ? record.items[0] : record;\n    var fmtr = this.locator.getService('valueFormatter');\n\n    for (var i = 0, len = columns.length; i < len; i++) {\n      value = getObject(columns[i].field || '', data);\n\n      if (!isNullOrUndefined(columns[i][cFormat])) {\n        columns[i].format = columns[i][cFormat];\n      }\n\n      if (!isNullOrUndefined(columns[i].validationRules) && !isNullOrUndefined(columns[i].validationRules[equalTo])) {\n        columns[i].validationRules[equalTo][0] = this.parent.element.id + columns[i].validationRules[equalTo][0];\n      }\n\n      if (columns[i].isForeignColumn() && columns[i].columnData) {\n        value = getObject(columns[i].foreignKeyValue || '', columns[i].columnData[0]);\n      }\n\n      if (!isNullOrUndefined(value)) {\n        this.isColTypeDef = true;\n\n        if (!columns[i].type) {\n          columns[i].type = value.getDay ? value.getHours() > 0 || value.getMinutes() > 0 || value.getSeconds() > 0 || value.getMilliseconds() > 0 ? 'datetime' : 'date' : typeof value;\n        }\n      } else {\n        columns[i].type = columns[i].type || null;\n      }\n\n      var valueFormatter = new ValueFormatter();\n\n      if (columns[i].format && (columns[i].format.skeleton || columns[i].format.format && typeof columns[i].format.format === 'string')) {\n        columns[i].setFormatter(valueFormatter.getFormatFunction(extend({}, columns[i].format)));\n        columns[i].setParser(valueFormatter.getParserFunction(columns[i].format));\n      }\n\n      if (typeof columns[i].format === 'string') {\n        setFormatter(this.locator, columns[i]);\n      } else if (!columns[i].format && columns[i].type === 'number') {\n        columns[i].setParser(fmtr.getParserFunction({\n          format: 'n2'\n        }));\n      }\n    }\n  };\n  /**\n   * @param {ReturnType} e - specifies the return type\n   * @param {NotifyArgs} args - specifies the Notifyargs\n   * @returns {void}\n   * @hidden\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  Render.prototype.dataManagerSuccess = function (e, args) {\n    var _this = this;\n\n    var gObj = this.parent;\n    this.contentRenderer = this.renderer.getRenderer(RenderType.Content);\n    this.headerRenderer = this.renderer.getRenderer(RenderType.Header);\n    e.actionArgs = args;\n    var isInfiniteDelete = this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache && !gObj.groupSettings.enableLazyLoading && (args.requestType === 'delete' || args.requestType === 'save' && this.parent.infiniteScrollModule.requestType === 'add' && !(gObj.sortSettings.columns.length || gObj.filterSettings.columns.length || this.parent.groupSettings.columns.length || gObj.searchSettings.key)); // tslint:disable-next-line:max-func-body-length\n\n    gObj.trigger(beforeDataBound, e, function (dataArgs) {\n      if (dataArgs.cancel) {\n        return;\n      }\n\n      dataArgs.result = isNullOrUndefined(dataArgs.result) ? [] : dataArgs.result;\n      var len = Object.keys(dataArgs.result).length;\n\n      if (_this.parent.isDestroyed) {\n        return;\n      }\n\n      if (!gObj.getColumns().length && !len && !(gObj.columns.length && gObj.columns[0] instanceof Column)) {\n        gObj.hideSpinner();\n        return;\n      }\n\n      if (_this.isInfiniteEnd(args) && !len) {\n        _this.parent.notify(infiniteEditHandler, {\n          e: args,\n          result: e.result,\n          count: e.count,\n          agg: e.aggregates\n        });\n\n        return;\n      }\n\n      _this.parent.isEdit = false;\n\n      _this.parent.notify(editReset, {});\n\n      _this.parent.notify(tooltipDestroy, {});\n\n      if (args && args.requestType !== 'infiniteScroll') {\n        _this.parent.notify(commandColumnDestroy, {\n          type: 'refreshCommandColumn'\n        });\n      }\n\n      _this.contentRenderer.prevCurrentView = _this.parent.currentViewData.slice();\n      gObj.currentViewData = dataArgs.result;\n      gObj.notify(refreshInfiniteCurrentViewData, {\n        args: args,\n        data: dataArgs.result\n      });\n\n      if (dataArgs.count && !gObj.allowPaging && (gObj.enableVirtualization || gObj.enableInfiniteScrolling)) {\n        gObj.totalDataRecordsCount = dataArgs.count;\n      }\n\n      if (!len && dataArgs.count && gObj.allowPaging && args && args.requestType !== 'delete') {\n        if (_this.parent.groupSettings.enableLazyLoading && (args.requestType === 'grouping' || args.requestType === 'ungrouping')) {\n          _this.parent.notify(groupComplete, args);\n        }\n\n        gObj.prevPageMoving = true;\n        gObj.pageSettings.totalRecordsCount = dataArgs.count;\n\n        if (args.requestType !== 'paging') {\n          gObj.pageSettings.currentPage = Math.ceil(dataArgs.count / gObj.pageSettings.pageSize);\n        }\n\n        gObj.dataBind();\n        return;\n      }\n\n      if ((!gObj.getColumns().length && len || !_this.isLayoutRendered) && !isGroupAdaptive(gObj)) {\n        gObj.removeMaskRow();\n\n        _this.updatesOnInitialRender(dataArgs);\n      }\n\n      if (!_this.isColTypeDef && gObj.getCurrentViewRecords()) {\n        if (_this.data.dataManager.dataSource.offline && gObj.dataSource && gObj.dataSource.length) {\n          _this.updateColumnType(gObj.dataSource[0]);\n        } else {\n          _this.updateColumnType(gObj.getCurrentViewRecords()[0]);\n        }\n      }\n\n      if (!_this.parent.isInitialLoad && _this.parent.groupSettings.disablePageWiseAggregates && !_this.parent.groupSettings.columns.length) {\n        dataArgs.result = _this.parent.dataSource instanceof Array ? _this.parent.dataSource : _this.parent.currentViewData;\n      }\n\n      if ((_this.parent.isReact || _this.parent.isVue) && !isNullOrUndefined(args) && args.requestType !== 'infiniteScroll' && !args.isFrozen) {\n        clearReactVueTemplates(_this.parent, ['footerTemplate']);\n      }\n\n      if (_this.parent.isAngular && _this.parent.allowGrouping && _this.parent.groupSettings.captionTemplate && !(!isNullOrUndefined(args) && args.requestType === 'infiniteScroll')) {\n        _this.parent.destroyTemplate(['groupSettings_captionTemplate']);\n      }\n\n      _this.parent.notify(dataReady, extend({\n        count: dataArgs.count,\n        result: dataArgs.result,\n        aggregates: dataArgs.aggregates\n      }, args));\n\n      if ((gObj.groupSettings.columns.length || args && args.requestType === 'ungrouping') && args && args.requestType !== 'filtering') {\n        _this.headerRenderer.refreshUI();\n      }\n\n      if (len) {\n        if (isGroupAdaptive(gObj)) {\n          var content$$1 = 'content';\n          args.scrollTop = {\n            top: _this.contentRenderer[content$$1].scrollTop\n          };\n        }\n\n        if (!isInfiniteDelete) {\n          if (_this.parent.enableImmutableMode) {\n            _this.contentRenderer.immutableModeRendering(args);\n          } else {\n            _this.contentRenderer.refreshContentRows(args);\n          }\n        } else {\n          _this.parent.notify(infiniteEditHandler, {\n            e: args,\n            result: e.result,\n            count: e.count,\n            agg: e.aggregates\n          });\n        }\n      } else {\n        if (args && args.isCaptionCollapse) {\n          return;\n        }\n\n        if (!gObj.getColumns().length) {\n          gObj.element.innerHTML = '';\n          alert(_this.l10n.getConstant('EmptyDataSourceError')); //ToDO: change this alert as dialog\n\n          return;\n        }\n\n        _this.contentRenderer.setRowElements([]);\n\n        _this.contentRenderer.setRowObjects([]);\n\n        _this.ariaService.setBusy(_this.parent.getContent().querySelector('.' + content), false);\n\n        gObj.removeMaskRow();\n\n        _this.renderEmptyRow();\n\n        if (args) {\n          var action = (args.requestType || '').toLowerCase() + '-complete';\n\n          _this.parent.notify(action, args);\n\n          if (args.requestType === 'batchsave') {\n            args.cancel = false;\n            args.rows = [];\n            args.isFrozen = _this.parent.getFrozenColumns() !== 0 && !args.isFrozen;\n\n            _this.parent.trigger(actionComplete, args);\n          }\n        }\n\n        _this.parent.hideSpinner();\n      }\n\n      _this.parent.notify(toolbarRefresh, {});\n\n      _this.setRowCount(_this.parent.getCurrentViewRecords().length);\n\n      if ('query' in e) {\n        _this.parent.getDataModule().isQueryInvokedFromData = false;\n      }\n    });\n  };\n  /**\n   * @param {object} e - specifies the object\n   * @param {Object[]} e.result - specifies the result\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Render.prototype.dataManagerFailure = function (e, args) {\n    this.ariaService.setOptions(this.parent.getContent().querySelector('.' + content), {\n      busy: false,\n      invalid: true\n    });\n    this.setRowCount(1);\n    this.parent.trigger(actionFailure, {\n      error: e\n    });\n    this.parent.hideSpinner();\n    this.parent.removeMaskRow();\n\n    if (args.requestType === 'save' || args.requestType === 'delete' || args.name === 'bulk-save') {\n      return;\n    }\n\n    this.parent.currentViewData = [];\n    this.renderEmptyRow();\n    this.parent.log('actionfailure', {\n      error: e\n    });\n  };\n\n  Render.prototype.setRowCount = function (dataRowCount) {\n    this.ariaService.setOptions(this.parent.getHeaderTable(), {\n      rowcount: dataRowCount ? dataRowCount.toString() : '1'\n    });\n  };\n\n  Render.prototype.isInfiniteEnd = function (args) {\n    return this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache && args.requestType === 'delete';\n  };\n\n  Render.prototype.updatesOnInitialRender = function (e) {\n    this.isLayoutRendered = true;\n\n    if (this.parent.columns.length < 1) {\n      this.buildColumns(e.result[0]);\n    }\n\n    prepareColumns(this.parent.columns, null, this.parent);\n    this.headerRenderer.renderTable();\n    this.contentRenderer.renderTable();\n    this.parent.isAutoGen = true;\n    this.parent.notify(autoCol, {});\n  };\n\n  Render.prototype.iterateComplexColumns = function (obj, field, split) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      var childKeys = typeof obj[keys[i]] === 'object' && obj[keys[i]] && !(obj[keys[i]] instanceof Date) ? Object.keys(obj[keys[i]]) : [];\n\n      if (childKeys.length) {\n        this.iterateComplexColumns(obj[keys[i]], field + (keys[i] + '.'), split);\n      } else {\n        split[this.counter] = field + keys[i];\n        this.counter++;\n      }\n    }\n  };\n\n  Render.prototype.buildColumns = function (record) {\n    var cols = [];\n    var complexCols = {};\n    this.iterateComplexColumns(record, '', complexCols);\n    var columns = Object.keys(complexCols).filter(function (e) {\n      return complexCols[e] !== 'BlazId';\n    }).map(function (field) {\n      return complexCols[field];\n    });\n\n    for (var i = 0, len = columns.length; i < len; i++) {\n      cols[i] = {\n        'field': columns[i]\n      };\n\n      if (this.parent.enableColumnVirtualization) {\n        cols[i].width = !isNullOrUndefined(cols[i].width) ? cols[i].width : 200;\n      }\n    }\n\n    this.parent.setProperties({\n      'columns': cols\n    }, true);\n  };\n\n  Render.prototype.instantiateRenderer = function () {\n    this.renderer.addRenderer(RenderType.Header, new HeaderRender(this.parent, this.locator));\n    this.renderer.addRenderer(RenderType.Content, new ContentRender(this.parent, this.locator));\n    var cellrender = this.locator.getService('cellRendererFactory');\n    cellrender.addCellRenderer(CellType.Header, new HeaderCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.Data, new CellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.StackedHeader, new StackedHeaderCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.Indent, new IndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.GroupCaption, new GroupCaptionCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.GroupCaptionEmpty, new GroupCaptionEmptyCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.Expand, new ExpandCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.HeaderIndent, new HeaderIndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.StackedHeader, new StackedHeaderCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.DetailHeader, new DetailHeaderIndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.RowDragHIcon, new RowDragDropHeaderRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.DetailExpand, new DetailExpandCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.DetailFooterIntent, new IndentCellRenderer(this.parent, this.locator));\n    cellrender.addCellRenderer(CellType.RowDragIcon, new RowDragDropRenderer(this.parent, this.locator));\n  };\n\n  Render.prototype.addEventListener = function () {\n    var _this = this;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on('refreshdataSource', this.dataManagerSuccess, this);\n    this.parent.on(modelChanged, this.refresh, this);\n    this.parent.on(refreshComplete, this.refreshComplete, this);\n    this.parent.on(bulkSave, this.sendBulkRequest, this);\n    this.parent.on(showEmptyGrid, function () {\n      _this.emptyGrid = true;\n    }, this);\n    this.parent.on(autoCol, this.dynamicColumnChange, this);\n  };\n  /**\n   * @param {ReturnType} e - specifies the Return type\n   * @returns {Promise<Object>} returns the object\n   * @hidden\n   */\n\n\n  Render.prototype.validateGroupRecords = function (e) {\n    var _this = this;\n\n    var index = e.result.length - 1;\n\n    if (index < 0) {\n      return Promise.resolve(e);\n    }\n\n    var group0 = e.result[0];\n    var groupN = e.result[index];\n    var predicate = [];\n\n    var addWhere = function (input) {\n      var groups = [group0, groupN];\n\n      for (var i = 0; i < groups.length; i++) {\n        predicate.push(new Predicate('field', '==', groups[i].field).and(_this.getPredicate('key', 'equal', groups[i].key)));\n      }\n\n      input.where(Predicate.or(predicate));\n    };\n\n    var query = new Query();\n    addWhere(query);\n    var curDm = new DataManager(e.result);\n    var curFilter = curDm.executeLocal(query);\n    var newQuery = this.data.generateQuery(true);\n    var rPredicate = [];\n\n    if (this.data.isRemote()) {\n      var groups = [group0, groupN];\n\n      for (var i = 0; i < groups.length; i++) {\n        rPredicate.push(this.getPredicate(groups[i].field, 'equal', groups[i].key));\n      }\n\n      newQuery.where(Predicate.or(rPredicate));\n    } else {\n      addWhere(newQuery);\n    }\n\n    var deferred = new Deferred();\n    this.data.getData({}, newQuery).then(function (r) {\n      _this.updateGroupInfo(curFilter, r.result);\n\n      deferred.resolve(e);\n    }).catch(function (e) {\n      return deferred.reject(e);\n    });\n    return deferred.promise;\n  };\n\n  Render.prototype.getPredicate = function (key, operator, value) {\n    if (value instanceof Date) {\n      return getDatePredicate({\n        field: key,\n        operator: operator,\n        value: value\n      });\n    }\n\n    return new Predicate(key, operator, value);\n  };\n\n  Render.prototype.updateGroupInfo = function (current, untouched) {\n    var dm = new DataManager(untouched);\n    var elements = current;\n\n    for (var i = 0; i < elements.length; i++) {\n      var uGroup = dm.executeLocal(new Query().where(new Predicate('field', '==', elements[i].field).and(this.getPredicate('key', 'equal', elements[i].key))))[0];\n      elements[i].count = uGroup.count;\n      var itemGroup = elements[i].items;\n      var uGroupItem = uGroup.items;\n\n      if (itemGroup.GroupGuid) {\n        elements[i].items = this.updateGroupInfo(elements[i].items, uGroup.items);\n      }\n\n      var rows = this.parent.aggregates;\n\n      for (var j = 0; j < rows.length; j++) {\n        var row$$1 = rows[j];\n\n        for (var k = 0; k < row$$1.columns.length; k++) {\n          var types = row$$1.columns[k].type instanceof Array ? row$$1.columns[k].type : [row$$1.columns[k].type];\n\n          for (var l = 0; l < types.length; l++) {\n            var key = row$$1.columns[k].field + ' - ' + types[l].toLowerCase();\n            var data = itemGroup.level ? uGroupItem.records : uGroup.items;\n            var context = this.parent;\n\n            if (types[l] === 'Custom') {\n              var data_1 = itemGroup.level ? uGroupItem : uGroup;\n              var temp = row$$1.columns[k].customAggregate;\n\n              if (typeof temp === 'string') {\n                temp = getValue(temp, window);\n              }\n\n              elements[i].aggregates[key] = temp ? temp.call(context, data_1, row$$1.columns[k]) : '';\n            } else {\n              // eslint-disable-next-line max-len\n              elements[i].aggregates[key] = DataUtil.aggregates[types[l].toLowerCase()](data, row$$1.columns[k].field);\n            }\n          }\n        }\n      }\n    }\n\n    return current;\n  };\n\n  return Render;\n}();\n/**\n * CellRendererFactory\n *\n * @hidden\n */\n\n\nvar CellRendererFactory =\n/** @__PURE__ @class */\nfunction () {\n  function CellRendererFactory() {\n    this.cellRenderMap = {};\n  }\n\n  CellRendererFactory.prototype.addCellRenderer = function (name, type) {\n    name = typeof name === 'string' ? name : getEnumValue(CellType, name);\n\n    if (isNullOrUndefined(this.cellRenderMap[name])) {\n      this.cellRenderMap[name] = type;\n    }\n  };\n\n  CellRendererFactory.prototype.getCellRenderer = function (name) {\n    name = typeof name === 'string' ? name : getEnumValue(CellType, name);\n\n    if (isNullOrUndefined(this.cellRenderMap[name])) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"The cellRenderer \" + name + \" is not found\";\n    } else {\n      return this.cellRenderMap[name];\n    }\n  };\n\n  return CellRendererFactory;\n}();\n/**\n *\n * The `ResponsiveDialogRenderer` module is used to render the responsive dialogs.\n */\n\n\nvar ResponsiveDialogRenderer =\n/** @__PURE__ @class */\nfunction () {\n  function ResponsiveDialogRenderer(parent, serviceLocator) {\n    this.sortedCols = [];\n    this.sortPredicate = [];\n    /** @hidden */\n\n    this.isCustomDialog = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  ResponsiveDialogRenderer.prototype.addEventListener = function () {\n    this.evtHandlers = [{\n      event: filterDialogClose,\n      handler: this.closeCustomDialog\n    }, {\n      event: refreshCustomFilterOkBtn,\n      handler: this.refreshCustomFilterOkBtn\n    }, {\n      event: renderResponsiveCmenu,\n      handler: this.renderResponsiveContextMenu\n    }, {\n      event: filterCmenuSelect,\n      handler: this.renderCustomFilterDiv\n    }, {\n      event: customFilterClose,\n      handler: this.customExFilterClose\n    }, {\n      event: refreshCustomFilterClearBtn,\n      handler: this.refreshCustomFilterClearBtn\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.onActionCompleteFn = this.editComplate.bind(this);\n    this.parent.addEventListener(actionComplete, this.onActionCompleteFn);\n  };\n\n  ResponsiveDialogRenderer.prototype.customExFilterClose = function () {\n    this.isCustomDlgRender = false;\n  };\n\n  ResponsiveDialogRenderer.prototype.renderCustomFilterDiv = function () {\n    var header = this.customResponsiveDlg.element.querySelector('.e-dlg-header-content');\n    var title = header.querySelector('.e-dlg-custom-header');\n    var closeBtn = header.querySelector('.e-dlg-closeicon-btn');\n    this.isCustomDlgRender = true;\n    this.parent.filterModule.filterModule.closeDialog();\n    this.saveBtn.element.style.display = '';\n    this.refreshCustomFilterOkBtn({\n      disabled: false\n    });\n    this.backBtn.element.style.display = 'none';\n    closeBtn.style.display = '';\n    title.innerHTML = this.parent.localeObj.getConstant('CustomFilter');\n    var content = this.customResponsiveDlg.element.querySelector('.e-dlg-content');\n    this.customExcelFilterParent = this.parent.createElement('div', {\n      className: 'e-xl-customfilterdiv e-default-filter'\n    });\n    content.appendChild(this.customExcelFilterParent);\n  };\n\n  ResponsiveDialogRenderer.prototype.renderResponsiveContextMenu = function (args) {\n    if (this.action === ResponsiveDialogAction.isFilter) {\n      var content = this.customResponsiveDlg.element.querySelector('.e-dlg-content');\n      var header = this.customResponsiveDlg.element.querySelector('.e-dlg-header-content');\n      var closeBtn = header.querySelector('.e-dlg-closeicon-btn');\n      var text = header.querySelector('.e-dlg-custom-header');\n\n      if (args.isOpen) {\n        content.firstChild.style.display = 'none';\n        content.appendChild(args.target);\n        closeBtn.style.display = 'none';\n        this.saveBtn.element.style.display = 'none';\n        this.filterClearBtn.element.style.display = 'none';\n        text.innerHTML = args.header;\n        var backBtn = this.parent.createElement('button');\n        var span = this.parent.createElement('span', {\n          className: 'e-btn-icon e-resfilterback e-icons'\n        });\n        backBtn.appendChild(span);\n        this.backBtn = new Button({\n          cssClass: this.parent.cssClass ? 'e-res-back-btn' + ' ' + this.parent.cssClass : 'e-res-back-btn'\n        });\n        this.backBtn.appendTo(backBtn);\n        text.parentElement.insertBefore(backBtn, text);\n      } else if (this.backBtn && !this.isCustomDlgRender) {\n        content.firstChild.style.display = '';\n        remove(this.backBtn.element);\n        closeBtn.style.display = '';\n        this.saveBtn.element.style.display = '';\n\n        if (this.isFiltered) {\n          this.filterClearBtn.element.style.display = '';\n        }\n\n        text.innerHTML = this.getHeaderTitle({\n          action: ResponsiveDialogAction.isFilter\n        }, args.col);\n      }\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.refreshCustomFilterClearBtn = function (args) {\n    if (this.filterClearBtn) {\n      this.isFiltered = args.isFiltered;\n      this.filterClearBtn.element.style.display = args.isFiltered ? '' : 'none';\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.refreshCustomFilterOkBtn = function (args) {\n    if (this.saveBtn) {\n      this.saveBtn.disabled = args.disabled;\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.renderResponsiveContent = function (col) {\n    var _this = this;\n\n    var gObj = this.parent;\n\n    if (col) {\n      this.filterParent = this.parent.createElement('div', {\n        className: 'e-mainfilterdiv e-default-filter',\n        id: col.uid + '-main-filter'\n      });\n      return this.filterParent;\n    } else {\n      var cols = gObj.getColumns();\n      this.customColumnDiv = gObj.createElement('div', {\n        className: 'columndiv',\n        styles: 'width: 100%'\n      });\n      var sortBtnParent = gObj.createElement('div', {\n        className: 'e-ressortbutton-parent'\n      });\n      var filteredCols = [];\n      var isSort = this.action === ResponsiveDialogAction.isSort;\n      var isFilter = this.action === ResponsiveDialogAction.isFilter;\n\n      if (isFilter) {\n        for (var i = 0; i < gObj.filterSettings.columns.length; i++) {\n          filteredCols.push(gObj.filterSettings.columns[i].field);\n        }\n      }\n\n      for (var i = 0; i < cols.length; i++) {\n        if (!cols[i].visible || !cols[i].allowSorting && isSort || !cols[i].allowFiltering && isFilter) {\n          continue;\n        }\n\n        var cDiv = gObj.createElement('div', {\n          className: 'e-responsivecoldiv'\n        });\n        cDiv.setAttribute('data-e-mappingname', cols[i].field);\n        cDiv.setAttribute('data-e-mappinguid', cols[i].uid);\n        var span = gObj.createElement('span', {\n          innerHTML: cols[i].headerText,\n          className: 'e-res-header-text'\n        });\n        cDiv.appendChild(span);\n        this.customColumnDiv.appendChild(cDiv);\n\n        if (isSort) {\n          var fields = this.getSortedFieldsAndDirections('field');\n          var index = fields.indexOf(cols[i].field);\n          var button = gObj.createElement('button', {\n            id: gObj.element.id + cols[i].field + 'sortbutton'\n          });\n          var clone = sortBtnParent.cloneNode();\n          clone.appendChild(button);\n          cDiv.appendChild(clone);\n          var btnObj = new Button({\n            cssClass: this.parent.cssClass ? 'e-ressortbutton' + ' ' + this.parent.cssClass : 'e-ressortbutton'\n          });\n          btnObj.appendTo(button);\n          button.innerHTML = index > -1 ? this.parent.sortSettings.columns[index].direction : 'None';\n\n          button.onclick = function (e) {\n            _this.sortButtonClickHandler(e.target);\n          };\n        }\n\n        if (isFilter && filteredCols.indexOf(cols[i].field) > -1) {\n          var divIcon = gObj.createElement('div', {\n            className: 'e-icons e-res-icon e-filtersetdiv'\n          });\n          var iconSpan = gObj.createElement('span', {\n            className: 'e-icons e-res-icon e-filterset'\n          });\n          iconSpan.setAttribute('colType', cols[i].type);\n          divIcon.appendChild(iconSpan);\n          cDiv.appendChild(divIcon);\n        }\n      }\n\n      EventHandler.add(this.customColumnDiv, 'click', this.customFilterColumnClickHandler, this);\n      return this.customColumnDiv;\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.getSortedFieldsAndDirections = function (name) {\n    var fields = [];\n\n    for (var i = 0; i < this.parent.sortSettings.columns.length; i++) {\n      fields.push(this.parent.sortSettings.columns[i][name]);\n    }\n\n    return fields;\n  };\n\n  ResponsiveDialogRenderer.prototype.sortButtonClickHandler = function (target) {\n    if (target) {\n      var columndiv = parentsUntil(target, 'e-responsivecoldiv');\n      var field = columndiv.getAttribute('data-e-mappingname');\n\n      if (!this.parent.allowMultiSorting) {\n        this.sortPredicate = [];\n        this.sortedCols = [];\n        this.isSortApplied = false;\n        this.resetSortButtons(target);\n      }\n\n      var txt = target.textContent;\n      var direction = txt === 'None' ? 'Ascending' : txt === 'Ascending' ? 'Descending' : 'None';\n      target.innerHTML = direction;\n      this.setSortedCols(field, direction);\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.resetSortButtons = function (target) {\n    var buttons = [].slice.call(this.customColumnDiv.getElementsByClassName('e-ressortbutton'));\n\n    for (var i = 0; i < buttons.length; i++) {\n      if (buttons[i] !== target) {\n        buttons[i].innerHTML = 'None';\n      }\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.setSortedCols = function (field, direction) {\n    var fields = this.getCurrentSortedFields();\n    var index = fields.indexOf(field);\n\n    if (this.parent.allowMultiSorting && index > -1) {\n      this.sortedCols.splice(index, 1);\n      this.sortPredicate.splice(index, 1);\n    }\n\n    this.isSortApplied = true;\n\n    if (direction !== 'None') {\n      this.sortedCols.push(field);\n      this.sortPredicate.push({\n        field: field,\n        direction: direction\n      });\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.getCurrentSortedFields = function () {\n    var fields = [];\n\n    for (var i = 0; i < this.sortedCols.length; i++) {\n      fields.push(this.sortedCols[i]);\n    }\n\n    return fields;\n  };\n\n  ResponsiveDialogRenderer.prototype.customFilterColumnClickHandler = function (e) {\n    if (this.action !== ResponsiveDialogAction.isFilter) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var target = e.target;\n\n    if (gObj.filterSettings.type !== 'FilterBar') {\n      if (target.classList.contains('e-responsivecoldiv') || target.parentElement.classList.contains('e-responsivecoldiv')) {\n        var field = target.getAttribute('data-e-mappingname');\n\n        if (!field) {\n          field = target.parentElement.getAttribute('data-e-mappingname');\n        }\n\n        if (field) {\n          var col = gObj.getColumnByField(field);\n          this.isRowResponsive = true;\n          this.showResponsiveDialog(col);\n        }\n      } else if (target.classList.contains('e-filterset') || target.parentElement.classList.contains('e-filtersetdiv')) {\n        var colDiv = parentsUntil(target, 'e-responsivecoldiv');\n\n        if (colDiv) {\n          var field = colDiv.getAttribute('data-e-mappingname');\n          var col = gObj.getColumnByField(field);\n\n          if (col.filter.type === 'Menu' || !col.filter.type && gObj.filterSettings.type === 'Menu') {\n            this.isDialogClose = true;\n          }\n\n          this.parent.filterModule.filterModule.clearCustomFilter(col);\n          this.removeCustomDlgFilterEle(target);\n        }\n      }\n    }\n  };\n  /**\n   * Function to show the responsive dialog\n   *\n   * @param {Column} col - specifies the column\n   * @returns {void}\n   */\n\n\n  ResponsiveDialogRenderer.prototype.showResponsiveDialog = function (col) {\n    if (this.isCustomDialog && this.action === ResponsiveDialogAction.isFilter && !this.isRowResponsive) {\n      this.renderCustomFilterDialog();\n    } else {\n      this.filteredCol = col;\n      this.renderResponsiveDialog(col);\n\n      if (this.parent.enableAdaptiveUI && col) {\n        this.parent.filterModule.setFilterModel(col);\n        this.parent.filterModule.filterModule.openDialog(this.parent.filterModule.createOptions(col, undefined));\n      }\n\n      if (this.action === ResponsiveDialogAction.isSort) {\n        var args = {\n          cancel: false,\n          dialogObj: this.customResponsiveDlg,\n          requestType: 'beforeOpenAptiveSortDialog'\n        };\n        this.parent.trigger(beforeOpenAdaptiveDialog, args);\n\n        if (args.cancel) {\n          return;\n        }\n      }\n\n      this.customResponsiveDlg.show(true);\n      this.customResponsiveDlg.element.style.maxHeight = '100%';\n      this.setTopToChildDialog(this.customResponsiveDlg.element);\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.setTopToChildDialog = function (dialogEle) {\n    var child = dialogEle.querySelector('.e-dialog');\n\n    if (child) {\n      var top_1 = dialogEle.querySelector('.e-dlg-header-content').getBoundingClientRect().height;\n      child.style.top = top_1 + 'px';\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.renderCustomFilterDialog = function (col) {\n    var gObj = this.parent;\n\n    if (this.action === ResponsiveDialogAction.isFilter && gObj.filterSettings.type === 'FilterBar') {\n      return;\n    }\n\n    var outerDiv = this.parent.createElement('div', {\n      id: gObj.element.id + 'customfilter',\n      className: this.parent.cssClass ? 'e-customfilterdiv e-responsive-dialog ' + this.parent.cssClass : 'e-customfilterdiv e-responsive-dialog'\n    });\n    this.parent.element.appendChild(outerDiv);\n    this.customFilterDlg = this.getDialogOptions(col, true);\n    var args = {\n      cancel: false,\n      dialogObj: this.customFilterDlg,\n      requestType: 'beforeOpenAptiveFilterDialog'\n    };\n    this.parent.trigger(beforeOpenAdaptiveDialog, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    this.customFilterDlg.appendTo(outerDiv);\n    this.customFilterDlg.show(true);\n    this.customFilterDlg.element.style.maxHeight = '100%';\n  };\n\n  ResponsiveDialogRenderer.prototype.getDialogOptions = function (col, isCustomFilter, id) {\n    var options = new Dialog({\n      isModal: true,\n      showCloseIcon: true,\n      closeOnEscape: false,\n      locale: this.parent.locale,\n      target: this.parent.adaptiveDlgTarget ? this.parent.adaptiveDlgTarget : document.body,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      content: this.renderResponsiveContent(col),\n      open: this.dialogOpen.bind(this),\n      created: this.dialogCreated.bind(this),\n      close: this.beforeDialogClose.bind(this),\n      width: '100%',\n      height: '100%',\n      animationSettings: {\n        effect: 'None'\n      },\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    var isStringTemplate = 'isStringTemplate';\n    options[isStringTemplate] = true;\n\n    if (isCustomFilter) {\n      options.header = this.renderResponsiveHeader(col, undefined, true);\n      options.cssClass = 'e-customfilter';\n    } else {\n      options.header = this.renderResponsiveHeader(col);\n      options.cssClass = this.parent.rowRenderingMode === 'Vertical' && this.action === ResponsiveDialogAction.isFilter ? 'e-res' + id + ' e-row-responsive-filter' : 'e-res' + id;\n    }\n\n    return options;\n  };\n\n  ResponsiveDialogRenderer.prototype.renderResponsiveDialog = function (col) {\n    var gObj = this.parent;\n\n    if (this.action === ResponsiveDialogAction.isFilter && gObj.filterSettings.type === 'FilterBar') {\n      return;\n    }\n\n    var id = this.action === ResponsiveDialogAction.isFilter ? 'filter' : 'sort';\n    var outerDiv = this.parent.createElement('div', {\n      id: gObj.element.id + 'responsive' + id,\n      className: this.parent.cssClass ? 'e-res' + id + 'div e-responsive-dialog ' + this.parent.cssClass : 'e-res' + id + 'div e-responsive-dialog'\n    });\n    this.parent.element.appendChild(outerDiv);\n    this.customResponsiveDlg = this.getDialogOptions(col, false, id);\n    this.customResponsiveDlg.appendTo(outerDiv);\n  };\n\n  ResponsiveDialogRenderer.prototype.dialogCreated = function () {\n    addBiggerDialog(this.parent);\n  };\n\n  ResponsiveDialogRenderer.prototype.dialogOpen = function () {\n    if (this.action === ResponsiveDialogAction.isSort && this.parent.allowMultiSorting) {\n      for (var i = 0; i < this.parent.sortSettings.columns.length; i++) {\n        this.sortedCols.push(this.parent.sortSettings.columns[i].field);\n        var sortField = this.parent.sortSettings.columns[i].field;\n        var sortDirection = this.parent.sortSettings.columns[i].direction;\n        this.sortPredicate.push({\n          field: sortField,\n          direction: sortDirection\n        });\n      }\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.beforeDialogClose = function (args) {\n    this.isDialogClose = args.element && !args.element.querySelector('.e-xl-customfilterdiv') && args.element.classList.contains('e-resfilterdiv');\n\n    if (this.action === ResponsiveDialogAction.isFilter) {\n      if (args.element.classList.contains('e-resfilterdiv')) {\n        this.parent.filterModule.filterModule.closeResponsiveDialog(this.isCustomDlgRender);\n      } else if (args.element.classList.contains('e-customfilterdiv')) {\n        this.closeCustomFilter();\n      }\n    } else if (this.action === ResponsiveDialogAction.isSort) {\n      this.closeCustomDialog();\n    }\n\n    this.parent.off(enterKeyHandler, this.keyHandler);\n  };\n\n  ResponsiveDialogRenderer.prototype.sortColumn = function () {\n    if (!this.isSortApplied) {\n      this.closeCustomDialog();\n      return;\n    }\n\n    if (this.sortPredicate.length) {\n      this.parent.setProperties({\n        sortSettings: {\n          columns: []\n        }\n      }, true);\n    }\n\n    for (var i = 0; i < this.sortPredicate.length; i++) {\n      this.parent.sortColumn(this.sortPredicate[i].field, this.sortPredicate[i].direction, this.parent.allowMultiSorting);\n    }\n\n    if (!this.sortPredicate.length) {\n      this.parent.clearSorting();\n    }\n\n    this.closeCustomDialog();\n  };\n\n  ResponsiveDialogRenderer.prototype.getHeaderTitle = function (args, col) {\n    var gObj = this.parent;\n    var title;\n\n    if (this.action === ResponsiveDialogAction.isEdit) {\n      title = gObj.localeObj.getConstant('EditFormTitle') + args.primaryKeyValue[0];\n    } else if (this.action === ResponsiveDialogAction.isAdd) {\n      title = gObj.localeObj.getConstant('AddFormTitle');\n    } else if (this.action === ResponsiveDialogAction.isFilter) {\n      title = col ? col.headerText || col.field : gObj.localeObj.getConstant('FilterButton');\n    } else if (this.action === ResponsiveDialogAction.isSort) {\n      title = gObj.localeObj.getConstant('Sort');\n    }\n\n    return title;\n  };\n\n  ResponsiveDialogRenderer.prototype.getDialogName = function (action) {\n    var name;\n\n    if (action === ResponsiveDialogAction.isAdd || action === ResponsiveDialogAction.isEdit) {\n      name = 'dialogEdit_wrapper_title';\n    } else if (action === ResponsiveDialogAction.isFilter) {\n      name = 'responsive_filter_dialog_wrapper';\n    }\n\n    return name;\n  };\n\n  ResponsiveDialogRenderer.prototype.getButtonText = function (action) {\n    var text;\n\n    if (action === ResponsiveDialogAction.isAdd || action === ResponsiveDialogAction.isEdit) {\n      text = 'Save';\n    } else if (action === ResponsiveDialogAction.isFilter || this.action === ResponsiveDialogAction.isSort) {\n      text = 'OKButton';\n    }\n\n    return text;\n  };\n  /**\n   * Function to render the responsive header\n   *\n   * @param {Column} col - specifies the column\n   * @param {ResponsiveDialogArgs} args - specifies the responsive dialog arguments\n   * @param {boolean} isCustomFilter - specifies whether it is custom filter or not\n   * @returns {HTMLElement | string} returns the html element or string\n   */\n\n\n  ResponsiveDialogRenderer.prototype.renderResponsiveHeader = function (col, args, isCustomFilter) {\n    var _this = this;\n\n    var gObj = this.parent;\n    gObj.on(enterKeyHandler, this.keyHandler, this);\n    var id = gObj.element.id + this.getDialogName(this.action);\n    var header = gObj.createElement('div', {\n      className: 'e-res-custom-element'\n    });\n    var titleDiv = gObj.createElement('div', {\n      className: 'e-dlg-custom-header',\n      id: id\n    });\n    titleDiv.innerHTML = this.getHeaderTitle(args, col);\n    header.appendChild(titleDiv);\n    var saveBtn = gObj.createElement('button');\n\n    if (!isCustomFilter) {\n      this.saveBtn = new Button({\n        cssClass: this.parent.cssClass ? 'e-primary e-flat e-res-apply-btn' + ' ' + this.parent.cssClass : 'e-primary e-flat e-res-apply-btn'\n      });\n      saveBtn.innerHTML = gObj.localeObj.getConstant(this.getButtonText(this.action));\n      this.saveBtn.appendTo(saveBtn); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n      saveBtn.onclick = function (e) {\n        _this.dialogHdrBtnClickHandler();\n      };\n    }\n\n    var isSort = this.action === ResponsiveDialogAction.isSort;\n    var isFilter = this.action === ResponsiveDialogAction.isFilter;\n\n    if (isFilter || isSort) {\n      var id_1 = isSort ? 'sort' : 'filter';\n      var clearBtn = gObj.createElement('button');\n      this.filterClearBtn = new Button({\n        cssClass: this.parent.cssClass ? 'e-primary e-flat e-res-' + id_1 + '-clear-btn' + ' ' + this.parent.cssClass : 'e-primary e-flat e-res-' + id_1 + '-clear-btn'\n      });\n\n      if (isFilter) {\n        var span = gObj.createElement('span', {\n          className: 'e-btn-icon e-icon-filter-clear e-icons'\n        });\n        clearBtn.appendChild(span);\n      } else {\n        clearBtn.innerHTML = gObj.localeObj.getConstant('Clear');\n      }\n\n      header.appendChild(clearBtn);\n      this.filterClearBtn.appendTo(clearBtn);\n\n      clearBtn.onclick = function (e) {\n        if (parentsUntil(e.target, 'e-customfilter')) {\n          _this.parent.filterModule.clearFiltering();\n\n          _this.removeCustomDlgFilterEle();\n        } else {\n          if (isFilter) {\n            _this.filterClear();\n          } else {\n            _this.resetSortButtons();\n\n            _this.sortedCols = [];\n            _this.sortPredicate = [];\n            _this.isSortApplied = true;\n          }\n        }\n      };\n\n      header.appendChild(clearBtn);\n    }\n\n    if (!isCustomFilter) {\n      header.appendChild(saveBtn);\n    }\n\n    return header;\n  };\n\n  ResponsiveDialogRenderer.prototype.filterClear = function () {\n    this.parent.filterModule.filterModule.clearCustomFilter(this.filteredCol);\n    this.parent.filterModule.filterModule.closeResponsiveDialog();\n  };\n\n  ResponsiveDialogRenderer.prototype.dialogHdrBtnClickHandler = function () {\n    if (this.action === ResponsiveDialogAction.isEdit || this.action === ResponsiveDialogAction.isAdd) {\n      this.parent.endEdit();\n    } else if (this.action === ResponsiveDialogAction.isFilter) {\n      this.parent.filterModule.filterModule.applyCustomFilter({\n        col: this.filteredCol,\n        isCustomFilter: this.isCustomDlgRender\n      });\n    } else if (this.action === ResponsiveDialogAction.isSort) {\n      this.sortColumn();\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.closeCustomDialog = function () {\n    if (this.isCustomDlgRender) {\n      var mainfilterdiv = this.customResponsiveDlg.element.querySelector('.e-mainfilterdiv');\n      remove(mainfilterdiv);\n      return;\n    }\n\n    this.isRowResponsive = false;\n    this.isCustomDlgRender = false;\n    this.destroyCustomFilterDialog();\n  };\n\n  ResponsiveDialogRenderer.prototype.destroyCustomFilterDialog = function () {\n    if (!this.customResponsiveDlg) {\n      return;\n    }\n\n    var elem = document.getElementById(this.customResponsiveDlg.element.id);\n\n    if (this.customResponsiveDlg && !this.customResponsiveDlg.isDestroyed && elem) {\n      this.customResponsiveDlg.destroy();\n      remove(elem);\n    }\n\n    this.closeCustomFilter();\n\n    if (this.action === ResponsiveDialogAction.isSort) {\n      this.sortPredicate = [];\n      this.sortedCols = [];\n      this.isSortApplied = false;\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.closeCustomFilter = function () {\n    if (!this.isDialogClose && this.customFilterDlg) {\n      var customEle = document.getElementById(this.customFilterDlg.element.id);\n\n      if (this.customFilterDlg && !this.customFilterDlg.isDestroyed && customEle) {\n        this.customFilterDlg.destroy();\n        remove(customEle);\n      }\n    }\n\n    this.isCustomDialog = false;\n    this.isDialogClose = false;\n  };\n\n  ResponsiveDialogRenderer.prototype.removeCustomDlgFilterEle = function (target) {\n    if (target) {\n      if (target.parentElement.classList.contains('e-filtersetdiv')) {\n        remove(target.parentElement);\n      } else {\n        remove(target);\n      }\n    } else {\n      var child = this.customColumnDiv.children;\n\n      for (var i = 0; i < child.length; i++) {\n        target = child[i].querySelector('.e-filtersetdiv');\n\n        if (target) {\n          remove(target);\n          i--;\n        }\n      }\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.keyHandler = function (e) {\n    if (e.keyCode === 13 && (this.action === ResponsiveDialogAction.isFilter && e.target.classList.contains('e-searchinput') || this.action === ResponsiveDialogAction.isEdit || this.action === ResponsiveDialogAction.isAdd)) {\n      this.dialogHdrBtnClickHandler();\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.editComplate = function (args) {\n    if (args.requestType === 'save' || args.requestType === 'cancel') {\n      this.parent.off(enterKeyHandler, this.keyHandler);\n    }\n  };\n\n  ResponsiveDialogRenderer.prototype.removeEventListener = function () {\n    if (this.customColumnDiv) {\n      EventHandler.remove(this.customColumnDiv, 'click', this.customFilterColumnClickHandler);\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.parent.removeEventListener(actionComplete, this.onActionCompleteFn);\n  };\n\n  return ResponsiveDialogRenderer;\n}();\n/**\n * ServiceLocator\n *\n * @hidden\n */\n\n\nvar ServiceLocator =\n/** @__PURE__ @class */\nfunction () {\n  function ServiceLocator() {\n    this.services = {};\n  }\n\n  ServiceLocator.prototype.register = function (name, type) {\n    if (isNullOrUndefined(this.services[name])) {\n      this.services[name] = type;\n    }\n  };\n\n  ServiceLocator.prototype.getService = function (name) {\n    if (isNullOrUndefined(this.services[name])) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"The service \" + name + \" is not registered\";\n    }\n\n    return this.services[name];\n  };\n\n  ServiceLocator.prototype.registerAdaptiveService = function (type, isAdaptiveUI, action) {\n    if (isAdaptiveUI) {\n      type.responsiveDialogRenderer = new ResponsiveDialogRenderer(type.parent, type.serviceLocator);\n      type.responsiveDialogRenderer.action = action;\n    } else {\n      if (type.responsiveDialogRenderer) {\n        type.responsiveDialogRenderer.removeEventListener();\n        type.responsiveDialogRenderer = undefined;\n      }\n    }\n  };\n\n  return ServiceLocator;\n}();\n/**\n * RendererFactory\n *\n * @hidden\n */\n\n\nvar RendererFactory =\n/** @__PURE__ @class */\nfunction () {\n  function RendererFactory() {\n    this.rendererMap = {};\n  }\n\n  RendererFactory.prototype.addRenderer = function (name, type) {\n    var rName = getEnumValue(RenderType, name);\n\n    if (isNullOrUndefined(this.rendererMap[rName])) {\n      this.rendererMap[rName] = type;\n    }\n  };\n\n  RendererFactory.prototype.getRenderer = function (name) {\n    var rName = getEnumValue(RenderType, name);\n\n    if (isNullOrUndefined(this.rendererMap[rName])) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"The renderer \" + rName + \" is not found\";\n    } else {\n      return this.rendererMap[rName];\n    }\n  };\n\n  return RendererFactory;\n}();\n/**\n * ColumnWidthService\n *\n * @hidden\n */\n\n\nvar ColumnWidthService =\n/** @__PURE__ @class */\nfunction () {\n  function ColumnWidthService(parent) {\n    this.parent = parent;\n  }\n\n  ColumnWidthService.prototype.setWidthToColumns = function () {\n    var i = 0;\n    var indexes = this.parent.getColumnIndexesInView();\n    var wFlag = true;\n    var totalColumnsWidth = 0;\n\n    if (this.parent.allowGrouping) {\n      for (var len = this.parent.groupSettings.columns.length; i < len; i++) {\n        if (this.parent.enableColumnVirtualization && indexes.indexOf(i) === -1) {\n          wFlag = false;\n          continue;\n        }\n\n        this.setColumnWidth(new Column({\n          width: '30px'\n        }), i);\n      }\n    }\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      this.setColumnWidth(new Column({\n        width: '30px'\n      }), i);\n      i++;\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() !== 'Right') {\n      this.setColumnWidth(new Column({\n        width: '30px'\n      }), i);\n      i++;\n    }\n\n    var columns = this.parent.getColumns();\n\n    for (var j = 0; j < columns.length; j++) {\n      this.setColumnWidth(columns[j], wFlag && this.parent.enableColumnVirtualization ? undefined : j + i);\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() === 'Right') {\n      this.setColumnWidth(new Column({\n        width: '30px'\n      }), columns.length);\n    }\n\n    totalColumnsWidth = this.getTableWidth(this.parent.getColumns());\n\n    if (this.parent.width !== 'auto' && this.parent.width.toString().indexOf('%') === -1) {\n      this.setMinwidthBycalculation(totalColumnsWidth);\n    }\n  };\n\n  ColumnWidthService.prototype.setMinwidthBycalculation = function (tWidth) {\n    var difference = 0;\n    var collection = this.parent.getColumns().filter(function (a) {\n      return isNullOrUndefined(a.width) || a.width === 'auto';\n    });\n\n    if (collection.length) {\n      if (!isNullOrUndefined(this.parent.width) && this.parent.width !== 'auto' && typeof this.parent.width === 'string' && this.parent.width.indexOf('%') === -1) {\n        difference = (typeof this.parent.width === 'string' ? parseInt(this.parent.width, 10) : this.parent.width) - tWidth;\n      } else {\n        difference = this.parent.element.getBoundingClientRect().width - tWidth;\n      }\n\n      var tmWidth = 0;\n\n      for (var _i = 0, collection_1 = collection; _i < collection_1.length; _i++) {\n        var cols = collection_1[_i];\n        tmWidth += !isNullOrUndefined(cols.minWidth) ? typeof cols.minWidth === 'string' ? parseInt(cols.minWidth, 10) : cols.minWidth : 0;\n      }\n\n      for (var i = 0; i < collection.length; i++) {\n        if (tWidth === 0 && this.parent.allowResizing && this.isWidthUndefined() && i !== collection.length - 1) {\n          this.setUndefinedColumnWidth(collection);\n        }\n\n        var index = this.parent.getColumnIndexByField(collection[i].field) + this.parent.getIndentCount();\n\n        if (tWidth !== 0 && difference < tmWidth) {\n          this.setWidth(collection[i].minWidth, index);\n        } else if (tWidth !== 0 && difference > tmWidth) {\n          this.setWidth('', index, true);\n        }\n      }\n    }\n  };\n\n  ColumnWidthService.prototype.setUndefinedColumnWidth = function (collection) {\n    for (var k = 0; k < collection.length; k++) {\n      if (k !== collection.length - 1) {\n        collection[k].width = 200;\n        this.setWidth(200, this.parent.getColumnIndexByField(collection[k].field));\n      }\n    }\n  };\n\n  ColumnWidthService.prototype.setColumnWidth = function (column, index, module) {\n    if (this.parent.getColumns().length < 1) {\n      return;\n    }\n\n    var columnIndex = isNullOrUndefined(index) ? this.parent.getNormalizedColumnIndex(column.uid) : index;\n    var cWidth = this.getWidth(column);\n    var tgridWidth = this.getTableWidth(this.parent.getColumns());\n\n    if (cWidth !== null) {\n      this.setWidth(cWidth, columnIndex);\n\n      if (this.parent.width !== 'auto' && this.parent.width.toString().indexOf('%') === -1) {\n        this.setMinwidthBycalculation(tgridWidth);\n      }\n\n      if (this.parent.allowResizing && module === 'resize' || this.parent.getFrozenColumns() && this.parent.allowResizing) {\n        this.setWidthToTable();\n      }\n\n      this.parent.notify(columnWidthChanged, {\n        index: columnIndex,\n        width: cWidth,\n        column: column,\n        module: module\n      });\n    }\n  };\n\n  ColumnWidthService.prototype.setWidth = function (width, index, clear) {\n    if (this.parent.groupSettings.columns.length > index && ispercentageWidth(this.parent)) {\n      var elementWidth = this.parent.element.offsetWidth;\n      width = (30 / elementWidth * 100).toFixed(1) + '%';\n    }\n\n    var header = this.parent.getHeaderTable();\n    var content$$1 = this.parent.getContentTable();\n    var fWidth = formatUnit(width);\n    var headerCol;\n    var frzCols = this.parent.getFrozenColumns();\n    var isDraggable = this.parent.isRowDragable();\n    frzCols = frzCols && isDraggable ? frzCols + 1 : frzCols;\n    var mHdr = this.parent.getHeaderContent().querySelector('.' + movableHeader);\n    var mCont = this.parent.getContent().querySelector('.' + movableContent);\n    var freezeLeft = this.parent.getFrozenLeftColumnsCount();\n    var freezeRight = this.parent.getFrozenRightColumnsCount();\n    var movableCount = this.parent.getMovableColumnsCount();\n    var isColFrozen = freezeLeft !== 0 || freezeRight !== 0;\n\n    if (frzCols && index >= frzCols) {\n      if (!mHdr || !mHdr.querySelector(colGroup)) {\n        return;\n      }\n\n      headerCol = mHdr.querySelector(colGroup + ':not(.e-masked-colgroup)').children[index - frzCols];\n    } else if (this.parent.enableColumnVirtualization && frzCols && this.parent.contentModule.isXaxis() && mHdr.scrollLeft > 0) {\n      var colGroup$$1 = mHdr.querySelector(colGroup);\n      headerCol = colGroup$$1.children[colGroup$$1.children.length - 1 - index];\n    } else if (isColFrozen) {\n      var target = void 0;\n\n      if (freezeLeft && !freezeRight) {\n        index = isDraggable ? index - 1 : index;\n        target = index < freezeLeft ? header : mHdr;\n      } else if (!freezeLeft && freezeRight) {\n        target = index >= movableCount ? header : mHdr;\n      } else if (freezeLeft && freezeRight) {\n        index = isDraggable ? index - 1 : index;\n        var frHdr = this.parent.getFrozenRightHeader();\n        target = index < freezeLeft ? header : index < freezeLeft + movableCount ? mHdr : frHdr;\n      }\n\n      headerCol = this.getColumnLevelFrozenColgroup(index, freezeLeft, movableCount, target);\n\n      if (!headerCol) {\n        return;\n      }\n    } else {\n      headerCol = header.querySelector(colGroup).children[index];\n    }\n\n    if (headerCol && !clear) {\n      headerCol.style.width = fWidth;\n    } else if (headerCol && clear) {\n      headerCol.style.width = '';\n    }\n\n    var contentCol;\n\n    if (frzCols && index >= frzCols) {\n      contentCol = this.parent.getContent().querySelector('.' + movableContent).querySelector(colGroup + ':not(.e-masked-colgroup)').children[index - frzCols];\n    } else if (this.parent.enableColumnVirtualization && frzCols && this.parent.contentModule.isXaxis() && mCont.scrollLeft > 0) {\n      var colGroup$$1 = this.parent.getContent().querySelector('.' + movableContent).querySelector(colGroup);\n      contentCol = colGroup$$1.children[colGroup$$1.children.length - 1 - index];\n    } else if (isColFrozen) {\n      var target = void 0;\n\n      if (freezeLeft && !freezeRight) {\n        target = index < freezeLeft ? content$$1 : mCont;\n      }\n\n      if (!freezeLeft && freezeRight) {\n        target = index >= movableCount ? content$$1 : mCont;\n      }\n\n      if (freezeLeft && freezeRight) {\n        var frCont = this.parent.getContent().querySelector('.e-frozen-right-content');\n        target = index < freezeLeft ? content$$1 : index < freezeLeft + movableCount ? mCont : frCont;\n      }\n\n      contentCol = this.getColumnLevelFrozenColgroup(index, freezeLeft, movableCount, target);\n    } else {\n      contentCol = content$$1.querySelector(colGroup).children[index];\n    }\n\n    if (contentCol && !clear) {\n      contentCol.style.width = fWidth;\n    } else if (contentCol && clear) {\n      contentCol.style.width = '';\n    }\n\n    if (!this.parent.enableColumnVirtualization) {\n      var edit = this.parent.element.querySelectorAll('.e-table.e-inline-edit');\n      var editTableCol = [];\n\n      for (var i = 0; i < edit.length; i++) {\n        if (parentsUntil(edit[i], 'e-grid').id === this.parent.element.id) {\n          for (var j = 0; j < edit[i].querySelector('colgroup').children.length; j++) {\n            editTableCol.push(edit[i].querySelector('colgroup').children[j]);\n          }\n        }\n      }\n\n      if (edit.length && editTableCol.length) {\n        editTableCol[index].style.width = fWidth;\n      }\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      this.refreshFrozenScrollbar();\n    }\n  };\n\n  ColumnWidthService.prototype.getColumnLevelFrozenColgroup = function (index, left, movable, ele) {\n    if (!ele || !ele.querySelector(colGroup)) {\n      return null;\n    }\n\n    var columns = this.parent.getColumns();\n    var isDrag = this.parent.isRowDragable();\n    var frzMode = this.parent.getFrozenMode();\n    var headerCol;\n    var colGroup$$1 = [].slice.call(ele.querySelector(colGroup + ':not(.e-masked-colgroup)').children);\n\n    if (frzMode === 'Right' && isDrag && index === movable + this.parent.getFrozenRightColumnsCount()) {\n      headerCol = colGroup$$1[colGroup$$1.length - 1];\n    } else if (isDrag && index === -1) {\n      headerCol = colGroup$$1[0];\n    } else if (columns[index].freeze === 'Left') {\n      headerCol = colGroup$$1[isDrag ? index + 1 : index];\n    } else if (columns[index].freeze === 'Right') {\n      headerCol = colGroup$$1[index - (left + movable)];\n    } else {\n      headerCol = colGroup$$1[index - left];\n    }\n\n    return headerCol;\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnWidthService.prototype.refreshFrozenScrollbar = function () {\n    var args = {\n      cancel: false\n    };\n    this.parent.notify(preventFrozenScrollRefresh, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    var scrollWidth = getScrollBarWidth();\n    var frozenScrollbar = this.parent.element.querySelector('.e-frozenscrollbar');\n    var movableScrollbar = this.parent.element.querySelector('.e-movablescrollbar');\n    var frozencontent = this.parent.getContent().querySelector('.' + frozenContent);\n    var movableContent$$1 = this.parent.getContent().querySelector('.' + movableContent);\n    var frozenWidth = frozencontent.firstElementChild.getBoundingClientRect().width;\n    var movableWidth = movableContent$$1.firstElementChild.getBoundingClientRect().width;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frozenWidth = frozenWidth + scrollWidth;\n    }\n\n    frozenScrollbar.style.width = frozenWidth + 'px';\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      var frozenRightScrollbar = this.parent.element.querySelector('.e-frozen-right-scrollbar');\n      var frozenRightWidth = this.parent.getContent().querySelector('.e-frozen-right-content').firstElementChild.getBoundingClientRect().width;\n\n      if (this.parent.height !== 'auto') {\n        frozenRightWidth = frozenRightWidth + scrollWidth;\n      }\n\n      frozenRightScrollbar.style.width = frozenRightWidth + 'px';\n    } else {\n      if (this.parent.enableColumnVirtualization) {\n        var placeHolder = this.parent.getMovableVirtualContent().querySelector('.e-virtualtrack');\n\n        if (placeHolder) {\n          movableWidth = placeHolder.scrollWidth;\n        }\n      }\n\n      if (this.parent.getFrozenMode() !== 'Right' && this.parent.height !== 'auto') {\n        movableWidth = movableWidth + scrollWidth;\n      }\n    }\n\n    movableScrollbar.firstElementChild.style.width = movableWidth + 'px';\n  };\n\n  ColumnWidthService.prototype.getSiblingsHeight = function (element) {\n    var previous = this.getHeightFromDirection(element, 'previous');\n    var next = this.getHeightFromDirection(element, 'next');\n    return previous + next;\n  };\n\n  ColumnWidthService.prototype.getHeightFromDirection = function (element, direction) {\n    var sibling = element[direction + 'ElementSibling'];\n    var result = 0;\n    var classList$$1 = [gridHeader, gridFooter, 'e-groupdroparea', 'e-gridpager', 'e-toolbar'];\n\n    while (sibling) {\n      if (classList$$1.some(function (value) {\n        return sibling.classList.contains(value);\n      })) {\n        result += sibling.offsetHeight;\n      }\n\n      sibling = sibling[direction + 'ElementSibling'];\n    }\n\n    return result;\n  };\n\n  ColumnWidthService.prototype.isWidthUndefined = function () {\n    var isWidUndefCount = this.parent.getColumns().filter(function (col) {\n      return isNullOrUndefined(col.width) && isNullOrUndefined(col.minWidth);\n    }).length;\n    return this.parent.getColumns().length === isWidUndefCount;\n  };\n\n  ColumnWidthService.prototype.getWidth = function (column) {\n    if (isNullOrUndefined(column.width) && this.parent.allowResizing && isNullOrUndefined(column.minWidth) && !this.isWidthUndefined()) {\n      column.width = 200;\n    }\n\n    if (this.parent.isFrozenGrid() && isNullOrUndefined(column.width) && (column.getFreezeTableName() === frozenLeft || column.getFreezeTableName() === frozenRight)) {\n      column.width = 200;\n    }\n\n    if (!column.width) {\n      return null;\n    }\n\n    var width = parseInt(column.width.toString(), 10);\n\n    if (column.minWidth && width < parseInt(column.minWidth.toString(), 10)) {\n      return column.minWidth;\n    } else if (column.maxWidth && width > parseInt(column.maxWidth.toString(), 10)) {\n      return column.maxWidth;\n    } else {\n      return column.width;\n    }\n  };\n\n  ColumnWidthService.prototype.getTableWidth = function (columns) {\n    var tWidth = 0;\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var column = columns_1[_i];\n      var cWidth = this.getWidth(column);\n\n      if (column.width === 'auto') {\n        cWidth = 0;\n      }\n\n      if (column.visible !== false && cWidth !== null) {\n        tWidth += parseInt(cWidth.toString(), 10);\n      }\n    }\n\n    return tWidth;\n  };\n\n  ColumnWidthService.prototype.calcMovableOrFreezeColWidth = function (tableType) {\n    var columns = this.parent.getColumns().slice();\n    var left = this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenColumns();\n    var movable = this.parent.getMovableColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n\n    if (tableType === 'movable') {\n      if (right) {\n        columns.splice(left + movable, columns.length);\n      }\n\n      if (left) {\n        columns.splice(0, left);\n      }\n    } else if (tableType === 'freeze-left') {\n      columns.splice(left, columns.length);\n    } else if (tableType === 'freeze-right') {\n      columns.splice(0, left + movable);\n    }\n\n    return formatUnit(this.getTableWidth(columns));\n  };\n\n  ColumnWidthService.prototype.setWidthToFrozenRightTable = function () {\n    var freezeWidth = this.calcMovableOrFreezeColWidth('freeze-right');\n    freezeWidth = this.isAutoResize() ? '100%' : freezeWidth;\n    var headerTbl = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector('.' + table + ':not(.e-masked-table)');\n    var cntTbl = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.' + table + ':not(.e-masked-table)');\n    headerTbl.style.width = freezeWidth;\n    cntTbl.style.width = freezeWidth;\n  };\n\n  ColumnWidthService.prototype.setWidthToFrozenLeftTable = function () {\n    var freezeWidth = this.calcMovableOrFreezeColWidth('freeze-left');\n    freezeWidth = this.isAutoResize() ? '100%' : freezeWidth;\n    this.parent.getHeaderTable().style.width = freezeWidth;\n    this.parent.getContentTable().style.width = freezeWidth;\n  };\n\n  ColumnWidthService.prototype.setWidthToMovableTable = function () {\n    var movableWidth = '';\n    var isColUndefined = this.parent.getColumns().filter(function (a) {\n      return isNullOrUndefined(a.width);\n    }).length >= 1;\n    var isWidthAuto = this.parent.getColumns().filter(function (a) {\n      return a.width === 'auto';\n    }).length >= 1;\n    var movableHeader$$1 = this.parent.getHeaderContent().querySelector('.' + movableHeader);\n    var movableContent$$1 = this.parent.getContent().querySelector('.' + movableContent);\n\n    if (typeof this.parent.width === 'number' && !isColUndefined && !isWidthAuto) {\n      movableWidth = formatUnit(this.parent.width - parseInt(this.calcMovableOrFreezeColWidth('freeze').split('px')[0], 10) - 5);\n    } else if (!isColUndefined && !isWidthAuto) {\n      movableWidth = this.calcMovableOrFreezeColWidth('movable');\n    }\n\n    movableWidth = this.isAutoResize() ? '100%' : movableWidth;\n\n    if (movableHeader$$1.firstElementChild) {\n      if (movableHeader$$1.firstElementChild.classList.contains('e-masked-table')) {\n        movableHeader$$1.childNodes[1].style.width = movableWidth;\n      } else {\n        movableHeader$$1.firstElementChild.style.width = movableWidth;\n      }\n    }\n\n    if (movableContent$$1.firstElementChild.classList.contains('e-masked-table')) {\n      movableContent$$1.childNodes[1].style.width = movableWidth;\n    } else {\n      movableContent$$1.firstElementChild.style.width = movableWidth;\n    }\n  };\n\n  ColumnWidthService.prototype.setWidthToFrozenEditTable = function () {\n    var freezeWidth = this.calcMovableOrFreezeColWidth('freeze');\n    freezeWidth = this.isAutoResize() ? '100%' : freezeWidth;\n    this.parent.element.querySelectorAll('.e-table.e-inline-edit')[0].style.width = freezeWidth;\n  };\n\n  ColumnWidthService.prototype.setWidthToMovableEditTable = function () {\n    var movableWidth = this.calcMovableOrFreezeColWidth('movable');\n    movableWidth = this.isAutoResize() ? '100%' : movableWidth;\n    this.parent.element.querySelectorAll('.e-table.e-inline-edit')[1].style.width = movableWidth;\n  };\n\n  ColumnWidthService.prototype.setWidthToTable = function () {\n    var tWidth = formatUnit(this.getTableWidth(this.parent.getColumns()));\n\n    if (this.parent.isFrozenGrid()) {\n      if (this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount()) {\n        this.setWidthToFrozenLeftTable();\n      }\n\n      this.setWidthToMovableTable();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.setWidthToFrozenRightTable();\n      }\n    } else {\n      if (this.parent.detailTemplate || this.parent.childGrid) {\n        this.setColumnWidth(new Column({\n          width: '30px'\n        }));\n      }\n\n      tWidth = this.isAutoResize() ? '100%' : tWidth;\n      this.parent.getHeaderTable().style.width = tWidth;\n      this.parent.getContentTable().style.width = tWidth;\n    }\n\n    var edit = this.parent.element.querySelector('.e-table.e-inline-edit');\n\n    if (edit && this.parent.getFrozenColumns()) {\n      this.setWidthToFrozenEditTable();\n      this.setWidthToMovableEditTable();\n    } else if (edit) {\n      edit.style.width = tWidth;\n    }\n  };\n\n  ColumnWidthService.prototype.isAutoResize = function () {\n    return this.parent.allowResizing && this.parent.resizeSettings.mode === 'Auto';\n  };\n\n  return ColumnWidthService;\n}();\n\nvar __extends$14 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * FocusStrategy class\n *\n * @hidden\n */\n\n\nvar FocusStrategy =\n/** @__PURE__ @class */\nfunction () {\n  function FocusStrategy(parent) {\n    this.currentInfo = {};\n    this.oneTime = true;\n    this.swap = {};\n    /** @hidden */\n\n    this.isInfiniteScroll = false;\n    this.forget = false;\n    this.skipFocus = true;\n    this.focusByClick = false;\n    this.prevIndexes = {};\n    this.refMatrix = this.refreshMatrix(true);\n    this.actions = ['downArrow', 'upArrow'];\n    this.isVirtualScroll = false;\n    this.parent = parent;\n    this.rowModelGen = new RowModelGenerator(this.parent);\n    this.addEventListener();\n  }\n\n  FocusStrategy.prototype.focusCheck = function (e) {\n    var target = e.target;\n    this.focusByClick = true;\n    this.skipFocus = target.classList.contains('e-grid');\n  };\n\n  FocusStrategy.prototype.onFocus = function (e) {\n    if (this.parent.isDestroyed || Browser.isDevice || this.parent.enableVirtualization || this.parent.element.querySelector('.e-masked-table') || !this.parent.isInitialLoad && e && e.target === this.parent.element && this.parent.element.querySelector('.e-spin-show')) {\n      return;\n    }\n\n    this.setActive(!this.parent.enableHeaderFocus && this.parent.frozenRows === 0, this.parent.isFrozenGrid());\n\n    if (!this.parent.enableHeaderFocus && !this.parent.getCurrentViewRecords().length && (this.parent.editSettings.mode !== 'Batch' || this.parent.editSettings.mode === 'Batch' && this.parent.editModule && !this.parent.editModule.getBatchChanges()[addedRecords].length)) {\n      this.getContent().matrix.generate(this.rowModelGen.generateRows({\n        rows: [new Row({\n          isDataRow: true\n        })]\n      }), this.getContent().selector, false);\n    }\n\n    var current = this.getContent().matrix.get(0, -1, [0, 1], null, this.getContent().validator());\n    this.getContent().matrix.select(current[0], current[1]);\n\n    if (this.skipFocus && !(e && e.target === this.parent.element)) {\n      this.focus(e);\n      this.skipFocus = false;\n    }\n  };\n\n  FocusStrategy.prototype.passiveFocus = function (e) {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (e.target && e.target.classList.contains('e-detailcell')) {\n      this.currentInfo.skipAction = false;\n      addClass([this.currentInfo.element], ['e-focused', 'e-focus']);\n    }\n  };\n\n  FocusStrategy.prototype.onBlur = function (e) {\n    if ((this.parent.isEdit || e && (!e.relatedTarget || closest(e.relatedTarget, '.e-grid')) && !(this.parent.element.classList.contains('e-childgrid') && !this.parent.element.matches(':focus-within'))) && !(isNullOrUndefined(e.relatedTarget) && parseInt(e.target.getAttribute('data-colindex'), 10) === 0 && parseInt(e.target.getAttribute('index'), 10) === 0)) {\n      return;\n    }\n\n    this.removeFocus();\n    this.skipFocus = true;\n    this.currentInfo.skipAction = false;\n    this.setLastContentCellTabIndex();\n    this.parent.element.tabIndex = 0;\n  };\n\n  FocusStrategy.prototype.setLastContentCellTabIndex = function () {\n    var contentTable = this.parent.getContentTable();\n    var lastCell = contentTable.rows[contentTable.rows.length - 1].lastElementChild;\n    lastCell.tabIndex = 0;\n  };\n\n  FocusStrategy.prototype.onClick = function (e, force) {\n    if (parentsUntil(e.target, 'e-filterbarcell') && (parentsUntil(e.target, 'e-multiselect') || e.target.classList.contains('e-input-group-icon'))) {\n      return;\n    }\n\n    var isContent = !isNullOrUndefined(closest(e.target, '.' + gridContent));\n    var isHeader = !isNullOrUndefined(closest(e.target, '.' + gridHeader));\n    isContent = isContent && isHeader ? !isContent : isContent;\n    var isFrozen = !isNullOrUndefined(closest(e.target, '.' + frozenContent)) || !isNullOrUndefined(closest(e.target, '.' + frozenHeader));\n    var isFrozenRight = false;\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      isFrozenRight = !isNullOrUndefined(closest(e.target, '.e-frozen-right-content')) || !isNullOrUndefined(closest(e.target, '.e-frozen-right-header'));\n      isFrozen = isFrozen && !isFrozenRight;\n    }\n\n    if (!isContent && isNullOrUndefined(closest(e.target, '.' + gridHeader)) || e.target.classList.contains(content) || !isNullOrUndefined(closest(e.target, '.e-unboundcell'))) {\n      return;\n    }\n\n    this.setActive(isContent, isFrozen, isFrozenRight);\n\n    if (!isContent && isNullOrUndefined(closest(e.target, '.' + gridHeader))) {\n      this.clearOutline();\n      return;\n    }\n\n    var beforeArgs = {\n      cancel: false,\n      byKey: false,\n      byClick: !isNullOrUndefined(e.target),\n      clickArgs: e\n    };\n    this.parent.notify(beforeCellFocused, beforeArgs);\n\n    if (beforeArgs.cancel || closest(e.target, '.e-inline-edit')) {\n      return;\n    }\n\n    this.setActive(isContent, isFrozen, isFrozenRight);\n\n    if (this.getContent()) {\n      var returnVal = this.getContent().onClick(e, force);\n\n      if (returnVal === false) {\n        return;\n      }\n\n      if (this.parent.isFrozenGrid() && isHeader && e.target === this.parent.getHeaderContent().firstChild && this.active.matrix.current[0] === -1 && this.active.matrix.current[1] === this.active.matrix.columns) {\n        this.active.matrix.current = [0, 0];\n      }\n\n      this.focus();\n    }\n  };\n\n  FocusStrategy.prototype.onKeyPress = function (e) {\n    if (this.parent.allowPaging) {\n      var pagerElement = this.parent.pagerModule.pagerObj.element;\n      var focusablePagerElements = this.parent.pagerModule.pagerObj.getFocusablePagerElements(pagerElement, []);\n\n      if (this.parent.childGrid && this.allowToPaging(e) && focusablePagerElements.length) {\n        focusablePagerElements[0].tabIndex = 0;\n      }\n\n      if (this.parent.pagerModule.pagerObj.checkPagerHasFocus()) {\n        if (e.action === 'shiftTab' && focusablePagerElements.length && focusablePagerElements[0] === e.target) {\n          this.setActive(true);\n          var lastHeaderCellIndex = [this.active.matrix.matrix.length - 1, this.active.matrix.matrix[this.active.matrix.matrix.length - 1].length - 1];\n\n          if (this.active.matrix.matrix[lastHeaderCellIndex[0]][lastHeaderCellIndex[1]] === 0) {\n            lastHeaderCellIndex = findCellIndex(this.active.matrix.matrix, lastHeaderCellIndex, false);\n          }\n\n          this.active.matrix.current = lastHeaderCellIndex;\n          e.preventDefault();\n          this.focus(e);\n          return;\n        }\n\n        if (!(e.action === 'tab' && this.parent.element.classList.contains('e-childgrid') && (!this.parent.pageSettings.pageSizes && focusablePagerElements.length && focusablePagerElements[focusablePagerElements.length - 1] === e.target || this.parent.pagerModule.pagerObj.getDropDownPage() === e.target))) {\n          this.parent.pagerModule.pagerObj.changePagerFocus(e);\n          return;\n        } else {\n          var parentCell = parentsUntil(this.parent.element, 'e-detailcell');\n          removeClass([this.parent.element], ['e-focus']);\n          removeClass([parentCell], ['e-focused']);\n          parentCell.tabIndex = -1;\n        }\n      }\n\n      if (this.parent.pagerModule.pagerObj.element.tabIndex === 0 && (e.keyCode === 38 || e.shiftKey && e.keyCode === 9)) {\n        e.preventDefault();\n        this.getFocusedElement().focus();\n        return;\n      } else if (this.parent.pagerModule.pagerObj.element.tabIndex === 0 && e.keyCode === 9) {\n        e.preventDefault();\n        this.parent.pagerModule.pagerObj.setPagerFocus();\n        return;\n      }\n\n      if (this.parent.pagerModule.pagerObj.checkFirstPagerFocus()) {\n        var lastRow = this.getContent().matrix.rows;\n        var lastColumn = this.getContent().matrix.columns;\n        this.getContent().matrix.current = [lastRow, lastColumn];\n      }\n    }\n\n    if (this.skipOn(e)) {\n      return;\n    }\n\n    if (e.target && parentsUntil(e.target, 'e-gridcontent') && !this.parent.isFrozenGrid()) {\n      var rows = [].slice.call(this.parent.getContentTable().rows);\n      var lastCell = rows[rows.length - 1].lastElementChild;\n\n      if (e.target === lastCell) {\n        this.setActive(true);\n        this.setLastContentCellActive();\n      }\n    }\n\n    if (e.action === 'shiftTab' && e.target && (e.target === this.parent.element || parentsUntil(e.target, 'e-toolbar') || parentsUntil(e.target, 'e-groupdroparea'))) {\n      if (e.target === this.parent.element) {\n        if (this.parent.element.classList.contains('e-childgrid')) {\n          this.focusOutFromChildGrid(e);\n        }\n\n        return;\n      }\n\n      if (parentsUntil(e.target, 'e-groupdroparea')) {\n        e.preventDefault();\n        this.parent.element.focus();\n        return;\n      }\n\n      if (parentsUntil(e.target, 'e-toolbar')) {\n        e.preventDefault();\n\n        if (this.parent.allowGrouping) {\n          var groupModule = this.parent.groupModule;\n          var focusableGroupedItems = groupModule.getFocusableGroupedItems();\n\n          if (focusableGroupedItems.length > 0) {\n            focusableGroupedItems[focusableGroupedItems.length - 1].focus();\n          } else {\n            groupModule.element.focus();\n          }\n        } else {\n          this.parent.element.focus();\n        }\n\n        return;\n      }\n    }\n\n    var focusFirstHeaderCell = false;\n\n    if (e.action === 'tab' && e.target && (e.target === this.parent.element || parentsUntil(e.target, 'e-toolbar') || parentsUntil(e.target, 'e-groupdroparea'))) {\n      if (this.parent.allowGrouping && this.parent.groupSettings.showDropArea && (e.target === this.parent.element || e.target.classList.contains('e-groupdroparea'))) {\n        var groupModule = this.parent.groupModule;\n        var focusableGroupedItems = groupModule.getFocusableGroupedItems();\n\n        if (focusableGroupedItems.length > 0) {\n          e.preventDefault();\n          focusableGroupedItems[0].focus();\n          return;\n        }\n\n        if (!e.target.classList.contains('e-groupdroparea')) {\n          e.preventDefault();\n          groupModule.element.focus();\n          return;\n        }\n      }\n\n      if ((this.parent.toolbar || this.parent.toolbarTemplate) && (e.target === this.parent.element || parentsUntil(e.target, 'e-groupdroparea') || e.target.classList.contains('e-toolbar'))) {\n        var toolbarElement = this.parent.toolbarModule.element;\n        var focusableToolbarItems = toolbarElement.querySelectorAll('.e-toolbar-item:not(.e-overlay):not(.e-hidden)');\n\n        if (focusableToolbarItems.length > 0) {\n          e.preventDefault();\n          focusableToolbarItems[0].querySelector('.e-btn,.e-input').focus();\n          return;\n        }\n\n        if (!e.target.classList.contains('e-toolbar')) {\n          e.preventDefault();\n          toolbarElement.focus();\n          return;\n        }\n      }\n\n      if (e.target === this.parent.element || parentsUntil(e.target, 'e-toolbar') || parentsUntil(e.target, 'e-groupdroparea')) {\n        focusFirstHeaderCell = true;\n      }\n    }\n\n    if (focusFirstHeaderCell) {\n      if (this.parent.isFrozenGrid() && (this.parent.getFrozenMode() === 'Left' || this.parent.getFrozenMode() === leftRight)) {\n        this.setActive(false, true);\n      } else if (this.parent.allowGrouping && this.parent.groupSettings.columns.length === this.parent.columns.length) {\n        this.setActive(true);\n      } else {\n        this.setActive(false);\n      }\n\n      this.active.matrix.current = [0, -1];\n    }\n\n    this.activeKey = e.action;\n    var beforeArgs = {\n      cancel: false,\n      byKey: true,\n      byClick: false,\n      keyArgs: e\n    };\n    this.parent.notify(beforeCellFocused, beforeArgs);\n\n    if (beforeArgs.cancel) {\n      return;\n    }\n\n    var bValue = this.getContent().matrix.current;\n    this.currentInfo.outline = true;\n    var swapInfo = this.getContent().jump(e.action, bValue);\n    this.swap = swapInfo;\n\n    if (swapInfo.swap) {\n      this.setActive(!swapInfo.toHeader, swapInfo.toFrozen, swapInfo.toFrozenRight);\n      this.getContent().matrix.current = this.getContent().getNextCurrent(bValue, swapInfo, this.active, e.action);\n      this.prevIndexes = {};\n    }\n\n    this.setActiveByKey(e.action, this.getContent());\n    var returnVal = this.content.lastIdxCell ? false : this.getContent().onKeyPress(e);\n\n    if (e.target && parentsUntil(e.target, 'e-gridheader')) {\n      if (!this.parent.isFrozenGrid()) {\n        if (e.action === 'tab' && bValue.toString() === this.active.matrix.current.toString()) {\n          var nextHeaderCellIndex = findCellIndex(this.active.matrix.matrix, this.active.matrix.current, true);\n          var lastHeaderCellIndex = [this.active.matrix.matrix.length - 1, this.active.matrix.matrix[this.active.matrix.matrix.length - 1].length - 1];\n\n          if (this.active.matrix.matrix[lastHeaderCellIndex[0]][lastHeaderCellIndex[1]] === 0) {\n            lastHeaderCellIndex = findCellIndex(this.active.matrix.matrix, lastHeaderCellIndex, false);\n          }\n\n          if (this.active.matrix.current.toString() === lastHeaderCellIndex.toString()) {\n            returnVal = true;\n            this.setActive(true);\n            var firstContentCellIndex = [0, 0];\n\n            if (this.active.matrix.matrix[firstContentCellIndex[0]][firstContentCellIndex[1]] === 0) {\n              firstContentCellIndex = findCellIndex(this.active.matrix.matrix, [0, 0], true);\n            }\n\n            this.active.matrix.current = firstContentCellIndex;\n          } else if (this.active.matrix.current.toString() !== nextHeaderCellIndex.toString()) {\n            this.active.matrix.current = nextHeaderCellIndex;\n          }\n        }\n\n        if (e.action === 'shiftTab' && bValue.toString() === this.active.matrix.current.toString()) {\n          var previousCellIndex = findCellIndex(this.active.matrix.matrix, this.active.matrix.current, false);\n\n          if (previousCellIndex.toString() === this.active.matrix.current.toString()) {\n            this.focusOutFromHeader(e);\n            return;\n          }\n\n          if (this.active.matrix.current.toString() !== previousCellIndex.toString() && !returnVal) {\n            returnVal = true;\n            this.active.matrix.current = previousCellIndex;\n          }\n        }\n      } else {\n        if (e.action === 'shiftTab' && bValue.toString() === this.active.matrix.current.toString() && !swapInfo.swap) {\n          this.focusOutFromHeader(e);\n          return;\n        }\n      }\n    }\n\n    if (e.target && parentsUntil(e.target, 'e-gridcontent')) {\n      if (!this.parent.isFrozenGrid()) {\n        if (e.action === 'shiftTab' && bValue.toString() === this.active.matrix.current.toString()) {\n          if (this.parent.allowGrouping && this.parent.groupSettings.columns.length === this.parent.columns.length) {\n            this.focusOutFromHeader(e);\n            return;\n          }\n\n          var firstContentCellIndex = [0, 0];\n\n          if (this.active.matrix.matrix[firstContentCellIndex[0]][firstContentCellIndex[1]] === 0) {\n            firstContentCellIndex = findCellIndex(this.active.matrix.matrix, [0, 0], true);\n          }\n\n          if (!returnVal && firstContentCellIndex.toString() === this.active.matrix.current.toString()) {\n            returnVal = true;\n            this.setActive(false);\n            this.setLastContentCellActive();\n          }\n        }\n      }\n    }\n\n    if (returnVal === false) {\n      this.clearIndicator();\n\n      if (e.action === 'shiftTab' && bValue.toString() === [0, 0].toString()) {\n        this.parent.element.tabIndex = -1;\n      }\n\n      if (this.parent.allowPaging && !this.parent.pagerModule.pagerObj.checkPagerHasFocus() && this.allowToPaging(e) && bValue.toString() !== [0, 0].toString()) {\n        e.preventDefault();\n\n        if (e.keyCode === 40) {\n          this.parent.pagerModule.pagerObj.setPagerContainerFocus();\n          return;\n        } else if (e.keyCode === 9) {\n          this.parent.pagerModule.pagerObj.setPagerFocus();\n          return;\n        }\n      }\n\n      if (this.parent.element.classList.contains('e-childgrid')) {\n        this.focusOutFromChildGrid(e);\n      }\n\n      return;\n    }\n\n    e.preventDefault();\n    this.focus(e);\n  };\n\n  FocusStrategy.prototype.setLastContentCellActive = function () {\n    var lastContentCellIndex = [this.active.matrix.matrix.length - 1, this.active.matrix.matrix[this.active.matrix.matrix.length - 1].length - 1];\n\n    if (this.active.matrix.matrix[lastContentCellIndex[0]][lastContentCellIndex[1]] === 0) {\n      lastContentCellIndex = findCellIndex(this.active.matrix.matrix, lastContentCellIndex, false);\n    }\n\n    this.active.matrix.current = lastContentCellIndex;\n  };\n\n  FocusStrategy.prototype.focusOutFromChildGrid = function (e) {\n    var parentTable = parentsUntil(this.parent.element, 'e-table');\n    var parentGrid = parentsUntil(parentTable, 'e-grid').ej2_instances[0];\n    var parentCell = parentsUntil(this.parent.element, 'e-detailcell');\n    var uid = parentsUntil(this.parent.element, 'e-detailrow').getAttribute('data-uid');\n    var parentRows = parentGrid.getRows();\n    var parentRowIndex = parentRows.map(function (m) {\n      return m.getAttribute('data-uid');\n    }).indexOf(uid);\n\n    if (e.action === 'tab' && parentRowIndex >= parentRows.length - 1) {\n      return;\n    }\n\n    removeClass([this.parent.element], ['e-focus']);\n    removeClass([parentCell], ['e-focused']);\n    parentCell.tabIndex = -1;\n    e.preventDefault();\n    var nextFocusCell;\n    parentGrid.focusModule.removeFocus();\n\n    if (e.action === 'shiftTab') {\n      var previousRow = parentRows[parentRowIndex - 1];\n      var rowCells = previousRow.cells;\n\n      for (var i = rowCells.length - 1; i >= 0; i--) {\n        nextFocusCell = rowCells[i];\n\n        if (!nextFocusCell.classList.contains('e-hide')) {\n          parentGrid.focusModule.active.matrix.current = [parentRowIndex - 1, i];\n          break;\n        }\n      }\n    } else {\n      nextFocusCell = parentRows[parentRowIndex + 1].cells[0];\n      parentGrid.focusModule.active.matrix.current = [parentRowIndex + 1, 0];\n    }\n\n    parentGrid.focusModule.currentInfo.element = nextFocusCell;\n    parentGrid.focusModule.currentInfo.elementToFocus = nextFocusCell;\n    addClass([nextFocusCell], ['e-focused', 'e-focus']);\n    nextFocusCell.tabIndex = 0;\n    nextFocusCell.focus();\n  };\n\n  FocusStrategy.prototype.focusOutFromHeader = function (e) {\n    e.preventDefault();\n    this.removeFocus();\n\n    if (this.parent.toolbar || this.parent.toolbarTemplate) {\n      var toolbarElement = this.parent.toolbarModule.element;\n      var focusableToolbarItems = toolbarElement.querySelectorAll('.e-toolbar-item:not(.e-overlay):not(.e-hidden)');\n\n      if (focusableToolbarItems.length > 0) {\n        focusableToolbarItems[focusableToolbarItems.length - 1].querySelector('.e-btn,.e-input').focus();\n      } else {\n        toolbarElement.focus();\n      }\n\n      return;\n    }\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.showDropArea) {\n      var groupModule = this.parent.groupModule;\n      var focusableGroupedItems = groupModule.getFocusableGroupedItems();\n\n      if (focusableGroupedItems.length > 0) {\n        focusableGroupedItems[focusableGroupedItems.length - 1].focus();\n      } else {\n        groupModule.element.focus();\n      }\n\n      return;\n    }\n\n    this.parent.element.focus();\n  };\n\n  FocusStrategy.prototype.allowToPaging = function (e) {\n    if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.allowAdding && e.keyCode !== 40) {\n      return false;\n    }\n\n    return true;\n  };\n\n  FocusStrategy.prototype.skipOn = function (e) {\n    var target = e.target;\n\n    if (!target) {\n      return false;\n    }\n\n    if (this.currentInfo.skipAction) {\n      this.clearIndicator();\n      return true;\n    }\n\n    if (['pageUp', 'pageDown', 'altDownArrow'].indexOf(e.action) > -1) {\n      this.clearIndicator();\n      return true;\n    }\n\n    if (this.parent.allowGrouping) {\n      var focusableGroupedItems = this.parent.groupModule.getFocusableGroupedItems();\n\n      if (parentsUntil(e.target, 'e-groupheadercell') && !(e.target === focusableGroupedItems[0] && e.action === 'shiftTab' || e.target === focusableGroupedItems[focusableGroupedItems.length - 1] && e.action === 'tab')) {\n        return true;\n      }\n    }\n\n    if (this.parent.toolbar || this.parent.toolbarTemplate) {\n      var toolbarElement = this.parent.toolbarModule.element;\n      var focusableToolbarItems = toolbarElement.querySelectorAll('.e-toolbar-item:not(.e-overlay):not(.e-hidden)');\n\n      if (parentsUntil(e.target, 'e-toolbar-item') && !(focusableToolbarItems.length > 0 && (parentsUntil(e.target, 'e-toolbar-item') === focusableToolbarItems[0] && e.action === 'shiftTab' || parentsUntil(e.target, 'e-toolbar-item') === focusableToolbarItems[focusableToolbarItems.length - 1] && e.action === 'tab'))) {\n        return true;\n      }\n    }\n\n    var th = closest(target, 'th') && !closest(target, 'th').tabIndex;\n\n    if (e.target.classList.contains('e-filterbaroperator') && (e.keyCode === 13 || e.keyCode === 27)) {\n      var inputTarget = closest(e.target, '.e-filterbarcell');\n      inputTarget.querySelector('input').focus();\n    }\n\n    if (th && closest(document.activeElement, '.e-filterbarcell') !== null) {\n      this.removeFocus();\n    }\n\n    var filterCell = closest(document.activeElement, '.e-filterbarcell') !== null;\n\n    if (this.parent.enableHeaderFocus && filterCell) {\n      var matrix = this.active.matrix;\n      var current = matrix.current;\n      filterCell = matrix.matrix[current[0]].lastIndexOf(1) !== current[1];\n    }\n\n    return e.action === 'delete' || this.parent.editSettings.mode !== 'Batch' && (this.parent.isEdit || ['insert', 'f2'].indexOf(e.action) > -1) || filterCell && this.parent.enableHeaderFocus || filterCell && e.action !== 'tab' && e.action !== 'shiftTab' || closest(document.activeElement, '#' + this.parent.element.id + '_searchbar') !== null && ['enter', 'leftArrow', 'rightArrow', 'shiftLeft', 'shiftRight', 'ctrlPlusA'].indexOf(e.action) > -1 || closest(target, '.' + gridContent) === null && closest(target, '.' + gridHeader) === null && !(e.target === this.parent.element || parentsUntil(e.target, 'e-toolbar') || parentsUntil(e.target, 'e-groupdroparea')) || e.action === 'space' && !target.classList.contains(gridChkBox) && closest(target, '.' + gridChkBox) === null && closest(target, '.e-headerchkcelldiv') === null || closest(target, '.e-filter-popup') !== null;\n  };\n\n  FocusStrategy.prototype.focusVirtualElement = function (e) {\n    var _this = this;\n\n    if (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) {\n      var data = {\n        virtualData: {},\n        isAdd: false,\n        isCancel: false\n      };\n      this.parent.notify(getVirtualData, data);\n      var isKeyFocus = this.actions.some(function (value) {\n        return value === _this.activeKey;\n      });\n      var isSelected = this.parent.contentModule ? this.parent.contentModule.selectedRowIndex > -1 : false;\n\n      if (data.isAdd || Object.keys(data.virtualData).length || isKeyFocus || data.isCancel || isSelected) {\n        this.parent.notify(resetVirtualFocus, {\n          isCancel: false\n        });\n        data.isCancel = false;\n        this.parent.contentModule.selectedRowIndex = -1;\n\n        if (isKeyFocus) {\n          this.activeKey = this.empty;\n          this.parent.notify('virtaul-key-handler', e);\n        } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n        this.currentInfo.elementToFocus.focus({\n          preventScroll: true\n        });\n      } else {\n        if (this.isVirtualScroll || this.isInfiniteScroll) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          this.currentInfo.elementToFocus.focus({\n            preventScroll: true\n          });\n        } else {\n          this.currentInfo.elementToFocus.focus();\n        }\n      }\n    }\n\n    this.isVirtualScroll = this.isInfiniteScroll = false;\n  };\n\n  FocusStrategy.prototype.getFocusedElement = function () {\n    return this.currentInfo.elementToFocus;\n  };\n\n  FocusStrategy.prototype.getContent = function () {\n    return this.active || this.content;\n  };\n\n  FocusStrategy.prototype.setActive = function (content$$1, isFrozen, isFrozenRight) {\n    this.active = content$$1 ? isFrozen ? this.fContent : isFrozenRight ? this.frContent : this.content : isFrozen ? this.fHeader : isFrozenRight ? this.frHeader : this.header;\n  };\n\n  FocusStrategy.prototype.setFocusedElement = function (element, e) {\n    var _this = this;\n\n    this.currentInfo.elementToFocus = element;\n    setTimeout(function () {\n      if (!isNullOrUndefined(_this.currentInfo.elementToFocus)) {\n        if (_this.parent.enableVirtualization || _this.parent.enableInfiniteScrolling) {\n          _this.focusVirtualElement(e);\n        } else {\n          _this.currentInfo.elementToFocus.focus();\n        }\n      }\n    }, 0);\n  };\n\n  FocusStrategy.prototype.focus = function (e) {\n    this.parent.notify(virtaulCellFocus, e);\n    this.removeFocus();\n    this.addFocus(this.getContent().getFocusInfo(), e);\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  FocusStrategy.prototype.removeFocus = function (e) {\n    if (!this.currentInfo.element) {\n      return;\n    }\n\n    removeClass([this.currentInfo.element, this.currentInfo.elementToFocus], ['e-focused', 'e-focus']);\n    this.currentInfo.element.tabIndex = -1;\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  FocusStrategy.prototype.addOutline = function () {\n    var info = this.getContent().getFocusInfo();\n\n    if (info.element) {\n      addClass([info.element], ['e-focused']);\n      addClass([info.elementToFocus], ['e-focus']);\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  FocusStrategy.prototype.focusHeader = function () {\n    this.setActive(false, this.parent.isFrozenGrid());\n    this.resetFocus();\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  FocusStrategy.prototype.focusContent = function () {\n    this.setActive(true, this.parent.isFrozenGrid());\n    this.resetFocus();\n  };\n\n  FocusStrategy.prototype.resetFocus = function () {\n    var current = this.getContent().matrix.get(0, -1, [0, 1], null, this.getContent().validator());\n    this.getContent().matrix.select(current[0], current[1]);\n    this.focus();\n  };\n\n  FocusStrategy.prototype.addFocus = function (info, e) {\n    this.currentInfo = info;\n    this.currentInfo.outline = info.outline && !isNullOrUndefined(e);\n\n    if (this.isInfiniteScroll) {\n      this.currentInfo.outline = true;\n    }\n\n    if (!info.element) {\n      return;\n    }\n\n    var isFocused = info.elementToFocus.classList.contains('e-focus');\n\n    if (isFocused) {\n      return;\n    }\n\n    if (this.currentInfo.outline) {\n      addClass([info.element], ['e-focused']);\n    }\n\n    addClass([info.elementToFocus], ['e-focus']);\n    info.element.tabIndex = 0;\n\n    if (!isFocused) {\n      this.setFocusedElement(info.elementToFocus, e);\n    }\n\n    this.parent.notify(cellFocused, {\n      element: info.elementToFocus,\n      parent: info.element,\n      indexes: this.getContent().matrix.current,\n      byKey: !isNullOrUndefined(e),\n      byClick: isNullOrUndefined(e),\n      keyArgs: e,\n      isJump: this.swap.swap,\n      container: this.getContent().getInfo(e),\n      outline: !isNullOrUndefined(e),\n      swapInfo: this.swap\n    });\n    var _a = this.getContent().matrix.current,\n        rowIndex = _a[0],\n        cellIndex = _a[1];\n    this.prevIndexes = {\n      rowIndex: rowIndex,\n      cellIndex: cellIndex\n    };\n    this.focusedColumnUid = this.parent.getColumnByIndex(cellIndex).uid;\n    this.focusByClick = false;\n  };\n\n  FocusStrategy.prototype.refreshMatrix = function (content$$1) {\n    var _this = this;\n\n    return function (e) {\n      if (content$$1 && e.args && e.args.isFrozen && !_this.fContent) {\n        _this.fContent = new FixedContentFocus(_this.parent);\n      } else if (content$$1 && !_this.frContent && e.args && e.args.renderFrozenRightContent) {\n        _this.frContent = new FixedRightContentFocus(_this.parent);\n      } else if (content$$1 && !_this.content) {\n        _this.content = new ContentFocus(_this.parent);\n      }\n\n      if (!content$$1 && e.args && e.args.isFrozen && !_this.fHeader) {\n        _this.fHeader = new FixedHeaderFocus(_this.parent);\n      } else if (!content$$1 && e.args && e.args.renderFrozenRightContent && !_this.frHeader) {\n        _this.frHeader = new FixedRightHeaderFocus(_this.parent);\n      } else if (!content$$1 && !_this.header) {\n        _this.header = new HeaderFocus(_this.parent);\n      }\n\n      var cFocus = content$$1 ? e.args && e.args.isFrozen ? _this.fContent : e.args && e.args.renderFrozenRightContent ? _this.frContent : _this.content : e.args && e.args.isFrozen ? _this.fHeader : e.args && e.args.renderFrozenRightContent ? _this.frHeader : _this.header;\n      var rows = content$$1 ? e.rows.slice(_this.parent.frozenRows) : e.rows;\n      var updateRow = content$$1 ? e.rows.slice(0, _this.parent.frozenRows) : e.rows;\n\n      if (_this.parent.isCollapseStateEnabled() && content$$1) {\n        rows = rows.filter(function (x) {\n          return x.visible !== false;\n        });\n      }\n\n      var isRowTemplate = !isNullOrUndefined(_this.parent.rowTemplate);\n      var matrix = cFocus.matrix.generate(updateRow, cFocus.selector, isRowTemplate);\n\n      if (e.name === 'batchAdd' && _this.parent.isFrozenGrid()) {\n        var mRows = _this.parent.getMovableRowsObject();\n\n        var newMovableRows = mRows.map(function (row$$1) {\n          return row$$1.clone();\n        });\n        var newFrozenRows = rows.map(function (row$$1) {\n          return row$$1.clone();\n        });\n\n        _this.fContent.matrix.generate(newFrozenRows, _this.fContent.selector, isRowTemplate);\n\n        _this.content.matrix.generate(newMovableRows, _this.content.selector, isRowTemplate);\n\n        if (_this.parent.getFrozenMode() === leftRight) {\n          var frRows = _this.parent.getFrozenRightRowsObject();\n\n          var newfrRows = frRows.map(function (row$$1) {\n            return row$$1.clone();\n          });\n\n          _this.frContent.matrix.generate(newfrRows, _this.frContent.selector, isRowTemplate);\n        }\n      } else {\n        cFocus.matrix.generate(rows, cFocus.selector, isRowTemplate);\n      }\n\n      if (!(_this.parent.isFrozenGrid() && e.args && e.args.requestType === 'sorting')) {\n        cFocus.generateRows(updateRow, {\n          matrix: matrix,\n          handlerInstance: e.args && e.args.isFrozen ? _this.fHeader : e.args && e.args.renderFrozenRightContent ? _this.frHeader : _this.header\n        });\n      }\n\n      if (!Browser.isDevice && e && e.args) {\n        if (!_this.focusByClick && e.args.requestType === 'paging' && !_this.parent.pagerModule.pagerObj.checkPagerHasFocus()) {\n          _this.skipFocus = false;\n\n          _this.parent.element.focus();\n        }\n\n        if (e.args.requestType === 'grouping') {\n          _this.skipFocus = true;\n        }\n      }\n\n      if (e && e.args && e.args.requestType === 'virtualscroll') {\n        if (_this.currentInfo.uid) {\n          var index_1;\n          var bool = e.rows.some(function (row$$1, i) {\n            index_1 = i;\n            return row$$1.uid === _this.currentInfo.uid;\n          });\n\n          if (bool) {\n            _this.content.matrix.current[0] = index_1;\n            _this.content.matrix.current[1] = _this.parent.getColumnIndexByUid(_this.focusedColumnUid) || 0;\n\n            var focusElement = _this.getContent().getFocusInfo().elementToFocus;\n\n            if (focusElement) {\n              var cellPosition = focusElement.getBoundingClientRect();\n\n              var gridPosition = _this.parent.element.getBoundingClientRect();\n\n              if (cellPosition.top >= 0 && cellPosition.left >= 0 && cellPosition.right <= Math.min(gridPosition.right, window.innerWidth || document.documentElement.clientWidth) && cellPosition.bottom <= Math.min(gridPosition.bottom, window.innerHeight || document.documentElement.clientHeight)) {\n                _this.isVirtualScroll = true;\n\n                _this.focus();\n              }\n            }\n          }\n        } else if (e.args.focusElement && e.args.focusElement.classList.contains('e-filtertext')) {\n          var focusElement = _this.parent.element.querySelector('#' + e.args.focusElement.id);\n\n          if (focusElement) {\n            focusElement.focus();\n          }\n        }\n      }\n    };\n  };\n\n  FocusStrategy.prototype.addEventListener = function () {\n    var _this = this;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.add(this.parent.element, 'mousedown', this.focusCheck, this);\n    EventHandler.add(this.parent.element, 'focus', this.onFocus, this);\n    this.parent.element.addEventListener('focus', this.passiveHandler = function (e) {\n      return _this.passiveFocus(e);\n    }, true);\n    EventHandler.add(this.parent.element, 'focusout', this.onBlur, this);\n    this.evtHandlers = [{\n      event: keyPressed,\n      handler: this.onKeyPress\n    }, {\n      event: click,\n      handler: this.onClick\n    }, {\n      event: contentReady,\n      handler: this.refMatrix\n    }, {\n      event: partialRefresh,\n      handler: this.refMatrix\n    }, {\n      event: refreshExpandandCollapse,\n      handler: this.refMatrix\n    }, {\n      event: headerRefreshed,\n      handler: this.refreshMatrix()\n    }, {\n      event: closeEdit,\n      handler: this.restoreFocus\n    }, {\n      event: restoreFocus,\n      handler: this.restoreFocus\n    }, {\n      event: 'start-edit',\n      handler: this.clearIndicator\n    }, {\n      event: 'start-add',\n      handler: this.clearIndicator\n    }, {\n      event: 'sorting-complete',\n      handler: this.restoreFocus\n    }, {\n      event: 'filtering-complete',\n      handler: this.filterfocus\n    }, {\n      event: 'grouping-complete',\n      handler: this.restoreFocusWithAction\n    }, {\n      event: 'ungrouping-complete',\n      handler: this.restoreFocusWithAction\n    }, {\n      event: batchAdd,\n      handler: this.refMatrix\n    }, {\n      event: batchCancel,\n      handler: this.refMatrix\n    }, {\n      event: batchDelete,\n      handler: this.refMatrix\n    }, {\n      event: detailDataBound,\n      handler: this.refMatrix\n    }, {\n      event: onEmpty,\n      handler: this.refMatrix\n    }, {\n      event: cellFocused,\n      handler: this.internalCellFocus\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  };\n\n  FocusStrategy.prototype.filterfocus = function () {\n    if (this.parent.filterSettings.type !== 'FilterBar') {\n      this.restoreFocus();\n    }\n  };\n\n  FocusStrategy.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(this.parent.element, 'mousedown', this.focusCheck);\n    EventHandler.remove(this.parent.element, 'focus', this.onFocus);\n    EventHandler.remove(this.parent.element, 'focusout', this.onBlur);\n    this.parent.element.removeEventListener('focus', this.passiveHandler, true);\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  };\n\n  FocusStrategy.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  FocusStrategy.prototype.restoreFocus = function () {\n    var groupModule = this.parent.groupModule;\n\n    if (this.parent.allowGrouping && groupModule && groupModule.groupSortFocus) {\n      groupModule.groupSortFocus = false;\n      return;\n    }\n\n    this.addFocus(this.getContent().getFocusInfo());\n  };\n\n  FocusStrategy.prototype.restoreFocusWithAction = function (e) {\n    if (!this.parent.enableInfiniteScrolling) {\n      var matrix = this.getContent().matrix;\n      var current = matrix.current;\n\n      switch (e.requestType) {\n        case 'grouping':\n        case 'ungrouping':\n          current[1] = current.length && !this.parent.groupSettings.showGroupedColumn && !isNullOrUndefined(matrix.matrix[current[0]]) ? matrix.matrix[current[0]].indexOf(1) : e.requestType === 'grouping' ? current[1] + 1 : current[1] - 1;\n          break;\n      }\n\n      this.getContent().matrix.current = current;\n      var groupModule = this.parent.groupModule;\n\n      if (this.parent.allowGrouping && groupModule && groupModule.groupCancelFocus) {\n        var focusableGroupedItems = groupModule.getFocusableGroupedItems();\n\n        if (focusableGroupedItems.length) {\n          if (focusableGroupedItems[0].parentElement.getAttribute('ej-mappingname') === e.columnName) {\n            focusableGroupedItems[3].focus();\n          } else {\n            focusableGroupedItems[0].focus();\n          }\n        } else {\n          groupModule.element.focus();\n        }\n\n        groupModule.groupCancelFocus = false;\n        return;\n      }\n\n      this.addFocus(this.getContent().getFocusInfo());\n    }\n  };\n\n  FocusStrategy.prototype.clearOutline = function () {\n    this.getContent().matrix.current = this.getContent().matrix.get(0, -1, [0, 1], 'downArrow', this.getContent().validator());\n    this.clearIndicator();\n  };\n\n  FocusStrategy.prototype.clearIndicator = function () {\n    if (!this.currentInfo.element || !this.currentInfo.elementToFocus) {\n      return;\n    }\n\n    removeClass([this.currentInfo.element, this.currentInfo.elementToFocus], ['e-focus', 'e-focused']);\n  };\n\n  FocusStrategy.prototype.getPrevIndexes = function () {\n    var forget = this.forget;\n    this.forget = false;\n    return forget || !Object.keys(this.prevIndexes).length ? {\n      rowIndex: null,\n      cellIndex: null\n    } : this.prevIndexes;\n  };\n\n  FocusStrategy.prototype.forgetPrevious = function () {\n    this.forget = true;\n  };\n\n  FocusStrategy.prototype.setActiveByKey = function (action, active) {\n    var _this = this;\n\n    if (!this.parent.isFrozenGrid() && this.parent.frozenRows === 0) {\n      return;\n    } // eslint-disable-next-line prefer-const\n\n\n    var info;\n    var actions = {\n      'home': function () {\n        return {\n          toHeader: !info.isContent,\n          toFrozen: true\n        };\n      },\n      'end': function () {\n        return {\n          toHeader: !info.isContent,\n          toFrozen: false\n        };\n      },\n      'ctrlHome': function () {\n        return {\n          toHeader: true,\n          toFrozen: _this.parent.isFrozenGrid()\n        };\n      },\n      'ctrlEnd': function () {\n        return {\n          toHeader: false,\n          toFrozen: false\n        };\n      }\n    };\n\n    if (!(action in actions)) {\n      return;\n    }\n\n    info = active.getInfo();\n    var swap = actions[action]();\n    this.setActive(!swap.toHeader, swap.toFrozen);\n    this.getContent().matrix.current = active.matrix.current;\n  };\n\n  FocusStrategy.prototype.internalCellFocus = function (e) {\n    if (!(e.byKey && e.container.isContent && e.keyArgs.action === 'enter' && (e.parent.classList.contains('e-detailcell') || e.parent.classList.contains('e-unboundcell') || e.parent.classList.contains('e-templatecell')))) {\n      return;\n    }\n\n    this.clearIndicator();\n    var focusEle = this.getContent().getFocusable(this.getFocusedElement());\n    this.setFocusedElement(focusEle);\n    this.currentInfo.skipAction = true;\n  };\n\n  return FocusStrategy;\n}();\n/**\n * Create matrix from row collection which act as mental model for cell navigation\n *\n * @hidden\n */\n\n\nvar Matrix =\n/** @__PURE__ @class */\nfunction () {\n  function Matrix() {\n    this.matrix = [];\n    this.current = [];\n  }\n\n  Matrix.prototype.set = function (rowIndex, columnIndex, allow) {\n    rowIndex = Math.max(0, Math.min(rowIndex, this.rows));\n    columnIndex = Math.max(0, Math.min(columnIndex, this.columns));\n    this.matrix[rowIndex] = this.matrix[rowIndex] || [];\n    this.matrix[rowIndex][columnIndex] = allow ? 1 : 0;\n  };\n\n  Matrix.prototype.get = function (rowIndex, columnIndex, navigator, action, validator) {\n    var tmp = columnIndex;\n\n    if (rowIndex + navigator[0] < 0) {\n      return [rowIndex, columnIndex];\n    }\n\n    rowIndex = Math.max(0, Math.min(rowIndex + navigator[0], this.rows));\n    var emptyTable = true;\n\n    if (isNullOrUndefined(this.matrix[rowIndex])) {\n      return null;\n    }\n\n    columnIndex = Math.max(0, Math.min(columnIndex + navigator[1], this.matrix[rowIndex].length - 1));\n\n    if (tmp + navigator[1] > this.matrix[rowIndex].length - 1 && validator(rowIndex, columnIndex, action)) {\n      return [rowIndex, tmp];\n    }\n\n    var first = this.first(this.matrix[rowIndex], columnIndex, navigator, true, action);\n    columnIndex = first === null ? tmp : first;\n    var val = getValue(rowIndex + \".\" + columnIndex, this.matrix);\n\n    if (rowIndex === this.rows && (action === 'downArrow' || action === 'enter')) {\n      navigator[0] = -1;\n    }\n\n    if (first === null) {\n      for (var i = 0; i < this.rows; i++) {\n        if (this.matrix[i].some(function (v) {\n          return v === 1;\n        })) {\n          emptyTable = false;\n          break;\n        }\n      }\n\n      if (emptyTable) {\n        rowIndex = this.current[0];\n        return [rowIndex, columnIndex];\n      }\n    }\n\n    return this.inValid(val) || !validator(rowIndex, columnIndex, action) ? this.get(rowIndex, tmp, navigator, action, validator) : [rowIndex, columnIndex];\n  };\n\n  Matrix.prototype.first = function (vector, index, navigator, moveTo, action) {\n    if ((index < 0 || index === vector.length) && this.inValid(vector[index]) && action !== 'upArrow' && action !== 'downArrow' || !vector.some(function (v) {\n      return v === 1;\n    })) {\n      return null;\n    }\n\n    return !this.inValid(vector[index]) ? index : this.first(vector, ['upArrow', 'downArrow', 'shiftUp', 'shiftDown'].indexOf(action) !== -1 ? moveTo ? 0 : ++index : index + navigator[1], navigator, false, action);\n  };\n\n  Matrix.prototype.select = function (rowIndex, columnIndex) {\n    rowIndex = Math.max(0, Math.min(rowIndex, this.rows));\n    columnIndex = Math.max(0, Math.min(columnIndex, this.matrix[rowIndex].length - 1));\n    this.current = [rowIndex, columnIndex];\n  };\n\n  Matrix.prototype.generate = function (rows, selector, isRowTemplate) {\n    this.rows = rows.length - 1;\n    this.matrix = [];\n\n    for (var i = 0; i < rows.length; i++) {\n      var cells = rows[i].cells.filter(function (c) {\n        return c.isSpanned !== true;\n      });\n      this.columns = Math.max(cells.length - 1, this.columns | 0);\n      var incrementNumber = 0;\n\n      for (var j = 0; j < cells.length; j++) {\n        if (cells[j].column && cells[j].column.columns) {\n          incrementNumber = this.columnsCount(cells[j].column.columns, incrementNumber);\n        } else {\n          incrementNumber++;\n        }\n\n        this.set(i, j, rows[i].visible === false ? false : selector(rows[i], cells[j], isRowTemplate));\n      }\n\n      this.columns = Math.max(incrementNumber - 1, this.columns | 0);\n    }\n\n    return this.matrix;\n  };\n\n  Matrix.prototype.columnsCount = function (rowColumns, currentColumnCount) {\n    var columns = rowColumns;\n    var incrementNumber = currentColumnCount;\n\n    for (var i = 0; i < columns.length; i++) {\n      if (columns[i].columns) {\n        incrementNumber = this.columnsCount(columns[i].columns, incrementNumber);\n      } else {\n        incrementNumber++;\n      }\n    }\n\n    return incrementNumber;\n  };\n\n  Matrix.prototype.inValid = function (value) {\n    return value === 0 || value === undefined;\n  };\n\n  return Matrix;\n}();\n/**\n * @hidden\n */\n\n\nvar ContentFocus =\n/** @__PURE__ @class */\nfunction () {\n  function ContentFocus(parent) {\n    var _this = this;\n\n    this.matrix = new Matrix();\n    this.lastIdxCell = false;\n    this.parent = parent;\n    this.keyActions = {\n      'rightArrow': [0, 1],\n      'tab': [0, 1],\n      'leftArrow': [0, -1],\n      'shiftTab': [0, -1],\n      'upArrow': [-1, 0],\n      'downArrow': [1, 0],\n      'shiftUp': [-1, 0],\n      'shiftDown': [1, 0],\n      'shiftRight': [0, 1],\n      'shiftLeft': [0, -1],\n      'enter': [1, 0],\n      'shiftEnter': [-1, 0]\n    };\n\n    this.indexesByKey = function (action) {\n      var opt = {\n        'home': [_this.matrix.current[0], -1, 0, 1],\n        'end': [_this.matrix.current[0], _this.matrix.columns + 1, 0, -1],\n        'ctrlHome': [0, -1, 0, 1],\n        'ctrlEnd': [_this.matrix.rows, _this.matrix.columns + 1, 0, -1]\n      };\n      return opt[action] || null;\n    };\n  }\n\n  ContentFocus.prototype.getTable = function () {\n    return this.parent.isFrozenGrid() ? this.parent.getContent().querySelector('.e-movablecontent .e-table') : this.parent.getContentTable();\n  };\n\n  ContentFocus.prototype.onKeyPress = function (e) {\n    var navigator = this.keyActions[e.action];\n    var current = this.getCurrentFromAction(e.action, navigator, e.action in this.keyActions, e);\n\n    if (!current) {\n      return;\n    }\n\n    if ((['tab', 'shiftTab'].indexOf(e.action) > -1 && this.matrix.current || []).toString() === current.toString() || this.parent.allowPaging && !this.parent.pagerModule.pagerObj.checkPagerHasFocus() && this.matrix.current[0] === this.matrix.rows && (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.allowAdding && e.keyCode === 40 || e.keyCode === 40)) {\n      if (current.toString() === [this.matrix.rows, this.matrix.columns].toString() || current.toString() === [0, 0].toString() || this.matrix.current[0] === this.matrix.rows && this.matrix.current.toString() === current.toString() || this.parent.allowGrouping && this.parent.infiniteScrollSettings.enableCache && current.toString() === [0, 1].toString()) {\n        return false;\n      } else {\n        current = this.editNextRow(current[0], current[1], e.action);\n      }\n    }\n\n    this.matrix.select(current[0], current[1]);\n  };\n\n  ContentFocus.prototype.editNextRow = function (rowIndex, cellIndex, action) {\n    var gObj = this.parent;\n    var editNextRow = gObj.editSettings.allowNextRowEdit && (gObj.isEdit || gObj.isLastCellPrimaryKey);\n    var visibleIndex = gObj.getColumnIndexByField(gObj.getVisibleColumns()[0].field);\n    var cell = this.getTable().rows[rowIndex].cells[cellIndex];\n\n    if (action === 'tab' && editNextRow) {\n      rowIndex++;\n      var index = this.getTable().rows[rowIndex].getElementsByClassName('e-indentcell').length + this.getTable().rows[rowIndex].getElementsByClassName('e-detailrowcollapse').length;\n      cellIndex = visibleIndex + index;\n    }\n\n    if (action === 'shiftTab' && editNextRow) {\n      rowIndex--;\n      cellIndex = gObj.getColumnIndexByField(gObj.getVisibleColumns()[gObj.getVisibleColumns().length - 1].field);\n    }\n\n    return !cell.classList.contains(rowCell) && !cell.classList.contains('e-headercell') && !cell.classList.contains('e-groupcaption') && !cell.classList.contains('e-filterbarcell') ? this.editNextRow(rowIndex, cellIndex, action) : [rowIndex, cellIndex];\n  };\n\n  ContentFocus.prototype.getCurrentFromAction = function (action, navigator, isPresent, e) {\n    if (navigator === void 0) {\n      navigator = [0, 0];\n    }\n\n    if (!isPresent && !this.indexesByKey(action) || this.matrix.current.length === 0) {\n      return null;\n    }\n\n    if (!this.shouldFocusChange(e)) {\n      return this.matrix.current;\n    } // eslint-disable-next-line\n\n\n    var _a = this.indexesByKey(action) || this.matrix.current.concat(navigator),\n        rowIndex = _a[0],\n        cellIndex = _a[1],\n        rN = _a[2],\n        cN = _a[3];\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && this.parent.aggregates.length && action === 'enter') {\n      for (var i = rowIndex; i < this.matrix.matrix.length; i++) {\n        var row$$1 = this.getTable().rows[i + 1];\n\n        if (row$$1 && row$$1.cells[cellIndex] && row$$1.cells[cellIndex].classList.contains('e-rowcell')) {\n          return [i + 1, cellIndex];\n        }\n\n        if (i === this.matrix.matrix.length - 1) {\n          return [rowIndex, cellIndex];\n        }\n      }\n    }\n\n    if (action === 'ctrlEnd') {\n      var lastContentCellIndex = [this.matrix.matrix.length - 1, this.matrix.matrix[this.matrix.matrix.length - 1].length - 1];\n\n      if (this.matrix.matrix[lastContentCellIndex[0]][lastContentCellIndex[1]] === 0) {\n        lastContentCellIndex = findCellIndex(this.matrix.matrix, lastContentCellIndex, false);\n      }\n\n      rowIndex = lastContentCellIndex[0];\n      cellIndex = lastContentCellIndex[1] + 1;\n    }\n\n    var current = this.matrix.get(rowIndex, cellIndex, [rN, cN], action, this.validator());\n    return current;\n  };\n\n  ContentFocus.prototype.onClick = function (e, force) {\n    var target = e.target;\n    this.target = target;\n    target = target.classList.contains(rowCell) ? target : closest(target, 'td');\n    target = target ? target : closest(e.target, 'td.e-detailrowcollapse') || closest(e.target, 'td.e-detailrowexpand');\n    target = closest(e.target, 'td.e-detailcell') ? isNullOrUndefined(closest(closest(e.target, '.e-grid'), 'td.e-detailcell')) ? null : target : target;\n    target = target && closest(target, 'table').classList.contains(table) ? target : null;\n\n    if (!target) {\n      return false;\n    }\n\n    var _a = [target.parentElement.rowIndex, target.cellIndex],\n        rowIndex = _a[0],\n        cellIndex = _a[1];\n    var _b = this.matrix.current,\n        oRowIndex = _b[0],\n        oCellIndex = _b[1];\n    var val = getValue(rowIndex + \".\" + cellIndex, this.matrix.matrix);\n\n    if (this.matrix.inValid(val) || !force && oRowIndex === rowIndex && oCellIndex === cellIndex || !parentsUntil(e.target, rowCell) && !parentsUntil(e.target, 'e-groupcaption') && !parentsUntil(e.target, 'e-recordpluscollapse') && !parentsUntil(e.target, 'e-recordplusexpand') && !parentsUntil(e.target, 'e-detailrowcollapse') && !parentsUntil(e.target, 'e-detailrowexpand') && !parentsUntil(e.target, 'e-templatecell')) {\n      return false;\n    }\n\n    this.matrix.select(rowIndex, cellIndex);\n  };\n\n  ContentFocus.prototype.getFocusInfo = function () {\n    var info = {};\n    var _a = this.matrix.current,\n        _b = _a[0],\n        rowIndex = _b === void 0 ? 0 : _b,\n        _c = _a[1],\n        cellIndex = _c === void 0 ? 0 : _c;\n    this.matrix.current = [rowIndex, cellIndex];\n    info.element = !isNullOrUndefined(this.getTable().rows[rowIndex]) ? this.getTable().rows[rowIndex].cells[cellIndex] : null;\n\n    if (!info.element) {\n      return info;\n    }\n\n    info.elementToFocus = !info.element.classList.contains('e-unboundcell') && !info.element.classList.contains('e-detailcell') ? this.getFocusable(info.element) : info.element;\n    info.elementToFocus = info.element.classList.contains('e-detailcell') && info.element.querySelector('.e-childgrid') ? info.element.querySelector('.e-childgrid') : info.elementToFocus;\n    info.outline = true;\n    info.uid = info.element.parentElement.getAttribute('data-uid');\n    return info;\n  };\n\n  ContentFocus.prototype.getFocusable = function (element) {\n    var query = 'button, [href], input:not([type=\"hidden\"]), select, textarea, [tabindex]:not([tabindex=\"-1\"])';\n    var isTemplate = !isNullOrUndefined(closest(element, '.e-templatecell'));\n\n    if (this.parent.isEdit) {\n      query = 'input:not([type=\"hidden\"]), select:not([aria-hidden=\"true\"]), textarea';\n    }\n\n    var child = [].slice.call(element.querySelectorAll(query));\n    /* Select the first focusable child element\n     * if no child found then select the cell itself.\n     * if Grid is in editable state, check for editable control inside child.\n     */\n\n    return child.length ? isTemplate && child.length > 1 ? this.target : child[0] : element;\n  };\n\n  ContentFocus.prototype.selector = function (row$$1, cell, isRowTemplate) {\n    var types = [CellType.Expand, CellType.GroupCaption, CellType.CaptionSummary, CellType.GroupSummary];\n    return (row$$1.isDataRow && cell.visible && (cell.isDataCell || cell.isTemplate) || row$$1.isDataRow && cell.cellType === CellType.DetailExpand && isNullOrUndefined(cell.visible) || !row$$1.isDataRow && types.indexOf(cell.cellType) > -1 && !((cell.cellType === CellType.GroupSummary || cell.cellType === CellType.CaptionSummary) && !(cell.isDataCell && cell.visible)) || cell.column && cell.visible && cell.column.type === 'checkbox' || cell.cellType === CellType.CommandColumn || row$$1.isDataRow && isRowTemplate) && !(row$$1.edit === 'delete' && row$$1.isDirty);\n  };\n\n  ContentFocus.prototype.nextRowFocusValidate = function (index) {\n    var lastIndex = index;\n\n    for (var i = index, len = this.matrix.rows; i <= len; i++) {\n      if (this.matrix.matrix[index].indexOf(1) === -1) {\n        index = index + 1;\n      } else {\n        return index;\n      }\n    }\n\n    this.lastIdxCell = true;\n    return lastIndex;\n  };\n\n  ContentFocus.prototype.previousRowFocusValidate = function (index) {\n    var firstIndex = index;\n\n    for (var i = index, len = 0; i >= len; i--) {\n      if (this.matrix.matrix[index].indexOf(1) === -1) {\n        index = index - 1;\n\n        if (index < 0) {\n          this.lastIdxCell = true;\n          return firstIndex;\n        }\n      } else {\n        return index;\n      }\n    }\n\n    return firstIndex;\n  };\n\n  ContentFocus.prototype.jump = function (action, current) {\n    var frozenSwap = this.parent.getFrozenLeftCount() && (action === 'leftArrow' || action === 'shiftTab') && current[1] === 0 || current[0] < this.matrix.matrix.length - 1 && action === 'tab' && this.parent.getFrozenMode() === 'Left' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n    var right = (action === 'rightArrow' || action === 'tab') && current[1] === this.matrix.columns || action === 'shiftTab' && this.parent.getFrozenMode() === 'Right' && current[1] === this.matrix.matrix[current[0]].indexOf(1);\n    var frSwap = this.parent.getFrozenMode() === leftRight && right;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frozenSwap = right;\n    }\n\n    this.lastIdxCell = false;\n    var enterFrozen = this.parent.frozenRows !== 0 && action === 'shiftEnter';\n    var headerSwap = (action === 'upArrow' || enterFrozen) && current[0] === 0 || action === 'shiftTab' && this.parent.getFrozenMode() === 'Right' && current[0] === 0 && current[1] === this.matrix.matrix[current[0]].indexOf(1);\n\n    if (!this.parent.isFrozenGrid() && action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1) && this.matrix.matrix.length - 1 !== current[0]) {\n      this.matrix.current[0] = this.nextRowFocusValidate(this.matrix.current[0] + 1);\n      this.matrix.current[1] = -1;\n      frozenSwap = this.parent.isFrozenGrid();\n    }\n\n    if (!this.parent.isFrozenGrid() && action === 'shiftTab' && current[0] !== 0 && this.matrix.matrix[current[0]].indexOf(1) === current[1]) {\n      this.matrix.current[0] = this.previousRowFocusValidate(this.matrix.current[0] - 1);\n      this.matrix.current[1] = this.matrix.matrix[current[0]].length;\n    }\n\n    var isHeaderFocus = false;\n    var row$$1 = document.activeElement.parentElement;\n\n    if ((this.parent.enableVirtualization || this.parent.infiniteScrollSettings.enableCache) && row$$1.classList.contains(row)) {\n      var rowIndex = parseInt(row$$1.getAttribute(dataRowIndex), 10);\n      isHeaderFocus = rowIndex > 0;\n    }\n\n    if (action === 'shiftTab' && this.parent.getFrozenMode() === 'Right' && current[0] === 0 && current[1] === this.matrix.matrix[current[0]].indexOf(1)) {\n      this.matrix.current[0] = -1;\n    }\n\n    var info = {\n      swap: !isHeaderFocus ? (action === 'upArrow' || enterFrozen) && current[0] === 0 || frozenSwap || frSwap : false,\n      toHeader: headerSwap,\n      toFrozen: frozenSwap,\n      toFrozenRight: frSwap\n    };\n    return info;\n  };\n\n  ContentFocus.prototype.getNextCurrent = function (previous, swap, active, action) {\n    if (previous === void 0) {\n      previous = [];\n    }\n\n    var current = [];\n\n    if (this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenMode() === leftRight) {\n      if (action === 'leftArrow' || action === 'shiftTab') {\n        current[0] = previous[0];\n        current[1] = this.matrix.matrix[current[0]].length;\n      }\n\n      if (this.parent.getFrozenMode() === leftRight && (action === 'rightArrow' || action === 'tab')) {\n        current[0] = previous[0];\n        current[1] = -1;\n      }\n\n      if (this.parent.getFrozenMode() === 'Right' && action === 'tab') {\n        current[0] = previous[0] + 1;\n        current[1] = -1;\n      }\n    } else if (action === 'rightArrow' || action === 'tab') {\n      current[0] = previous[0];\n      current[1] = -1;\n    }\n\n    if (action === 'downArrow' || action === 'enter') {\n      current[0] = -1;\n      current[1] = previous[1];\n    }\n\n    if (action === 'shiftTab' && this.parent.getFrozenMode() === 'Left') {\n      current[0] = previous[0] - 1;\n      current[1] = this.matrix.matrix[current[0]].length;\n    }\n\n    return current;\n  };\n\n  ContentFocus.prototype.generateRows = function (rows, optionals) {\n    var _a;\n\n    var matrix = optionals.matrix,\n        handlerInstance = optionals.handlerInstance;\n    var len = handlerInstance.matrix.matrix.length;\n    var defaultLen = this.parent.allowFiltering && this.parent.filterSettings.type === 'FilterBar' ? len + 1 : len;\n    handlerInstance.matrix.matrix = handlerInstance.matrix.matrix.slice(0, defaultLen); //Header matrix update.\n\n    handlerInstance.matrix.rows = defaultLen;\n\n    (_a = handlerInstance.matrix.matrix).push.apply(_a, matrix);\n\n    handlerInstance.matrix.rows += matrix.length;\n  };\n\n  ContentFocus.prototype.getInfo = function (e) {\n    var info = this.getFocusInfo();\n    var _a = this.matrix.current,\n        rIndex = _a[0],\n        cIndex = _a[1];\n    var isData = info.element.classList.contains(rowCell);\n    var isSelectable = isData || e && e.action !== 'enter' && (info.element.classList.contains('e-detailrowcollapse') || info.element.classList.contains('e-detailrowexpand')); // eslint-disable-next-line\n\n    var _b = [Math.min(parseInt(info.element.parentElement.getAttribute(dataRowIndex), 10), rIndex), Math.min(parseInt(info.element.getAttribute(dataColIndex), 10), cIndex)],\n        rowIndex = _b[0],\n        cellIndex = _b[1];\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.enableLazyLoading && isData) {\n      rowIndex = this.parent.getDataRows().indexOf(info.element.parentElement);\n    }\n\n    return {\n      isContent: true,\n      isDataCell: isData,\n      indexes: [rowIndex, cellIndex],\n      isSelectable: isSelectable\n    };\n  };\n\n  ContentFocus.prototype.validator = function () {\n    var table$$1 = this.getTable();\n    return function (rowIndex, cellIndex, action) {\n      if (!isNullOrUndefined(table$$1.rows[rowIndex])) {\n        var cell = void 0;\n        cellIndex = table$$1.querySelector('.e-emptyrow') ? 0 : cellIndex;\n\n        if (table$$1.rows[rowIndex].cells[0].classList.contains('e-editcell')) {\n          cell = table$$1.rows[rowIndex].cells[0].querySelectorAll('td')[cellIndex];\n        } else {\n          cell = table$$1.rows[rowIndex].cells[cellIndex];\n        }\n\n        var isCellWidth = cell.getBoundingClientRect().width !== 0;\n\n        if (action === 'enter' || action === 'shiftEnter') {\n          return isCellWidth && cell.classList.contains(rowCell);\n        }\n\n        if ((action === 'shiftUp' || action === 'shiftDown') && cell.classList.contains(rowCell)) {\n          return isCellWidth;\n        } else if (action !== 'shiftUp' && action !== 'shiftDown') {\n          return isCellWidth;\n        }\n      }\n\n      return false;\n    };\n  };\n\n  ContentFocus.prototype.shouldFocusChange = function (e) {\n    var _a = this.matrix.current,\n        _b = _a[0],\n        rIndex = _b === void 0 ? -1 : _b,\n        _c = _a[1],\n        cIndex = _c === void 0 ? -1 : _c;\n\n    if (rIndex < 0 || cIndex < 0) {\n      return true;\n    }\n\n    var cell = getValue(rIndex + \".cells.\" + cIndex, this.getTable().rows);\n\n    if (!cell) {\n      return true;\n    }\n\n    return e.action === 'enter' || e.action === 'shiftEnter' ? cell.classList.contains(rowCell) && !cell.classList.contains('e-unboundcell') && (!cell.classList.contains('e-templatecell') || cell.classList.contains('e-editedbatchcell')) && !cell.classList.contains('e-detailcell') : true;\n  };\n\n  ContentFocus.prototype.getGridSeletion = function () {\n    return this.parent.allowSelection && this.parent.selectionSettings.allowColumnSelection;\n  };\n\n  return ContentFocus;\n}();\n/**\n * @hidden\n */\n\n\nvar HeaderFocus =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$14(HeaderFocus, _super);\n\n  function HeaderFocus(parent) {\n    return _super.call(this, parent) || this;\n  }\n\n  HeaderFocus.prototype.getTable = function () {\n    return this.parent.isFrozenGrid() ? this.parent.getHeaderContent().querySelector('.e-movableheader .e-table') : this.parent.getHeaderTable();\n  };\n\n  HeaderFocus.prototype.onClick = function (e) {\n    var target = e.target;\n    this.target = target;\n    target = target.classList.contains('e-headercell') ? target : closest(target, 'th');\n\n    if (!target && this.parent.frozenRows !== 0) {\n      target = e.target.classList.contains(rowCell) ? e.target : closest(e.target, 'td');\n    }\n\n    if (e.target.classList.contains('e-columnheader') || e.target.querySelector('.e-stackedheadercell')) {\n      return false;\n    }\n\n    if (!target) {\n      return;\n    }\n\n    var _a = [target.parentElement.rowIndex, target.cellIndex],\n        rowIndex = _a[0],\n        cellIndex = _a[1];\n    var val = getValue(rowIndex + \".\" + cellIndex, this.matrix.matrix);\n\n    if (this.matrix.inValid(val)) {\n      return false;\n    }\n\n    this.matrix.select(target.parentElement.rowIndex, target.cellIndex);\n  };\n\n  HeaderFocus.prototype.getFocusInfo = function () {\n    var info = {};\n    var _a = this.matrix.current,\n        _b = _a[0],\n        rowIndex = _b === void 0 ? 0 : _b,\n        _c = _a[1],\n        cellIndex = _c === void 0 ? 0 : _c;\n    info.element = this.getTable().rows[rowIndex].cells[cellIndex];\n\n    if (!isNullOrUndefined(info.element)) {\n      info.elementToFocus = this.getFocusable(info.element);\n      info.outline = !info.element.classList.contains('e-filterbarcell');\n    }\n\n    return info;\n  };\n\n  HeaderFocus.prototype.selector = function (row$$1, cell) {\n    return cell.visible && (cell.column.field !== undefined || cell.isTemplate || !isNullOrUndefined(cell.column.template)) || cell.column.type === 'checkbox' || cell.cellType === CellType.StackedHeader;\n  };\n\n  HeaderFocus.prototype.jump = function (action, current) {\n    var frozenSwap = this.parent.getFrozenLeftCount() && (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') && (current[1] === 0 || current[1] === this.matrix.matrix[current[0]].indexOf(1)) || this.parent.getFrozenMode() === 'Left' && action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n    var right = (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') && (current[1] === this.matrix.columns || current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) || current[0] > 0 && action === 'shiftTab' && this.parent.getFrozenMode() === 'Right' && current[1] === this.matrix.matrix[current[0]].indexOf(1);\n    var frSwap = this.parent.getFrozenMode() === leftRight && right;\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frozenSwap = right;\n    }\n\n    var enterFrozen = this.parent.frozenRows !== 0 && action === 'enter';\n    var isLastCell;\n    var lastRow;\n    var headerSwap = frozenSwap && !(this.parent.getFrozenMode() === 'Left' && action === 'tab' && current[0] === this.matrix.matrix.length - 1) || frSwap;\n    var fMatrix = this.parent.focusModule.fHeader && this.parent.focusModule.fHeader.matrix.matrix;\n    var isPresent = fMatrix && !isNullOrUndefined(fMatrix[current[0]]);\n\n    if (this.parent.enableHeaderFocus && action === 'tab') {\n      lastRow = this.matrix.matrix.length - 1 === current[0];\n      isLastCell = current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n\n      if (isLastCell) {\n        if (!lastRow) {\n          this.matrix.current[0] = this.matrix.current[0] + 1;\n        } else {\n          this.matrix.current[0] = 0;\n        }\n\n        this.matrix.current[1] = -1;\n      }\n\n      if (this.parent.isFrozenGrid() && lastRow && isLastCell) {\n        frozenSwap = true;\n        headerSwap = false;\n      }\n    }\n\n    if (action === 'tab' && this.parent.getFrozenMode() === 'Left' && current[0] === this.matrix.matrix.length - 1 && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) {\n      this.matrix.current[0] = -1;\n    }\n\n    return {\n      swap: (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1 || isPresent && (frozenSwap || frSwap) || action === 'tab' && lastRow && isLastCell,\n      toHeader: headerSwap,\n      toFrozen: frozenSwap,\n      toFrozenRight: frSwap\n    };\n  };\n\n  HeaderFocus.prototype.getNextCurrent = function (previous, swap, active, action) {\n    if (previous === void 0) {\n      previous = [];\n    }\n\n    var current1 = [];\n\n    if (this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenMode() === leftRight) {\n      if (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') {\n        current1[0] = previous[0];\n        current1[1] = this.matrix.matrix[current1[0]].length;\n      }\n\n      if (this.parent.getFrozenMode() === leftRight && (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab')) {\n        current1[0] = previous[0];\n        current1[1] = -1;\n      }\n    } else if (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') {\n      current1[0] = previous[0];\n      current1[1] = -1;\n    }\n\n    if (action === 'upArrow' || action === 'shiftEnter') {\n      current1[0] = this.matrix.matrix.length;\n      current1[1] = previous[1];\n    }\n\n    if (this.parent.getFrozenMode() === 'Left' && action === 'shiftTab') {\n      current1[0] = previous[0] === -1 ? this.matrix.matrix.length - 1 : previous[0] - 1;\n      current1[1] = this.matrix.matrix[current1[0]].length;\n    }\n\n    if (this.parent.getFrozenMode() === 'Right' && action === 'tab') {\n      current1[0] = previous[0] + 1;\n      current1[1] = -1;\n    }\n\n    return current1;\n  };\n\n  HeaderFocus.prototype.generateRows = function (rows) {\n    var length = this.matrix.matrix.length;\n\n    if (this.parent.allowFiltering && this.parent.filterSettings.type === 'FilterBar') {\n      this.matrix.rows = ++this.matrix.rows;\n      var cells = rows[0].cells;\n      var incrementNumber = 0;\n      var headerTable = this.getHeaderType() === 'FixedHeaderFocus' && this.parent.getFrozenMode() !== 'Right' ? frozenLeft : this.getHeaderType() === 'FixedHeaderFocus' || this.getHeaderType() === 'FixedRightHeaderFocus' ? frozenRight : 'movable';\n\n      for (var i = 0; i < cells.length; i++) {\n        if (cells[i].column && cells[i].column.columns) {\n          incrementNumber = this.checkFilterColumn(cells[i].column.columns, length, incrementNumber, headerTable);\n        } else {\n          if (!this.parent.isFrozenGrid() || this.parent.isFrozenGrid() && cells[i].column.freezeTable === headerTable) {\n            this.matrix.set(length, incrementNumber, cells[i].visible && cells[i].column.allowFiltering !== false);\n            incrementNumber++;\n          }\n        }\n      }\n    }\n  };\n\n  HeaderFocus.prototype.checkFilterColumn = function (rowColumns, rowIndex, columnIndex, headerTable) {\n    var columns = rowColumns;\n    var incrementNumber = columnIndex;\n\n    for (var i = 0; i < columns.length; i++) {\n      if (columns[i].columns) {\n        incrementNumber = this.checkFilterColumn(columns[i].columns, rowIndex, incrementNumber, headerTable);\n      } else {\n        if (!this.parent.isFrozenGrid() || this.parent.isFrozenGrid() && columns[i].freezeTable === headerTable) {\n          this.matrix.set(rowIndex, incrementNumber, columns[i].visible && columns[i].allowFiltering !== false);\n          incrementNumber++;\n        }\n      }\n    }\n\n    return incrementNumber;\n  };\n\n  HeaderFocus.prototype.getInfo = function (e) {\n    return extend(_super.prototype.getInfo.call(this, e), {\n      isContent: false,\n      isHeader: true\n    });\n  };\n\n  HeaderFocus.prototype.validator = function () {\n    return function () {\n      return true;\n    };\n  };\n\n  HeaderFocus.prototype.shouldFocusChange = function (e) {\n    var _a = this.matrix.current,\n        rowIndex = _a[0],\n        columnIndex = _a[1];\n\n    if (rowIndex < 0 || columnIndex < 0) {\n      return true;\n    }\n\n    var cell = getValue(rowIndex + \".cells.\" + columnIndex, this.getTable().rows);\n\n    if (!cell) {\n      return true;\n    }\n\n    return e.action === 'enter' || e.action === 'altDownArrow' ? !cell.classList.contains('e-headercell') : true;\n  };\n\n  HeaderFocus.prototype.getHeaderType = function () {\n    return 'HeaderFocus';\n  };\n\n  return HeaderFocus;\n}(ContentFocus);\n\nvar FixedContentFocus =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$14(FixedContentFocus, _super);\n\n  function FixedContentFocus() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FixedContentFocus.prototype.getTable = function () {\n    return this.parent.getContent().querySelector('.e-frozencontent .e-table');\n  };\n\n  FixedContentFocus.prototype.jump = function (action, current) {\n    var enterFrozen = this.parent.frozenRows !== 0 && action === 'shiftEnter';\n    var toHeader = (action === 'upArrow' || enterFrozen) && current[0] === 0 || action === 'shiftTab' && this.parent.getFrozenMode() !== 'Right' && current[0] === 0 && current[1] === this.matrix.matrix[current[0]].indexOf(1);\n    var fSwap = (action === 'upArrow' || enterFrozen) && current[0] === 0;\n    var frSwap = action === 'shiftTab' && this.parent.getFrozenMode() === leftRight && current[1] === this.matrix.matrix[current[0]].indexOf(1);\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      var swap = toHeader || (action === 'shiftTab' || action === 'leftArrow') && current[1] === 0 || action === 'tab' && current[0] < this.matrix.matrix.length - 1 && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n      return {\n        swap: swap,\n        toHeader: toHeader,\n        toFrozen: fSwap\n      };\n    }\n\n    if (action === 'shiftTab' && current[0] === 0 && current[1] === this.matrix.matrix[current[0]].indexOf(1)) {\n      this.matrix.current[0] = -1;\n    }\n\n    return {\n      swap: toHeader || (action === 'tab' || action === 'rightArrow') && current[1] === this.matrix.columns || action === 'shiftTab' && current[1] === this.matrix.matrix[current[0]].indexOf(1),\n      toHeader: toHeader,\n      toFrozen: fSwap,\n      toFrozenRight: frSwap\n    };\n  };\n\n  FixedContentFocus.prototype.getNextCurrent = function (previous, swap, active, action) {\n    if (previous === void 0) {\n      previous = [];\n    }\n\n    var current2 = [];\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      if (action === 'rightArrow' || action === 'tab') {\n        current2[0] = previous[0];\n        current2[1] = -1;\n      }\n\n      if (action === 'shiftTab') {\n        current2[0] = previous[0] - 1;\n        current2[1] = this.matrix.matrix[current2[0]].length;\n      }\n    } else {\n      if (action === 'tab' && this.parent.enableHeaderFocus) {\n        current2[0] = previous[0];\n        current2[1] = -1;\n      }\n\n      if (action === 'leftArrow' || action === 'shiftTab') {\n        current2[0] = previous[0];\n        current2[1] = active.matrix.columns + 1;\n      }\n    }\n\n    if (action === 'downArrow' || action === 'enter') {\n      current2[0] = -1;\n      current2[1] = previous[1];\n    }\n\n    if (action === 'tab' && this.parent.getFrozenMode() !== 'Right') {\n      current2[0] = previous[0] + 1;\n      current2[1] = -1;\n    }\n\n    return current2;\n  };\n\n  return FixedContentFocus;\n}(ContentFocus);\n\nvar FixedHeaderFocus =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$14(FixedHeaderFocus, _super);\n\n  function FixedHeaderFocus() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FixedHeaderFocus.prototype.jump = function (action, current) {\n    var enterFrozen = this.parent.frozenRows !== 0 && action === 'enter';\n    var hMatrix = this.parent.focusModule.header && this.parent.focusModule.header.matrix.matrix;\n    var isPresent = hMatrix && !isNullOrUndefined(hMatrix[current[0]]);\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      var frSwap_1 = (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') && (current[1] === 0 || current[1] === this.matrix.matrix[current[0]].indexOf(1)) || current[0] < this.matrix.matrix.length - 1 && action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n      var swap = (action === 'downArrow' || enterFrozen || action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) && current[0] === this.matrix.matrix.length - 1 || isPresent && frSwap_1;\n      var toFrozen = (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1;\n\n      if (action === 'tab' && current[0] === this.matrix.matrix.length - 1 && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) {\n        this.matrix.current[0] = -1;\n      }\n\n      return {\n        swap: swap,\n        toHeader: frSwap_1,\n        toFrozen: toFrozen\n      };\n    }\n\n    var frSwap = current[0] > 0 && action === 'shiftTab' && this.parent.getFrozenMode() === leftRight && current[1] === this.matrix.matrix[current[0]].indexOf(1);\n    return {\n      swap: (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1 || (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') && (current[1] === this.matrix.columns || current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) && isPresent || action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1) || action === 'shiftTab' && current[1] === this.matrix.matrix[current[0]].indexOf(1) && current[0] > 0,\n      toHeader: (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') && (current[1] === this.matrix.columns || current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) || action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1) || action === 'shiftTab' && current[1] === this.matrix.matrix[current[0]].indexOf(1) && current[0] > 0,\n      toFrozen: (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1,\n      toFrozenRight: frSwap\n    };\n  };\n\n  FixedHeaderFocus.prototype.getTable = function () {\n    return this.parent.getHeaderContent().querySelector('.e-frozenheader .e-table');\n  };\n\n  FixedHeaderFocus.prototype.getNextCurrent = function (previous, swap, active, action) {\n    if (previous === void 0) {\n      previous = [];\n    }\n\n    var current3 = [];\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      if (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') {\n        current3[0] = previous[0];\n        current3[1] = -1;\n      }\n\n      if (action === 'shiftTab') {\n        current3[0] = previous[0] === -1 ? this.matrix.matrix.length - 1 : previous[0] - 1;\n        current3[1] = this.matrix.matrix[current3[0]].length;\n      }\n    } else {\n      if (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') {\n        current3[0] = previous[0];\n        current3[1] = this.matrix.matrix[current3[0]].length;\n      }\n    }\n\n    if (action === 'upArrow' || action === 'shiftEnter') {\n      current3[0] = this.matrix.matrix.length;\n      current3[1] = previous[1];\n    }\n\n    if (action === 'tab' && this.parent.getFrozenMode() !== 'Right') {\n      current3[0] = previous[0] + 1;\n      current3[1] = -1;\n    }\n\n    return current3;\n  };\n\n  FixedHeaderFocus.prototype.getHeaderType = function () {\n    return 'FixedHeaderFocus';\n  };\n\n  return FixedHeaderFocus;\n}(HeaderFocus);\n/** @hidden */\n\n\nvar SearchBox =\n/** @__PURE__ @class */\nfunction () {\n  function SearchBox(searchBox) {\n    this.searchBox = searchBox;\n  }\n\n  SearchBox.prototype.searchFocus = function (args) {\n    args.target.parentElement.classList.add('e-input-focus');\n\n    if (args.target.classList.contains('e-input') && args.target.classList.contains('e-search') && args.target.value) {\n      args.target.parentElement.querySelector('.e-clear-icon').classList.remove('e-clear-icon-hide');\n    }\n  };\n\n  SearchBox.prototype.searchBlur = function (args) {\n    args.target.parentElement.classList.remove('e-input-focus');\n\n    if (args.target.classList.contains('e-search') && args.relatedTarget && !args.relatedTarget.classList.contains('e-sicon e-clear-icon') && !args.relatedTarget.classList.contains('e-sicon')) {\n      args.target.parentElement.querySelector('.e-clear-icon').classList.add('e-clear-icon-hide');\n    }\n  };\n\n  SearchBox.prototype.wireEvent = function () {\n    if (this.searchBox) {\n      EventHandler.add(this.searchBox, 'focus', this.searchFocus, this);\n      EventHandler.add(this.searchBox, 'blur', this.searchBlur, this);\n    }\n  };\n\n  SearchBox.prototype.unWireEvent = function () {\n    if (this.searchBox) {\n      EventHandler.remove(this.searchBox, 'focus', this.searchFocus);\n      EventHandler.remove(this.searchBox, 'blur', this.searchBlur);\n    }\n  };\n\n  return SearchBox;\n}();\n\nvar FixedRightContentFocus =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$14(FixedRightContentFocus, _super);\n\n  function FixedRightContentFocus() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FixedRightContentFocus.prototype.getTable = function () {\n    return this.parent.getContent().querySelector('.e-frozen-right-content .e-table');\n  };\n\n  FixedRightContentFocus.prototype.jump = function (action, current) {\n    var enterFrozen = this.parent.frozenRows !== 0 && action === 'shiftEnter';\n    var toHeader = (action === 'upArrow' || enterFrozen) && current[0] === 0;\n    var toFrozenSwap = this.parent.getFrozenMode() === leftRight && action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n    return {\n      swap: toHeader || (action === 'shiftTab' || action === 'leftArrow') && current[1] === 0 || action === 'tab' && current[0] < this.matrix.matrix.length - 1 && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1),\n      toHeader: toHeader,\n      toFrozenRight: toHeader,\n      toFrozen: toFrozenSwap\n    };\n  };\n\n  FixedRightContentFocus.prototype.getNextCurrent = function (previous, swap, active, action) {\n    if (previous === void 0) {\n      previous = [];\n    }\n\n    var current2 = [];\n\n    if (action === 'rightArrow' || action === 'tab') {\n      current2[0] = previous[0];\n      current2[1] = -1;\n    }\n\n    if (action === 'downArrow' || action === 'enter') {\n      current2[0] = -1;\n      current2[1] = previous[1];\n    }\n\n    if (action === 'shiftTab') {\n      current2[0] = previous[0] - 1;\n      current2[1] = this.matrix.matrix[current2[0]].length;\n    }\n\n    return current2;\n  };\n\n  return FixedRightContentFocus;\n}(ContentFocus);\n\nvar FixedRightHeaderFocus =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$14(FixedRightHeaderFocus, _super);\n\n  function FixedRightHeaderFocus() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FixedRightHeaderFocus.prototype.jump = function (action, current) {\n    var headerMat = this.parent.focusModule.header && this.parent.focusModule.header.matrix.matrix;\n    var isPresent = headerMat && !isNullOrUndefined(headerMat[current[0]]);\n    var enterFrozen = this.parent.frozenRows !== 0 && action === 'enter';\n    var frozenSwap = (action === 'leftArrow' || action === 'shiftLeft' && this.getGridSeletion() || action === 'shiftTab') && (current[1] === 0 || current[1] === this.matrix.matrix[current[0]].indexOf(1)) || current[0] < this.matrix.matrix.length - 1 && action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n    var swap = (action === 'downArrow' || enterFrozen || action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) && current[0] === this.matrix.matrix.length - 1 || isPresent && frozenSwap;\n    var fSwap = action === 'tab' && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1);\n    var frSwap = (action === 'downArrow' || enterFrozen) && current[0] === this.matrix.matrix.length - 1;\n\n    if (action === 'tab' && current[0] === this.matrix.matrix.length - 1 && current[1] === this.matrix.matrix[current[0]].lastIndexOf(1)) {\n      this.matrix.current[0] = -1;\n    }\n\n    return {\n      swap: swap,\n      toHeader: frozenSwap,\n      toFrozen: fSwap,\n      toFrozenRight: frSwap\n    };\n  };\n\n  FixedRightHeaderFocus.prototype.getTable = function () {\n    return this.parent.getHeaderContent().querySelector('.e-frozen-right-header .e-table');\n  };\n\n  FixedRightHeaderFocus.prototype.getNextCurrent = function (previous, swap, active, action) {\n    if (previous === void 0) {\n      previous = [];\n    }\n\n    var current3 = [];\n\n    if (action === 'rightArrow' || action === 'shiftRight' && this.getGridSeletion() || action === 'tab') {\n      current3[0] = previous[0];\n      current3[1] = -1;\n    }\n\n    if (action === 'upArrow' || action === 'shiftEnter') {\n      current3[0] = this.matrix.matrix.length;\n      current3[1] = previous[1];\n    }\n\n    if (action === 'shiftTab') {\n      current3[0] = previous[0] === -1 ? this.matrix.matrix.length - 1 : previous[0] - 1;\n      current3[1] = this.matrix.matrix[current3[0]].length;\n    }\n\n    return current3;\n  };\n\n  FixedRightHeaderFocus.prototype.getHeaderType = function () {\n    return 'FixedRightHeaderFocus';\n  };\n\n  return FixedRightHeaderFocus;\n}(HeaderFocus);\n\nvar __extends$15 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Configures the paging behavior of the Grid.\n */\n\n\nvar PageSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$15(PageSettings, _super);\n\n  function PageSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$2([Property(12)], PageSettings.prototype, \"pageSize\", void 0);\n\n  __decorate$2([Property(8)], PageSettings.prototype, \"pageCount\", void 0);\n\n  __decorate$2([Property(1)], PageSettings.prototype, \"currentPage\", void 0);\n\n  __decorate$2([Property()], PageSettings.prototype, \"totalRecordsCount\", void 0);\n\n  __decorate$2([Property(false)], PageSettings.prototype, \"enableQueryString\", void 0);\n\n  __decorate$2([Property(false)], PageSettings.prototype, \"pageSizes\", void 0);\n\n  __decorate$2([Property(null)], PageSettings.prototype, \"template\", void 0);\n\n  return PageSettings;\n}(ChildProperty);\n\nvar __extends$16 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Configures the column chooser behavior of the Grid.\n */\n\n\nvar ColumnChooserSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$16(ColumnChooserSettings, _super);\n\n  function ColumnChooserSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$3([Property('startsWith')], ColumnChooserSettings.prototype, \"operator\", void 0);\n\n  __decorate$3([Property(false)], ColumnChooserSettings.prototype, \"ignoreAccent\", void 0);\n\n  return ColumnChooserSettings;\n}(ChildProperty);\n\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/**\n * The `Selection` module is used to handle cell and row selection.\n */\n\n\nvar Selection =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid selection module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {SelectionSettings} selectionSettings - specifies the selectionsettings\n   * @param {ServiceLocator} locator - specifies the ServiceLocator\n   * @hidden\n   */\n  function Selection(parent, selectionSettings, locator) {\n    //Internal letiables\n\n    /**\n     * @hidden\n     */\n    this.selectedRowIndexes = [];\n    /**\n     * @hidden\n     */\n\n    this.selectedRowCellIndexes = [];\n    /**\n     * @hidden\n     */\n\n    this.selectedRecords = [];\n    /**\n     * @hidden\n     */\n\n    this.preventFocus = false;\n    /**\n     *  @hidden\n     */\n\n    this.selectedColumnsIndexes = [];\n    this.checkBoxState = false;\n    this.isMultiShiftRequest = false;\n    this.isMultiCtrlRequest = false;\n    this.enableSelectMultiTouch = false;\n    this.clearRowCheck = false;\n    this.selectRowCheck = false;\n    this.selectedRowState = {};\n    this.unSelectedRowState = {};\n    this.totalRecordsCount = 0;\n    this.chkAllCollec = [];\n    this.isCheckedOnAdd = false;\n    this.persistSelectedData = [];\n    this.deSelectedData = [];\n    this.isHdrSelectAllClicked = false;\n    this.needColumnSelection = false;\n    this.isCancelDeSelect = false;\n    this.isPreventCellSelect = false;\n    this.disableUI = false;\n    this.isPersisted = false;\n    this.cmdKeyPressed = false;\n    this.cellselected = false;\n    this.isMultiSelection = false;\n    this.isAddRowsToSelection = false;\n    this.initialRowSelection = false;\n    this.isPrevRowSelection = false;\n    this.isKeyAction = false;\n    this.isRowDragSelected = false;\n    this.isPartialSelection = false;\n    this.rmtHdrChkbxClicked = false;\n    /**\n     * @hidden\n     */\n\n    this.autoFillRLselection = true;\n    this.bottom = '0 0 2px 0';\n    this.top = '2px 0 0 0';\n    /* eslint-disable */\n\n    this.right_bottom = '0 2px 2px 0';\n    this.bottom_left = '0 0 2px 2px';\n    this.top_right = '2px 2px 0 0';\n    this.top_left = '2px 0 0 2px';\n    this.top_bottom = '2px 0 2px 0';\n    this.top_right_bottom = '2px 2px 2px 0';\n    this.top_bottom_left = '2px 0 2px 2px';\n    this.top_right_left = '2px 2px 0 2px';\n    this.right_bottom_left = '0 2px 2px 2px';\n    this.all_border = '2px';\n    this.parent = parent;\n    this.selectionSettings = selectionSettings;\n    this.factory = locator.getService('rendererFactory');\n    this.focus = locator.getService('focus');\n    this.addEventListener();\n    this.wireEvents();\n  }\n\n  Selection.prototype.initializeSelection = function () {\n    this.parent.log('selection_key_missing');\n    this.render();\n  };\n  /**\n   * The function used to trigger onActionBegin\n   *\n   * @param {Object} args - specifies the args\n   * @param {string} type - specifies the type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.onActionBegin = function (args, type) {\n    this.parent.trigger(type, this.fDataUpdate(args));\n  };\n\n  Selection.prototype.fDataUpdate = function (args) {\n    if (!this.isMultiSelection && (!isNullOrUndefined(args.cellIndex) || !isNullOrUndefined(args.rowIndex))) {\n      var rowObj = this.getRowObj(isNullOrUndefined(args.rowIndex) ? isNullOrUndefined(args.cellIndex) ? this.currentIndex : args.cellIndex.rowIndex : args.rowIndex);\n      args.foreignKeyData = rowObj.foreignKeyData;\n    }\n\n    return args;\n  };\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {Object} args - specifies the args\n   * @param {string} type - specifies the type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.onActionComplete = function (args, type) {\n    this.parent.trigger(type, this.fDataUpdate(args));\n    this.isMultiSelection = false;\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Selection.prototype.getModuleName = function () {\n    return 'selection';\n  };\n  /**\n   * To destroy the selection\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.hidePopUp();\n    this.clearSelection();\n    this.removeEventListener();\n    this.unWireEvents();\n    EventHandler.remove(this.parent.getContent(), 'mousedown', this.mouseDownHandler);\n    EventHandler.remove(this.parent.getHeaderContent(), 'mousedown', this.mouseDownHandler);\n  };\n\n  Selection.prototype.isEditing = function () {\n    return (this.parent.editSettings.mode === 'Normal' || this.parent.editSettings.mode === 'Batch' && this.parent.editModule && this.parent.editModule.formObj && !this.parent.editModule.formObj.validate()) && this.parent.isEdit && !this.parent.isPersistSelection;\n  };\n\n  Selection.prototype.getSelectedMovableRow = function (index) {\n    var gObj = this.parent;\n\n    if (gObj.isFrozenGrid() && this.parent.getContent().querySelector('.' + movableContent)) {\n      return gObj.getMovableRowByIndex(index);\n    }\n\n    return null;\n  };\n\n  Selection.prototype.getSelectedFrozenRightRow = function (index) {\n    var gObj = this.parent;\n\n    if (gObj.isFrozenGrid() && gObj.getFrozenMode() === leftRight && gObj.getFrozenRightContent()) {\n      return gObj.getFrozenRightRowByIndex(index);\n    }\n\n    return null;\n  };\n\n  Selection.prototype.getCurrentBatchRecordChanges = function () {\n    var gObj = this.parent;\n\n    if (gObj.editSettings.mode === 'Batch' && gObj.editModule) {\n      var currentRecords = iterateExtend(this.parent.getCurrentViewRecords());\n      currentRecords = gObj.editSettings.newRowPosition === 'Bottom' ? currentRecords.concat(this.parent.editModule.getBatchChanges()[addedRecords]) : this.parent.editModule.getBatchChanges()[addedRecords].concat(currentRecords);\n      var deletedRecords$$1 = this.parent.editModule.getBatchChanges()[deletedRecords];\n      var primaryKey = this.parent.getPrimaryKeyFieldNames()[0];\n\n      for (var i = 0; i < deletedRecords$$1.length; i++) {\n        for (var j = 0; j < currentRecords.length; j++) {\n          if (deletedRecords$$1[i][primaryKey] === currentRecords[j][primaryKey]) {\n            currentRecords.splice(j, 1);\n            break;\n          }\n        }\n      }\n\n      return currentRecords;\n    } else {\n      return gObj.getCurrentViewRecords();\n    }\n  };\n  /**\n   * Selects a row by the given index.\n   *\n   * @param  {number} index - Defines the row index.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectRow = function (index, isToggle) {\n    if (this.selectedRowIndexes.length && this.selectionSettings.enableSimpleMultiRowSelection) {\n      this.addRowsToSelection([index]);\n      return;\n    }\n\n    var gObj = this.parent;\n    var selectedRow = gObj.getRowByIndex(index);\n    var rowObj = selectedRow && gObj.getRowObjectFromUID(selectedRow.getAttribute('data-uid'));\n\n    if (this.isPartialSelection && rowObj && rowObj.isDataRow && !rowObj.isSelectable) {\n      return;\n    }\n\n    var selectedMovableRow = this.getSelectedMovableRow(index);\n    var selectedFrozenRightRow = this.getSelectedFrozenRightRow(index);\n    var selectData;\n    var isRemoved = false;\n\n    if (gObj.enableVirtualization && index > -1) {\n      var e = {\n        selectedIndex: index,\n        isAvailable: true\n      };\n      this.parent.notify(selectVirtualRow, e);\n      var frozenData = gObj.isFrozenGrid() ? gObj.contentModule.getRowObjectByIndex(index) : null;\n\n      if (selectedRow && (gObj.getRowObjectFromUID(selectedRow.getAttribute('data-uid')) || frozenData)) {\n        selectData = frozenData ? frozenData : gObj.getRowObjectFromUID(selectedRow.getAttribute('data-uid')).data;\n      } else {\n        if (e.isAvailable && !gObj.selectionSettings.persistSelection) {\n          var prevSelectedData = this.parent.getSelectedRecords();\n\n          if (prevSelectedData.length > 0) {\n            this.clearRowSelection();\n          }\n        }\n\n        return;\n      }\n    } else {\n      selectData = this.getRowObj(index).data;\n    }\n\n    if (!this.isRowType() || !selectedRow || this.isEditing()) {\n      // if (this.isEditing()) {\n      //     gObj.selectedRowIndex = index;\n      // }\n      return;\n    }\n\n    var isRowSelected = selectedRow.hasAttribute('aria-selected');\n    this.activeTarget();\n    isToggle = !isToggle ? isToggle : !this.selectedRowIndexes.length ? false : this.selectedRowIndexes.length === 1 ? this.isKeyAction && this.parent.isCheckBoxSelection ? false : index === this.selectedRowIndexes[0] : false;\n    this.isKeyAction = false;\n    var args;\n    var can = 'cancel';\n\n    if (!isToggle) {\n      args = {\n        data: selectData,\n        rowIndex: index,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest,\n        row: selectedRow,\n        previousRow: gObj.getRowByIndex(this.prevRowIndex),\n        previousRowIndex: this.prevRowIndex,\n        target: this.actualTarget,\n        cancel: false,\n        isInteracted: this.isInteracted,\n        isHeaderCheckboxClicked: this.isHeaderCheckboxClicked\n      };\n      args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n      this.parent.trigger(rowSelecting, this.fDataUpdate(args), this.rowSelectingCallBack(args, isToggle, index, selectData, isRemoved, isRowSelected, can));\n    } else {\n      this.rowSelectingCallBack(args, isToggle, index, selectData, isRemoved, isRowSelected, can)(args);\n    }\n  };\n\n  Selection.prototype.rowSelectingCallBack = function (args, isToggle, index, selectData, isRemoved, isRowSelected, can) {\n    var _this = this;\n\n    return function (args) {\n      if (!isNullOrUndefined(args) && args[can] === true) {\n        _this.disableInteracted();\n\n        return;\n      }\n\n      _this.index = index;\n      _this.toggle = isToggle;\n      _this.data = selectData;\n      _this.removed = isRemoved;\n\n      if (isRowSelected && _this.selectionSettings.persistSelection && !(_this.selectionSettings.checkboxMode === 'ResetOnRowClick')) {\n        _this.clearSelectedRow(index);\n\n        _this.selectRowCallBack();\n      } else if (!isRowSelected && _this.selectionSettings.persistSelection && _this.selectionSettings.checkboxMode !== 'ResetOnRowClick') {\n        _this.selectRowCallBack();\n      }\n\n      if (_this.selectionSettings.checkboxMode === 'ResetOnRowClick') {\n        _this.clearSelection();\n      }\n\n      if (!_this.selectionSettings.persistSelection || _this.selectionSettings.checkboxMode === 'ResetOnRowClick' || !_this.parent.isCheckBoxSelection && _this.selectionSettings.persistSelection) {\n        _this.selectRowCheck = true;\n\n        _this.clearRow();\n      }\n    };\n  };\n\n  Selection.prototype.selectRowCallBack = function () {\n    var gObj = this.parent;\n    var args;\n    var index = this.index;\n    var isToggle = this.toggle;\n    var selectData = this.data;\n    var isRemoved = this.removed;\n    var selectedRow = gObj.getRowByIndex(index);\n    var selectedMovableRow = this.getSelectedMovableRow(index);\n    var selectedFrozenRightRow = this.getSelectedFrozenRightRow(index);\n\n    if (!isToggle && !isRemoved) {\n      if (this.selectedRowIndexes.indexOf(index) <= -1) {\n        this.updateRowSelection(selectedRow, index);\n        this.selectMovableRow(selectedMovableRow, selectedFrozenRightRow, index);\n      }\n\n      this.selectRowIndex(index);\n    }\n\n    if (!isToggle) {\n      args = {\n        data: selectData,\n        rowIndex: index,\n        row: selectedRow,\n        previousRow: gObj.getRowByIndex(this.prevRowIndex),\n        previousRowIndex: this.prevRowIndex,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        isHeaderCheckBoxClicked: this.isHeaderCheckboxClicked\n      };\n      args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n      this.onActionComplete(args, rowSelected);\n    }\n\n    this.isInteracted = false;\n    this.updateRowProps(index);\n  };\n\n  Selection.prototype.selectMovableRow = function (selectedMovableRow, selectedFrozenRightRow, index) {\n    if (this.parent.isFrozenGrid()) {\n      this.updateRowSelection(selectedMovableRow, index);\n\n      if (this.parent.getFrozenMode() === leftRight && selectedFrozenRightRow) {\n        this.updateRowSelection(selectedFrozenRightRow, index);\n      }\n    }\n  };\n\n  Selection.prototype.addMovableArgs = function (targetObj, mRow, frRow) {\n    if (this.parent.isFrozenGrid()) {\n      var mObj = {\n        mRow: mRow,\n        previousMovRow: this.parent.getMovableRows()[this.prevRowIndex]\n      };\n      var frozenRightRow = 'frozenRightRow';\n      var previousFrozenRightRow = 'previousFrozenRightRow';\n\n      if (this.parent.getFrozenMode() === leftRight && frRow) {\n        mObj[frozenRightRow] = frRow;\n        mObj[previousFrozenRightRow] = this.parent.getFrozenRightDataRows()[this.prevRowIndex];\n      }\n\n      targetObj = __assign({}, targetObj, mObj);\n    }\n\n    return targetObj;\n  };\n  /**\n   * Selects a range of rows from start and end row indexes.\n   *\n   * @param  {number} startIndex - Specifies the start row index.\n   * @param  {number} endIndex - Specifies the end row index.\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectRowsByRange = function (startIndex, endIndex) {\n    this.selectRows(this.getCollectionFromIndexes(startIndex, endIndex));\n    this.selectRowIndex(endIndex);\n  };\n\n  Selection.prototype.selectedDataUpdate = function (selectedData, foreignKeyData$$1, selectedRows, rowIndexes, selectableRowIndex) {\n    for (var i = 0, len = rowIndexes.length; i < len; i++) {\n      var currentRow = this.parent.getDataRows()[rowIndexes[i]];\n\n      if (this.parent.enableVirtualization) {\n        currentRow = this.parent.getRowByIndex(rowIndexes[i]);\n      }\n\n      var rowObj = this.getRowObj(currentRow);\n\n      if (rowObj && rowObj.isDataRow && rowObj.isSelectable) {\n        selectedData.push(rowObj.data);\n        selectedRows.push(currentRow);\n        foreignKeyData$$1.push(rowObj.foreignKeyData);\n      } else {\n        if (this.isPartialSelection && selectableRowIndex) {\n          selectableRowIndex.splice(selectableRowIndex.indexOf(rowIndexes[i]), 1);\n        }\n      }\n    }\n  };\n  /**\n   * Selects a collection of rows by index.\n   *\n   * @param  {number[]} rowIndexes - Specifies an array of row indexes.\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectRows = function (rowIndexes) {\n    var _this = this;\n\n    var gObj = this.parent;\n    var selectableRowIndex = rowIndexes.slice();\n    var rowIndex = !this.isSingleSel() ? rowIndexes[0] : rowIndexes[rowIndexes.length - 1];\n    this.isMultiSelection = true;\n    var selectedRows = [];\n    var foreignKeyData$$1 = [];\n    var selectedMovableRow = this.getSelectedMovableRow(rowIndex);\n    var selectedFrozenRightRow = this.getSelectedFrozenRightRow(rowIndex);\n    var can = 'cancel';\n    var selectedData = [];\n\n    if (!this.isRowType() || this.isEditing()) {\n      return;\n    }\n\n    this.selectedDataUpdate(selectedData, foreignKeyData$$1, selectedRows, rowIndexes, selectableRowIndex);\n    this.activeTarget();\n    var args = {\n      cancel: false,\n      rowIndexes: selectableRowIndex,\n      row: selectedRows,\n      rowIndex: rowIndex,\n      target: this.actualTarget,\n      prevRow: gObj.getRows()[this.prevRowIndex],\n      previousRowIndex: this.prevRowIndex,\n      isInteracted: this.isInteracted,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest,\n      data: selectedData,\n      isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n      foreignKeyData: foreignKeyData$$1\n    };\n    args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n    this.parent.trigger(rowSelecting, this.fDataUpdate(args), function (args) {\n      if (!isNullOrUndefined(args) && args[can] === true) {\n        _this.disableInteracted();\n\n        return;\n      }\n\n      _this.clearRow();\n\n      _this.selectRowIndex(selectableRowIndex.slice(-1)[0]);\n\n      var selectRowFn = function (index) {\n        _this.updateRowSelection(gObj.getRowByIndex(index), index);\n\n        if (gObj.isFrozenGrid()) {\n          var rightEle = _this.parent.getFrozenMode() === leftRight ? gObj.getFrozenRightRowByIndex(index) : undefined;\n\n          _this.selectMovableRow(gObj.getMovableRowByIndex(index), rightEle, index);\n        }\n\n        _this.updateRowProps(rowIndex);\n      };\n\n      if (!_this.isSingleSel()) {\n        for (var _i = 0, selectableRowIndex_1 = selectableRowIndex; _i < selectableRowIndex_1.length; _i++) {\n          var rowIdx = selectableRowIndex_1[_i];\n          selectRowFn(rowIdx);\n        }\n      } else {\n        selectRowFn(rowIndex);\n      }\n\n      args = {\n        rowIndexes: selectableRowIndex,\n        row: selectedRows,\n        rowIndex: rowIndex,\n        target: _this.actualTarget,\n        prevRow: gObj.getRows()[_this.prevRowIndex],\n        previousRowIndex: _this.prevRowIndex,\n        data: _this.getSelectedRecords(),\n        isInteracted: _this.isInteracted,\n        isHeaderCheckboxClicked: _this.isHeaderCheckboxClicked,\n        foreignKeyData: foreignKeyData$$1\n      };\n      args = _this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n\n      if (_this.isRowSelected) {\n        _this.onActionComplete(args, rowSelected);\n      }\n\n      _this.isInteracted = false;\n    });\n  };\n  /**\n   * Select rows with existing row selection by passing row indexes.\n   *\n   * @param {number} rowIndexes - Specifies the row indexes.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.addRowsToSelection = function (rowIndexes) {\n    var gObj = this.parent;\n    var can = 'cancel';\n    var target = this.target;\n    this.isMultiSelection = true;\n    var selectedRows = [];\n    var foreignKeyData$$1 = [];\n    var selectedData = [];\n    var indexes = gObj.getSelectedRowIndexes().concat(rowIndexes);\n    var selectedRow = !this.isSingleSel() ? gObj.getRowByIndex(rowIndexes[0]) : gObj.getRowByIndex(rowIndexes[rowIndexes.length - 1]);\n    var selectedMovableRow = !this.isSingleSel() ? this.getSelectedMovableRow(rowIndexes[0]) : this.getSelectedMovableRow(rowIndexes[rowIndexes.length - 1]);\n    var selectedFrozenRightRow = !this.isSingleSel() ? this.getSelectedFrozenRightRow(rowIndexes[0]) : this.getSelectedFrozenRightRow(rowIndexes[rowIndexes.length - 1]);\n\n    if ((!this.isRowType() || this.isEditing()) && !this.selectionSettings.checkboxOnly) {\n      return;\n    }\n\n    var args;\n    var checkboxColumn = this.parent.getColumns().filter(function (col) {\n      return col.type === 'checkbox';\n    });\n\n    if (this.isMultiCtrlRequest && !checkboxColumn.length) {\n      this.selectedDataUpdate(selectedData, foreignKeyData$$1, selectedRows, indexes);\n    }\n\n    for (var _i = 0, rowIndexes_1 = rowIndexes; _i < rowIndexes_1.length; _i++) {\n      var rowIndex = rowIndexes_1[_i];\n      var rowObj = this.getRowObj(rowIndex);\n      var isUnSelected = this.selectedRowIndexes.indexOf(rowIndex) > -1;\n\n      if (this.isPartialSelection && rowObj && rowObj.isDataRow && !rowObj.isSelectable) {\n        continue;\n      }\n\n      this.selectRowIndex(rowIndex);\n\n      if (isUnSelected && ((checkboxColumn.length ? true : this.selectionSettings.enableToggle) || this.isMultiCtrlRequest)) {\n        this.isAddRowsToSelection = true;\n        this.rowDeselect(rowDeselecting, [rowIndex], [rowObj.data], [selectedRow], [rowObj.foreignKeyData], target);\n\n        if (this.isCancelDeSelect) {\n          return;\n        }\n\n        this.selectedRowIndexes.splice(this.selectedRowIndexes.indexOf(rowIndex), 1);\n        this.selectedRecords.splice(this.selectedRecords.indexOf(selectedRow), 1);\n        this.selectRowIndex(this.selectedRowIndexes.length ? this.selectedRowIndexes[this.selectedRowIndexes.length - 1] : -1);\n        selectedRow.removeAttribute('aria-selected');\n        this.addRemoveClassesForRow(selectedRow, false, null, 'e-selectionbackground', 'e-active');\n\n        if (selectedMovableRow) {\n          this.selectedRecords.splice(this.selectedRecords.indexOf(selectedMovableRow), 1);\n          selectedMovableRow.removeAttribute('aria-selected');\n          this.addRemoveClassesForRow(selectedMovableRow, false, null, 'e-selectionbackground', 'e-active');\n        }\n\n        if (selectedFrozenRightRow) {\n          this.selectedRecords.splice(this.selectedRecords.indexOf(selectedFrozenRightRow), 1);\n          selectedFrozenRightRow.removeAttribute('aria-selected');\n          this.addRemoveClassesForRow(selectedFrozenRightRow, false, null, 'e-selectionbackground', 'e-active');\n        }\n\n        this.rowDeselect(rowDeselected, [rowIndex], [rowObj.data], [selectedRow], [rowObj.foreignKeyData], target, [selectedMovableRow], undefined, [selectedFrozenRightRow]);\n        this.isInteracted = false;\n        this.isMultiSelection = false;\n        this.isAddRowsToSelection = false;\n        this.isHdrSelectAllClicked = false;\n      } else {\n        this.activeTarget();\n        args = {\n          cancel: false,\n          data: selectedData.length ? selectedData : rowObj.data,\n          rowIndex: rowIndex,\n          row: selectedRows.length ? selectedRows : selectedRow,\n          target: this.actualTarget,\n          prevRow: gObj.getRows()[this.prevRowIndex],\n          previousRowIndex: this.prevRowIndex,\n          isCtrlPressed: this.isMultiCtrlRequest,\n          isShiftPressed: this.isMultiShiftRequest,\n          foreignKeyData: foreignKeyData$$1.length ? foreignKeyData$$1 : rowObj.foreignKeyData,\n          isInteracted: this.isInteracted,\n          isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n          rowIndexes: indexes\n        };\n        args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n        this.parent.trigger(rowSelecting, this.fDataUpdate(args));\n\n        if (!isNullOrUndefined(args) && args[can] === true) {\n          this.disableInteracted();\n          return;\n        }\n\n        if (this.isSingleSel()) {\n          this.clearRow();\n        }\n\n        this.updateRowSelection(selectedRow, rowIndex);\n        this.selectMovableRow(selectedMovableRow, selectedFrozenRightRow, rowIndex);\n      }\n\n      if (!isUnSelected) {\n        args = {\n          data: selectedData.length ? selectedData : rowObj.data,\n          rowIndex: rowIndex,\n          row: selectedRows.length ? selectedRows : selectedRow,\n          target: this.actualTarget,\n          prevRow: gObj.getRows()[this.prevRowIndex],\n          previousRowIndex: this.prevRowIndex,\n          foreignKeyData: foreignKeyData$$1.length ? foreignKeyData$$1 : rowObj.foreignKeyData,\n          isInteracted: this.isInteracted,\n          isHeaderCheckboxClicked: this.isHeaderCheckboxClicked,\n          rowIndexes: indexes\n        };\n        args = this.addMovableArgs(args, selectedMovableRow, selectedFrozenRightRow);\n        this.onActionComplete(args, rowSelected);\n      }\n\n      this.isInteracted = false;\n      this.updateRowProps(rowIndex);\n\n      if (this.isSingleSel()) {\n        break;\n      }\n    }\n  };\n\n  Selection.prototype.getCollectionFromIndexes = function (startIndex, endIndex) {\n    var indexes = []; // eslint-disable-next-line prefer-const\n\n    var _a = startIndex <= endIndex ? {\n      i: startIndex,\n      max: endIndex\n    } : {\n      i: endIndex,\n      max: startIndex\n    },\n        i = _a.i,\n        max = _a.max;\n\n    for (; i <= max; i++) {\n      indexes.push(i);\n    }\n\n    if (startIndex > endIndex) {\n      indexes.reverse();\n    }\n\n    return indexes;\n  };\n\n  Selection.prototype.clearRow = function () {\n    this.clearRowCheck = true;\n    this.clearRowSelection();\n  };\n\n  Selection.prototype.clearRowCallBack = function () {\n    if (this.isCancelDeSelect && this.parent.checkAllRows !== 'Check') {\n      return;\n    }\n\n    this.selectedRowIndexes = [];\n    this.selectedRecords = [];\n    this.selectRowIndex(-1);\n\n    if (this.isSingleSel() && this.parent.isPersistSelection) {\n      this.selectedRowState = {};\n    }\n  };\n\n  Selection.prototype.clearSelectedRow = function (index) {\n    if (this.toggle) {\n      var selectedEle = this.parent.getRowByIndex(index);\n\n      if (!this.disableUI) {\n        selectedEle.removeAttribute('aria-selected');\n        this.addRemoveClassesForRow(selectedEle, false, true, 'e-selectionbackground', 'e-active');\n      }\n\n      this.removed = true;\n      this.updatePersistCollection(selectedEle, false);\n      this.updateCheckBoxes(selectedEle);\n      this.selectedRowIndexes.splice(this.selectedRowIndexes.indexOf(index), 1);\n      this.selectedRecords.splice(this.selectedRecords.indexOf(this.parent.getRowByIndex(index)), 1);\n    }\n  };\n\n  Selection.prototype.updateRowProps = function (startIndex) {\n    this.prevRowIndex = startIndex;\n    this.isRowSelected = this.selectedRowIndexes.length && true;\n  };\n\n  Selection.prototype.getPkValue = function (pkField, data) {\n    return pkField ? isComplexField(pkField) ? getObject(pkField, data) : data[pkField] : data[pkField];\n  };\n\n  Selection.prototype.updatePersistCollection = function (selectedRow, chkState) {\n    var _this = this;\n\n    if ((this.parent.isPersistSelection || this.parent.selectionSettings.persistSelection && this.parent.getPrimaryKeyFieldNames().length > 0) && !isNullOrUndefined(selectedRow)) {\n      if (!this.parent.isPersistSelection) {\n        this.ensureCheckboxFieldSelection();\n      }\n\n      var rowObj = this.getRowObj(selectedRow);\n      var pKey_1 = rowObj.data ? this.getPkValue(this.primaryKey, rowObj.data) : null;\n\n      if (pKey_1 === null) {\n        return;\n      }\n\n      rowObj.isSelected = chkState;\n\n      if (chkState && !this.isPartialSelection || this.isPartialSelection && rowObj.isSelectable && rowObj.isSelected) {\n        this.selectedRowState[pKey_1] = chkState;\n        delete this.unSelectedRowState[pKey_1];\n\n        if (!this.persistSelectedData.some(function (data) {\n          return _this.getPkValue(_this.primaryKey, data) === pKey_1;\n        })) {\n          this.persistSelectedData.push(rowObj.data);\n        }\n      } else {\n        this.updatePersistDelete(pKey_1);\n      }\n    }\n  };\n\n  Selection.prototype.updatePersistDelete = function (pKey, isPartialSelection) {\n    var _this = this;\n\n    delete this.selectedRowState[pKey];\n\n    if (this.rmtHdrChkbxClicked) {\n      this.unSelectedRowState[pKey] = true;\n    }\n\n    var index;\n    var isPresent = this.persistSelectedData.some(function (data, i) {\n      index = i;\n      return _this.getPkValue(_this.primaryKey, data) === pKey;\n    });\n\n    if (isPresent) {\n      this.persistSelectedData.splice(index, 1);\n\n      if (isPartialSelection) {\n        this.parent.partialSelectedRecords.splice(index, 1);\n      }\n    }\n  };\n\n  Selection.prototype.updateCheckBoxes = function (row$$1, chkState, rowIndex) {\n    if (!isNullOrUndefined(row$$1)) {\n      var chkBox = row$$1.querySelector('.e-checkselect');\n\n      if (!isNullOrUndefined(chkBox)) {\n        removeAddCboxClasses(chkBox.nextElementSibling, chkState);\n        setChecked(chkBox, chkState);\n\n        if (isNullOrUndefined(this.checkedTarget) || !isNullOrUndefined(this.checkedTarget) && !this.checkedTarget.classList.contains('e-checkselectall')) {\n          this.setCheckAllState(rowIndex);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.updateRowSelection = function (selectedRow, startIndex) {\n    if (!selectedRow) {\n      return;\n    }\n\n    this.selectedRowIndexes.push(startIndex);\n    var len = this.selectedRowIndexes.length;\n\n    if (this.parent.isFrozenGrid() && len > 1) {\n      if (this.selectedRowIndexes[len - 2] === this.selectedRowIndexes[len - 1]) {\n        this.selectedRowIndexes.pop();\n      }\n    }\n\n    this.selectedRecords.push(selectedRow);\n    selectedRow.setAttribute('aria-selected', 'true');\n    this.updatePersistCollection(selectedRow, true);\n    this.updateCheckBoxes(selectedRow, true);\n    this.addRemoveClassesForRow(selectedRow, true, null, 'e-selectionbackground', 'e-active');\n\n    if (!this.preventFocus) {\n      var target = this.focus.getPrevIndexes().cellIndex ? selectedRow.cells[this.focus.getPrevIndexes().cellIndex] : selectedRow.querySelector('.e-selectionbackground:not(.e-hide):not(.e-detailrowcollapse):not(.e-detailrowexpand)');\n\n      if (this.parent.contextMenuModule && this.mouseButton === 2) {\n        target = this.parent.contextMenuModule.cell;\n      }\n\n      if (!target) {\n        return;\n      }\n\n      this.focus.onClick({\n        target: target\n      }, true);\n    }\n  };\n  /**\n   * Deselects the currently selected rows and cells.\n   *\n   * @returns {void}\n   */\n\n\n  Selection.prototype.clearSelection = function () {\n    this.checkSelectAllClicked = true;\n\n    if (this.selectionSettings.persistSelection && this.persistSelectedData.length) {\n      this.deSelectedData = iterateExtend(this.persistSelectedData);\n    }\n\n    if (!this.parent.isPersistSelection || this.parent.isPersistSelection && !this.parent.isEdit || !isNullOrUndefined(this.checkedTarget) && this.checkedTarget.classList.contains('e-checkselectall')) {\n      var span = this.parent.element.querySelector('.e-gridpopup').querySelector('span');\n\n      if (span.classList.contains('e-rowselect')) {\n        span.classList.remove('e-spanclicked');\n      }\n\n      if (this.parent.isPersistSelection) {\n        this.persistSelectedData = [];\n        this.selectedRowState = {};\n      }\n\n      this.clearRowSelection();\n      this.clearCellSelection();\n      this.clearColumnSelection();\n      this.prevRowIndex = undefined;\n      this.prevCIdxs = undefined;\n      this.prevECIdxs = undefined;\n      this.enableSelectMultiTouch = false;\n      this.isInteracted = false;\n      this.checkSelectAllClicked = false;\n      this.isHdrSelectAllClicked = false;\n    }\n  };\n  /**\n   * Deselects the currently selected rows.\n   *\n   * @returns {void}\n   */\n\n\n  Selection.prototype.clearRowSelection = function () {\n    var _this = this;\n\n    if (this.isRowSelected) {\n      var gObj = this.parent;\n      var rows_1 = this.parent.getDataRows();\n      var data_1 = [];\n      var row_1 = [];\n      var mRow_1 = [];\n      var fRightRow_1 = [];\n      var rowIndex_1 = [];\n      var foreignKeyData_1 = [];\n      var target_1 = this.target;\n\n      for (var i = 0, len = this.selectedRowIndexes.length; i < len; i++) {\n        var currentRow = this.parent.editSettings.mode === 'Batch' ? this.parent.getRows()[this.selectedRowIndexes[i]] : this.parent.getDataRows()[this.selectedRowIndexes[i]];\n        var rowObj = this.getRowObj(currentRow);\n\n        if (rowObj) {\n          data_1.push(rowObj.data);\n          row_1.push(currentRow);\n          rowIndex_1.push(this.selectedRowIndexes[i]);\n          foreignKeyData_1.push(rowObj.foreignKeyData);\n        }\n\n        if (gObj.isFrozenGrid()) {\n          var mRows = gObj.getMovableRows();\n\n          if (mRows && mRows.length) {\n            mRow_1.push(mRows[this.selectedRowIndexes[i]]);\n          }\n\n          if (gObj.getFrozenMode() === leftRight) {\n            var frRows = gObj.getFrozenRightRows();\n\n            if (frRows && frRows.length) {\n              fRightRow_1.push(frRows[this.selectedRowIndexes[i]]);\n            }\n          }\n        }\n      }\n\n      if (this.selectionSettings.persistSelection && this.selectionSettings.checkboxMode !== 'ResetOnRowClick') {\n        this.isRowClicked = this.checkSelectAllClicked ? true : false;\n      }\n\n      this.rowDeselect(rowDeselecting, rowIndex_1, data_1, row_1, foreignKeyData_1, target_1, mRow_1, function () {\n        if (_this.isCancelDeSelect && (_this.isRowClicked || _this.checkSelectAllClicked || _this.isInteracted && !_this.parent.isPersistSelection)) {\n          if (_this.parent.isPersistSelection) {\n            if (_this.getCheckAllStatus(_this.parent.element.querySelector('.e-checkselectall')) === 'Intermediate') {\n              for (var i = 0; i < _this.selectedRecords.length; i++) {\n                _this.updatePersistCollection(_this.selectedRecords[i], true);\n              }\n            } else {\n              _this.parent.checkAllRows = 'Check';\n\n              _this.updatePersistSelectedData(true);\n            }\n          }\n\n          if (_this.clearRowCheck) {\n            _this.clearRowCallBack();\n\n            _this.clearRowCheck = false;\n\n            if (_this.selectRowCheck) {\n              _this.selectRowCallBack();\n\n              _this.selectRowCheck = false;\n            }\n          }\n\n          return;\n        }\n\n        var element = [].slice.call(rows_1.filter(function (record) {\n          return record.hasAttribute('aria-selected');\n        }));\n\n        for (var j = 0; j < element.length; j++) {\n          if (!_this.disableUI) {\n            element[j].removeAttribute('aria-selected');\n\n            _this.addRemoveClassesForRow(element[j], false, true, 'e-selectionbackground', 'e-active');\n          } // tslint:disable-next-line:align\n\n\n          if (!_this.isPrevRowSelection) {\n            _this.updatePersistCollection(element[j], false);\n          }\n\n          _this.updateCheckBoxes(element[j]);\n        }\n\n        for (var i = 0, len = _this.selectedRowIndexes.length; i < len; i++) {\n          var movableRow = _this.getSelectedMovableRow(_this.selectedRowIndexes[i]);\n\n          if (movableRow) {\n            if (!_this.disableUI) {\n              movableRow.removeAttribute('aria-selected');\n\n              _this.addRemoveClassesForRow(movableRow, false, true, 'e-selectionbackground', 'e-active');\n            }\n\n            _this.updateCheckBoxes(movableRow);\n\n            if (!_this.isPrevRowSelection) {\n              _this.updatePersistCollection(movableRow, false);\n            }\n          }\n\n          var frRow = _this.getSelectedFrozenRightRow(_this.selectedRowIndexes[i]);\n\n          if (frRow) {\n            if (!_this.disableUI) {\n              frRow.removeAttribute('aria-selected');\n\n              _this.addRemoveClassesForRow(frRow, false, true, 'e-selectionbackground', 'e-active');\n            }\n\n            _this.updateCheckBoxes(frRow);\n\n            if (!_this.isPrevRowSelection) {\n              _this.updatePersistCollection(frRow, false);\n            }\n          }\n        }\n\n        _this.selectedRowIndexes = [];\n        _this.selectedRecords = [];\n        _this.isRowSelected = false;\n\n        _this.selectRowIndex(-1);\n\n        _this.isPrevRowSelection = false;\n\n        _this.rowDeselect(rowDeselected, rowIndex_1, data_1, row_1, foreignKeyData_1, target_1, mRow_1, undefined, fRightRow_1);\n\n        if (_this.clearRowCheck) {\n          _this.clearRowCallBack();\n\n          _this.clearRowCheck = false;\n\n          if (_this.selectRowCheck) {\n            _this.selectRowCallBack();\n\n            _this.selectRowCheck = false;\n          }\n        }\n      }, fRightRow_1);\n    } else {\n      if (this.clearRowCheck) {\n        this.clearRowCallBack();\n        this.clearRowCheck = false;\n\n        if (this.selectRowCheck) {\n          this.selectRowCallBack();\n          this.selectRowCheck = false;\n        }\n      }\n    }\n  };\n\n  Selection.prototype.rowDeselect = function (type, rowIndex, data, row$$1, foreignKeyData$$1, target, mRow, rowDeselectCallBack, frozenRightRow) {\n    var _this = this;\n\n    if (this.selectionSettings.persistSelection && (this.isRowClicked || this.checkSelectAllClicked || this.focus['activeKey'] && this.focus.currentInfo.element.classList.contains('e-gridchkbox') && this.focus['activeKey'] === 'space') || !this.selectionSettings.persistSelection) {\n      var cancl_1 = 'cancel';\n      var isSingleDeSel = rowIndex.length === 1 && this.deSelectedData.length === 1;\n      var rowDeselectObj = {\n        rowIndex: rowIndex[0],\n        data: this.selectionSettings.persistSelection && this.parent.checkAllRows === 'Uncheck' && !isSingleDeSel && this.selectionSettings.checkboxMode !== 'ResetOnRowClick' ? this.deSelectedData : data,\n        foreignKeyData: foreignKeyData$$1,\n        cancel: false,\n        isInteracted: this.isInteracted,\n        isHeaderCheckboxClicked: this.isHeaderCheckboxClicked\n      };\n\n      if (type === 'rowDeselected') {\n        delete rowDeselectObj.cancel;\n      }\n\n      var rowInString = 'row';\n      var target_2 = 'target';\n      var rowidx = 'rowIndex';\n      var rowidxex = 'rowIndexes';\n      var dataTxt = 'data';\n      var foreignKey = 'foreignKeyData';\n      rowDeselectObj[rowInString] = row$$1;\n      rowDeselectObj[target_2] = this.actualTarget;\n      var isHeaderCheckBxClick = this.actualTarget && !isNullOrUndefined(closest(this.actualTarget, 'thead'));\n\n      if (isHeaderCheckBxClick || rowIndex.length > 1) {\n        rowDeselectObj[rowidx] = rowIndex[0];\n        rowDeselectObj[rowidxex] = rowIndex;\n      } else if (rowIndex.length === 1) {\n        rowDeselectObj[dataTxt] = rowDeselectObj[dataTxt][0];\n        rowDeselectObj[rowInString] = rowDeselectObj[rowInString][0];\n        rowDeselectObj[foreignKey] = rowDeselectObj[foreignKey][0];\n\n        if (this.isAddRowsToSelection) {\n          rowDeselectObj[rowidxex] = rowIndex;\n        }\n      }\n\n      this.parent.trigger(type, this.parent.isFrozenGrid() ? __assign({}, rowDeselectObj, {\n        mRow: mRow,\n        frozenRightRow: frozenRightRow\n      }) : rowDeselectObj, function (args) {\n        _this.isCancelDeSelect = args[cancl_1];\n\n        if (!_this.isCancelDeSelect || !_this.isRowClicked && !_this.isInteracted && !_this.checkSelectAllClicked) {\n          _this.updatePersistCollection(row$$1[0], false);\n\n          _this.updateCheckBoxes(row$$1[0], undefined, rowIndex[0]);\n\n          if (mRow) {\n            _this.updateCheckBoxes(mRow[0], undefined, rowIndex[0]);\n          }\n\n          if (frozenRightRow) {\n            _this.updateCheckBoxes(frozenRightRow[0], undefined, rowIndex[0]);\n          }\n        }\n\n        if (rowDeselectCallBack !== undefined) {\n          rowDeselectCallBack();\n        }\n      });\n    } else if (this.selectionSettings.persistSelection && !this.isInteracted) {\n      if (rowDeselectCallBack !== undefined) {\n        rowDeselectCallBack();\n      }\n    }\n  };\n\n  Selection.prototype.getRowObj = function (row$$1) {\n    if (row$$1 === void 0) {\n      row$$1 = this.currentIndex;\n    }\n\n    if (isNullOrUndefined(row$$1)) {\n      return {};\n    }\n\n    if (typeof row$$1 === 'number') {\n      row$$1 = this.parent.getRowByIndex(row$$1);\n    }\n\n    if (row$$1) {\n      return this.parent.getRowObjectFromUID(row$$1.getAttribute('data-uid')) || {};\n    }\n\n    return {};\n  };\n\n  Selection.prototype.getSelectedMovableCell = function (cellIndex) {\n    var gObj = this.parent;\n    var col = gObj.getColumnByIndex(cellIndex.cellIndex);\n    var frzCols = gObj.isFrozenGrid();\n\n    if (frzCols) {\n      if (col.getFreezeTableName() === 'movable') {\n        return gObj.getMovableCellFromIndex(cellIndex.rowIndex, this.getColIndex(cellIndex.rowIndex, cellIndex.cellIndex));\n      }\n\n      return null;\n    }\n\n    return null;\n  };\n  /**\n   * Selects a cell by the given index.\n   *\n   * @param  {IIndex} cellIndex - Defines the row and column indexes.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectCell = function (cellIndex, isToggle) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var selectedCell = this.getSelectedMovableCell(cellIndex);\n    var args;\n\n    if (!selectedCell) {\n      selectedCell = gObj.getCellFromIndex(cellIndex.rowIndex, this.getColIndex(cellIndex.rowIndex, cellIndex.cellIndex));\n    }\n\n    this.currentIndex = cellIndex.rowIndex;\n    var selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n\n    if (!this.isCellType() || !selectedCell || this.isEditing()) {\n      return;\n    }\n\n    var isCellSelected = selectedCell.classList.contains('e-cellselectionbackground');\n    isToggle = !isToggle ? isToggle : !isUndefined(this.prevCIdxs) && cellIndex.rowIndex === this.prevCIdxs.rowIndex && cellIndex.cellIndex === this.prevCIdxs.cellIndex && isCellSelected;\n\n    if (!isToggle) {\n      args = {\n        data: selectedData,\n        cellIndex: cellIndex,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest,\n        previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined,\n        cancel: false\n      };\n      var currentCell = 'currentCell';\n      args[currentCell] = selectedCell;\n      var previousRowCellIndex = 'previousRowCellIndex';\n      args[previousRowCellIndex] = this.prevECIdxs;\n      this.parent.trigger(cellSelecting, this.fDataUpdate(args), this.successCallBack(args, isToggle, cellIndex, selectedCell, selectedData));\n      this.cellselected = true;\n    } else {\n      this.successCallBack(args, isToggle, cellIndex, selectedCell, selectedData)(args);\n    }\n  };\n\n  Selection.prototype.successCallBack = function (cellSelectingArgs, isToggle, cellIndex, selectedCell, selectedData) {\n    var _this = this;\n\n    return function (cellSelectingArgs) {\n      var cncl = 'cancel';\n      var currentCell = 'currentCell';\n\n      if (!isNullOrUndefined(cellSelectingArgs) && cellSelectingArgs[cncl] === true) {\n        return;\n      }\n\n      if (!isToggle) {\n        cellSelectingArgs[currentCell] = cellSelectingArgs[currentCell] ? cellSelectingArgs[currentCell] : selectedCell;\n      }\n\n      _this.clearCell();\n\n      if (!isToggle) {\n        _this.updateCellSelection(selectedCell, cellIndex.rowIndex, cellIndex.cellIndex);\n      }\n\n      if (!isToggle) {\n        var args = {\n          data: selectedData,\n          cellIndex: cellIndex,\n          currentCell: selectedCell,\n          selectedRowCellIndex: _this.selectedRowCellIndexes,\n          previousRowCell: _this.prevECIdxs ? _this.getCellIndex(_this.prevECIdxs.rowIndex, _this.prevECIdxs.cellIndex) : undefined\n        };\n        var previousRowCellIndex = 'previousRowCellIndex';\n        args[previousRowCellIndex] = _this.prevECIdxs;\n\n        _this.updateCellProps(cellIndex, cellIndex);\n\n        _this.onActionComplete(args, cellSelected);\n      }\n    };\n  };\n\n  Selection.prototype.getCellIndex = function (rIdx, cIdx) {\n    return this.parent.getFrozenColumns() ? cIdx >= this.parent.getFrozenColumns() ? this.parent.getMovableCellFromIndex(rIdx, cIdx) : this.parent.getCellFromIndex(rIdx, cIdx) : this.parent.getCellFromIndex(rIdx, cIdx);\n  };\n  /**\n   * Selects a range of cells from start and end indexes.\n   *\n   * @param  {IIndex} startIndex - Specifies the row and column's start index.\n   * @param  {IIndex} endIndex - Specifies the row and column's end index.\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectCellsByRange = function (startIndex, endIndex) {\n    var _this = this;\n\n    if (!this.isCellType()) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var selectedCell = this.getSelectedMovableCell(startIndex);\n    var frzCols = gObj.getFrozenColumns();\n\n    if (!selectedCell) {\n      selectedCell = gObj.getCellFromIndex(startIndex.rowIndex, startIndex.cellIndex);\n    }\n\n    var min;\n    var max;\n    var stIndex = startIndex;\n    var edIndex = endIndex = endIndex ? endIndex : startIndex;\n    var cellIndexes;\n    this.currentIndex = startIndex.rowIndex;\n    var cncl = 'cancel';\n    var selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n\n    if (this.isSingleSel() || !this.isCellType() || this.isEditing()) {\n      return;\n    }\n\n    var args = {\n      data: selectedData,\n      cellIndex: startIndex,\n      currentCell: selectedCell,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest,\n      previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n    };\n    var previousRowCellIndex = 'previousRowCellIndex';\n    args[previousRowCellIndex] = this.prevECIdxs;\n    this.parent.trigger(cellSelecting, this.fDataUpdate(args), function (cellSelectingArgs) {\n      if (!isNullOrUndefined(cellSelectingArgs) && cellSelectingArgs[cncl] === true) {\n        return;\n      }\n\n      _this.clearCell();\n\n      if (startIndex.rowIndex > endIndex.rowIndex) {\n        var temp = startIndex;\n        startIndex = endIndex;\n        endIndex = temp;\n      }\n\n      for (var i = startIndex.rowIndex; i <= endIndex.rowIndex; i++) {\n        if (_this.selectionSettings.cellSelectionMode.indexOf('Box') < 0) {\n          min = i === startIndex.rowIndex ? startIndex.cellIndex : 0;\n          max = i === endIndex.rowIndex ? endIndex.cellIndex : _this.getLastColIndex(i);\n        } else {\n          min = startIndex.cellIndex;\n          max = endIndex.cellIndex;\n        }\n\n        cellIndexes = [];\n\n        for (var j = min < max ? min : max, len = min > max ? min : max; j <= len; j++) {\n          if (frzCols) {\n            if (j < frzCols) {\n              selectedCell = gObj.getCellFromIndex(i, j);\n            } else {\n              selectedCell = gObj.getMovableCellFromIndex(i, j);\n            }\n          } else {\n            selectedCell = gObj.getCellFromIndex(i, j);\n          }\n\n          if (!selectedCell) {\n            continue;\n          }\n\n          cellIndexes.push(j);\n\n          _this.updateCellSelection(selectedCell);\n\n          _this.addAttribute(selectedCell);\n        }\n\n        _this.selectedRowCellIndexes.push({\n          rowIndex: i,\n          cellIndexes: cellIndexes\n        });\n      }\n\n      var cellSelectedArgs = {\n        data: selectedData,\n        cellIndex: edIndex,\n        currentCell: gObj.getCellFromIndex(edIndex.rowIndex, edIndex.cellIndex),\n        selectedRowCellIndex: _this.selectedRowCellIndexes,\n        previousRowCell: _this.prevECIdxs ? _this.getCellIndex(_this.prevECIdxs.rowIndex, _this.prevECIdxs.cellIndex) : undefined\n      };\n      var previousRowCellIndex = 'previousRowCellIndex';\n      cellSelectedArgs[previousRowCellIndex] = _this.prevECIdxs;\n\n      if (!_this.isDragged) {\n        _this.onActionComplete(cellSelectedArgs, cellSelected);\n\n        _this.cellselected = true;\n      }\n\n      _this.updateCellProps(stIndex, edIndex);\n    });\n  };\n  /**\n   * Selects a collection of cells by row and column indexes.\n   *\n   * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectCells = function (rowCellIndexes) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var selectedCell = this.getSelectedMovableCell(rowCellIndexes[0]);\n    var frzCols = gObj.getFrozenColumns();\n\n    if (!selectedCell) {\n      selectedCell = gObj.getCellFromIndex(rowCellIndexes[0].rowIndex, rowCellIndexes[0].cellIndexes[0]);\n    }\n\n    this.currentIndex = rowCellIndexes[0].rowIndex;\n    var selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n\n    if (this.isSingleSel() || !this.isCellType() || this.isEditing()) {\n      return;\n    }\n\n    var cellSelectArgs = {\n      data: selectedData,\n      cellIndex: rowCellIndexes[0].cellIndexes[0],\n      currentCell: selectedCell,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest,\n      previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n    };\n    var previousRowCellIndex = 'previousRowCellIndex';\n    cellSelectArgs[previousRowCellIndex] = this.prevECIdxs;\n    this.onActionBegin(cellSelectArgs, cellSelecting);\n\n    for (var i = 0, len = rowCellIndexes.length; i < len; i++) {\n      for (var j = 0, cellLen = rowCellIndexes[i].cellIndexes.length; j < cellLen; j++) {\n        if (frzCols) {\n          if (rowCellIndexes[i].cellIndexes[j] < frzCols) {\n            selectedCell = gObj.getCellFromIndex(rowCellIndexes[i].rowIndex, rowCellIndexes[i].cellIndexes[j]);\n          } else {\n            selectedCell = gObj.getMovableCellFromIndex(rowCellIndexes[i].rowIndex, rowCellIndexes[i].cellIndexes[j]);\n          }\n        } else {\n          selectedCell = gObj.getCellFromIndex(rowCellIndexes[i].rowIndex, rowCellIndexes[i].cellIndexes[j]);\n        }\n\n        if (!selectedCell) {\n          continue;\n        }\n\n        this.updateCellSelection(selectedCell);\n        this.addAttribute(selectedCell);\n        this.addRowCellIndex({\n          rowIndex: rowCellIndexes[i].rowIndex,\n          cellIndex: rowCellIndexes[i].cellIndexes[j]\n        });\n      }\n    }\n\n    this.updateCellProps({\n      rowIndex: rowCellIndexes[0].rowIndex,\n      cellIndex: rowCellIndexes[0].cellIndexes[0]\n    }, {\n      rowIndex: rowCellIndexes[0].rowIndex,\n      cellIndex: rowCellIndexes[0].cellIndexes[0]\n    });\n    var cellSelectedArgs = {\n      data: selectedData,\n      cellIndex: rowCellIndexes[0].cellIndexes[0],\n      currentCell: selectedCell,\n      selectedRowCellIndex: this.selectedRowCellIndexes,\n      previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n    };\n    var prvRowCellIndex = 'previousRowCellIndex';\n    cellSelectedArgs[prvRowCellIndex] = this.prevECIdxs;\n    this.onActionComplete(cellSelectedArgs, cellSelected);\n  };\n  /**\n   * Select cells with existing cell selection by passing row and column index.\n   *\n   * @param {IIndex} cellIndexes - Defines the collection of row and column index.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.addCellsToSelection = function (cellIndexes) {\n    if (!this.isCellType()) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var selectedCell;\n    var index;\n    this.currentIndex = cellIndexes[0].rowIndex;\n    var cncl = 'cancel';\n    var selectedData = this.getCurrentBatchRecordChanges()[this.currentIndex];\n    var left = gObj.getFrozenLeftCount();\n    var movable = gObj.getMovableColumnsCount();\n\n    if (this.isSingleSel() || !this.isCellType() || this.isEditing()) {\n      return;\n    }\n\n    this.hideAutoFill();\n    var col = gObj.getColumnByIndex(cellIndexes[0].cellIndex);\n    var rowObj;\n    gridActionHandler(this.parent, function (tableName, rows) {\n      rowObj = rows[cellIndexes[0].rowIndex];\n    }, [!col.getFreezeTableName() || col.getFreezeTableName() === frozenLeft ? gObj.getRowsObject() : [], col.getFreezeTableName() === 'movable' ? gObj.getMovableRowsObject() : [], col.getFreezeTableName() === frozenRight ? gObj.getFrozenRightRowsObject() : []]);\n\n    if (gObj.groupSettings.columns.length > 0) {\n      rowObj = gObj.getRowObjectFromUID(this.target.parentElement.getAttribute('data-uid'));\n    }\n\n    var foreignKeyData$$1 = [];\n\n    for (var _i = 0, cellIndexes_1 = cellIndexes; _i < cellIndexes_1.length; _i++) {\n      var cellIndex = cellIndexes_1[_i];\n\n      for (var i = 0, len = this.selectedRowCellIndexes.length; i < len; i++) {\n        if (this.selectedRowCellIndexes[i].rowIndex === cellIndex.rowIndex) {\n          index = i;\n          break;\n        }\n      }\n\n      selectedCell = this.getSelectedMovableCell(cellIndex);\n\n      if (!selectedCell) {\n        selectedCell = gObj.getCellFromIndex(cellIndex.rowIndex, this.getColIndex(cellIndex.rowIndex, cellIndex.cellIndex));\n      }\n\n      var idx = col.getFreezeTableName() === 'movable' ? cellIndex.cellIndex - left : col.getFreezeTableName() === frozenRight ? cellIndex.cellIndex - (left + movable) : cellIndex.cellIndex;\n\n      if (gObj.groupSettings.columns.length > 0) {\n        foreignKeyData$$1.push(rowObj.cells[idx + gObj.groupSettings.columns.length].foreignKeyData);\n      } else {\n        foreignKeyData$$1.push(rowObj.cells[idx].foreignKeyData);\n      }\n\n      var args = {\n        cancel: false,\n        data: selectedData,\n        cellIndex: cellIndexes[0],\n        isShiftPressed: this.isMultiShiftRequest,\n        currentCell: selectedCell,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        previousRowCell: this.prevECIdxs ? gObj.getCellFromIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined\n      };\n      var prvRowCellIndex = 'previousRowCellIndex';\n      args[prvRowCellIndex] = this.prevECIdxs;\n      var isUnSelected = index > -1;\n\n      if (isUnSelected) {\n        var selectedCellIdx = this.selectedRowCellIndexes[index].cellIndexes;\n\n        if (selectedCellIdx.indexOf(cellIndex.cellIndex) > -1) {\n          this.cellDeselect(cellDeselecting, [{\n            rowIndex: cellIndex.rowIndex,\n            cellIndexes: [cellIndex.cellIndex]\n          }], selectedData, [selectedCell], foreignKeyData$$1);\n          selectedCellIdx.splice(selectedCellIdx.indexOf(cellIndex.cellIndex), 1);\n\n          if (selectedCellIdx.length === 0) {\n            this.selectedRowCellIndexes.splice(index, 1);\n          }\n\n          selectedCell.classList.remove('e-cellselectionbackground');\n          selectedCell.removeAttribute('aria-selected');\n          this.cellDeselect(cellDeselected, [{\n            rowIndex: cellIndex.rowIndex,\n            cellIndexes: [cellIndex.cellIndex]\n          }], selectedData, [selectedCell], foreignKeyData$$1);\n        } else {\n          isUnSelected = false;\n          this.onActionBegin(args, cellSelecting);\n          this.addRowCellIndex({\n            rowIndex: cellIndex.rowIndex,\n            cellIndex: cellIndex.cellIndex\n          });\n          this.updateCellSelection(selectedCell);\n          this.addAttribute(selectedCell);\n        }\n      } else {\n        this.onActionBegin(args, cellSelecting);\n\n        if (!isNullOrUndefined(args) && args[cncl] === true) {\n          return;\n        }\n\n        this.updateCellSelection(selectedCell, cellIndex.rowIndex, cellIndex.cellIndex);\n      }\n\n      if (!isUnSelected) {\n        var cellSelectedArgs = {\n          data: selectedData,\n          cellIndex: cellIndexes[0],\n          currentCell: selectedCell,\n          previousRowCell: this.prevECIdxs ? this.getCellIndex(this.prevECIdxs.rowIndex, this.prevECIdxs.cellIndex) : undefined,\n          selectedRowCellIndex: this.selectedRowCellIndexes\n        };\n        cellSelectedArgs[prvRowCellIndex] = this.prevECIdxs;\n        this.onActionComplete(cellSelectedArgs, cellSelected);\n        this.cellselected = true;\n      }\n\n      this.updateCellProps(cellIndex, cellIndex);\n    }\n  };\n\n  Selection.prototype.getColIndex = function (rowIndex, index) {\n    var frzCols = this.parent.isFrozenGrid();\n    var col = this.parent.getColumnByIndex(index);\n    var cells = getCellsByTableName(this.parent, col, rowIndex);\n\n    if (cells) {\n      for (var m = 0; m < cells.length; m++) {\n        var colIndex = parseInt(cells[m].getAttribute(dataColIndex), 10);\n\n        if (colIndex === index) {\n          if (frzCols) {\n            if (col.getFreezeTableName() === 'movable') {\n              m += this.parent.getFrozenLeftCount();\n            } else if (col.getFreezeTableName() === frozenRight) {\n              m += this.parent.getFrozenLeftColumnsCount() + this.parent.getMovableColumnsCount();\n            }\n          }\n\n          return m;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  Selection.prototype.getLastColIndex = function (rowIndex) {\n    var cells = this.parent.getFrozenColumns() ? this.parent.getMovableDataRows()[rowIndex].querySelectorAll('td.e-rowcell') : this.parent.getDataRows()[rowIndex].querySelectorAll('td.e-rowcell');\n    return parseInt(cells[cells.length - 1].getAttribute(dataColIndex), 10);\n  };\n\n  Selection.prototype.clearCell = function () {\n    this.clearCellSelection();\n  };\n\n  Selection.prototype.cellDeselect = function (type, cellIndexes, data, cells, foreignKeyData$$1) {\n    var cancl = 'cancel';\n\n    if (cells[0] && cells[0].classList.contains(gridChkBox)) {\n      this.updateCheckBoxes(closest(cells[0], 'tr'));\n    }\n\n    var args = {\n      cells: cells,\n      data: data,\n      cellIndexes: cellIndexes,\n      foreignKeyData: foreignKeyData$$1,\n      cancel: false\n    };\n    this.parent.trigger(type, args);\n    this.isPreventCellSelect = args[cancl];\n  };\n\n  Selection.prototype.updateCellSelection = function (selectedCell, rowIndex, cellIndex) {\n    if (!isNullOrUndefined(rowIndex)) {\n      this.addRowCellIndex({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n    }\n\n    selectedCell.classList.add('e-cellselectionbackground');\n\n    if (selectedCell.classList.contains(gridChkBox)) {\n      this.updateCheckBoxes(closest(selectedCell, 'tr'), true);\n    }\n\n    this.addAttribute(selectedCell);\n  };\n\n  Selection.prototype.addAttribute = function (cell) {\n    this.target = cell;\n\n    if (!isNullOrUndefined(cell)) {\n      cell.setAttribute('aria-selected', 'true');\n\n      if (!this.preventFocus) {\n        this.focus.onClick({\n          target: cell\n        }, true);\n      }\n    }\n  };\n\n  Selection.prototype.updateCellProps = function (startIndex, endIndex) {\n    this.prevCIdxs = startIndex;\n    this.prevECIdxs = endIndex;\n    this.isCellSelected = this.selectedRowCellIndexes.length && true;\n  };\n\n  Selection.prototype.addRowCellIndex = function (rowCellIndex) {\n    var isRowAvail;\n    var index;\n\n    for (var i = 0, len = this.selectedRowCellIndexes.length; i < len; i++) {\n      if (this.selectedRowCellIndexes[i].rowIndex === rowCellIndex.rowIndex) {\n        isRowAvail = true;\n        index = i;\n        break;\n      }\n    }\n\n    if (isRowAvail) {\n      if (this.selectedRowCellIndexes[index].cellIndexes.indexOf(rowCellIndex.cellIndex) < 0) {\n        this.selectedRowCellIndexes[index].cellIndexes.push(rowCellIndex.cellIndex);\n      }\n    } else {\n      this.selectedRowCellIndexes.push({\n        rowIndex: rowCellIndex.rowIndex,\n        cellIndexes: [rowCellIndex.cellIndex]\n      });\n    }\n  };\n  /**\n   * Deselects the currently selected cells.\n   *\n   * @returns {void}\n   */\n\n\n  Selection.prototype.clearCellSelection = function () {\n    if (this.isCellSelected) {\n      var gObj = this.parent;\n      var selectedCells = this.getSelectedCellsElement();\n      var rowCell$$1 = this.selectedRowCellIndexes;\n      var data = [];\n      var cells = [];\n      var foreignKeyData$$1 = [];\n      var currentViewData = this.getCurrentBatchRecordChanges();\n      var frzCols = gObj.isFrozenGrid();\n      this.hideAutoFill();\n\n      for (var i = 0, len = rowCell$$1.length; i < len; i++) {\n        data.push(currentViewData[rowCell$$1[i].rowIndex]);\n        var rowObj = this.getRowObj(rowCell$$1[i].rowIndex);\n\n        for (var j = 0, cLen = rowCell$$1[i].cellIndexes.length; j < cLen; j++) {\n          if (frzCols) {\n            var col = gObj.getColumnByIndex(rowCell$$1[i].cellIndexes[j]);\n            cells.push(getCellByColAndRowIndex(this.parent, col, rowCell$$1[i].rowIndex, rowCell$$1[i].cellIndexes[j]));\n          } else {\n            if (rowObj.cells) {\n              foreignKeyData$$1.push(rowObj.cells[rowCell$$1[i].cellIndexes[j]].foreignKeyData);\n            }\n\n            cells.push(gObj.getCellFromIndex(rowCell$$1[i].rowIndex, rowCell$$1[i].cellIndexes[j]));\n          }\n        }\n      }\n\n      this.cellDeselect(cellDeselecting, rowCell$$1, data, cells, foreignKeyData$$1);\n\n      if (this.isPreventCellSelect === true) {\n        return;\n      }\n\n      for (var i = 0, len = selectedCells.length; i < len; i++) {\n        selectedCells[i].classList.remove('e-cellselectionbackground');\n        selectedCells[i].removeAttribute('aria-selected');\n      }\n\n      if (this.bdrElement) {\n        this.showHideBorders('none');\n      }\n\n      this.selectedRowCellIndexes = [];\n      this.isCellSelected = false;\n\n      if (!this.isDragged && this.cellselected) {\n        this.cellDeselect(cellDeselected, rowCell$$1, data, cells, foreignKeyData$$1);\n      }\n    }\n  };\n\n  Selection.prototype.getSelectedCellsElement = function () {\n    var gObj = this.parent;\n    var rows = gObj.getDataRows();\n    var mRows;\n\n    if (gObj.isFrozenGrid()) {\n      mRows = gObj.getMovableDataRows();\n      rows = gObj.addMovableRows(rows, mRows);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        rows = gObj.addMovableRows(rows, gObj.getFrozenRightDataRows());\n      }\n    }\n\n    var cells = [];\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      cells = cells.concat([].slice.call(rows[i].getElementsByClassName('e-cellselectionbackground')));\n    }\n\n    return cells;\n  };\n\n  Selection.prototype.mouseMoveHandler = function (e) {\n    e.preventDefault();\n    var gBRect = this.parent.element.getBoundingClientRect();\n    var x1 = this.x;\n    var y1 = this.y;\n    var position = getPosition(e);\n    var x2 = position.x - gBRect.left;\n    var y2 = position.y - gBRect.top;\n    var tmp;\n    var target = closest(e.target, 'tr');\n    this.isDragged = true;\n\n    if (!this.isCellDrag) {\n      if (!target) {\n        target = closest(document.elementFromPoint(this.parent.element.offsetLeft + 2, e.clientY), 'tr');\n      }\n\n      if (x1 > x2) {\n        tmp = x2;\n        x2 = x1;\n        x1 = tmp;\n      }\n\n      if (y1 > y2) {\n        tmp = y2;\n        y2 = y1;\n        y1 = tmp;\n      }\n\n      this.element.style.left = x1 + 'px';\n      this.element.style.top = y1 + 'px';\n      this.element.style.width = x2 - x1 + 'px';\n      this.element.style.height = y2 - y1 + 'px';\n    }\n\n    if (target && !e.ctrlKey && !e.shiftKey) {\n      var rowIndex = parseInt(target.getAttribute(dataRowIndex), 10);\n\n      if (!this.isCellDrag) {\n        this.hideAutoFill();\n        this.selectRowsByRange(this.startDIndex, rowIndex);\n        this.isRowDragSelected = true;\n      } else {\n        var td = parentsUntil(e.target, rowCell);\n\n        if (td) {\n          this.startAFCell = this.startCell;\n          this.endAFCell = parentsUntil(e.target, rowCell);\n          this.selectLikeExcel(e, rowIndex, parseInt(td.getAttribute(dataColIndex), 10));\n        }\n      }\n    }\n  };\n\n  Selection.prototype.selectLikeExcel = function (e, rowIndex, cellIndex) {\n    if (!this.isAutoFillSel) {\n      this.clearCellSelection();\n      this.selectCellsByRange({\n        rowIndex: this.startDIndex,\n        cellIndex: this.startDCellIndex\n      }, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n      this.drawBorders();\n    } else {\n      //Autofill\n      this.showAFBorders();\n      this.selectLikeAutoFill(e);\n    }\n  };\n\n  Selection.prototype.drawBorders = function () {\n    if (this.selectionSettings.cellSelectionMode === 'BoxWithBorder' && this.selectedRowCellIndexes.length && !this.parent.isEdit) {\n      this.parent.element.classList.add('e-enabledboxbdr');\n\n      if (!this.bdrElement) {\n        this.createBorders();\n      }\n\n      this.positionBorders();\n    } else {\n      this.showHideBorders('none');\n    }\n  };\n\n  Selection.prototype.isLastCell = function (cell) {\n    var cells = [].slice.call(cell.parentElement.querySelectorAll('.e-rowcell:not(.e-hide)'));\n    return cells[cells.length - 1] === cell;\n  };\n\n  Selection.prototype.isLastRow = function (cell) {\n    var rows = [].slice.call(closest(cell, tbody).querySelectorAll('.e-row:not(.e-hiddenrow)'));\n    return cell.parentElement === rows[rows.length - 1];\n  };\n\n  Selection.prototype.isFirstRow = function (cell) {\n    var rows = [].slice.call(closest(cell, tbody).querySelectorAll('.e-row:not(.e-hiddenrow)'));\n    return cell.parentElement === rows[0];\n  };\n\n  Selection.prototype.isFirstCell = function (cell) {\n    var cells = [].slice.call(cell.parentElement.querySelectorAll('.e-rowcell:not(.e-hide)'));\n    return cells[0] === cell;\n  };\n\n  Selection.prototype.setBorders = function (parentEle, border, bdrStr) {\n    var cells = [].slice.call(parentEle.getElementsByClassName('e-cellselectionbackground')).filter(function (ele) {\n      return ele.style.display === '';\n    });\n\n    if (cells.length) {\n      var isFrozen = this.parent.isFrozenGrid();\n      var start = cells[0];\n      var end = cells[cells.length - 1];\n      var stOff = start.getBoundingClientRect();\n      var endOff = end.getBoundingClientRect();\n      var parentOff = start.offsetParent.getBoundingClientRect();\n      var rowHeight = this.isLastRow(end) && (bdrStr === '1' || bdrStr === '2' || bdrStr === '5') ? 2 : 0;\n      var topOffSet = this.parent.frozenRows && (bdrStr === '1' || bdrStr === '2') && this.isFirstRow(start) ? 1.5 : 0;\n      var leftOffset = isFrozen && (bdrStr === '2' || bdrStr === '4') && this.isFirstCell(start) ? 1 : 0;\n      var rightOffset = (this.parent.getFrozenMode() === 'Right' && (bdrStr === '1' || bdrStr === '3') || this.parent.getFrozenMode() === leftRight && (bdrStr === '5' || bdrStr === '6')) && this.isFirstCell(start) ? 1 : 0;\n\n      if (this.parent.enableRtl) {\n        border.style.right = parentOff.right - stOff.right - leftOffset + 'px';\n        border.style.width = stOff.right - endOff.left + leftOffset + 1 + 'px';\n      } else {\n        border.style.left = stOff.left - parentOff.left - leftOffset - rightOffset + 'px';\n        border.style.width = endOff.right - stOff.left + leftOffset - rightOffset + 1 + 'px';\n      }\n\n      border.style.top = stOff.top - parentOff.top - topOffSet + 'px';\n      border.style.height = endOff.top - stOff.top > 0 ? endOff.top - parentOff.top + endOff.height + 1 - (stOff.top - parentOff.top) - rowHeight + topOffSet + 'px' : endOff.height + topOffSet - rowHeight + 1 + 'px';\n      this.selectDirection += bdrStr;\n    } else {\n      border.style.display = 'none';\n    }\n  };\n\n  Selection.prototype.positionBorders = function () {\n    this.updateStartEndCells();\n\n    if (!this.startCell || !this.bdrElement || !this.selectedRowCellIndexes.length) {\n      return;\n    }\n\n    this.selectDirection = '';\n    this.showHideBorders('');\n    this.setBorders(this.parent.getContentTable(), this.bdrElement, '1');\n\n    if (this.parent.isFrozenGrid()) {\n      this.setBorders(this.parent.contentModule.getMovableContent(), this.mcBdrElement, '2');\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        this.setBorders(this.parent.contentModule.getFrozenRightContent(), this.frcBdrElement, '5');\n      }\n    }\n\n    if (this.parent.frozenRows) {\n      this.setBorders(this.parent.getHeaderTable(), this.fhBdrElement, '3');\n\n      if (this.parent.isFrozenGrid()) {\n        this.setBorders(this.parent.headerModule.getMovableHeader(), this.mhBdrElement, '4');\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.setBorders(this.parent.headerModule.getFrozenRightHeader(), this.frhBdrElement, '6');\n        }\n      }\n    }\n\n    this.applyBorders(this.selectDirection);\n  };\n  /* eslint-enable */\n\n\n  Selection.prototype.applyBothFrozenBorders = function (str) {\n    var rtl = this.parent.enableRtl;\n\n    switch (str.length) {\n      case 6:\n        {\n          this.bdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n          this.mcBdrElement.style.borderWidth = this.bottom;\n          this.fhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n          this.mhBdrElement.style.borderWidth = this.top;\n          this.frcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n          this.frhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n        }\n        break;\n\n      case 4:\n        {\n          if (str.includes('1') && str.includes('2') && str.includes('3') && str.includes('4')) {\n            this.fhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n            this.bdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n            this.mcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n          }\n\n          if (str.includes('2') && str.includes('4') && str.includes('5') && str.includes('6')) {\n            this.mcBdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n            this.frcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n            this.frhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n          }\n        }\n        break;\n\n      case 3:\n        {\n          this.bdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n          this.mcBdrElement.style.borderWidth = this.top_bottom;\n          this.frcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n\n          if (this.parent.frozenRows) {\n            this.fhBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.mhBdrElement.style.borderWidth = this.top_bottom;\n            this.frcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n          }\n        }\n        break;\n\n      case 2:\n        {\n          if (str.includes('1')) {\n            this.mcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n\n            if (this.parent.frozenRows) {\n              this.fhBdrElement.style.borderWidth = this.top_right_left;\n            }\n          }\n\n          if (str.includes('2')) {\n            this.bdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.frcBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n\n            if (this.parent.frozenRows) {\n              this.mhBdrElement.style.borderWidth = this.top_right_left;\n            }\n          }\n\n          if (str.includes('3')) {\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n            this.bdrElement.style.borderWidth = this.right_bottom_left;\n          }\n\n          if (str.includes('4')) {\n            this.fhBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.frhBdrElement.style.borderWidth = rtl ? this.top_bottom_left : this.top_right_bottom;\n            this.mcBdrElement.style.borderWidth = this.right_bottom_left;\n          }\n\n          if (str.includes('5')) {\n            this.mcBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n\n            if (this.parent.frozenRows) {\n              this.frhBdrElement.style.borderWidth = this.top_right_left;\n            }\n          }\n\n          if (str.includes('6')) {\n            this.mhBdrElement.style.borderWidth = rtl ? this.top_right_bottom : this.top_bottom_left;\n            this.frcBdrElement.style.borderWidth = this.right_bottom_left;\n          }\n        }\n        break;\n\n      default:\n        this.bdrElement.style.borderWidth = this.all_border;\n        this.mcBdrElement.style.borderWidth = this.all_border;\n        this.frcBdrElement.style.borderWidth = this.all_border;\n\n        if (this.parent.frozenRows) {\n          this.fhBdrElement.style.borderWidth = this.all_border;\n          this.mhBdrElement.style.borderWidth = this.all_border;\n          this.frhBdrElement.style.borderWidth = this.all_border;\n        }\n\n        break;\n    }\n  };\n\n  Selection.prototype.applyBorders = function (str) {\n    var rtl = this.parent.enableRtl;\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      this.applyBothFrozenBorders(str);\n    } else {\n      switch (str.length) {\n        case 4:\n          {\n            if (this.parent.getFrozenMode() === 'Right') {\n              this.bdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n              this.mcBdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n              this.fhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n              this.mhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n            } else {\n              this.bdrElement.style.borderWidth = rtl ? this.right_bottom : this.bottom_left;\n              this.mcBdrElement.style.borderWidth = rtl ? this.bottom_left : this.right_bottom;\n              this.fhBdrElement.style.borderWidth = rtl ? this.top_right : this.top_left;\n              this.mhBdrElement.style.borderWidth = rtl ? this.top_left : this.top_right;\n            }\n          }\n          break;\n\n        case 2:\n          {\n            if (this.parent.getFrozenMode() === 'Right') {\n              this.bdrElement.style.borderWidth = str.includes('2') ? rtl ? this.top_bottom_left : this.top_right_bottom : this.right_bottom_left;\n              this.mcBdrElement.style.borderWidth = str.includes('1') ? rtl ? this.top_right_bottom : this.top_bottom_left : this.right_bottom_left;\n\n              if (this.parent.frozenRows) {\n                this.fhBdrElement.style.borderWidth = str.includes('1') ? this.top_right_left : rtl ? this.top_bottom_left : this.top_right_bottom;\n                this.mhBdrElement.style.borderWidth = str.includes('2') ? this.top_right_left : rtl ? this.top_right_bottom : this.top_bottom_left;\n              }\n            } else {\n              this.bdrElement.style.borderWidth = str.includes('2') ? rtl ? this.top_right_bottom : this.top_bottom_left : this.right_bottom_left;\n\n              if (this.parent.isFrozenGrid()) {\n                this.mcBdrElement.style.borderWidth = str.includes('1') ? rtl ? this.top_bottom_left : this.top_right_bottom : this.right_bottom_left;\n              }\n\n              if (this.parent.frozenRows) {\n                this.fhBdrElement.style.borderWidth = str.includes('1') ? this.top_right_left : rtl ? this.top_right_bottom : this.top_bottom_left;\n\n                if (this.parent.isFrozenGrid()) {\n                  this.mhBdrElement.style.borderWidth = str.includes('2') ? this.top_right_left : rtl ? this.top_bottom_left : this.top_right_bottom;\n                }\n              }\n            }\n          }\n          break;\n\n        default:\n          this.bdrElement.style.borderWidth = this.all_border;\n\n          if (this.parent.isFrozenGrid()) {\n            this.mcBdrElement.style.borderWidth = this.all_border;\n          }\n\n          if (this.parent.frozenRows) {\n            this.fhBdrElement.style.borderWidth = this.all_border;\n\n            if (this.parent.isFrozenGrid()) {\n              this.mhBdrElement.style.borderWidth = this.all_border;\n            }\n          }\n\n          break;\n      }\n    }\n  };\n\n  Selection.prototype.createBorders = function () {\n    if (!this.bdrElement) {\n      this.bdrElement = this.parent.getContentTable().parentElement.appendChild(createElement('div', {\n        className: 'e-xlsel',\n        id: this.parent.element.id + '_bdr',\n        styles: 'width: 2px; border-width: 0;'\n      }));\n\n      if (this.parent.isFrozenGrid()) {\n        this.mcBdrElement = this.parent.contentModule.getMovableContent().appendChild(createElement('div', {\n          className: 'e-xlsel',\n          id: this.parent.element.id + '_mcbdr',\n          styles: 'height: 2px; border-width: 0;'\n        }));\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frcBdrElement = this.parent.contentModule.getFrozenRightContent().appendChild(createElement('div', {\n            className: 'e-xlsel',\n            id: this.parent.element.id + '_frcbdr',\n            styles: 'height: 2px; border-width: 0;'\n          }));\n        }\n      }\n\n      if (this.parent.frozenRows) {\n        this.fhBdrElement = this.parent.getHeaderTable().parentElement.appendChild(createElement('div', {\n          className: 'e-xlsel',\n          id: this.parent.element.id + '_fhbdr',\n          styles: 'height: 2px;'\n        }));\n      }\n\n      if (this.parent.frozenRows && this.parent.isFrozenGrid()) {\n        this.mhBdrElement = this.parent.headerModule.getMovableHeader().appendChild(createElement('div', {\n          className: 'e-xlsel',\n          id: this.parent.element.id + '_mhbdr',\n          styles: 'height: 2px;'\n        }));\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frhBdrElement = this.parent.headerModule.getFrozenRightHeader().appendChild(createElement('div', {\n            className: 'e-xlsel',\n            id: this.parent.element.id + '_frhbdr',\n            styles: 'height: 2px;'\n          }));\n        }\n      }\n    }\n  };\n\n  Selection.prototype.showHideBorders = function (display) {\n    if (this.bdrElement) {\n      this.bdrElement.style.display = display;\n\n      if (this.parent.isFrozenGrid()) {\n        this.mcBdrElement.style.display = display;\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frcBdrElement.style.display = display;\n        }\n      }\n\n      if (this.parent.frozenRows) {\n        this.fhBdrElement.style.display = display;\n      }\n\n      if (this.parent.frozenRows && this.parent.isFrozenGrid()) {\n        this.mhBdrElement.style.display = display;\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          this.frhBdrElement.style.display = display;\n        }\n      }\n    }\n  };\n\n  Selection.prototype.drawAFBorders = function () {\n    if (!this.bdrAFBottom) {\n      this.createAFBorders();\n    }\n\n    this.positionAFBorders();\n  };\n\n  Selection.prototype.positionAFBorders = function () {\n    if (!this.startCell || !this.bdrAFLeft) {\n      return;\n    }\n\n    var stOff = this.startAFCell.getBoundingClientRect();\n    var endOff = this.endAFCell.getBoundingClientRect();\n    var top = endOff.top - stOff.top > 0 ? 1 : 0;\n    var firstCellTop = endOff.top - stOff.top >= 0 && (parentsUntil(this.startAFCell, movableContent) || parentsUntil(this.startAFCell, 'e-frozencontent')) && this.isFirstRow(this.startAFCell) ? 1.5 : 0;\n    var firstCellLeft = (parentsUntil(this.startAFCell, movableContent) || parentsUntil(this.startAFCell, movableHeader)) && this.isFirstCell(this.startAFCell) ? 1 : 0;\n    var rowHeight = this.isLastRow(this.endAFCell) && (parentsUntil(this.endAFCell, movableContent) || parentsUntil(this.endAFCell, 'e-frozencontent')) ? 2 : 0;\n    var parentOff = this.startAFCell.offsetParent.getBoundingClientRect();\n    var parentRect = this.parent.element.getBoundingClientRect();\n    var sTop = this.startAFCell.offsetParent.parentElement.scrollTop;\n    var sLeft = this.startAFCell.offsetParent.parentElement.scrollLeft;\n    var scrollTop = sTop - this.startAFCell.offsetTop;\n    var scrollLeft = sLeft - this.startAFCell.offsetLeft;\n    var totalHeight = this.parent.element.clientHeight;\n    var totalWidth = this.parent.element.clientWidth;\n    scrollTop = scrollTop > 0 ? Math.floor(scrollTop) - 1 : 0;\n    scrollLeft = scrollLeft > 0 ? scrollLeft : 0;\n    var left = stOff.left - parentRect.left;\n\n    if (!this.parent.enableRtl) {\n      this.bdrAFLeft.style.left = left - firstCellLeft + scrollLeft - 1 + 'px';\n      this.bdrAFRight.style.left = endOff.left - parentRect.left - 2 + endOff.width + 'px';\n      this.bdrAFRight.style.width = totalWidth <= parseInt(this.bdrAFRight.style.left, 10) ? '0px' : '2px';\n      this.bdrAFTop.style.left = left + scrollLeft - 0.5 + 'px';\n      this.bdrAFTop.style.width = parseInt(this.bdrAFRight.style.left, 10) - parseInt(this.bdrAFLeft.style.left, 10) - firstCellLeft + 1 + 'px';\n\n      if (totalWidth <= parseInt(this.bdrAFTop.style.width, 10) + parseInt(this.bdrAFTop.style.left, 10)) {\n        var leftRemove = parseInt(this.bdrAFTop.style.width, 10) + parseInt(this.bdrAFTop.style.left, 10) - totalWidth;\n        this.bdrAFTop.style.width = parseInt(this.bdrAFTop.style.width, 10) - leftRemove + 'px';\n      }\n    } else {\n      var scrolloffSet = parentsUntil(this.startAFCell, movableContent) || parentsUntil(this.startAFCell, movableHeader) ? stOff.right - this.startAFCell.offsetParent.parentElement.getBoundingClientRect().width - parentRect.left : 0;\n      this.bdrAFLeft.style.right = parentRect.right - endOff.right - 2 + endOff.width + 'px';\n      this.bdrAFLeft.style.width = totalWidth <= parseInt(this.bdrAFLeft.style.right, 10) ? '0px' : '2px';\n      this.bdrAFRight.style.right = parentRect.right - stOff.right - firstCellLeft + scrolloffSet - 1 + 'px';\n      this.bdrAFTop.style.left = endOff.left - parentRect.left - 0.5 + 'px';\n      this.bdrAFTop.style.width = parseInt(this.bdrAFLeft.style.right, 10) - parseInt(this.bdrAFRight.style.right, 10) - firstCellLeft + 1 + 'px';\n\n      if (parseInt(this.bdrAFTop.style.left, 10) < 0) {\n        this.bdrAFTop.style.width = parseInt(this.bdrAFTop.style.width, 10) + parseInt(this.bdrAFTop.style.left, 10) + 'px';\n        this.bdrAFTop.style.left = '0px';\n      }\n    }\n\n    this.bdrAFLeft.style.top = stOff.top - parentRect.top - firstCellTop + scrollTop + 'px';\n    this.bdrAFLeft.style.height = endOff.top - stOff.top > 0 ? endOff.top - parentOff.top + endOff.height + 1 - (stOff.top - parentOff.top) + firstCellTop - rowHeight - scrollTop + 'px' : endOff.height + firstCellTop - rowHeight - scrollTop + 'px';\n    this.bdrAFRight.style.top = this.bdrAFLeft.style.top;\n    this.bdrAFRight.style.height = parseInt(this.bdrAFLeft.style.height, 10) + 'px';\n    this.bdrAFTop.style.top = this.bdrAFRight.style.top;\n    this.bdrAFBottom.style.left = this.bdrAFTop.style.left;\n    this.bdrAFBottom.style.top = parseFloat(this.bdrAFLeft.style.top) + parseFloat(this.bdrAFLeft.style.height) - top - 1 + 'px';\n    this.bdrAFBottom.style.width = totalHeight <= parseFloat(this.bdrAFBottom.style.top) ? '0px' : this.bdrAFTop.style.width;\n\n    if (totalHeight <= parseInt(this.bdrAFLeft.style.height, 10) + parseInt(this.bdrAFLeft.style.top, 10)) {\n      var topRemove = parseInt(this.bdrAFLeft.style.height, 10) + parseInt(this.bdrAFLeft.style.top, 10) - totalHeight;\n      this.bdrAFLeft.style.height = parseInt(this.bdrAFLeft.style.height, 10) - topRemove + 'px';\n      this.bdrAFRight.style.height = parseInt(this.bdrAFLeft.style.height, 10) + 'px';\n    }\n  };\n\n  Selection.prototype.createAFBorders = function () {\n    if (!this.bdrAFLeft) {\n      this.bdrAFLeft = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdrafleft',\n        styles: 'width: 2px;'\n      }));\n      this.bdrAFRight = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdrafright',\n        styles: 'width: 2px;'\n      }));\n      this.bdrAFBottom = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdrafbottom',\n        styles: 'height: 2px;'\n      }));\n      this.bdrAFTop = this.parent.element.appendChild(createElement('div', {\n        className: 'e-xlselaf',\n        id: this.parent.element.id + '_bdraftop',\n        styles: 'height: 2px;'\n      }));\n    }\n  };\n\n  Selection.prototype.showAFBorders = function () {\n    if (this.bdrAFLeft) {\n      this.bdrAFLeft.style.display = '';\n      this.bdrAFRight.style.display = '';\n      this.bdrAFBottom.style.display = '';\n      this.bdrAFTop.style.display = '';\n    }\n  };\n\n  Selection.prototype.hideAFBorders = function () {\n    if (this.bdrAFLeft) {\n      this.bdrAFLeft.style.display = 'none';\n      this.bdrAFRight.style.display = 'none';\n      this.bdrAFBottom.style.display = 'none';\n      this.bdrAFTop.style.display = 'none';\n    }\n  };\n\n  Selection.prototype.updateValue = function (rIdx, cIdx, cell) {\n    var args = this.createBeforeAutoFill(rIdx, cIdx, cell);\n\n    if (!args.cancel) {\n      var col = this.parent.getColumnByIndex(cIdx);\n\n      if (this.parent.editModule && cell) {\n        if (col.type === 'number') {\n          this.parent.editModule.updateCell(rIdx, col.field, parseFloat(args.value));\n        } else {\n          this.parent.editModule.updateCell(rIdx, col.field, args.value);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.createBeforeAutoFill = function (rowIndex, colIndex, cell) {\n    var col = this.parent.getColumnByIndex(colIndex);\n    var args = {\n      column: col,\n      value: cell.innerText\n    };\n    this.parent.trigger(beforeAutoFill, args);\n    return args;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Selection.prototype.getAutoFillCells = function (rowIndex, startCellIdx) {\n    var cls = '.e-cellselectionbackground';\n    var cells = [].slice.call(this.parent.getDataRows()[rowIndex].querySelectorAll(cls));\n\n    if (this.parent.isFrozenGrid()) {\n      cells = cells.concat([].slice.call(this.parent.getMovableDataRows()[rowIndex].querySelectorAll(cls)));\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        cells = cells.concat([].slice.call(this.parent.getFrozenRightDataRows()[rowIndex].querySelectorAll(cls)));\n      }\n    }\n\n    return cells;\n  };\n\n  Selection.prototype.selectLikeAutoFill = function (e, isApply) {\n    var startrowIdx = parseInt(parentsUntil(this.startAFCell, row).getAttribute(dataRowIndex), 10);\n    var startCellIdx = parseInt(this.startAFCell.getAttribute(dataColIndex), 10);\n    var endrowIdx = parseInt(parentsUntil(this.endAFCell, row).getAttribute(dataRowIndex), 10);\n    var endCellIdx = parseInt(this.endAFCell.getAttribute(dataColIndex), 10);\n    var rowLen = this.selectedRowCellIndexes.length - 1;\n    var colLen = this.selectedRowCellIndexes[0].cellIndexes.length - 1;\n\n    switch (true) {\n      //direction\n      case !isApply && this.endAFCell.classList.contains('e-cellselectionbackground') && !!parentsUntil(e.target, rowCell):\n        this.startAFCell = this.parent.getCellFromIndex(startrowIdx, startCellIdx);\n        this.endAFCell = this.parent.getCellFromIndex(startrowIdx + rowLen, startCellIdx + colLen);\n        this.drawAFBorders();\n        break;\n\n      case this.autoFillRLselection && startCellIdx + colLen < endCellIdx && //right\n      endCellIdx - startCellIdx - colLen + 1 > endrowIdx - startrowIdx - rowLen // right bottom\n      && endCellIdx - startCellIdx - colLen + 1 > startrowIdx - endrowIdx:\n        //right top\n        this.endAFCell = this.parent.getCellFromIndex(startrowIdx + rowLen, endCellIdx);\n        endrowIdx = parseInt(parentsUntil(this.endAFCell, row).getAttribute(dataRowIndex), 10);\n        endCellIdx = parseInt(this.endAFCell.getAttribute(dataColIndex), 10);\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          var cellIdx = parseInt(this.endCell.getAttribute(dataColIndex), 10);\n\n          for (var i = startrowIdx; i <= endrowIdx; i++) {\n            var cells = this.getAutoFillCells(i, startCellIdx);\n            var c = 0;\n\n            for (var j = cellIdx + 1; j <= endCellIdx; j++) {\n              if (c > colLen) {\n                c = 0;\n              }\n\n              this.updateValue(i, j, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: startrowIdx,\n            cellIndex: this.startCellIndex\n          }, {\n            rowIndex: endrowIdx,\n            cellIndex: endCellIdx\n          });\n        }\n\n        break;\n\n      case this.autoFillRLselection && startCellIdx > endCellIdx && // left\n      startCellIdx - endCellIdx + 1 > endrowIdx - startrowIdx - rowLen && //left top\n      startCellIdx - endCellIdx + 1 > startrowIdx - endrowIdx:\n        // left bottom\n        this.startAFCell = this.parent.getCellFromIndex(startrowIdx, endCellIdx);\n        this.endAFCell = this.endCell;\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          for (var i = startrowIdx; i <= startrowIdx + rowLen; i++) {\n            var cells = this.getAutoFillCells(i, startCellIdx);\n            cells.reverse();\n            var c = 0;\n\n            for (var j = this.startCellIndex - 1; j >= endCellIdx; j--) {\n              if (c > colLen) {\n                c = 0;\n              }\n\n              this.updateValue(i, j, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: startrowIdx,\n            cellIndex: endCellIdx\n          }, {\n            rowIndex: startrowIdx + rowLen,\n            cellIndex: this.startCellIndex + colLen\n          });\n        }\n\n        break;\n\n      case startrowIdx > endrowIdx:\n        //up\n        this.startAFCell = this.parent.getCellFromIndex(endrowIdx, startCellIdx);\n        this.endAFCell = this.endCell;\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          var trIdx = parseInt(this.endCell.parentElement.getAttribute(dataRowIndex), 10);\n          var r = trIdx;\n\n          for (var i = startrowIdx - 1; i >= endrowIdx; i--) {\n            if (r === this.startIndex - 1) {\n              r = trIdx;\n            }\n\n            var cells = this.getAutoFillCells(r, startCellIdx);\n            var c = 0;\n            r--;\n\n            for (var j = this.startCellIndex; j <= this.startCellIndex + colLen; j++) {\n              this.updateValue(i, j, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: endrowIdx,\n            cellIndex: startCellIdx + colLen\n          }, {\n            rowIndex: startrowIdx + rowLen,\n            cellIndex: startCellIdx\n          });\n        }\n\n        break;\n\n      default:\n        //down\n        this.endAFCell = this.parent.getCellFromIndex(endrowIdx, startCellIdx + colLen);\n\n        if (!isApply) {\n          this.drawAFBorders();\n        } else {\n          var trIdx = parseInt(this.endCell.parentElement.getAttribute(dataRowIndex), 10);\n          var r = this.startIndex;\n\n          for (var i = trIdx + 1; i <= endrowIdx; i++) {\n            if (r === trIdx + 1) {\n              r = this.startIndex;\n            }\n\n            var cells = this.getAutoFillCells(r, startCellIdx);\n            r++;\n            var c = 0;\n\n            for (var m = this.startCellIndex; m <= this.startCellIndex + colLen; m++) {\n              this.updateValue(i, m, cells[c]);\n              c++;\n            }\n          }\n\n          this.selectCellsByRange({\n            rowIndex: trIdx - rowLen,\n            cellIndex: startCellIdx\n          }, {\n            rowIndex: endrowIdx,\n            cellIndex: startCellIdx + colLen\n          });\n        }\n\n        break;\n    }\n  };\n\n  Selection.prototype.mouseUpHandler = function (e) {\n    document.body.classList.remove('e-disableuserselect');\n\n    if (this.element) {\n      remove(this.element);\n    }\n\n    if (this.isDragged && this.selectedRowCellIndexes.length === 1 && this.selectedRowCellIndexes[0].cellIndexes.length === 1) {\n      this.mUPTarget = parentsUntil(e.target, rowCell);\n    } else {\n      this.mUPTarget = null;\n    }\n\n    if (this.isDragged && !this.isAutoFillSel && this.selectionSettings.mode === 'Cell' && e.target.classList.contains(rowCell)) {\n      var target = e.target;\n      var rowIndex = parseInt(target.parentElement.getAttribute(dataRowIndex), 10);\n      var cellIndex = parseInt(target.getAttribute(dataColIndex), 10);\n      this.isDragged = false;\n      this.clearCellSelection();\n      this.selectCellsByRange({\n        rowIndex: this.startDIndex,\n        cellIndex: this.startDCellIndex\n      }, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n    }\n\n    this.isDragged = false;\n    this.updateAutoFillPosition();\n\n    if (this.isAutoFillSel) {\n      var lastCell = parentsUntil(e.target, rowCell);\n      this.endAFCell = lastCell ? lastCell : this.endCell === this.endAFCell ? this.startAFCell : this.endAFCell;\n      this.startAFCell = this.startCell;\n      this.updateStartCellsIndex();\n      this.selectLikeAutoFill(e, true);\n      this.updateAutoFillPosition();\n      this.hideAFBorders();\n      this.positionBorders();\n      this.isAutoFillSel = false;\n    }\n\n    EventHandler.remove(this.parent.getContent(), 'mousemove', this.mouseMoveHandler);\n\n    if (this.parent.frozenRows) {\n      EventHandler.remove(this.parent.getHeaderContent(), 'mousemove', this.mouseMoveHandler);\n    }\n\n    EventHandler.remove(document, 'mouseup', this.mouseUpHandler);\n  };\n\n  Selection.prototype.hideAutoFill = function () {\n    if (this.autofill) {\n      this.autofill.style.display = 'none';\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.updateAutoFillPosition = function () {\n    if (this.parent.enableAutoFill && !this.parent.isEdit && this.selectionSettings.cellSelectionMode.indexOf('Box') > -1 && !this.isRowType() && !this.isSingleSel() && this.selectedRowCellIndexes.length) {\n      var index = parseInt(this.target.getAttribute(dataColIndex), 10);\n      var rindex = parseInt(this.target.getAttribute('index'), 10);\n      var rowIndex = this.selectedRowCellIndexes[this.selectedRowCellIndexes.length - 1].rowIndex;\n      var cells = this.getAutoFillCells(rowIndex, index).filter(function (ele) {\n        return ele.style.display === '';\n      });\n      var col = this.parent.getColumnByIndex(index);\n      var isFrozenCol = col.getFreezeTableName() === 'movable';\n      var isFrozenRow = rindex < this.parent.frozenRows;\n      var isFrozenRight = this.parent.getFrozenMode() === leftRight && col.getFreezeTableName() === frozenRight;\n\n      if (!select('#' + this.parent.element.id + '_autofill', parentsUntil(this.target, table))) {\n        if (select('#' + this.parent.element.id + '_autofill', this.parent.element)) {\n          select('#' + this.parent.element.id + '_autofill', this.parent.element).remove();\n        }\n\n        this.autofill = createElement('div', {\n          className: 'e-autofill',\n          id: this.parent.element.id + '_autofill'\n        });\n        this.autofill.style.display = 'none';\n\n        if (!isFrozenRow) {\n          if (!isFrozenCol) {\n            this.parent.getContentTable().parentElement.appendChild(this.autofill);\n          } else {\n            this.parent.contentModule.getMovableContent().appendChild(this.autofill);\n          }\n        } else {\n          if (!isFrozenCol) {\n            this.parent.getHeaderTable().parentElement.appendChild(this.autofill);\n          } else {\n            this.parent.headerModule.getMovableHeader().appendChild(this.autofill);\n          }\n        }\n\n        if (isFrozenRight) {\n          if (isFrozenRow) {\n            this.parent.getFrozenRightHeader().appendChild(this.autofill);\n          } else {\n            this.parent.getFrozenRightContent().appendChild(this.autofill);\n          }\n        }\n      }\n\n      var cell = cells[cells.length - 1];\n\n      if (cell && cell.offsetParent) {\n        var clientRect = cell.getBoundingClientRect();\n        var parentOff = cell.offsetParent.getBoundingClientRect();\n        var colWidth = this.isLastCell(cell) ? 4 : 0;\n        var rowHeight = this.isLastRow(cell) ? 3 : 0;\n\n        if (!this.parent.enableRtl) {\n          this.autofill.style.left = clientRect.left - parentOff.left + clientRect.width - 4 - colWidth + 'px';\n        } else {\n          this.autofill.style.right = parentOff.right - clientRect.right + clientRect.width - 4 - colWidth + 'px';\n        }\n\n        this.autofill.style.top = clientRect.top - parentOff.top + clientRect.height - 5 - rowHeight + 'px';\n      }\n\n      this.autofill.style.display = '';\n    } else {\n      this.hideAutoFill();\n    }\n  };\n\n  Selection.prototype.mouseDownHandler = function (e) {\n    this.mouseButton = e.button;\n    var target = e.target;\n    var gObj = this.parent;\n    var isDrag;\n    var gridElement = parentsUntil(target, 'e-grid');\n\n    if (gridElement && gridElement.id !== gObj.element.id || parentsUntil(target, headerContent) && !this.parent.frozenRows || parentsUntil(target, 'e-editedbatchcell') || parentsUntil(target, editedRow)) {\n      return;\n    }\n\n    if (e.shiftKey || e.ctrlKey) {\n      e.preventDefault();\n    }\n\n    if (parentsUntil(target, rowCell) && !e.shiftKey && !e.ctrlKey) {\n      if (gObj.selectionSettings.cellSelectionMode.indexOf('Box') > -1 && !this.isRowType() && !this.isSingleSel()) {\n        this.isCellDrag = true;\n        isDrag = true;\n      } else if (gObj.allowRowDragAndDrop && !gObj.isEdit && !this.parent.selectionSettings.checkboxOnly) {\n        this.isRowDragSelected = false;\n\n        if (!this.isRowType() || this.isSingleSel() || closest(target, 'td').classList.contains('e-selectionbackground')) {\n          this.isDragged = false;\n          return;\n        }\n\n        isDrag = true;\n        this.element = this.parent.createElement('div', {\n          className: 'e-griddragarea'\n        });\n        gObj.getContent().appendChild(this.element);\n      }\n\n      if (isDrag) {\n        this.enableDrag(e, true);\n      }\n    }\n\n    this.updateStartEndCells();\n\n    if (target.classList.contains('e-autofill') || target.classList.contains('e-xlsel')) {\n      this.isCellDrag = true;\n      this.isAutoFillSel = true;\n      this.enableDrag(e);\n    }\n  };\n\n  Selection.prototype.updateStartEndCells = function () {\n    var cells = [].slice.call(this.parent.element.getElementsByClassName('e-cellselectionbackground'));\n    this.startCell = cells[0];\n    this.endCell = cells[cells.length - 1];\n\n    if (this.startCell) {\n      this.startIndex = parseInt(this.startCell.parentElement.getAttribute(dataRowIndex), 10);\n      this.startCellIndex = parseInt(parentsUntil(this.startCell, rowCell).getAttribute(dataColIndex), 10);\n    }\n  };\n\n  Selection.prototype.updateStartCellsIndex = function () {\n    if (this.startCell) {\n      this.startIndex = parseInt(this.startCell.parentElement.getAttribute(dataRowIndex), 10);\n      this.startCellIndex = parseInt(parentsUntil(this.startCell, rowCell).getAttribute(dataColIndex), 10);\n    }\n  };\n\n  Selection.prototype.enableDrag = function (e, isUpdate) {\n    var gObj = this.parent;\n\n    if (isUpdate) {\n      var tr = closest(e.target, 'tr');\n      this.startDIndex = parseInt(tr.getAttribute(dataRowIndex), 10);\n      this.startDCellIndex = parseInt(parentsUntil(e.target, rowCell).getAttribute(dataColIndex), 10);\n    }\n\n    document.body.classList.add('e-disableuserselect');\n    var gBRect = gObj.element.getBoundingClientRect();\n    var postion = getPosition(e);\n    this.x = postion.x - gBRect.left;\n    this.y = postion.y - gBRect.top;\n    EventHandler.add(gObj.getContent(), 'mousemove', this.mouseMoveHandler, this);\n\n    if (this.parent.frozenRows) {\n      EventHandler.add(gObj.getHeaderContent(), 'mousemove', this.mouseMoveHandler, this);\n    }\n\n    EventHandler.add(document, 'mouseup', this.mouseUpHandler, this);\n  };\n\n  Selection.prototype.clearSelAfterRefresh = function (e) {\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && e.requestType === 'infiniteScroll';\n\n    if (e.requestType !== 'virtualscroll' && !this.parent.isPersistSelection && !isInfiniteScroll) {\n      this.clearSelection();\n    }\n\n    if ((e.requestType === 'virtualscroll' || isInfiniteScroll) && this.parent.isPersistSelection && this.isPartialSelection && this.isHdrSelectAllClicked) {\n      var rowObj = this.parent.getRowsObject().filter(function (e) {\n        return e.isSelectable;\n      });\n      var indexes = [];\n      this.selectedRowState = {};\n      this.persistSelectedData = [];\n\n      for (var i = 0; i < rowObj.length; i++) {\n        indexes.push(rowObj[i].index);\n        var pkValue = this.getPkValue(this.primaryKey, rowObj[i].data);\n        this.selectedRowState[pkValue] = true;\n        this.persistSelectedData.push(rowObj[i].data);\n      }\n\n      this.selectedRowIndexes = indexes;\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: uiUpdate,\n      handler: this.enableAfterRender\n    }, {\n      event: initialEnd,\n      handler: this.initializeSelection\n    }, {\n      event: rowSelectionComplete,\n      handler: this.onActionComplete\n    }, {\n      event: cellSelectionComplete,\n      handler: this.onActionComplete\n    }, {\n      event: inBoundModelChanged,\n      handler: this.onPropertyChanged\n    }, {\n      event: cellFocused,\n      handler: this.onCellFocused\n    }, {\n      event: beforeFragAppend,\n      handler: this.clearSelAfterRefresh\n    }, {\n      event: columnPositionChanged,\n      handler: this.columnPositionChanged\n    }, {\n      event: contentReady,\n      handler: this.initialEnd\n    }, {\n      event: rowsRemoved,\n      handler: this.rowsRemoved\n    }, {\n      event: headerRefreshed,\n      handler: this.refreshHeader\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.actionBeginFunction = this.actionBegin.bind(this);\n    this.actionCompleteFunction = this.actionComplete.bind(this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunction);\n    this.addEventListener_checkbox();\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunction);\n    this.removeEventListener_checkbox();\n  };\n\n  Selection.prototype.wireEvents = function () {\n    this.isMacOS = navigator.userAgent.indexOf('Mac OS') !== -1;\n\n    if (this.isMacOS) {\n      EventHandler.add(this.parent.element, 'keydown', this.keyDownHandler, this);\n      EventHandler.add(this.parent.element, 'keyup', this.keyUpHandler, this);\n    } else {\n      if (!this.parent.allowKeyboard) {\n        EventHandler.add(this.parent.element, 'keydown', this.keyDownHandler, this);\n      }\n    }\n  };\n\n  Selection.prototype.unWireEvents = function () {\n    if (this.isMacOS) {\n      EventHandler.remove(this.parent.element, 'keydown', this.keyDownHandler);\n      EventHandler.remove(this.parent.element, 'keyup', this.keyUpHandler);\n    } else {\n      if (!this.parent.allowKeyboard) {\n        EventHandler.remove(this.parent.element, 'keydown', this.keyDownHandler);\n      }\n    }\n  };\n\n  Selection.prototype.columnPositionChanged = function () {\n    if (!this.parent.isPersistSelection) {\n      this.clearSelection();\n    }\n  };\n\n  Selection.prototype.refreshHeader = function () {\n    this.setCheckAllState();\n  };\n\n  Selection.prototype.rowsRemoved = function (e) {\n    for (var i = 0; i < e.records.length; i++) {\n      var pkValue = this.getPkValue(this.primaryKey, e.records[i]);\n      delete this.selectedRowState[pkValue];\n      --this.totalRecordsCount;\n    }\n\n    this.setCheckAllState();\n  };\n\n  Selection.prototype.beforeFragAppend = function (e) {\n    if (e.requestType !== 'virtualscroll' && !this.parent.isPersistSelection) {\n      this.clearSelection();\n    }\n  };\n\n  Selection.prototype.getCheckAllBox = function () {\n    return this.parent.getHeaderContent().querySelector('.e-checkselectall');\n  };\n\n  Selection.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n      this.initPerisistSelection();\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Selection.prototype.render = function (e) {\n    EventHandler.add(this.parent.getContent(), 'mousedown', this.mouseDownHandler, this);\n    EventHandler.add(this.parent.getHeaderContent(), 'mousedown', this.mouseDownHandler, this);\n  };\n\n  Selection.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    var gObj = this.parent;\n\n    if (!isNullOrUndefined(e.properties.type) && this.selectionSettings.type === 'Single') {\n      if (this.selectedRowCellIndexes.length > 1) {\n        this.clearCellSelection();\n        this.prevCIdxs = undefined;\n      }\n\n      if (this.selectedRowIndexes.length > 1) {\n        this.clearRowSelection();\n        this.prevRowIndex = undefined;\n      }\n\n      if (this.selectedColumnsIndexes.length > 1) {\n        this.clearColumnSelection();\n        this.prevColIndex = undefined;\n      }\n\n      this.enableSelectMultiTouch = false;\n      this.hidePopUp();\n    }\n\n    if (!isNullOrUndefined(e.properties.mode) || !isNullOrUndefined(e.properties.cellSelectionMode)) {\n      this.clearSelection();\n      this.prevRowIndex = undefined;\n      this.prevCIdxs = undefined;\n      this.prevColIndex = undefined;\n    }\n\n    this.isPersisted = true;\n    this.checkBoxSelectionChanged();\n    this.isPersisted = false;\n\n    if (!this.parent.isCheckBoxSelection) {\n      this.initPerisistSelection();\n    }\n\n    var checkboxColumn = this.parent.getColumns().filter(function (col) {\n      return col.type === 'checkbox';\n    });\n\n    if (checkboxColumn.length) {\n      gObj.isCheckBoxSelection = !(this.selectionSettings.checkboxMode === 'ResetOnRowClick');\n    }\n\n    this.drawBorders();\n  };\n\n  Selection.prototype.hidePopUp = function () {\n    if (this.parent.element.querySelector('.e-gridpopup').getElementsByClassName('e-rowselect').length) {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    }\n  };\n\n  Selection.prototype.initialEnd = function (e) {\n    var isFrozen = this.parent.isFrozenGrid();\n    var isLeftRightFrozen = this.parent.getFrozenMode() === leftRight;\n\n    if ((!isFrozen || isFrozen && !isLeftRightFrozen && !e.args.isFrozen || isLeftRightFrozen && e.args.renderFrozenRightContent) && !this.selectedRowIndexes.length) {\n      this.parent.off(contentReady, this.initialEnd);\n      this.selectRow(this.parent.selectedRowIndex);\n    }\n  };\n\n  Selection.prototype.checkBoxSelectionChanged = function () {\n    var gobj = this.parent;\n    gobj.off(contentReady, this.checkBoxSelectionChanged);\n    var checkboxColumn = gobj.getColumns().filter(function (col) {\n      return col.type === 'checkbox';\n    });\n\n    if (checkboxColumn.length > 0) {\n      gobj.isCheckBoxSelection = true;\n      this.chkField = checkboxColumn[0].field;\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n\n      if (isNullOrUndefined(this.totalRecordsCount)) {\n        this.totalRecordsCount = this.getCurrentBatchRecordChanges().length;\n      }\n\n      if (this.isSingleSel()) {\n        gobj.selectionSettings.type = 'Multiple';\n        gobj.dataBind();\n      } else {\n        this.initPerisistSelection();\n      }\n    }\n\n    if (!gobj.isCheckBoxSelection && !this.isPersisted) {\n      this.chkField = null;\n      this.initPerisistSelection();\n    }\n  };\n\n  Selection.prototype.initPerisistSelection = function () {\n    var gobj = this.parent;\n\n    if (this.parent.selectionSettings.persistSelection && this.parent.getPrimaryKeyFieldNames().length > 0) {\n      gobj.isPersistSelection = true;\n      this.ensureCheckboxFieldSelection();\n    } else if (this.parent.getPrimaryKeyFieldNames().length > 0) {\n      gobj.isPersistSelection = false;\n      this.ensureCheckboxFieldSelection();\n    } else {\n      gobj.isPersistSelection = false;\n      this.selectedRowState = {};\n    }\n  };\n\n  Selection.prototype.ensureCheckboxFieldSelection = function () {\n    var gobj = this.parent;\n    this.primaryKey = this.parent.getPrimaryKeyFieldNames()[0];\n\n    if (!gobj.enableVirtualization && this.chkField && (gobj.isPersistSelection && Object.keys(this.selectedRowState).length === 0 || !gobj.isPersistSelection)) {\n      var data = this.parent.getDataModule();\n      var query = new Query().where(this.chkField, 'equal', true);\n\n      if (!query.params) {\n        query.params = this.parent.query.params;\n      }\n\n      var dataManager = data.getData({}, query); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      var proxy_1 = this;\n      this.parent.showSpinner();\n      dataManager.then(function (e) {\n        proxy_1.dataSuccess(e.result);\n        proxy_1.refreshPersistSelection();\n        proxy_1.parent.hideSpinner();\n      });\n    }\n  };\n\n  Selection.prototype.dataSuccess = function (res) {\n    for (var i = 0; i < res.length; i++) {\n      var pkValue = this.getPkValue(this.primaryKey, res[i]);\n\n      if (isNullOrUndefined(this.selectedRowState[pkValue]) && res[i][this.chkField]) {\n        this.selectedRowState[pkValue] = res[i][this.chkField];\n      }\n    }\n\n    this.persistSelectedData = res;\n  };\n\n  Selection.prototype.setRowSelection = function (state) {\n    if (!this.parent.getDataModule().isRemote()) {\n      if (state) {\n        if (this.isPartialSelection && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling)) {\n          var rowObj = this.parent.getRowsObject().filter(function (e) {\n            return e.isSelectable;\n          });\n\n          for (var _i = 0, rowObj_1 = rowObj; _i < rowObj_1.length; _i++) {\n            var row$$1 = rowObj_1[_i];\n            this.selectedRowState[this.getPkValue(this.primaryKey, row$$1.data)] = true;\n          }\n        } else {\n          var selectedData = this.isPartialSelection ? this.parent.partialSelectedRecords : this.getData();\n\n          if (this.parent.groupSettings.columns.length) {\n            for (var _a = 0, _b = this.isPartialSelection ? selectedData : selectedData.records; _a < _b.length; _a++) {\n              var data = _b[_a];\n              this.selectedRowState[this.getPkValue(this.primaryKey, data)] = true;\n            }\n          } else {\n            for (var _c = 0, selectedData_1 = selectedData; _c < selectedData_1.length; _c++) {\n              var data = selectedData_1[_c];\n              this.selectedRowState[this.getPkValue(this.primaryKey, data)] = true;\n            }\n          }\n        }\n      } else {\n        this.selectedRowState = {};\n      } // (this.getData()).forEach(function (data) {\n      //     this.selectedRowState[data[this.primaryKey]] = true;\n      // })\n\n    } else {\n      if (state) {\n        var selectedStateKeys = Object.keys(this.selectedRowState);\n        var unSelectedRowStateKeys = Object.keys(this.unSelectedRowState);\n\n        for (var _d = 0, _e = this.parent.currentViewData; _d < _e.length; _d++) {\n          var data = _e[_d];\n          var key = data[this.primaryKey].toString();\n\n          if (selectedStateKeys.indexOf(key) === -1 && unSelectedRowStateKeys.indexOf(key) === -1) {\n            this.selectedRowState[data[this.primaryKey]] = true;\n          }\n        }\n      } else {\n        this.selectedRowState = {};\n        this.unSelectedRowState = {};\n        this.rmtHdrChkbxClicked = false;\n      }\n    }\n  };\n\n  Selection.prototype.getData = function () {\n    return this.parent.getDataModule().dataManager.executeLocal(this.parent.getDataModule().generateQuery(true));\n  };\n\n  Selection.prototype.refreshPersistSelection = function () {\n    var rows = this.parent.getRows();\n\n    if (this.parent.isCheckBoxSelection && this.parent.isFrozenGrid()) {\n      var mtbody = this.parent.getMovableContentTbody();\n\n      if (mtbody.querySelector('.e-checkselect')) {\n        rows = this.parent.getMovableRows();\n      }\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        var frtbody = this.parent.getFrozenRightContentTbody();\n\n        if (frtbody.querySelector('.e-checkselect')) {\n          rows = this.parent.getFrozenRightRows();\n        }\n      }\n    }\n\n    this.totalRecordsCount = this.parent.getCurrentViewRecords().length;\n\n    if (this.parent.allowPaging) {\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n    }\n\n    if (rows !== null && rows.length > 0 && (this.parent.isPersistSelection || this.chkField)) {\n      var indexes = [];\n\n      for (var j = 0; j < rows.length; j++) {\n        var rowObj = this.getRowObj(rows[j]);\n        var pKey = rowObj ? rowObj.data ? this.getPkValue(this.primaryKey, rowObj.data) : null : null;\n\n        if (pKey === null) {\n          return;\n        }\n\n        if (this.isPartialSelection && !rowObj.isSelectable) {\n          continue;\n        }\n\n        var checkState = void 0;\n        var chkBox = rows[j].querySelector('.e-checkselect');\n\n        if (this.selectedRowState[pKey] || this.parent.checkAllRows === 'Check' && this.selectedRowState[pKey] && this.totalRecordsCount === Object.keys(this.selectedRowState).length && this.chkAllCollec.indexOf(pKey) < 0 || this.parent.checkAllRows === 'Uncheck' && this.chkAllCollec.indexOf(pKey) > 0 && !this.parent.selectedRowIndex || this.parent.checkAllRows === 'Intermediate' && !isNullOrUndefined(this.chkField) && rowObj.data[this.chkField]) {\n          indexes.push(parseInt(rows[j].getAttribute(dataRowIndex), 10));\n          checkState = true;\n        } else {\n          checkState = false;\n\n          if (this.checkedTarget !== chkBox && this.parent.isCheckBoxSelection && chkBox) {\n            removeAddCboxClasses(chkBox.nextElementSibling, checkState);\n          }\n        }\n\n        this.updatePersistCollection(rows[j], checkState);\n      }\n\n      if (this.isSingleSel() && indexes.length > 0) {\n        this.selectRow(indexes[0], true);\n      } else {\n        this.selectRows(indexes);\n      }\n    }\n\n    if (this.parent.isCheckBoxSelection && this.getCurrentBatchRecordChanges().length > 0) {\n      this.setCheckAllState();\n    }\n  };\n\n  Selection.prototype.actionBegin = function (e) {\n    if (e.requestType === 'save' && this.parent.isPersistSelection) {\n      var editChkBox = this.parent.element.querySelector('.e-edit-checkselect');\n\n      if (!isNullOrUndefined(editChkBox)) {\n        var row$$1 = closest(editChkBox, '.' + editedRow);\n\n        if (row$$1) {\n          if (this.parent.editSettings.mode === 'Dialog') {\n            row$$1 = this.parent.element.querySelector('.e-dlgeditrow');\n          }\n\n          var rowObj = this.getRowObj(row$$1);\n\n          if (!rowObj) {\n            return;\n          }\n\n          this.selectedRowState[this.getPkValue(this.primaryKey, rowObj.data)] = rowObj.isSelected = editChkBox.checked;\n        } else {\n          this.isCheckedOnAdd = editChkBox.checked;\n        }\n      }\n    }\n\n    if (this.parent.isPersistSelection && this.isPartialSelection) {\n      if (e.requestType === 'paging' && this.parent.getDataModule().isRemote()) {\n        this.selectedRowIndexes = [];\n      }\n\n      if (e.requestType === 'filtering' || e.requestType === 'searching') {\n        this.parent.partialSelectedRecords = [];\n        this.parent.disableSelectedRecords = [];\n      }\n    }\n  };\n\n  Selection.prototype.actionComplete = function (e) {\n    if (e.requestType === 'save' && this.parent.isPersistSelection) {\n      if (e.action === 'add') {\n        if (this.isCheckedOnAdd) {\n          var rowObj = this.parent.getRowObjectFromUID(this.parent.getRows()[e.selectedRow].getAttribute('data-uid'));\n          this.selectedRowState[this.getPkValue(this.primaryKey, rowObj.data)] = rowObj.isSelected = this.isCheckedOnAdd;\n        }\n\n        this.isHdrSelectAllClicked = false;\n        this.setCheckAllState();\n      }\n\n      this.refreshPersistSelection();\n    }\n\n    if (e.requestType === 'delete' && this.parent.isPersistSelection) {\n      var records = e.data;\n      var data = records.slice();\n\n      for (var i = 0; i < data.length; i++) {\n        var pkValue = this.getPkValue(this.primaryKey, data[i]);\n\n        if (!isNullOrUndefined(pkValue)) {\n          this.updatePersistDelete(pkValue, this.isPartialSelection);\n        }\n      }\n\n      this.isHdrSelectAllClicked = false;\n      this.setCheckAllState();\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n    }\n\n    if (e.requestType === 'paging') {\n      if (this.parent.isPersistSelection && this.isPartialSelection && this.isHdrSelectAllClicked) {\n        var rows = this.parent.getRowsObject();\n        var indexes = [];\n\n        for (var i = 0; i < rows.length; i++) {\n          if (rows[i].isSelectable) {\n            indexes.push(rows[i].index);\n          }\n        }\n\n        if (indexes.length) {\n          this.selectRows(indexes);\n        }\n      }\n\n      this.prevRowIndex = undefined;\n      this.prevCIdxs = undefined;\n      this.prevECIdxs = undefined;\n    }\n  };\n\n  Selection.prototype.onDataBound = function () {\n    if (!this.parent.enableVirtualization && this.parent.isPersistSelection) {\n      if (this.selectedRecords.length) {\n        this.isPrevRowSelection = true;\n      }\n    }\n\n    if (this.parent.getDataModule().isRemote() && this.rmtHdrChkbxClicked) {\n      if (this.parent.checkAllRows === \"Intermediate\") {\n        this.setRowSelection(true);\n      } else if (this.parent.checkAllRows === \"Uncheck\") {\n        this.setRowSelection(false);\n      }\n    }\n\n    if (this.parent.enableVirtualization) {\n      this.setCheckAllState();\n    }\n\n    if (this.parent.isPersistSelection) {\n      this.refreshPersistSelection();\n    }\n\n    this.initialRowSelection = this.isRowType() && this.parent.element.querySelectorAll('.e-selectionbackground') && this.parent.getSelectedRows().length ? true : false;\n\n    if (this.parent.isCheckBoxSelection && !this.initialRowSelection) {\n      var totalRecords = this.parent.getRowsObject();\n      var indexes = [];\n\n      for (var i = 0; i < totalRecords.length; i++) {\n        if (totalRecords[i].isSelected) {\n          indexes.push(i);\n        }\n      }\n\n      if (indexes.length) {\n        this.selectRows(indexes);\n      }\n\n      this.initialRowSelection = true;\n    }\n  };\n\n  Selection.prototype.updatePersistSelectedData = function (checkState) {\n    if (this.parent.isPersistSelection) {\n      var rows = this.parent.getRows();\n\n      for (var i = 0; i < rows.length; i++) {\n        this.updatePersistCollection(rows[i], checkState);\n      }\n\n      if (this.parent.checkAllRows === 'Uncheck') {\n        this.setRowSelection(false);\n        this.persistSelectedData = this.parent.getDataModule().isRemote() ? this.persistSelectedData : [];\n      } else if (this.parent.checkAllRows === 'Check') {\n        this.setRowSelection(true);\n        this.persistSelectedData = !this.parent.getDataModule().isRemote() && !this.isPartialSelection ? this.parent.groupSettings.columns.length ? this.getData().records.slice() : this.getData().slice() : this.persistSelectedData;\n      }\n    }\n  };\n\n  Selection.prototype.checkSelectAllAction = function (checkState) {\n    var cRenderer = this.getRenderer();\n    var editForm = this.parent.element.querySelector('.e-gridform');\n    this.checkedTarget = this.getCheckAllBox();\n\n    if (checkState && this.getCurrentBatchRecordChanges().length) {\n      this.parent.checkAllRows = 'Check';\n      this.updatePersistSelectedData(checkState);\n      this.selectRowsByRange(cRenderer.getVirtualRowIndex(0), cRenderer.getVirtualRowIndex(this.getCurrentBatchRecordChanges().length - 1));\n    } else {\n      this.parent.checkAllRows = 'Uncheck';\n      this.updatePersistSelectedData(checkState);\n      this.clearSelection();\n    }\n\n    this.chkAllCollec = [];\n\n    if (!isNullOrUndefined(editForm)) {\n      var editChkBox = editForm.querySelector('.e-edit-checkselect');\n\n      if (!isNullOrUndefined(editChkBox)) {\n        removeAddCboxClasses(editChkBox.nextElementSibling, checkState);\n      }\n    }\n  };\n\n  Selection.prototype.checkSelectAll = function (checkBox) {\n    var _this = this;\n\n    var stateStr = this.getCheckAllStatus(checkBox);\n    var state = stateStr === 'Check';\n    this.isHeaderCheckboxClicked = true;\n\n    if (this.parent.getDataModule().isRemote() && stateStr === \"Uncheck\") {\n      this.rmtHdrChkbxClicked = true;\n    } else {\n      this.rmtHdrChkbxClicked = false;\n    }\n\n    if (stateStr === 'Intermediate') {\n      state = this.getCurrentBatchRecordChanges().some(function (data) {\n        return _this.getPkValue(_this.primaryKey, data) in _this.selectedRowState;\n      });\n    }\n\n    if (this.parent.isPersistSelection && this.parent.allowPaging) {\n      this.totalRecordsCount = this.parent.pageSettings.totalRecordsCount;\n    }\n\n    this.checkSelectAllAction(!state);\n    this.target = null;\n\n    if (this.getCurrentBatchRecordChanges().length > 0) {\n      this.setCheckAllState();\n      this.updateSelectedRowIndexes();\n    }\n\n    this.triggerChkChangeEvent(checkBox, !state);\n  };\n\n  Selection.prototype.getCheckAllStatus = function (ele) {\n    var classes = ele ? ele.nextElementSibling.classList : this.getCheckAllBox().nextElementSibling.classList;\n    var status;\n\n    if (classes.contains('e-check')) {\n      status = 'Check';\n    } else if (classes.contains('e-uncheck')) {\n      status = 'Uncheck';\n    } else if (classes.contains('e-stop')) {\n      status = 'Intermediate';\n    } else {\n      status = 'None';\n    }\n\n    return status;\n  };\n\n  Selection.prototype.checkSelect = function (checkBox) {\n    var target = closest(this.checkedTarget, '.' + rowCell);\n    var gObj = this.parent;\n    this.isMultiCtrlRequest = true;\n    var rIndex = 0;\n    this.isHeaderCheckboxClicked = false;\n\n    if (isGroupAdaptive(gObj)) {\n      var uid = target.parentElement.getAttribute('data-uid');\n      rIndex = gObj.getRows().map(function (m) {\n        return m.getAttribute('data-uid');\n      }).indexOf(uid);\n    } else {\n      rIndex = parseInt(target.parentElement.getAttribute(dataRowIndex), 10);\n    }\n\n    if (this.parent.isPersistSelection && this.parent.element.getElementsByClassName(addedRow).length > 0 && this.parent.editSettings.newRowPosition === 'Top') {\n      ++rIndex;\n    }\n\n    this.rowCellSelectionHandler(rIndex, parseInt(target.getAttribute(dataColIndex), 10));\n    this.moveIntoUncheckCollection(closest(target, '.' + row));\n    this.setCheckAllState();\n    this.isMultiCtrlRequest = false;\n    this.triggerChkChangeEvent(checkBox, checkBox.nextElementSibling.classList.contains('e-check'));\n  };\n\n  Selection.prototype.moveIntoUncheckCollection = function (row$$1) {\n    if (this.parent.checkAllRows === 'Check' || this.parent.checkAllRows === 'Uncheck') {\n      var rowObj = this.getRowObj(row$$1);\n      var pKey = rowObj && rowObj.data ? this.getPkValue(this.primaryKey, rowObj.data) : null;\n\n      if (!pKey) {\n        return;\n      }\n\n      if (this.chkAllCollec.indexOf(pKey) < 0) {\n        this.chkAllCollec.push(pKey);\n      } else {\n        this.chkAllCollec.splice(this.chkAllCollec.indexOf(pKey), 1);\n      }\n    }\n  };\n\n  Selection.prototype.triggerChkChangeEvent = function (checkBox, checkState) {\n    this.parent.trigger(checkBoxChange, {\n      checked: checkState,\n      selectedRowIndexes: this.parent.getSelectedRowIndexes(),\n      target: checkBox\n    });\n\n    if (!this.parent.isEdit) {\n      this.checkedTarget = null;\n    }\n  };\n\n  Selection.prototype.updateSelectedRowIndexes = function () {\n    if (this.parent.isCheckBoxSelection && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && this.isPartialSelection && !this.parent.getDataModule().isRemote() && this.parent.selectionSettings.persistSelection) {\n      if (this.parent.checkAllRows !== 'Uncheck') {\n        var rowObj = this.parent.getRowsObject().filter(function (e) {\n          return e.isSelectable;\n        });\n\n        for (var _i = 0, rowObj_2 = rowObj; _i < rowObj_2.length; _i++) {\n          var row$$1 = rowObj_2[_i];\n          this.selectedRowIndexes.push(row$$1.index);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.updateSelectedRowIndex = function (index) {\n    if (this.parent.isCheckBoxSelection && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && !this.parent.getDataModule().isRemote() && !this.isPartialSelection) {\n      if (this.parent.checkAllRows === 'Check') {\n        this.selectedRowIndexes = [];\n        var dataLength = this.getData().length;\n\n        for (var data = 0; data < dataLength; data++) {\n          this.selectedRowIndexes.push(data);\n        }\n      } else if (this.parent.checkAllRows === 'Uncheck') {\n        this.selectedRowIndexes = [];\n      } else {\n        var row$$1 = this.parent.getRowByIndex(index);\n\n        if (index && row$$1 && row$$1.getAttribute('aria-selected') === 'false') {\n          var selectedVal = this.selectedRowIndexes.indexOf(index);\n          this.selectedRowIndexes.splice(selectedVal, 1);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.isAllSelected = function (count) {\n    if (this.isPartialSelection) {\n      if (this.parent.allowPaging && this.parent.pageSettings.pageSize < this.parent.pageSettings.totalRecordsCount) {\n        var data = this.parent.partialSelectedRecords;\n\n        for (var i = 0; i < data.length; i++) {\n          var pKey = this.getPkValue(this.primaryKey, data[i]);\n\n          if (!this.selectedRowState[pKey]) {\n            return false;\n          }\n        }\n\n        return true;\n      } else {\n        return this.isSelectAllRowCount(count);\n      }\n    } else {\n      var data = this.getData();\n\n      for (var i = 0; i < data.length; i++) {\n        var pKey = this.getPkValue(this.primaryKey, data[i]);\n\n        if (!this.selectedRowState[pKey]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  };\n\n  Selection.prototype.someDataSelected = function () {\n    var data = this.isPartialSelection ? this.parent.partialSelectedRecords : this.getData();\n\n    for (var i = 0; i < data.length; i++) {\n      var pKey = this.getPkValue(this.primaryKey, data[i]);\n\n      if (this.selectedRowState[pKey]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.setCheckAllState = function (index, isInteraction) {\n    if (this.parent.isCheckBoxSelection || this.parent.selectionSettings.checkboxMode === 'ResetOnRowClick') {\n      var checkToSelectAll = false;\n      var isFiltered = false;\n      var checkedLen = Object.keys(this.selectedRowState).length;\n\n      if (!this.parent.isPersistSelection) {\n        checkedLen = this.selectedRowIndexes.length;\n        this.totalRecordsCount = this.getCurrentBatchRecordChanges().length;\n      }\n\n      if (this.parent.isPersistSelection && !this.parent.getDataModule().isRemote() && (this.parent.searchSettings.key.length || this.parent.filterSettings.columns.length)) {\n        isFiltered = true;\n        checkToSelectAll = this.isAllSelected(checkedLen);\n      }\n\n      var input = this.getCheckAllBox();\n\n      if (input) {\n        var spanEle = input.nextElementSibling;\n        removeClass([spanEle], ['e-check', 'e-stop', 'e-uncheck']);\n        setChecked(input, false);\n        input.indeterminate = false;\n\n        if (checkToSelectAll && isFiltered && this.getData().length || !isFiltered && (checkedLen === this.totalRecordsCount && this.totalRecordsCount && !this.isPartialSelection && !this.parent.enableVirtualization || !this.parent.enableVirtualization && !this.parent.enableInfiniteScrolling && this.isPartialSelection && (this.isSelectAllRowCount(checkedLen) || this.isHdrSelectAllClicked) || (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && !this.parent.allowPaging && (!this.parent.getDataModule().isRemote() && this.getData().length && checkedLen === this.getData().length || this.parent.getDataModule().isRemote() && !this.isPartialSelection && checkedLen === this.parent.totalDataRecordsCount || this.isPartialSelection && (this.isHdrSelectAllClicked || this.isSelectAllRowCount(checkedLen))))) {\n          addClass([spanEle], ['e-check']);\n          setChecked(input, true);\n\n          if (isInteraction) {\n            this.getRenderer().setSelection(null, true, true);\n          }\n\n          this.parent.checkAllRows = 'Check';\n        } else if ((!this.selectedRowIndexes.length && !this.parent.enableVirtualization || this.parent.enableVirtualization && (!this.persistSelectedData.length && !isFiltered || isFiltered && this.someDataSelected()) || checkedLen === 0 && this.getCurrentBatchRecordChanges().length === 0) && !this.parent.allowPaging || this.parent.allowPaging && (checkedLen === 0 || checkedLen && isFiltered && this.someDataSelected())) {\n          addClass([spanEle], ['e-uncheck']);\n\n          if (isInteraction) {\n            this.getRenderer().setSelection(null, false, true);\n          }\n\n          this.parent.checkAllRows = 'Uncheck';\n\n          if (checkedLen === 0 && this.getCurrentBatchRecordChanges().length === 0) {\n            addClass([spanEle.parentElement], ['e-checkbox-disabled']);\n          } else {\n            removeClass([spanEle.parentElement], ['e-checkbox-disabled']);\n          }\n        } else {\n          addClass([spanEle], ['e-stop']);\n          this.parent.checkAllRows = 'Intermediate';\n          input.indeterminate = true;\n        }\n\n        if (this.isPartialSelection) {\n          var rowCount = this.parent.getRowsObject().filter(function (e) {\n            return e.isSelectable;\n          }).length;\n\n          if (rowCount === 0 && spanEle.parentElement.querySelector('.e-frame').classList.contains('e-uncheck')) {\n            addClass([spanEle.parentElement], ['e-checkbox-disabled']);\n          } else {\n            removeClass([spanEle.parentElement], ['e-checkbox-disabled']);\n          }\n        }\n\n        if ((this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && !this.parent.allowPaging && !this.parent.getDataModule().isRemote()) {\n          this.updateSelectedRowIndex(index);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.isSelectAllRowCount = function (count) {\n    var rowCount = 0;\n    var rowObj = this.parent.getRowsObject();\n\n    if (this.parent.selectionSettings.persistSelection && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling)) {\n      var dataLen = this.parent.getDataModule().isRemote() ? this.parent.totalDataRecordsCount : this.getData() && this.getData().length;\n\n      if (dataLen === rowObj.length) {\n        rowCount = rowObj.filter(function (e) {\n          return e.isSelectable;\n        }).length;\n        return rowCount && count === rowCount;\n      } else {\n        return false;\n      }\n    } else {\n      if (this.parent.allowPaging && this.parent.selectionSettings.persistSelection) {\n        rowCount = this.parent.partialSelectedRecords.length + this.parent.disableSelectedRecords.length;\n\n        if (rowCount === this.totalRecordsCount) {\n          return this.parent.partialSelectedRecords.length && count === this.parent.partialSelectedRecords.length;\n        } else {\n          return false;\n        }\n      } else {\n        rowCount = rowObj.filter(function (e) {\n          return e.isSelectable;\n        }).length;\n        return rowCount && count === rowCount;\n      }\n    }\n  };\n\n  Selection.prototype.keyDownHandler = function (e) {\n    // Below are keyCode for command key in MAC OS. Safari/Chrome(91-Left command, 93-Right Command), Opera(17), FireFox(224)\n    if ((Browser.info.name === 'chrome' || Browser.info.name === 'safari') && (e.keyCode === 91 || e.keyCode === 93) || Browser.info.name === 'opera' && e.keyCode === 17 || Browser.info.name === 'mozilla' && e.keyCode === 224) {\n      this.cmdKeyPressed = true;\n    }\n\n    var targetHeadCell = parentsUntil(e.target, 'e-headercell');\n    var targetRowCell = parentsUntil(e.target, rowCell);\n    var isCheckBox = targetHeadCell ? targetHeadCell.children[0].classList.contains('e-headerchkcelldiv') : targetRowCell ? targetRowCell.classList.contains('e-gridchkbox') : false;\n\n    if (isCheckBox && !this.parent.allowKeyboard && e.keyCode === 32) {\n      e.preventDefault();\n    }\n  };\n\n  Selection.prototype.keyUpHandler = function (e) {\n    if ((Browser.info.name === 'chrome' || Browser.info.name === 'safari') && (e.keyCode === 91 || e.keyCode === 93) || Browser.info.name === 'opera' && e.keyCode === 17 || Browser.info.name === 'mozilla' && e.keyCode === 224) {\n      this.cmdKeyPressed = false;\n    }\n  };\n\n  Selection.prototype.clickHandler = function (e) {\n    var target = e.target;\n    this.actualTarget = target;\n\n    if (this.selectionSettings.persistSelection) {\n      this.deSelectedData = iterateExtend(this.persistSelectedData);\n    }\n\n    if (parentsUntil(target, row) || parentsUntil(target, 'e-headerchkcelldiv') || this.selectionSettings.allowColumnSelection && target.classList.contains('e-headercell')) {\n      this.isInteracted = true;\n    }\n\n    this.isMultiCtrlRequest = e.ctrlKey || this.enableSelectMultiTouch || this.isMacOS && this.cmdKeyPressed;\n\n    if (!this.parent.allowKeyboard) {\n      this.isMultiShiftRequest = false;\n      this.isMultiCtrlRequest = false;\n    } else {\n      this.isMultiShiftRequest = e.shiftKey;\n    }\n\n    this.popUpClickHandler(e);\n    var chkSelect = false;\n    this.preventFocus = true;\n    var checkBox;\n    var checkWrap = parentsUntil(target, 'e-checkbox-wrapper');\n    this.checkSelectAllClicked = checkWrap && checkWrap.getElementsByClassName('e-checkselectall') || this.selectionSettings.persistSelection && parentsUntil(target, row) ? true : false;\n\n    if (this.selectionSettings.persistSelection && this.isPartialSelection && parentsUntil(target, 'e-headerchkcelldiv') && !target.querySelector('.e-checkbox-disabled')) {\n      this.isHdrSelectAllClicked = true;\n    }\n\n    if (checkWrap && checkWrap.querySelectorAll('.e-checkselect,.e-checkselectall').length > 0) {\n      checkBox = checkWrap.querySelector('input[type=\"checkbox\"]');\n      chkSelect = true;\n    }\n\n    this.drawBorders();\n    this.updateAutoFillPosition();\n    target = parentsUntil(target, rowCell);\n\n    if ((target && target.parentElement.classList.contains(row) && !this.parent.selectionSettings.checkboxOnly || chkSelect) && !this.isRowDragSelected) {\n      if (this.parent.isCheckBoxSelection) {\n        this.isMultiCtrlRequest = true;\n      }\n\n      this.target = target;\n\n      if (!isNullOrUndefined(checkBox)) {\n        this.checkedTarget = checkBox;\n\n        if (checkBox.classList.contains('e-checkselectall')) {\n          this.checkSelectAll(checkBox);\n        } else {\n          this.checkSelect(checkBox);\n        }\n      } else {\n        var gObj = this.parent;\n        var rIndex = 0;\n\n        if (isGroupAdaptive(gObj)) {\n          var uid = target.parentElement.getAttribute('data-uid');\n          rIndex = gObj.getRows().map(function (m) {\n            return m.getAttribute('data-uid');\n          }).indexOf(uid);\n        } else {\n          rIndex = parseInt(target.parentElement.getAttribute(dataRowIndex), 10);\n        }\n\n        if (this.parent.isPersistSelection && this.parent.element.getElementsByClassName(addedRow).length > 0) {\n          ++rIndex;\n        }\n\n        if (!this.mUPTarget || !this.mUPTarget.isEqualNode(target)) {\n          this.rowCellSelectionHandler(rIndex, parseInt(target.getAttribute(dataColIndex), 10));\n        }\n\n        this.parent.hoverFrozenRows(e);\n\n        if (this.parent.isCheckBoxSelection) {\n          this.moveIntoUncheckCollection(closest(target, '.' + row));\n          this.setCheckAllState();\n        }\n      }\n\n      if (!this.parent.isCheckBoxSelection && Browser.isDevice && !this.isSingleSel()) {\n        this.showPopup(e);\n      }\n    } else if (e.target.classList.contains('e-headercell') && !e.target.classList.contains('e-stackedheadercell')) {\n      var uid = e.target.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n      this.headerSelectionHandler(this.parent.getColumnIndexByUid(uid));\n    }\n\n    this.isMultiCtrlRequest = false;\n    this.isMultiShiftRequest = false;\n\n    if (isNullOrUndefined(closest(e.target, '.e-unboundcell'))) {\n      this.preventFocus = false;\n    }\n  };\n\n  Selection.prototype.popUpClickHandler = function (e) {\n    var target = e.target;\n\n    if (closest(target, '.e-headercell') || e.target.classList.contains(rowCell) || closest(target, '.e-gridpopup')) {\n      if (target.classList.contains('e-rowselect')) {\n        if (!target.classList.contains('e-spanclicked')) {\n          target.classList.add('e-spanclicked');\n          this.enableSelectMultiTouch = true;\n        } else {\n          target.classList.remove('e-spanclicked');\n          this.enableSelectMultiTouch = false;\n          this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n        }\n      }\n    } else {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    }\n  };\n\n  Selection.prototype.showPopup = function (e) {\n    if (!this.selectionSettings.enableSimpleMultiRowSelection) {\n      setCssInGridPopUp(this.parent.element.querySelector('.e-gridpopup'), e, 'e-rowselect e-icons e-icon-rowselect' + (!this.isSingleSel() && (this.selectedRecords.length > (this.parent.getFrozenColumns() ? 2 : 1) || this.selectedRowCellIndexes.length > 1) ? ' e-spanclicked' : ''));\n    }\n  };\n\n  Selection.prototype.rowCellSelectionHandler = function (rowIndex, cellIndex) {\n    if (!this.isMultiCtrlRequest && !this.isMultiShiftRequest || this.isSingleSel()) {\n      if (!this.isDragged) {\n        this.selectRow(rowIndex, this.selectionSettings.enableToggle);\n      }\n\n      this.selectCell({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }, this.selectionSettings.enableToggle);\n\n      if (this.selectedRowCellIndexes.length) {\n        this.updateAutoFillPosition();\n      }\n\n      this.drawBorders();\n    } else if (this.isMultiShiftRequest) {\n      if (this.parent.isCheckBoxSelection || !this.parent.isCheckBoxSelection && !closest(this.target, '.' + rowCell).classList.contains(gridChkBox)) {\n        this.selectRowsByRange(isUndefined(this.prevRowIndex) ? rowIndex : this.prevRowIndex, rowIndex);\n      } else {\n        this.addRowsToSelection([rowIndex]);\n      }\n\n      this.selectCellsByRange(isUndefined(this.prevCIdxs) ? {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      } : this.prevCIdxs, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n      this.updateAutoFillPosition();\n      this.drawBorders();\n    } else {\n      this.addRowsToSelection([rowIndex]);\n      this.addCellsToSelection([{\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }]);\n      this.showHideBorders('none');\n    }\n\n    this.isDragged = false;\n  };\n\n  Selection.prototype.onCellFocused = function (e) {\n    if (this.parent.frozenRows && e.container.isHeader && e.byKey) {\n      if (e.keyArgs.action === 'upArrow') {\n        if (this.parent.allowFiltering) {\n          e.isJump = e.element.tagName === 'INPUT' ? true : false;\n        } else {\n          e.isJump = e.element.tagName === 'TH' ? true : false;\n        }\n      } else {\n        if (e.keyArgs.action === 'downArrow') {\n          var rIdx = Number(e.element.parentElement.getAttribute(dataRowIndex));\n          e.isJump = rIdx === 0 ? true : false;\n        } else {\n          if (e.keyArgs.action === 'ctrlHome') {\n            e.isJump = true;\n          }\n        }\n      }\n    }\n\n    var clear = this.parent.isFrozenGrid() ? (e.container.isHeader && e.element.tagName !== 'TD' && e.isJump && !this.selectionSettings.allowColumnSelection || (e.container.isContent || e.element.tagName === 'TD') && !(e.container.isSelectable || e.element.tagName === 'TD')) && !(e.byKey && e.keyArgs.action === 'space') : (e.container.isHeader && e.isJump || e.container.isContent && !e.container.isSelectable) && !(e.byKey && e.keyArgs.action === 'space') && !(e.element.classList.contains('e-detailrowexpand') || e.element.classList.contains('e-detailrowcollapse'));\n    var headerAction = e.container.isHeader && e.element.tagName !== 'TD' && !closest(e.element, '.' + rowCell) && !(e.byKey && e.keyArgs.action === 'space');\n\n    if (!e.byKey || clear) {\n      if (clear && !this.parent.isCheckBoxSelection) {\n        this.clearSelection();\n      }\n\n      return;\n    }\n\n    var _a = e.container.isContent ? e.container.indexes : e.indexes,\n        rowIndex = _a[0],\n        cellIndex = _a[1];\n\n    var prev = this.focus.getPrevIndexes();\n\n    if (this.parent.frozenRows) {\n      if (e.container.isHeader && (e.element.tagName === 'TD' || closest(e.element, '.' + rowCell))) {\n        var thLen = this.parent.getHeaderTable().querySelector('thead').childElementCount;\n        rowIndex -= thLen;\n        prev.rowIndex = !isNullOrUndefined(prev.rowIndex) ? prev.rowIndex - thLen : null;\n      } else {\n        rowIndex += this.parent.frozenRows;\n        prev.rowIndex = prev.rowIndex === 0 || !isNullOrUndefined(prev.rowIndex) ? prev.rowIndex + this.parent.frozenRows : null;\n      }\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      var cIdx = Number(e.element.getAttribute(dataColIndex));\n      var selectedIndexes = this.parent.getSelectedRowCellIndexes();\n\n      if (selectedIndexes.length && prev.cellIndex === 0) {\n        prev.cellIndex = selectedIndexes[selectedIndexes.length - 1].cellIndexes[0];\n      }\n\n      prev.cellIndex = !isNullOrUndefined(prev.cellIndex) ? prev.cellIndex === cellIndex ? cIdx : cIdx - 1 : null;\n      cellIndex = cIdx;\n    }\n\n    if (this.parent.enableInfiniteScrolling && this.parent.infiniteScrollSettings.enableCache) {\n      rowIndex = parseInt(e.element.parentElement.getAttribute('data-rowindex'), 10);\n    }\n\n    if ((headerAction || ['ctrlPlusA', 'escape'].indexOf(e.keyArgs.action) === -1 && e.keyArgs.action !== 'space' && rowIndex === prev.rowIndex && cellIndex === prev.cellIndex) && !this.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    this.preventFocus = true;\n    var columnIndex = this.getKeyColIndex(e);\n\n    if (this.needColumnSelection) {\n      cellIndex = columnIndex;\n    }\n\n    if (this.parent.element.classList.contains('e-gridcell-read') && (e.keyArgs.action === 'tab' || e.keyArgs.action === 'shiftTab' || e.keyArgs.action === 'rightArrow' || e.keyArgs.action === 'leftArrow')) {\n      var targetLabel = this.target.getAttribute('aria-label');\n      targetLabel = this.target.innerHTML + ' column header ' + this.parent.getColumnByIndex(cellIndex).field;\n      this.target.setAttribute('aria-label', targetLabel);\n    }\n\n    switch (e.keyArgs.action) {\n      case 'downArrow':\n      case 'upArrow':\n      case 'enter':\n      case 'shiftEnter':\n        this.target = e.element;\n        this.isKeyAction = true;\n        this.applyDownUpKey(rowIndex, cellIndex);\n        break;\n\n      case 'rightArrow':\n      case 'leftArrow':\n        this.applyRightLeftKey(rowIndex, cellIndex);\n        break;\n\n      case 'shiftDown':\n      case 'shiftUp':\n        this.shiftDownKey(rowIndex, cellIndex);\n        break;\n\n      case 'shiftLeft':\n      case 'shiftRight':\n        this.applyShiftLeftRightKey(rowIndex, cellIndex);\n        break;\n\n      case 'home':\n      case 'end':\n        cellIndex = e.keyArgs.action === 'end' ? this.getLastColIndex(rowIndex) : 0;\n        this.applyHomeEndKey(rowIndex, cellIndex);\n        break;\n\n      case 'ctrlHome':\n      case 'ctrlEnd':\n        this.applyCtrlHomeEndKey(rowIndex, cellIndex);\n        break;\n\n      case 'escape':\n        this.clearSelection();\n        break;\n\n      case 'ctrlPlusA':\n        this.ctrlPlusA();\n        break;\n\n      case 'space':\n        this.applySpaceSelection(e.element);\n        break;\n\n      case 'tab':\n        if (this.parent.editSettings.allowNextRowEdit) {\n          this.selectRow(rowIndex);\n        }\n\n        break;\n    }\n\n    this.needColumnSelection = false;\n    this.preventFocus = false;\n    this.positionBorders();\n    this.updateAutoFillPosition();\n  };\n\n  Selection.prototype.getKeyColIndex = function (e) {\n    var uid;\n    var index = null;\n    var stackedHeader = e.element.querySelector('.e-stackedheadercelldiv');\n\n    if (this.selectionSettings.allowColumnSelection && parentsUntil(e.element, 'e-columnheader')) {\n      this.needColumnSelection = e.container.isHeader ? true : false;\n\n      if (stackedHeader) {\n        if (e.keyArgs.action === 'rightArrow' || e.keyArgs.action === 'leftArrow') {\n          return index;\n        }\n\n        uid = stackedHeader.getAttribute('e-mappinguid');\n        var innerColumn = this.getstackedColumns(this.parent.getColumnByUid(uid).columns);\n        var lastIndex = this.parent.getColumnIndexByUid(innerColumn[innerColumn.length - 1].uid);\n        var firstIndex = this.parent.getColumnIndexByUid(innerColumn[0].uid);\n        index = this.prevColIndex >= lastIndex ? firstIndex : lastIndex;\n      } else {\n        index = this.parent.getColumnIndexByUid(e.element.querySelector('.e-headercelldiv').getAttribute('e-mappinguid'));\n      }\n    }\n\n    return index;\n  };\n  /**\n   * Apply ctrl + A key selection\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.ctrlPlusA = function () {\n    if (this.isRowType() && !this.isSingleSel()) {\n      this.selectRowsByRange(0, this.getCurrentBatchRecordChanges().length - 1);\n    }\n\n    if (this.isCellType() && !this.isSingleSel()) {\n      this.selectCellsByRange({\n        rowIndex: 0,\n        cellIndex: 0\n      }, {\n        rowIndex: this.parent.getRows().length - 1,\n        cellIndex: this.parent.getColumns().length - 1\n      });\n    }\n  };\n\n  Selection.prototype.applySpaceSelection = function (target) {\n    if (target.classList.contains('e-checkselectall')) {\n      this.checkedTarget = target;\n      this.checkSelectAll(this.checkedTarget);\n    } else {\n      if (target.classList.contains('e-checkselect')) {\n        this.checkedTarget = target;\n        this.checkSelect(this.checkedTarget);\n      }\n    }\n  };\n\n  Selection.prototype.applyDownUpKey = function (rowIndex, cellIndex) {\n    var gObj = this.parent;\n\n    if (this.parent.isCheckBoxSelection && this.parent.checkAllRows === 'Check' && !this.selectionSettings.persistSelection) {\n      this.checkSelectAllAction(false);\n      this.checkedTarget = null;\n    }\n\n    if (this.isRowType() && !this.selectionSettings.checkboxOnly) {\n      if (this.parent.frozenRows) {\n        this.selectRow(rowIndex, true);\n        this.applyUpDown(gObj.selectedRowIndex);\n      } else {\n        this.selectRow(rowIndex, true);\n        this.applyUpDown(gObj.selectedRowIndex);\n      }\n    }\n\n    if (this.isCellType()) {\n      this.selectCell({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }, true);\n    }\n\n    if (this.selectionSettings.allowColumnSelection && this.needColumnSelection) {\n      this.selectColumn(cellIndex);\n    }\n  };\n\n  Selection.prototype.applyUpDown = function (rowIndex) {\n    if (rowIndex < 0) {\n      return;\n    }\n\n    if (!this.target) {\n      this.target = this.parent.getRows()[0].children[this.parent.groupSettings.columns.length || 0];\n    }\n\n    var cIndex = parseInt(this.target.getAttribute(dataColIndex), 10);\n    var frzCols = this.parent.getFrozenColumns();\n\n    if (frzCols) {\n      if (cIndex >= frzCols) {\n        this.target = this.contentRenderer.getMovableRowByIndex(rowIndex).getElementsByClassName(rowCell)[cIndex - frzCols];\n      } else {\n        this.target = this.contentRenderer.getRowByIndex(rowIndex).getElementsByClassName(rowCell)[cIndex];\n      }\n    } else {\n      var row$$1 = this.contentRenderer.getRowByIndex(rowIndex);\n\n      if (row$$1) {\n        this.target = row$$1.getElementsByClassName(rowCell)[cIndex];\n      }\n    }\n\n    this.addAttribute(this.target);\n\n    if (this.parent.element.classList.contains('e-gridcell-read')) {\n      var targetLabel = this.target.getAttribute('aria-label');\n      targetLabel = this.target.innerHTML;\n      this.target.setAttribute('aria-label', targetLabel);\n    }\n  };\n\n  Selection.prototype.applyRightLeftKey = function (rowIndex, cellIndex) {\n    if (this.selectionSettings.allowColumnSelection && this.needColumnSelection) {\n      this.selectColumn(cellIndex);\n    } else if (this.isCellType()) {\n      this.selectCell({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }, true);\n      this.addAttribute(this.target);\n    }\n  };\n\n  Selection.prototype.applyHomeEndKey = function (rowIndex, cellIndex) {\n    if (this.isCellType()) {\n      this.selectCell({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }, true);\n    } else {\n      this.addAttribute(this.parent.getCellFromIndex(rowIndex, cellIndex));\n    }\n  };\n  /**\n   * Apply shift+down key selection\n   *\n   * @param {number} rowIndex - specfies the rowIndex\n   * @param {number} cellIndex - specifies the CellIndex\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Selection.prototype.shiftDownKey = function (rowIndex, cellIndex) {\n    this.isMultiShiftRequest = true;\n\n    if (this.isRowType() && !this.isSingleSel()) {\n      if (!isUndefined(this.prevRowIndex)) {\n        this.selectRowsByRange(this.prevRowIndex, rowIndex);\n        this.applyUpDown(rowIndex);\n      } else if (this.isPartialSelection) {\n        this.selectRow(rowIndex, true);\n      } else {\n        this.selectRow(0, true);\n      }\n    }\n\n    if (this.isCellType() && !this.isSingleSel()) {\n      this.selectCellsByRange(this.prevCIdxs || {\n        rowIndex: 0,\n        cellIndex: 0\n      }, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n    }\n\n    this.isMultiShiftRequest = false;\n  };\n\n  Selection.prototype.applyShiftLeftRightKey = function (rowIndex, cellIndex) {\n    this.isMultiShiftRequest = true;\n\n    if (this.selectionSettings.allowColumnSelection && this.needColumnSelection) {\n      this.selectColumnsByRange(this.prevColIndex, cellIndex);\n    } else {\n      this.selectCellsByRange(this.prevCIdxs, {\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      });\n    }\n\n    this.isMultiShiftRequest = false;\n  };\n\n  Selection.prototype.getstackedColumns = function (column) {\n    var innerColumnIndexes = [];\n\n    for (var i = 0, len = column.length; i < len; i++) {\n      if (column[i].columns) {\n        this.getstackedColumns(column[i].columns);\n      } else {\n        innerColumnIndexes.push(column[i]);\n      }\n    }\n\n    return innerColumnIndexes;\n  };\n\n  Selection.prototype.applyCtrlHomeEndKey = function (rowIndex, cellIndex) {\n    if (this.isRowType()) {\n      this.selectRow(rowIndex, true);\n      this.addAttribute(this.parent.getCellFromIndex(rowIndex, cellIndex));\n    }\n\n    if (this.isCellType()) {\n      this.selectCell({\n        rowIndex: rowIndex,\n        cellIndex: cellIndex\n      }, true);\n    }\n  };\n\n  Selection.prototype.addRemoveClassesForRow = function (row$$1, isAdd, clearAll) {\n    var args = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n\n    if (row$$1) {\n      var cells = [].slice.call(row$$1.getElementsByClassName(rowCell));\n      var detailIndentCell = row$$1.querySelector('.e-detailrowcollapse') || row$$1.querySelector('.e-detailrowexpand');\n      var dragdropIndentCell = row$$1.querySelector('.e-rowdragdrop');\n\n      if (detailIndentCell) {\n        cells.push(detailIndentCell);\n      }\n\n      if (dragdropIndentCell) {\n        cells.push(dragdropIndentCell);\n      }\n\n      addRemoveActiveClasses.apply(void 0, [cells, isAdd].concat(args));\n    }\n\n    this.getRenderer().setSelection(row$$1 ? row$$1.getAttribute('data-uid') : null, isAdd, clearAll);\n  };\n\n  Selection.prototype.isRowType = function () {\n    return this.selectionSettings.mode === 'Row' || this.selectionSettings.mode === 'Both';\n  };\n\n  Selection.prototype.isCellType = function () {\n    return this.selectionSettings.mode === 'Cell' || this.selectionSettings.mode === 'Both';\n  };\n\n  Selection.prototype.isSingleSel = function () {\n    return this.selectionSettings.type === 'Single';\n  };\n\n  Selection.prototype.getRenderer = function () {\n    if (isNullOrUndefined(this.contentRenderer)) {\n      this.contentRenderer = this.factory.getRenderer(RenderType.Content);\n    }\n\n    return this.contentRenderer;\n  };\n  /**\n   * Gets the collection of selected records.\n   *\n   * @returns {Object[]} returns the Object\n   */\n\n\n  Selection.prototype.getSelectedRecords = function () {\n    var selectedData = [];\n\n    if (!this.selectionSettings.persistSelection && this.selectedRecords.length) {\n      selectedData = this.parent.getRowsObject().filter(function (row$$1) {\n        return row$$1.isSelected;\n      }).map(function (m) {\n        return m.data;\n      });\n    } else {\n      selectedData = this.persistSelectedData;\n    }\n\n    return selectedData;\n  };\n  /**\n   * Select the column by passing start column index\n   *\n   * @param {number} index - specifies the index\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectColumn = function (index) {\n    var gObj = this.parent;\n\n    if (isNullOrUndefined(gObj.getColumns()[index])) {\n      return;\n    }\n\n    var column = gObj.getColumnByIndex(index);\n    var selectedCol = gObj.getColumnHeaderByUid(column.uid);\n    var isColSelected = selectedCol.classList.contains('e-columnselection');\n\n    if (!gObj.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    var isMultiColumns = this.selectedColumnsIndexes.length > 1 && this.selectedColumnsIndexes.indexOf(index) > -1;\n    this.clearColDependency();\n\n    if (!isColSelected || !this.selectionSettings.enableToggle || isMultiColumns) {\n      var args = {\n        columnIndex: index,\n        headerCell: selectedCol,\n        column: column,\n        cancel: false,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest\n      };\n      this.onActionBegin(args, columnSelecting);\n\n      if (args.cancel) {\n        this.disableInteracted();\n        return;\n      }\n\n      if (!(gObj.selectionSettings.enableToggle && index === this.prevColIndex && isColSelected) || isMultiColumns) {\n        this.updateColSelection(selectedCol, index);\n      }\n\n      var selectedArgs = {\n        columnIndex: index,\n        headerCell: selectedCol,\n        column: column,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex\n      };\n      this.onActionComplete(selectedArgs, columnSelected);\n    }\n\n    this.updateColProps(index);\n  };\n  /**\n   * Select the columns by passing start and end column index\n   *\n   * @param  {number} startIndex - specifies the start index\n   * @param  {number} endIndex - specifies the end index\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectColumnsByRange = function (startIndex, endIndex) {\n    var gObj = this.parent;\n\n    if (isNullOrUndefined(gObj.getColumns()[startIndex])) {\n      return;\n    }\n\n    var indexes = [];\n\n    if (gObj.selectionSettings.type === 'Single' || isNullOrUndefined(endIndex)) {\n      indexes[0] = startIndex;\n    } else {\n      var min = startIndex < endIndex;\n\n      for (var i = startIndex; min ? i <= endIndex : i >= endIndex; min ? i++ : i--) {\n        indexes.push(i);\n      }\n    }\n\n    this.selectColumns(indexes);\n  };\n  /**\n   * Select the columns by passing column indexes\n   *\n   * @param  {number[]} columnIndexes - specifies the columnIndexes\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectColumns = function (columnIndexes) {\n    var gObj = this.parent;\n    var selectedCol = this.getselectedCols();\n\n    if (gObj.selectionSettings.type === 'Single') {\n      columnIndexes = [columnIndexes[0]];\n    }\n\n    if (!gObj.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    this.clearColDependency();\n    var selectingArgs = {\n      columnIndex: columnIndexes[0],\n      headerCell: selectedCol,\n      columnIndexes: columnIndexes,\n      column: gObj.getColumnByIndex(columnIndexes[0]),\n      cancel: false,\n      target: this.actualTarget,\n      isInteracted: this.isInteracted,\n      previousColumnIndex: this.prevColIndex,\n      isCtrlPressed: this.isMultiCtrlRequest,\n      isShiftPressed: this.isMultiShiftRequest\n    };\n    this.onActionBegin(selectingArgs, columnSelecting);\n\n    if (selectingArgs.cancel) {\n      this.disableInteracted();\n      return;\n    }\n\n    for (var i = 0, len = columnIndexes.length; i < len; i++) {\n      this.updateColSelection(gObj.getColumnHeaderByUid(gObj.getColumnByIndex(columnIndexes[i]).uid), columnIndexes[i]);\n    }\n\n    selectedCol = this.getselectedCols();\n    var selectedArgs = {\n      columnIndex: columnIndexes[0],\n      headerCell: selectedCol,\n      columnIndexes: columnIndexes,\n      column: gObj.getColumnByIndex(columnIndexes[0]),\n      target: this.actualTarget,\n      isInteracted: this.isInteracted,\n      previousColumnIndex: this.prevColIndex\n    };\n    this.onActionComplete(selectedArgs, columnSelected);\n    this.updateColProps(columnIndexes[0]);\n  };\n  /**\n   * Select the column with existing column by passing column index\n   *\n   * @param  {number} startIndex - specifies the start index\n   * @returns {void}\n   */\n\n\n  Selection.prototype.selectColumnWithExisting = function (startIndex) {\n    var gObj = this.parent;\n\n    if (isNullOrUndefined(gObj.getColumns()[startIndex])) {\n      return;\n    }\n\n    var newCol = gObj.getColumnHeaderByUid(gObj.getColumnByIndex(startIndex).uid);\n    var selectedCol = this.getselectedCols();\n\n    if (gObj.selectionSettings.type === 'Single') {\n      this.clearColDependency();\n    }\n\n    if (!gObj.selectionSettings.allowColumnSelection) {\n      return;\n    }\n\n    if (this.selectedColumnsIndexes.indexOf(startIndex) > -1) {\n      this.clearColumnSelection(startIndex);\n    } else {\n      var selectingArgs = {\n        columnIndex: startIndex,\n        headerCell: selectedCol,\n        columnIndexes: this.selectedColumnsIndexes,\n        column: gObj.getColumnByIndex(startIndex),\n        cancel: false,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex,\n        isCtrlPressed: this.isMultiCtrlRequest,\n        isShiftPressed: this.isMultiShiftRequest\n      };\n      this.onActionBegin(selectingArgs, columnSelecting);\n\n      if (selectingArgs.cancel) {\n        this.disableInteracted();\n        return;\n      }\n\n      this.updateColSelection(newCol, startIndex);\n      selectedCol = this.getselectedCols();\n      var selectedArgs = {\n        columnIndex: startIndex,\n        headerCell: selectedCol,\n        column: gObj.getColumnByIndex(startIndex),\n        columnIndexes: this.selectedColumnsIndexes,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted,\n        previousColumnIndex: this.prevColIndex\n      };\n      this.onActionComplete(selectedArgs, columnSelected);\n    }\n\n    this.updateColProps(startIndex);\n  };\n  /**\n   * Clear the column selection\n   *\n   * @param {number} clearIndex - specifies the clearIndex\n   * @returns {void}\n   */\n\n\n  Selection.prototype.clearColumnSelection = function (clearIndex) {\n    if (this.isColumnSelected) {\n      var gObj = this.parent;\n\n      if (!isNullOrUndefined(clearIndex) && this.selectedColumnsIndexes.indexOf(clearIndex) === -1) {\n        return;\n      }\n\n      var index = !isNullOrUndefined(clearIndex) ? clearIndex : this.selectedColumnsIndexes[this.selectedColumnsIndexes.length - 1];\n      var col = gObj.getColumnByIndex(index);\n      var selectedCol = void 0;\n      var column = gObj.getColumnByIndex(index);\n\n      if (col.getFreezeTableName() === frozenRight) {\n        selectedCol = gObj.getFrozenRightColumnHeaderByIndex(index);\n      } else if (col.getFreezeTableName() === 'movable') {\n        selectedCol = gObj.getMovableColumnHeaderByIndex(index);\n      } else {\n        selectedCol = gObj.getColumnHeaderByUid(column.uid);\n      }\n\n      var deselectedArgs = {\n        columnIndex: index,\n        headerCell: selectedCol,\n        columnIndexes: this.selectedColumnsIndexes,\n        column: column,\n        cancel: false,\n        target: this.actualTarget,\n        isInteracted: this.isInteracted\n      };\n      var isCanceled = this.columnDeselect(deselectedArgs, columnDeselecting);\n\n      if (isCanceled) {\n        this.disableInteracted();\n        return;\n      }\n\n      var selectedHeader = !isNullOrUndefined(clearIndex) ? [selectedCol] : [].slice.call(gObj.getHeaderContent().getElementsByClassName('e-columnselection'));\n      var selectedCells = this.getSelectedColumnCells(clearIndex);\n\n      for (var i = 0, len = selectedHeader.length; i < len; i++) {\n        addRemoveActiveClasses([selectedHeader[i]], false, 'e-columnselection');\n      }\n\n      for (var i = 0, len = selectedCells.length; i < len; i++) {\n        addRemoveActiveClasses([selectedCells[i]], false, 'e-columnselection');\n      }\n\n      if (!isNullOrUndefined(clearIndex)) {\n        this.selectedColumnsIndexes.splice(this.selectedColumnsIndexes.indexOf(clearIndex), 1);\n        this.parent.getColumns()[clearIndex].isSelected = false;\n      } else {\n        this.columnDeselect(deselectedArgs, columnDeselected);\n        this.selectedColumnsIndexes = [];\n        this.isColumnSelected = false;\n        this.parent.getColumns().filter(function (col) {\n          return col.isSelected = false;\n        });\n      }\n    }\n  };\n\n  Selection.prototype.getselectedCols = function () {\n    var gObj = this.parent;\n    var selectedCol;\n\n    if (this.selectedColumnsIndexes.length > 1) {\n      selectedCol = [];\n\n      for (var i = 0; i < this.selectedColumnsIndexes.length; i++) {\n        selectedCol.push(gObj.getColumnHeaderByUid(gObj.getColumnByIndex(this.selectedColumnsIndexes[i]).uid));\n      }\n    } else {\n      selectedCol = gObj.getColumnHeaderByUid(gObj.getColumnByIndex(this.selectedColumnsIndexes[0]).uid);\n    }\n\n    return selectedCol;\n  };\n\n  Selection.prototype.getSelectedColumnCells = function (clearIndex) {\n    var gObj = this.parent;\n    var isRowTemplate = !isNullOrUndefined(this.parent.rowTemplate);\n    var rows = isRowTemplate ? gObj.getRows() : gObj.getDataRows();\n    var movableRows;\n    var frRows;\n\n    if (gObj.isFrozenGrid() && gObj.getContent().querySelector('.' + movableContent)) {\n      movableRows = isRowTemplate ? gObj.getMovableRows() : gObj.getMovableDataRows();\n      rows = gObj.addMovableRows(rows, movableRows);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frRows = isRowTemplate ? gObj.getFrozenRightRows() : gObj.getFrozenRightDataRows();\n        rows = gObj.addMovableRows(rows, frRows);\n      }\n    }\n\n    var seletedcells = [];\n    var selectionString = !isNullOrUndefined(clearIndex) ? '[data-colindex=\"' + clearIndex + '\"]' : '.e-columnselection';\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      seletedcells = seletedcells.concat([].slice.call(rows[i].querySelectorAll(selectionString)));\n    }\n\n    return seletedcells;\n  };\n\n  Selection.prototype.columnDeselect = function (args, event) {\n    if (event === 'columnDeselected') {\n      delete args.cancel;\n    }\n\n    this.onActionComplete(args, event);\n    return args.cancel;\n  };\n\n  Selection.prototype.updateColProps = function (startIndex) {\n    this.prevColIndex = startIndex;\n    this.isColumnSelected = this.selectedColumnsIndexes.length && true;\n  };\n\n  Selection.prototype.clearColDependency = function () {\n    this.clearColumnSelection();\n    this.selectedColumnsIndexes = [];\n  };\n\n  Selection.prototype.updateColSelection = function (selectedCol, startIndex) {\n    if (isNullOrUndefined(this.parent.getColumns()[startIndex])) {\n      return;\n    }\n\n    var left = this.parent.getFrozenLeftCount();\n    var movable = this.parent.getMovableColumnsCount();\n    var col = this.parent.getColumnByIndex(startIndex);\n    var isRowTemplate = !isNullOrUndefined(this.parent.rowTemplate);\n    var rows;\n    this.selectedColumnsIndexes.push(startIndex);\n    this.parent.getColumns()[startIndex].isSelected = true;\n\n    if (col.getFreezeTableName() === frozenRight) {\n      startIndex = startIndex - (left + movable);\n      rows = isRowTemplate ? this.parent.getFrozenRightRows() : this.parent.getFrozenRightDataRows();\n    } else if (col.getFreezeTableName() === 'movable') {\n      startIndex = startIndex - left;\n      rows = isRowTemplate ? this.parent.getMovableRows() : this.parent.getMovableDataRows();\n    } else {\n      startIndex = startIndex + this.parent.getIndentCount();\n      rows = isRowTemplate ? this.parent.getRows() : this.parent.getDataRows();\n    }\n\n    addRemoveActiveClasses([selectedCol], true, 'e-columnselection');\n\n    for (var j = 0, len = rows.length; j < len; j++) {\n      if (rows[j].classList.contains(row)) {\n        if ((rows[j].classList.contains(editedRow) || rows[j].classList.contains(addedRow)) && this.parent.editSettings.mode === 'Normal' && !isNullOrUndefined(rows[j].querySelector('tr').childNodes[startIndex])) {\n          addRemoveActiveClasses([rows[j].querySelector('tr').childNodes[startIndex]], true, 'e-columnselection');\n        } else if (!isNullOrUndefined(rows[j].childNodes[startIndex])) {\n          addRemoveActiveClasses([rows[j].childNodes[startIndex]], true, 'e-columnselection');\n        }\n      }\n    }\n  };\n\n  Selection.prototype.headerSelectionHandler = function (colIndex) {\n    if (!this.isMultiCtrlRequest && !this.isMultiShiftRequest || this.isSingleSel()) {\n      this.selectColumn(colIndex);\n    } else if (this.isMultiShiftRequest) {\n      this.selectColumnsByRange(isUndefined(this.prevColIndex) ? colIndex : this.prevColIndex, colIndex);\n    } else {\n      this.selectColumnWithExisting(colIndex);\n    }\n  }; // eslint-disable-next-line camelcase\n\n\n  Selection.prototype.addEventListener_checkbox = function () {\n    var _this = this;\n\n    this.parent.on(dataReady, this.dataReady, this);\n    this.onDataBoundFunction = this.onDataBound.bind(this);\n    this.parent.addEventListener(dataBound, this.onDataBoundFunction);\n    this.parent.on(refreshInfinitePersistSelection, this.onDataBoundFunction);\n    this.parent.on(contentReady, this.checkBoxSelectionChanged, this);\n    this.parent.on(beforeRefreshOnDataChange, this.initPerisistSelection, this);\n    this.parent.on(onEmpty, this.setCheckAllForEmptyGrid, this);\n    this.actionCompleteFunc = this.actionCompleteHandler.bind(this);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.on(click, this.clickHandler, this);\n\n    this.resizeEndFn = function () {\n      _this.updateAutoFillPosition();\n\n      _this.drawBorders();\n    };\n\n    this.resizeEndFn.bind(this);\n    this.parent.addEventListener(resizeStop, this.resizeEndFn);\n  }; // eslint-disable-next-line camelcase\n\n\n  Selection.prototype.removeEventListener_checkbox = function () {\n    this.parent.off(dataReady, this.dataReady);\n    this.parent.removeEventListener(dataBound, this.onDataBoundFunction);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.off(refreshInfinitePersistSelection, this.onDataBoundFunction);\n    this.parent.off(onEmpty, this.setCheckAllForEmptyGrid);\n    this.parent.off(click, this.clickHandler);\n    this.parent.off(beforeRefreshOnDataChange, this.initPerisistSelection);\n  };\n\n  Selection.prototype.setCheckAllForEmptyGrid = function () {\n    var checkAllBox = this.getCheckAllBox();\n\n    if (checkAllBox) {\n      this.parent.isCheckBoxSelection = true;\n      var spanEle = checkAllBox.nextElementSibling;\n      removeClass([spanEle], ['e-check', 'e-stop', 'e-uncheck']);\n    }\n  };\n\n  Selection.prototype.dataReady = function (e) {\n    this.isHeaderCheckboxClicked = false;\n    var isInfinitecroll = this.parent.enableInfiniteScrolling && e.requestType === 'infiniteScroll';\n\n    if (e.requestType !== 'virtualscroll' && !this.parent.isPersistSelection && !isInfinitecroll) {\n      this.disableUI = !this.parent.enableImmutableMode;\n      this.clearSelection();\n      this.setCheckAllState();\n      this.disableUI = false;\n    }\n  };\n\n  Selection.prototype.actionCompleteHandler = function (e) {\n    if (e.requestType === 'save' && this.parent.isPersistSelection) {\n      this.refreshPersistSelection();\n    }\n  };\n\n  Selection.prototype.selectRowIndex = function (index) {\n    this.parent.isSelectedRowIndexUpdating = true;\n    this.parent.selectedRowIndex = index;\n  };\n\n  Selection.prototype.disableInteracted = function () {\n    this.isInteracted = false;\n  };\n\n  Selection.prototype.activeTarget = function () {\n    this.actualTarget = this.isInteracted ? this.actualTarget : null;\n  };\n\n  return Selection;\n}();\n/**\n * The `Search` module is used to handle search action.\n */\n\n\nvar Search =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for Grid search module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function Search(parent) {\n    this.parent = parent;\n    this.addEventListener();\n  }\n  /**\n   * Searches Grid records by given key.\n   *\n   * > You can customize the default search action by using [`searchSettings`](grid/#searchsettings/).\n   *\n   * @param  {string} searchString - Defines the key.\n   * @returns {void}\n   */\n\n\n  Search.prototype.search = function (searchString) {\n    var gObj = this.parent;\n    searchString = isNullOrUndefined(searchString) ? '' : searchString;\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.search,\n        arg1: searchString\n      });\n      return;\n    }\n\n    if (searchString !== gObj.searchSettings.key) {\n      gObj.searchSettings.key = searchString.toString();\n      gObj.dataBind();\n    } else if (this.refreshSearch) {\n      gObj.refresh();\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Search.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(searchComplete, this.onSearchComplete, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.actionCompleteFunc = this.onActionComplete.bind(this);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.on(cancelBegin, this.cancelBeginEvent, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Search.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(searchComplete, this.onSearchComplete);\n    this.parent.off(destroy, this.destroy);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunc);\n    this.parent.off(cancelBegin, this.cancelBeginEvent);\n  };\n  /**\n   * To destroy the print\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Search.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n  /**\n   * @param {NotifyArgs} e - specfies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Search.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    if (!isNullOrUndefined(e.properties.key)) {\n      this.parent.notify(modelChanged, {\n        requestType: 'searching',\n        type: actionBegin,\n        searchString: this.parent.searchSettings.key\n      });\n    } else {\n      this.parent.notify(modelChanged, {\n        requestType: 'searching',\n        type: actionBegin\n      });\n    }\n  };\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Search.prototype.onSearchComplete = function (e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      searchString: this.parent.searchSettings.key,\n      requestType: 'searching',\n      type: actionComplete\n    }));\n  };\n  /**\n   * The function used to store the requestType\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Search.prototype.onActionComplete = function (e) {\n    this.refreshSearch = e.requestType !== 'searching';\n  };\n\n  Search.prototype.cancelBeginEvent = function (e) {\n    if (e.requestType === 'searching') {\n      this.parent.setProperties({\n        searchSettings: {\n          key: ''\n        }\n      }, true);\n    }\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Search.prototype.getModuleName = function () {\n    return 'search';\n  };\n\n  return Search;\n}();\n/**\n * The `ShowHide` module is used to control column visibility.\n */\n\n\nvar ShowHide =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the show hide module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function ShowHide(parent) {\n    this.parent = parent;\n  }\n  /**\n   * Shows a column by column name.\n   *\n   * @param  {string|string[]} columnName - Defines a single or collection of column names to show.\n   * @param  {string} showBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  ShowHide.prototype.show = function (columnName, showBy) {\n    var keys = this.getToggleFields(columnName);\n    var columns = this.getColumns(keys, showBy);\n    this.parent.notify(tooltipDestroy, {\n      module: 'edit'\n    });\n\n    for (var i = 0; i < columns.length; i++) {\n      columns[i].visible = true;\n    }\n\n    this.setVisible(columns);\n  };\n  /**\n   * Hides a column by column name.\n   *\n   * @param  {string|string[]} columnName - Defines a single or collection of column names to hide.\n   * @param  {string} hideBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  ShowHide.prototype.hide = function (columnName, hideBy) {\n    var keys = this.getToggleFields(columnName);\n    var columns = this.getColumns(keys, hideBy);\n    this.parent.notify(tooltipDestroy, {\n      module: 'edit'\n    });\n\n    for (var i = 0; i < columns.length; i++) {\n      columns[i].visible = false;\n    }\n\n    this.setVisible(columns);\n  };\n\n  ShowHide.prototype.getToggleFields = function (key) {\n    var finalized = [];\n\n    if (typeof key === 'string') {\n      finalized = [key];\n    } else {\n      finalized = key;\n    }\n\n    return finalized;\n  };\n\n  ShowHide.prototype.getColumns = function (keys, getKeyBy) {\n    var _this = this;\n\n    var columns = iterateArrayOrObject(keys, function (key) {\n      return iterateArrayOrObject(_this.parent.columnModel, function (item) {\n        if (item[getKeyBy] === key) {\n          return item;\n        }\n\n        return undefined;\n      })[0];\n    });\n    return columns;\n  };\n  /**\n   * Shows or hides columns by given column collection.\n   *\n   * @private\n   * @param {Column[]} columns - Specifies the columns.\n   * @param {Column[]} changedStateColumns - specifies the changedStateColumns\n   * @returns {void}\n   */\n\n\n  ShowHide.prototype.setVisible = function (columns, changedStateColumns) {\n    var _this = this;\n\n    if (changedStateColumns === void 0) {\n      changedStateColumns = [];\n    }\n\n    changedStateColumns = changedStateColumns.length > 0 ? changedStateColumns : columns;\n    var args = {\n      requestType: 'columnstate',\n      cancel: false,\n      columns: changedStateColumns\n    };\n    var cancel = 'cancel';\n\n    if (this.parent.enableInfiniteScrolling && this.parent.allowGrouping && this.parent.groupModule.groupSettings.columns.length > 0) {\n      this.parent.contentModule.visibleRows = [];\n    }\n\n    this.parent.trigger(actionBegin, args, function (showHideArgs) {\n      var currentViewCols = _this.parent.getColumns();\n\n      columns = isNullOrUndefined(columns) ? currentViewCols : columns;\n\n      if (showHideArgs[cancel]) {\n        _this.parent.notify(resetColumns, {\n          showHideArgs: showHideArgs\n        });\n\n        if (columns.length > 0) {\n          columns[0].visible = true;\n        }\n\n        return;\n      }\n\n      if (isGroupAdaptive(_this.parent)) {\n        _this.parent.contentModule.emptyVcRows();\n      }\n\n      if (_this.parent.allowSelection && _this.parent.getSelectedRecords().length && !_this.parent.selectionSettings.persistSelection) {\n        _this.parent.clearSelection();\n      }\n\n      if (_this.parent.enableColumnVirtualization) {\n        var colsInCurrentView = columns.filter(function (col1) {\n          return currentViewCols.some(function (col2) {\n            return col1.field === col2.field;\n          });\n        });\n\n        if (colsInCurrentView.length) {\n          _this.parent.notify(columnVisibilityChanged, columns);\n        }\n      } else {\n        _this.parent.notify(columnVisibilityChanged, columns);\n      }\n\n      var params = {\n        requestType: 'columnstate',\n        columns: changedStateColumns\n      };\n\n      _this.parent.trigger(actionComplete, params);\n\n      if (_this.parent.columnQueryMode !== 'All') {\n        _this.parent.refresh();\n      }\n    });\n  };\n\n  return ShowHide;\n}();\n/**\n * The `Scroll` module is used to handle scrolling behaviour.\n */\n\n\nvar Scroll =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid scrolling.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function Scroll(parent) {\n    //To maintain scroll state on grid actions.\n    this.previousValues = {\n      top: 0,\n      left: 0\n    };\n    this.oneTimeReady = true;\n    this.parent = parent;\n    this.widthService = new ColumnWidthService(parent);\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Scroll.prototype.getModuleName = function () {\n    return 'scroll';\n  };\n  /**\n   * @param {boolean} uiupdate - specifies the uiupdate\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.setWidth = function (uiupdate) {\n    this.parent.element.style.width = formatUnit(this.parent.width);\n\n    if (uiupdate) {\n      this.widthService.setWidthToColumns();\n    }\n\n    if (this.parent.toolbarModule && this.parent.toolbarModule.toolbar && this.parent.toolbarModule.toolbar.element) {\n      this.parent.toolbarModule.toolbar.refreshOverflow();\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.setHeight = function () {\n    var mHdrHeight = 0;\n    var content$$1 = this.parent.getContent().querySelector('.' + content);\n    var height = this.parent.height;\n\n    if (this.parent.isFrozenGrid() && this.parent.height !== 'auto' && this.parent.height.toString().indexOf('%') < 0) {\n      height = parseInt(height, 10) - Scroll.getScrollBarWidth();\n    }\n\n    if (!this.parent.enableVirtualization && this.parent.frozenRows && this.parent.height !== 'auto') {\n      var tbody$$1 = this.parent.getHeaderContent().querySelector(tbody + ':not(.e-masked-tbody)');\n      mHdrHeight = tbody$$1 ? tbody$$1.offsetHeight : 0;\n\n      if (tbody$$1 && mHdrHeight) {\n        var add = tbody$$1.getElementsByClassName(addedRow).length;\n        var height_1 = add * this.parent.getRowHeight();\n        mHdrHeight -= height_1;\n      } else if (!this.parent.isInitialLoad && this.parent.loadingIndicator.indicatorType === 'Shimmer' && this.parent.getHeaderContent().querySelector('.e-masked-table')) {\n        height = parseInt(height, 10) - this.parent.frozenRows * this.parent.getRowHeight();\n      }\n\n      content$$1.style.height = formatUnit(height - mHdrHeight);\n    } else {\n      content$$1.style.height = formatUnit(height);\n    }\n\n    this.ensureOverflow(content$$1);\n\n    if (this.parent.isFrozenGrid()) {\n      this.refresh();\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.setPadding = function () {\n    var content$$1 = this.parent.getHeaderContent();\n    var scrollWidth = Scroll.getScrollBarWidth() - this.getThreshold();\n    var cssProps = this.getCssProperties();\n    var padding = this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenMode() === leftRight ? '0.5px' : '1px';\n    content$$1.querySelector('.' + headerContent).style[cssProps.border] = scrollWidth > 0 ? padding : '0px';\n    content$$1.style[cssProps.padding] = scrollWidth > 0 ? scrollWidth + 'px' : '0px';\n  };\n  /**\n   * @param {boolean} rtl - specifies the rtl\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.removePadding = function (rtl) {\n    var cssProps = this.getCssProperties(rtl);\n    var hDiv = this.parent.getHeaderContent().querySelector('.' + headerContent);\n    hDiv.style[cssProps.border] = '';\n    hDiv.parentElement.style[cssProps.padding] = '';\n    var footerDiv = this.parent.getFooterContent();\n\n    if (footerDiv && footerDiv.classList.contains('e-footerpadding')) {\n      footerDiv.classList.remove('e-footerpadding');\n    }\n  };\n  /**\n   * Refresh makes the Grid adoptable with the height of parent container.\n   *\n   * > The [`height`](grid/#height/) must be set to 100%.\n   *\n   * @returns {void}\n   */\n\n\n  Scroll.prototype.refresh = function () {\n    if (this.parent.height !== '100%') {\n      return;\n    }\n\n    var content$$1 = this.parent.getContent();\n    this.parent.element.style.height = '100%';\n    var height = this.widthService.getSiblingsHeight(content$$1);\n    content$$1.style.height = 'calc(100% - ' + height + 'px)'; //Set the height to the  '.' + literals.gridContent;\n\n    if (this.parent.isFrozenGrid()) {\n      content$$1.firstElementChild.style.height = 'calc(100% - ' + getScrollBarWidth() + 'px)';\n    }\n  };\n\n  Scroll.prototype.getThreshold = function () {\n    /* Some browsers places the scroller outside the content,\n     * hence the padding should be adjusted.*/\n    var appName = Browser.info.name;\n\n    if (appName === 'mozilla') {\n      return 0.5;\n    }\n\n    return 1;\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(onEmpty, this.wireEvents, this);\n    this.parent.on(contentReady, this.wireEvents, this);\n    this.parent.on(uiUpdate, this.onPropertyChanged, this);\n    this.parent.on(textWrapRefresh, this.wireEvents, this);\n    this.parent.on(headerRefreshed, this.setScrollLeft, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(onEmpty, this.wireEvents);\n    this.parent.off(contentReady, this.wireEvents);\n    this.parent.off(uiUpdate, this.onPropertyChanged);\n    this.parent.off(textWrapRefresh, this.wireEvents);\n    this.parent.off(headerRefreshed, this.setScrollLeft);\n  };\n\n  Scroll.prototype.setScrollLeft = function () {\n    if (this.parent.isFrozenGrid()) {\n      this.parent.headerModule.getMovableHeader().scrollLeft = this.previousValues.left;\n    } else {\n      this.parent.getHeaderContent().querySelector('.' + headerContent).scrollLeft = this.previousValues.left;\n    }\n  };\n\n  Scroll.prototype.onFrozenContentScroll = function () {\n    var _this = this;\n\n    return function (e) {\n      if (_this.content.querySelector(tbody) === null || _this.parent.isPreventScrollEvent) {\n        return;\n      }\n\n      if (!isNullOrUndefined(_this.parent.infiniteScrollModule) && _this.parent.enableInfiniteScrolling) {\n        _this.parent.notify(infiniteScrollHandler, e);\n      }\n\n      _this.previousValues.top = e.target.scrollTop;\n    };\n  };\n\n  Scroll.prototype.onContentScroll = function (scrollTarget) {\n    var _this = this;\n\n    var element = scrollTarget;\n    var isHeader = element.classList.contains(headerContent);\n    return function (e) {\n      if (_this.content.querySelector(tbody) === null || _this.parent.isPreventScrollEvent) {\n        return;\n      }\n\n      var target = e.target;\n      var left = target.scrollLeft;\n\n      if (!isNullOrUndefined(_this.parent.infiniteScrollModule) && _this.parent.enableInfiniteScrolling) {\n        _this.parent.notify(infiniteScrollHandler, {\n          target: e.target,\n          isLeft: _this.previousValues.left !== left\n        });\n      }\n\n      if (_this.parent.groupSettings.columns.length && _this.parent.groupSettings.enableLazyLoading) {\n        var isDown = _this.previousValues.top < _this.parent.getContent().firstElementChild.scrollTop;\n\n        _this.parent.notify(lazyLoadScrollHandler, {\n          scrollDown: isDown\n        });\n      }\n\n      _this.parent.notify(virtualScrollEdit, {});\n\n      var isFooter = target.classList.contains('e-summarycontent');\n\n      if (_this.previousValues.left === left) {\n        _this.previousValues.top = !isHeader ? _this.previousValues.top : target.scrollTop;\n        return;\n      }\n\n      _this.parent.notify(closeFilterDialog, e);\n\n      element.scrollLeft = left;\n\n      if (isFooter) {\n        _this.header.scrollLeft = left;\n      }\n\n      _this.previousValues.left = left;\n\n      _this.parent.notify(scroll, {\n        left: left\n      });\n    };\n  };\n\n  Scroll.prototype.onCustomScrollbarScroll = function (mCont, mHdr) {\n    var _this = this;\n\n    var content$$1 = mCont;\n    var header = mHdr;\n    return function (e) {\n      if (_this.content.querySelector(tbody) === null) {\n        return;\n      }\n\n      var target = e.target;\n      var left = target.scrollLeft;\n\n      if (_this.previousValues.left === left) {\n        return;\n      }\n\n      content$$1.scrollLeft = left;\n      header.scrollLeft = left;\n      _this.previousValues.left = left;\n\n      _this.parent.notify(scroll, {\n        left: left\n      });\n\n      if (_this.parent.isDestroyed) {\n        return;\n      }\n    };\n  };\n\n  Scroll.prototype.onTouchScroll = function (scrollTarget) {\n    var _this = this;\n\n    var element = scrollTarget;\n    return function (e) {\n      if (e.pointerType === 'mouse') {\n        return;\n      }\n\n      var isFrozen = _this.parent.isFrozenGrid();\n\n      var pageXY = _this.getPointXY(e);\n\n      var left = element.scrollLeft + (_this.pageXY.x - pageXY.x);\n      var mHdr = isFrozen ? _this.parent.getHeaderContent().querySelector('.' + movableHeader) : _this.parent.getHeaderContent().querySelector('.' + headerContent);\n      var mCont = isFrozen ? _this.parent.getContent().querySelector('.' + movableContent) : _this.parent.getContent().querySelector('.' + content);\n\n      if (_this.previousValues.left === left || left < 0 || mHdr.scrollWidth - mHdr.clientWidth < left) {\n        return;\n      }\n\n      e.preventDefault();\n      mHdr.scrollLeft = left;\n      mCont.scrollLeft = left;\n\n      if (isFrozen) {\n        var scrollBar = _this.parent.getContent().querySelector('.e-movablescrollbar');\n\n        scrollBar.scrollLeft = left;\n      }\n\n      _this.pageXY.x = pageXY.x;\n      _this.previousValues.left = left;\n    };\n  };\n\n  Scroll.prototype.setPageXY = function () {\n    var _this = this;\n\n    return function (e) {\n      if (e.pointerType === 'mouse') {\n        return;\n      }\n\n      _this.pageXY = _this.getPointXY(e);\n    };\n  };\n\n  Scroll.prototype.getPointXY = function (e) {\n    var pageXY = {\n      x: 0,\n      y: 0\n    };\n\n    if (e.touches && e.touches.length) {\n      pageXY.x = e.touches[0].pageX;\n      pageXY.y = e.touches[0].pageY;\n    } else {\n      pageXY.x = e.pageX;\n      pageXY.y = e.pageY;\n    }\n\n    return pageXY;\n  };\n\n  Scroll.prototype.getScrollbleParent = function (node) {\n    if (node === null) {\n      return null;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var parent = isNullOrUndefined(node.tagName) ? node.scrollingElement : node;\n    var overflowY = document.defaultView.getComputedStyle(parent, null).overflowY;\n\n    if (parent.scrollHeight > parent.clientHeight && overflowY !== 'hidden' && overflowY !== 'visible' || node.tagName === 'HTML' || node.tagName === 'BODY') {\n      return node;\n    } else {\n      return this.getScrollbleParent(node.parentNode);\n    }\n  };\n  /**\n   * @param {boolean} isAdd - specifies whether adding/removing the event\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.addStickyListener = function (isAdd) {\n    this.parentElement = this.getScrollbleParent(this.parent.element.parentElement);\n\n    if (isAdd && this.parentElement) {\n      this.eventElement = this.parentElement.tagName === 'HTML' || this.parentElement.tagName === 'BODY' ? document : this.parentElement;\n      EventHandler.add(this.eventElement, 'scroll', this.makeStickyHeader, this);\n    } else if (this.eventElement) {\n      EventHandler.remove(this.eventElement, 'scroll', this.makeStickyHeader);\n      this.eventElement = null;\n    }\n  };\n\n  Scroll.prototype.wireEvents = function () {\n    var _this = this;\n\n    if (this.oneTimeReady) {\n      var frzCols = this.parent.isFrozenGrid();\n      this.content = this.parent.getContent().querySelector('.' + content);\n      this.header = this.parent.getHeaderContent().querySelector('.' + headerContent);\n      var mCont = this.content.querySelector('.' + movableContent);\n      var mHdr = this.header.querySelector('.' + movableHeader);\n      var mScrollBar = this.parent.getContent().querySelector('.e-movablescrollbar');\n\n      if (this.parent.frozenRows) {\n        EventHandler.add(frzCols ? mHdr : this.header, 'touchstart pointerdown', this.setPageXY(), this);\n        EventHandler.add(frzCols ? mHdr : this.header, 'touchmove pointermove', this.onTouchScroll(frzCols ? mCont : this.content), this);\n      }\n\n      if (this.parent.isFrozenGrid()) {\n        EventHandler.add(mScrollBar, 'scroll', this.onCustomScrollbarScroll(mCont, mHdr), this);\n        EventHandler.add(mCont, 'scroll', this.onCustomScrollbarScroll(mScrollBar, mHdr), this);\n        EventHandler.add(mHdr, 'scroll', this.onCustomScrollbarScroll(mScrollBar, mCont), this);\n        EventHandler.add(this.content, 'scroll', this.onFrozenContentScroll(), this);\n        EventHandler.add(mHdr, 'touchstart pointerdown', this.setPageXY(), this);\n        EventHandler.add(mHdr, 'touchmove pointermove', this.onTouchScroll(mCont), this);\n        EventHandler.add(mCont, 'touchstart pointerdown', this.setPageXY(), this);\n\n        if (!(/macintosh|ipad/.test(Browser.userAgent.toLowerCase()) && Browser.isDevice)) {\n          EventHandler.add(mCont, 'touchmove pointermove', this.onTouchScroll(mHdr), this);\n        }\n      } else {\n        EventHandler.add(this.content, 'scroll', this.onContentScroll(this.header), this);\n        EventHandler.add(this.header, 'scroll', this.onContentScroll(this.content), this);\n      }\n\n      if (this.parent.aggregates.length) {\n        EventHandler.add(this.parent.getFooterContent().firstChild, 'scroll', this.onContentScroll(this.content), this);\n      }\n\n      if (this.parent.enableStickyHeader) {\n        this.addStickyListener(true);\n      }\n\n      this.refresh();\n      this.oneTimeReady = false;\n    }\n\n    var table$$1 = this.parent.getContentTable();\n    var sLeft;\n    var sHeight;\n    var clientHeight;\n    getUpdateUsingRaf(function () {\n      sLeft = _this.header.scrollLeft;\n      sHeight = table$$1.scrollHeight;\n      clientHeight = _this.parent.getContent().clientHeight;\n    }, function () {\n      var args = {\n        cancel: false\n      };\n\n      _this.parent.notify(checkScrollReset, args);\n\n      if (!_this.parent.enableVirtualization && !_this.parent.enableInfiniteScrolling) {\n        if (sHeight < clientHeight) {\n          addClass(table$$1.querySelectorAll('tr:last-child td'), 'e-lastrowcell');\n\n          if (_this.parent.isFrozenGrid()) {\n            addClass(_this.parent.getContent().querySelector('.' + movableContent).querySelectorAll('tr:last-child td'), 'e-lastrowcell');\n\n            if (_this.parent.getFrozenRightColumnsCount()) {\n              addClass(_this.parent.getContent().querySelector('.e-frozen-right-content').querySelectorAll('tr:last-child td'), 'e-lastrowcell');\n            }\n          }\n        }\n\n        if (!args.cancel) {\n          if ((_this.parent.frozenRows > 0 || _this.parent.isFrozenGrid()) && _this.header.querySelector('.' + movableHeader)) {\n            _this.header.querySelector('.' + movableHeader).scrollLeft = _this.previousValues.left;\n          } else {\n            _this.header.scrollLeft = _this.previousValues.left;\n          }\n\n          _this.content.scrollLeft = _this.previousValues.left;\n          _this.content.scrollTop = _this.previousValues.top;\n        }\n      }\n\n      if (!_this.parent.enableColumnVirtualization) {\n        _this.content.scrollLeft = sLeft;\n      }\n\n      if (_this.parent.isFrozenGrid() && _this.header.querySelector('.' + movableHeader)) {\n        _this.header.querySelector('.' + movableHeader).scrollLeft = _this.content.querySelector('.' + movableContent).scrollLeft;\n      }\n    });\n    this.parent.isPreventScrollEvent = false;\n  };\n  /**\n   * @param {boolean} rtl - specifies the rtl\n   * @returns {ScrollCss} returns the ScrollCss\n   * @hidden\n   */\n\n\n  Scroll.prototype.getCssProperties = function (rtl) {\n    var css = {};\n    var enableRtl = isNullOrUndefined(rtl) ? this.parent.enableRtl : rtl;\n    css.border = enableRtl ? 'borderLeftWidth' : 'borderRightWidth';\n    css.padding = enableRtl ? 'paddingLeft' : 'paddingRight';\n    return css;\n  };\n\n  Scroll.prototype.ensureOverflow = function (content$$1) {\n    content$$1.style.overflowY = this.parent.height === 'auto' ? 'auto' : 'scroll';\n  };\n\n  Scroll.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    this.setPadding();\n    this.oneTimeReady = true;\n\n    if (this.parent.height === 'auto') {\n      this.removePadding();\n    }\n\n    this.wireEvents();\n    this.setHeight();\n    var width = 'width';\n    this.setWidth(!isNullOrUndefined(e.properties[width]));\n  };\n\n  Scroll.prototype.makeStickyHeader = function () {\n    if (this.parent.enableStickyHeader && this.parent.element && this.parent.getContent()) {\n      var contentRect = this.parent.getContent().getClientRects()[0];\n\n      if (contentRect) {\n        var headerEle = this.parent.getHeaderContent();\n        var toolbarEle = this.parent.element.querySelector('.e-toolbar');\n        var groupHeaderEle = this.parent.element.querySelector('.e-groupdroparea');\n        var height = headerEle.offsetHeight + (toolbarEle ? toolbarEle.offsetHeight : 0) + (groupHeaderEle ? groupHeaderEle.offsetHeight : 0);\n        var parentTop = this.parentElement.getClientRects()[0].top;\n        var top_1 = contentRect.top - (parentTop < 0 ? 0 : parentTop);\n        var left = contentRect.left;\n\n        if (top_1 < height && contentRect.bottom > 0) {\n          headerEle.classList.add('e-sticky');\n          var elemTop = 0;\n\n          if (groupHeaderEle && this.parent.groupSettings.showDropArea) {\n            this.setSticky(groupHeaderEle, elemTop, contentRect.width, left, true);\n            elemTop += groupHeaderEle.getClientRects()[0].height;\n          }\n\n          if (toolbarEle) {\n            this.setSticky(toolbarEle, elemTop, contentRect.width, left, true);\n            elemTop += toolbarEle.getClientRects()[0].height;\n          }\n\n          this.setSticky(headerEle, elemTop, contentRect.width, left, true);\n        } else {\n          if (headerEle.classList.contains('e-sticky')) {\n            this.setSticky(headerEle, null, null, null, false);\n\n            if (toolbarEle) {\n              this.setSticky(toolbarEle, null, null, null, false);\n            }\n\n            if (groupHeaderEle) {\n              this.setSticky(groupHeaderEle, null, null, null, false);\n            }\n\n            var ccDlg = this.parent.element.querySelector('.e-ccdlg');\n\n            if (ccDlg) {\n              ccDlg.classList.remove('e-sticky');\n            }\n          }\n        }\n\n        this.parent.notify(stickyScrollComplete, {});\n      }\n    }\n  };\n\n  Scroll.prototype.setSticky = function (ele, top, width, left, isAdd) {\n    if (isAdd) {\n      ele.style.width = width + 'px';\n      ele.classList.add('e-sticky');\n    } else {\n      ele.classList.remove('e-sticky');\n    }\n\n    ele.style.top = top != null ? top + 'px' : '';\n    ele.style.left = left !== null ? parseInt(ele.style.left, 10) !== left ? left + 'px' : ele.style.left : '';\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Scroll.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.removeEventListener(); //Remove Dom event\n\n    var cont = this.parent.getContent().querySelector('.' + content);\n    EventHandler.remove(cont, 'scroll', this.onContentScroll);\n\n    if (this.parent.enableStickyHeader) {\n      this.addStickyListener(false);\n    } //Remove padding\n\n\n    this.removePadding();\n    removeClass([this.parent.getHeaderContent().querySelector('.' + headerContent)], headerContent);\n    removeClass([cont], content); //Remove height\n\n    cont.style.height = ''; //Remove width\n\n    this.parent.element.style.width = '';\n  };\n  /**\n   * Function to get the scrollbar width of the browser.\n   *\n   * @returns {number} return the width\n   * @hidden\n   */\n\n\n  Scroll.getScrollBarWidth = function () {\n    return getScrollBarWidth();\n  };\n\n  return Scroll;\n}();\n\nvar __extends$17 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Configures the Grid's aggregate column.\n */\n\n\nvar AggregateColumn =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$17(AggregateColumn, _super);\n\n  function AggregateColumn() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.templateFn = {};\n    return _this;\n  }\n  /**\n   * @param {Function} value - specifies the value\n   * @returns {void}\n   * @hidden\n   */\n\n\n  AggregateColumn.prototype.setFormatter = function (value) {\n    this.formatFn = value;\n  };\n  /**\n   * @returns {Function} returns the Function\n   * @hidden\n   */\n\n\n  AggregateColumn.prototype.getFormatter = function () {\n    return this.formatFn;\n  };\n  /**\n   * @param {Object} helper - specifies the helper\n   * @returns {void}\n   * @hidden\n   */\n\n\n  AggregateColumn.prototype.setTemplate = function (helper) {\n    if (helper === void 0) {\n      helper = {};\n    }\n\n    if (this.footerTemplate !== undefined) {\n      this.templateFn[getEnumValue(CellType, CellType.Summary)] = {\n        fn: compile(this.footerTemplate, helper),\n        property: 'footerTemplate'\n      };\n    }\n\n    if (this.groupFooterTemplate !== undefined) {\n      this.templateFn[getEnumValue(CellType, CellType.GroupSummary)] = {\n        fn: compile(this.groupFooterTemplate, helper),\n        property: 'groupFooterTemplate'\n      };\n    }\n\n    if (this.groupCaptionTemplate !== undefined) {\n      this.templateFn[getEnumValue(CellType, CellType.CaptionSummary)] = {\n        fn: compile(this.groupCaptionTemplate, helper),\n        property: 'groupCaptionTemplate'\n      };\n    }\n  };\n  /**\n   * @param {CellType} type - specifies the cell type\n   * @returns {Object} returns the object\n   * @hidden\n   */\n\n\n  AggregateColumn.prototype.getTemplate = function (type) {\n    return this.templateFn[getEnumValue(CellType, type)];\n  };\n  /**\n   * @param {Object} prop - returns the Object\n   * @returns {void}\n   * @hidden\n   */\n\n\n  AggregateColumn.prototype.setPropertiesSilent = function (prop) {\n    this.setProperties(prop, true);\n  };\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"type\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"field\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"columnName\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"format\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"footerTemplate\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"groupFooterTemplate\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"groupCaptionTemplate\", void 0);\n\n  __decorate$4([Property()], AggregateColumn.prototype, \"customAggregate\", void 0);\n\n  return AggregateColumn;\n}(ChildProperty);\n/**\n * Configures the aggregate rows.\n */\n\n\nvar AggregateRow =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$17(AggregateRow, _super);\n\n  function AggregateRow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$4([Collection([], AggregateColumn)], AggregateRow.prototype, \"columns\", void 0);\n\n  return AggregateRow;\n}(ChildProperty);\n/**\n * The `Clipboard` module is used to handle clipboard copy action.\n */\n\n\nvar Clipboard =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid clipboard module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @hidden\n   */\n  function Clipboard(parent, serviceLocator) {\n    this.copyContent = '';\n    this.isSelect = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Clipboard.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(contentReady, this.initialEnd, this);\n    this.parent.on(keyPressed, this.keyDownHandler, this);\n    this.parent.on(click, this.clickHandler, this);\n    EventHandler.add(this.parent.element, 'keydown', this.pasteHandler, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Clipboard.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(keyPressed, this.keyDownHandler);\n    this.parent.off(contentReady, this.initialEnd);\n    this.parent.off(click, this.clickHandler);\n    EventHandler.remove(this.parent.element, 'keydown', this.pasteHandler);\n  };\n\n  Clipboard.prototype.clickHandler = function (e) {\n    var target = e.target; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    target = parentsUntil(target, 'e-rowcell');\n  };\n\n  Clipboard.prototype.pasteHandler = function (e) {\n    var _this = this;\n\n    var grid = this.parent;\n    var isMacLike = /(Mac)/i.test(navigator.platform);\n\n    if (e.keyCode === 67 && isMacLike && e.metaKey && !grid.isEdit) {\n      this.copy();\n    }\n\n    if (e.keyCode === 86 && (e.ctrlKey || isMacLike && e.metaKey) && !grid.isEdit) {\n      var target = closest(document.activeElement, '.' + rowCell);\n\n      if (!target || !grid.editSettings.allowEditing || grid.editSettings.mode !== 'Batch' || grid.selectionSettings.mode !== 'Cell' || grid.selectionSettings.cellSelectionMode === 'Flow') {\n        return;\n      }\n\n      this.activeElement = document.activeElement;\n      this.clipBoardTextArea.value = '';\n      var x_1 = window.scrollX;\n      var y_1 = window.scrollY;\n      this.clipBoardTextArea.focus();\n      setTimeout(function () {\n        _this.activeElement.focus();\n\n        window.scrollTo(x_1, y_1);\n\n        _this.paste(_this.clipBoardTextArea.value, _this.parent.getSelectedRowCellIndexes()[0].rowIndex, _this.parent.getSelectedRowCellIndexes()[0].cellIndexes[0]);\n      }, 10);\n    }\n  };\n  /**\n   * Paste data from clipboard to selected cells.\n   *\n   * @param {boolean} data - Specifies the date for paste.\n   * @param {boolean} rowIndex - Specifies the row index.\n   * @param {boolean} colIndex - Specifies the column index.\n   * @returns {void}\n   */\n\n\n  Clipboard.prototype.paste = function (data, rowIndex, colIndex) {\n    var grid = this.parent;\n    var cIdx = colIndex;\n    var rIdx = rowIndex;\n    var col;\n    var value;\n    var isAvail;\n\n    if (!grid.editSettings.allowEditing || grid.editSettings.mode !== 'Batch' || grid.selectionSettings.mode !== 'Cell' || grid.selectionSettings.cellSelectionMode === 'Flow') {\n      return;\n    }\n\n    var rows = data.split('\\n');\n    var cols;\n    var dataRows = grid.getDataRows();\n    var mRows;\n    var frRows;\n    var isFrozen = this.parent.isFrozenGrid();\n\n    if (isFrozen) {\n      mRows = grid.getMovableDataRows();\n\n      if (grid.getFrozenRightColumnsCount()) {\n        frRows = grid.getFrozenRightDataRows();\n      }\n    }\n\n    for (var r = 0; r < rows.length; r++) {\n      cols = rows[r].split('\\t');\n      cIdx = colIndex;\n\n      if (r === rows.length - 1 && rows[r] === '' || isUndefined(grid.getRowByIndex(rIdx))) {\n        cIdx++;\n        break;\n      }\n\n      for (var c = 0; c < cols.length; c++) {\n        isAvail = grid.getCellFromIndex(rIdx, cIdx);\n\n        if (isFrozen) {\n          var fTr = dataRows[rIdx];\n          var mTr = mRows[rIdx];\n          isAvail = !fTr.querySelector('[data-colindex=\"' + cIdx + '\"]') ? mTr.querySelector('[data-colindex=\"' + cIdx + '\"]') : true;\n\n          if (frRows && !isAvail) {\n            var frTr = frRows[rIdx];\n            isAvail = frTr.querySelector('[data-colindex=\"' + cIdx + '\"]');\n          }\n        }\n\n        if (!isAvail) {\n          cIdx++;\n          break;\n        }\n\n        col = grid.getColumnByIndex(cIdx);\n        value = col.getParser() ? col.getParser()(cols[c]) : cols[c];\n\n        if (col.allowEditing && !col.isPrimaryKey && !col.template) {\n          var args = {\n            column: col,\n            data: value,\n            rowIndex: rIdx\n          };\n          this.parent.trigger(beforePaste, args);\n          rIdx = args.rowIndex;\n\n          if (!args.cancel) {\n            if (grid.editModule) {\n              if (col.type === 'number') {\n                this.parent.editModule.updateCell(rIdx, col.field, parseFloat(args.data));\n              } else {\n                grid.editModule.updateCell(rIdx, col.field, args.data);\n              }\n            }\n          }\n        }\n\n        cIdx++;\n      }\n\n      rIdx++;\n    }\n\n    grid.selectionModule.selectCellsByRange({\n      rowIndex: rowIndex,\n      cellIndex: colIndex\n    }, {\n      rowIndex: rIdx - 1,\n      cellIndex: cIdx - 1\n    });\n    var cell = this.parent.getCellFromIndex(rIdx - 1, cIdx - 1);\n\n    if (cell) {\n      classList(cell, ['e-focus', 'e-focused'], []);\n    }\n  };\n\n  Clipboard.prototype.initialEnd = function () {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.parent.off(contentReady, this.initialEnd);\n    this.clipBoardTextArea = this.parent.createElement('textarea', {\n      className: 'e-clipboard',\n      styles: 'opacity: 0',\n      attrs: {\n        tabindex: '-1',\n        'aria-label': this.l10n.getConstant('ClipBoard')\n      }\n    });\n    this.parent.element.appendChild(this.clipBoardTextArea);\n  };\n\n  Clipboard.prototype.keyDownHandler = function (e) {\n    if (e.action === 'ctrlPlusC') {\n      this.copy();\n    } else if (e.action === 'ctrlShiftPlusH') {\n      this.copy(true);\n    }\n  };\n\n  Clipboard.prototype.setCopyData = function (withHeader) {\n    if (window.getSelection().toString() === '') {\n      var isFrozen = this.parent.isFrozenGrid();\n      this.clipBoardTextArea.value = this.copyContent = '';\n      var mRows = void 0;\n      var frRows = void 0;\n      var rows = this.parent.getRows();\n\n      if (isFrozen) {\n        mRows = this.parent.getMovableDataRows();\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          frRows = this.parent.getFrozenRightRows();\n        }\n      }\n\n      if (this.parent.selectionSettings.mode !== 'Cell') {\n        var selectedIndexes = this.parent.getSelectedRowIndexes().sort(function (a, b) {\n          return a - b;\n        });\n\n        if (withHeader) {\n          var headerTextArray = [];\n\n          for (var i = 0; i < this.parent.getVisibleColumns().length; i++) {\n            headerTextArray[i] = this.parent.getVisibleColumns()[i].headerText;\n          }\n\n          this.getCopyData(headerTextArray, false, '\\t', withHeader);\n          this.copyContent += '\\n';\n        }\n\n        for (var i = 0; i < selectedIndexes.length; i++) {\n          if (i > 0) {\n            this.copyContent += '\\n';\n          }\n\n          var cells = [].slice.call(rows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)'));\n\n          if (isFrozen) {\n            cells.push.apply(cells, [].slice.call(mRows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)')));\n\n            if (frRows) {\n              cells.push.apply(cells, [].slice.call(frRows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)')));\n            }\n          }\n\n          this.getCopyData(cells, false, '\\t', withHeader);\n        }\n      } else {\n        var obj = this.checkBoxSelection();\n\n        if (obj.status) {\n          if (withHeader) {\n            var headers = [];\n\n            for (var i = 0; i < obj.colIndexes.length; i++) {\n              headers.push(this.parent.getColumnHeaderByIndex(obj.colIndexes[i]));\n            }\n\n            this.getCopyData(headers, false, '\\t', withHeader);\n            this.copyContent += '\\n';\n          }\n\n          for (var i = 0; i < obj.rowIndexes.length; i++) {\n            if (i > 0) {\n              this.copyContent += '\\n';\n            }\n\n            var cells = [].slice.call(rows[obj.rowIndexes[i]].getElementsByClassName('e-cellselectionbackground'));\n\n            if (isFrozen) {\n              cells.push.apply(cells, [].slice.call(mRows[obj.rowIndexes[i]].getElementsByClassName('e-cellselectionbackground')));\n\n              if (frRows) {\n                cells.push.apply(cells, [].slice.call(frRows[obj.rowIndexes[i]].getElementsByClassName('e-cellselectionbackground')));\n              }\n            }\n\n            this.getCopyData(cells, false, '\\t', withHeader);\n          }\n        } else {\n          this.getCopyData([].slice.call(this.parent.element.getElementsByClassName('e-cellselectionbackground')), true, '\\n', withHeader);\n        }\n      }\n\n      var args = {\n        data: this.copyContent,\n        cancel: false\n      };\n      this.parent.trigger(beforeCopy, args);\n\n      if (args.cancel) {\n        return;\n      }\n\n      this.clipBoardTextArea.value = this.copyContent = args.data;\n\n      if (!Browser.userAgent.match(/ipad|ipod|iphone/i)) {\n        this.clipBoardTextArea.select();\n      } else {\n        this.clipBoardTextArea.setSelectionRange(0, this.clipBoardTextArea.value.length);\n      }\n\n      this.isSelect = true;\n    }\n  };\n\n  Clipboard.prototype.getCopyData = function (cells, isCell, splitKey, withHeader) {\n    var isElement = typeof cells[0] !== 'string';\n\n    for (var j = 0; j < cells.length; j++) {\n      if (withHeader && isCell) {\n        var colIdx = parseInt(cells[j].getAttribute(dataColIndex), 10);\n        this.copyContent += this.parent.getColumns()[colIdx].headerText + '\\n';\n      }\n\n      if (isElement) {\n        if (!cells[j].classList.contains('e-hide')) {\n          this.copyContent += cells[j].innerText;\n        }\n      } else {\n        this.copyContent += cells[j];\n      }\n\n      if (j < cells.length - 1) {\n        this.copyContent += splitKey;\n      }\n    }\n  };\n  /**\n   * Copy selected rows or cells data into clipboard.\n   *\n   * @returns {void}\n   * @param {boolean} withHeader - Specifies whether the column header data need to be copied or not.\n   */\n\n\n  Clipboard.prototype.copy = function (withHeader) {\n    if (document.queryCommandSupported('copy')) {\n      this.setCopyData(withHeader);\n      document.execCommand('copy');\n      this.clipBoardTextArea.blur();\n    }\n\n    if (this.isSelect) {\n      window.getSelection().removeAllRanges();\n      this.isSelect = false;\n    }\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Clipboard.prototype.getModuleName = function () {\n    return 'clipboard';\n  };\n  /**\n   * To destroy the clipboard\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Clipboard.prototype.destroy = function () {\n    this.removeEventListener();\n\n    if (this.clipBoardTextArea) {\n      remove(this.clipBoardTextArea);\n    }\n  };\n\n  Clipboard.prototype.checkBoxSelection = function () {\n    var gridObj = this.parent;\n    var obj = {\n      status: false\n    };\n\n    if (gridObj.selectionSettings.mode === 'Cell') {\n      var rowCellIndxes = gridObj.getSelectedRowCellIndexes();\n      var str = void 0;\n      var rowIndexes = [];\n      var i = void 0;\n\n      for (i = 0; i < rowCellIndxes.length; i++) {\n        if (rowCellIndxes[i].cellIndexes.length) {\n          rowIndexes.push(rowCellIndxes[i].rowIndex);\n        }\n\n        if (rowCellIndxes[i].cellIndexes.length) {\n          if (!str) {\n            str = JSON.stringify(rowCellIndxes[i].cellIndexes.sort());\n          }\n\n          if (str !== JSON.stringify(rowCellIndxes[i].cellIndexes.sort())) {\n            break;\n          }\n        }\n      }\n\n      rowIndexes.sort(function (a, b) {\n        return a - b;\n      });\n\n      if (i === rowCellIndxes.length && rowIndexes[rowIndexes.length - 1] - rowIndexes[0] === rowIndexes.length - 1) {\n        obj = {\n          status: true,\n          rowIndexes: rowIndexes,\n          colIndexes: rowCellIndxes[0].cellIndexes\n        };\n      }\n    }\n\n    return obj;\n  };\n\n  return Clipboard;\n}();\n\nvar __extends$1 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Represents the field name and direction of sort column.\n */\n\n\nvar SortDescriptor =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(SortDescriptor, _super);\n\n  function SortDescriptor() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property()], SortDescriptor.prototype, \"field\", void 0);\n\n  __decorate$1([Property()], SortDescriptor.prototype, \"direction\", void 0);\n\n  __decorate$1([Property(false)], SortDescriptor.prototype, \"isFromGroup\", void 0);\n\n  return SortDescriptor;\n}(ChildProperty);\n/**\n * Configures the sorting behavior of Grid.\n */\n\n\nvar SortSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(SortSettings, _super);\n\n  function SortSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Collection([], SortDescriptor)], SortSettings.prototype, \"columns\", void 0);\n\n  __decorate$1([Property(true)], SortSettings.prototype, \"allowUnsort\", void 0);\n\n  return SortSettings;\n}(ChildProperty);\n/**\n * Represents the predicate for the filter column.\n */\n\n\nvar Predicate$1 =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(Predicate$$1, _super);\n\n  function Predicate$$1() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"field\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"operator\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"value\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"matchCase\", void 0);\n\n  __decorate$1([Property(false)], Predicate$$1.prototype, \"ignoreAccent\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"predicate\", void 0);\n\n  __decorate$1([Property({})], Predicate$$1.prototype, \"actualFilterValue\", void 0);\n\n  __decorate$1([Property({})], Predicate$$1.prototype, \"actualOperator\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"type\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"ejpredicate\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"uid\", void 0);\n\n  __decorate$1([Property()], Predicate$$1.prototype, \"isForeignKey\", void 0);\n\n  return Predicate$$1;\n}(ChildProperty);\n/**\n * Configures the infinite scroll behavior of Grid.\n */\n\n\nvar InfiniteScrollSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(InfiniteScrollSettings, _super);\n\n  function InfiniteScrollSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property(false)], InfiniteScrollSettings.prototype, \"enableCache\", void 0);\n\n  __decorate$1([Property(3)], InfiniteScrollSettings.prototype, \"maxBlocks\", void 0);\n\n  __decorate$1([Property(3)], InfiniteScrollSettings.prototype, \"initialBlocks\", void 0);\n\n  return InfiniteScrollSettings;\n}(ChildProperty);\n/**\n * Configures the filtering behavior of the Grid.\n */\n\n\nvar FilterSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(FilterSettings, _super);\n\n  function FilterSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Collection([], Predicate$1)], FilterSettings.prototype, \"columns\", void 0);\n\n  __decorate$1([Property('FilterBar')], FilterSettings.prototype, \"type\", void 0);\n\n  __decorate$1([Property()], FilterSettings.prototype, \"mode\", void 0);\n\n  __decorate$1([Property(true)], FilterSettings.prototype, \"showFilterBarStatus\", void 0);\n\n  __decorate$1([Property(1500)], FilterSettings.prototype, \"immediateModeDelay\", void 0);\n\n  __decorate$1([Property()], FilterSettings.prototype, \"operators\", void 0);\n\n  __decorate$1([Property(false)], FilterSettings.prototype, \"ignoreAccent\", void 0);\n\n  __decorate$1([Property(false)], FilterSettings.prototype, \"enableCaseSensitivity\", void 0);\n\n  __decorate$1([Property(false)], FilterSettings.prototype, \"showFilterBarOperator\", void 0);\n\n  return FilterSettings;\n}(ChildProperty);\n/**\n * Configures the selection behavior of the Grid.\n */\n\n\nvar SelectionSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(SelectionSettings, _super);\n\n  function SelectionSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property('Row')], SelectionSettings.prototype, \"mode\", void 0);\n\n  __decorate$1([Property('Flow')], SelectionSettings.prototype, \"cellSelectionMode\", void 0);\n\n  __decorate$1([Property('Single')], SelectionSettings.prototype, \"type\", void 0);\n\n  __decorate$1([Property(false)], SelectionSettings.prototype, \"checkboxOnly\", void 0);\n\n  __decorate$1([Property(false)], SelectionSettings.prototype, \"persistSelection\", void 0);\n\n  __decorate$1([Property('Default')], SelectionSettings.prototype, \"checkboxMode\", void 0);\n\n  __decorate$1([Property(false)], SelectionSettings.prototype, \"enableSimpleMultiRowSelection\", void 0);\n\n  __decorate$1([Property(true)], SelectionSettings.prototype, \"enableToggle\", void 0);\n\n  __decorate$1([Property(false)], SelectionSettings.prototype, \"allowColumnSelection\", void 0);\n\n  return SelectionSettings;\n}(ChildProperty);\n/**\n * Configures the search behavior of the Grid.\n */\n\n\nvar SearchSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(SearchSettings, _super);\n\n  function SearchSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property([])], SearchSettings.prototype, \"fields\", void 0);\n\n  __decorate$1([Property('')], SearchSettings.prototype, \"key\", void 0);\n\n  __decorate$1([Property('contains')], SearchSettings.prototype, \"operator\", void 0);\n\n  __decorate$1([Property(true)], SearchSettings.prototype, \"ignoreCase\", void 0);\n\n  __decorate$1([Property(false)], SearchSettings.prototype, \"ignoreAccent\", void 0);\n\n  return SearchSettings;\n}(ChildProperty);\n/**\n * Configures the row drop settings of the Grid.\n */\n\n\nvar RowDropSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(RowDropSettings, _super);\n\n  function RowDropSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property()], RowDropSettings.prototype, \"targetID\", void 0);\n\n  return RowDropSettings;\n}(ChildProperty);\n/**\n * Configures the text wrap settings of the Grid.\n */\n\n\nvar TextWrapSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(TextWrapSettings, _super);\n\n  function TextWrapSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property('Both')], TextWrapSettings.prototype, \"wrapMode\", void 0);\n\n  return TextWrapSettings;\n}(ChildProperty);\n/**\n * Configures the resize behavior of the Grid.\n */\n\n\nvar ResizeSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(ResizeSettings, _super);\n\n  function ResizeSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property('Normal')], ResizeSettings.prototype, \"mode\", void 0);\n\n  return ResizeSettings;\n}(ChildProperty);\n/**\n * Configures the group behavior of the Grid.\n */\n\n\nvar GroupSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(GroupSettings, _super);\n\n  function GroupSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property(true)], GroupSettings.prototype, \"showDropArea\", void 0);\n\n  __decorate$1([Property(false)], GroupSettings.prototype, \"allowReordering\", void 0);\n\n  __decorate$1([Property(false)], GroupSettings.prototype, \"showToggleButton\", void 0);\n\n  __decorate$1([Property(false)], GroupSettings.prototype, \"showGroupedColumn\", void 0);\n\n  __decorate$1([Property(true)], GroupSettings.prototype, \"showUngroupButton\", void 0);\n\n  __decorate$1([Property(false)], GroupSettings.prototype, \"disablePageWiseAggregates\", void 0);\n\n  __decorate$1([Property([])], GroupSettings.prototype, \"columns\", void 0);\n\n  __decorate$1([Property()], GroupSettings.prototype, \"captionTemplate\", void 0);\n\n  __decorate$1([Property(false)], GroupSettings.prototype, \"enableLazyLoading\", void 0);\n\n  return GroupSettings;\n}(ChildProperty);\n/**\n * Configures the edit behavior of the Grid.\n */\n\n\nvar EditSettings =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(EditSettings, _super);\n\n  function EditSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property(false)], EditSettings.prototype, \"allowAdding\", void 0);\n\n  __decorate$1([Property(false)], EditSettings.prototype, \"allowEditing\", void 0);\n\n  __decorate$1([Property(false)], EditSettings.prototype, \"allowDeleting\", void 0);\n\n  __decorate$1([Property('Normal')], EditSettings.prototype, \"mode\", void 0);\n\n  __decorate$1([Property(true)], EditSettings.prototype, \"allowEditOnDblClick\", void 0);\n\n  __decorate$1([Property(true)], EditSettings.prototype, \"showConfirmDialog\", void 0);\n\n  __decorate$1([Property(false)], EditSettings.prototype, \"showDeleteConfirmDialog\", void 0);\n\n  __decorate$1([Property('')], EditSettings.prototype, \"template\", void 0);\n\n  __decorate$1([Property('')], EditSettings.prototype, \"headerTemplate\", void 0);\n\n  __decorate$1([Property('')], EditSettings.prototype, \"footerTemplate\", void 0);\n\n  __decorate$1([Property('Top')], EditSettings.prototype, \"newRowPosition\", void 0);\n\n  __decorate$1([Property({})], EditSettings.prototype, \"dialog\", void 0);\n\n  __decorate$1([Property(false)], EditSettings.prototype, \"allowNextRowEdit\", void 0);\n\n  return EditSettings;\n}(ChildProperty);\n/**\n * Configures the Loading Indicator of the Grid.\n */\n\n\nvar LoadingIndicator =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(LoadingIndicator, _super);\n\n  function LoadingIndicator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate$1([Property('Spinner')], LoadingIndicator.prototype, \"indicatorType\", void 0);\n\n  return LoadingIndicator;\n}(ChildProperty);\n/**\n * Represents the Grid component.\n * ```html\n * <div id=\"grid\"></div>\n * <script>\n *  var gridObj = new Grid({ allowPaging: true });\n *  gridObj.appendTo(\"#grid\");\n * </script>\n * ```\n */\n\n\nvar Grid =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$1(Grid, _super);\n  /**\n   * Constructor for creating the component\n   *\n   * @param {GridModel} options - specifies the options\n   * @param {string | HTMLElement} element - specifies the element\n   * @hidden\n   */\n\n\n  function Grid(options, element) {\n    var _this = _super.call(this, options, element) || this;\n\n    _this.isPreventScrollEvent = false;\n    _this.inViewIndexes = [];\n    _this.keyA = false;\n    _this.frozenRightCount = 0;\n    _this.frozenLeftCount = 0;\n    _this.tablesCount = 1;\n    _this.movableCount = 0;\n    _this.visibleFrozenLeft = 0;\n    _this.visibleFrozenRight = 0;\n    _this.visibleMovable = 0;\n    _this.frozenLeftColumns = [];\n    _this.frozenRightColumns = [];\n    _this.movableColumns = [];\n    _this.media = {};\n    _this.isFreezeRefresh = false;\n    /** @hidden */\n\n    _this.tableIndex = 0;\n    _this.componentRefresh = Component.prototype.refresh;\n    /** @hidden */\n\n    _this.isVirtualAdaptive = false;\n    /** @hidden */\n\n    _this.vRows = [];\n    /** @hidden */\n\n    _this.vcRows = [];\n    /** @hidden */\n\n    _this.vGroupOffsets = {};\n    /** @hidden */\n\n    _this.rowUid = 0;\n    /**\n     * Gets the currently visible records of the Grid.\n     */\n\n    _this.currentViewData = [];\n    /** @hidden */\n\n    _this.isManualRefresh = false;\n    /** @hidden */\n\n    _this.isAutoFitColumns = false;\n    /** @hidden */\n\n    _this.enableDeepCompare = false;\n    /** @hidden */\n\n    _this.totalDataRecordsCount = 0;\n    /** @hidden */\n\n    _this.disableSelectedRecords = [];\n    /** @hidden */\n\n    _this.partialSelectedRecords = [];\n    /** @hidden */\n\n    _this.lockcolPositionCount = 0;\n    /** @hidden */\n\n    _this.prevPageMoving = false;\n    /** @hidden */\n\n    _this.pageTemplateChange = false;\n    /** @hidden */\n\n    _this.isAutoGen = false;\n    _this.mediaBindInstance = {};\n    /** @hidden */\n\n    _this.commandDelIndex = undefined;\n    /** @hidden */\n\n    _this.asyncTimeOut = 50;\n    /** @hidden */\n\n    _this.isExportGrid = false; // enable/disable logger for MVC & Core\n\n    _this.enableLogger = true;\n    _this.needsID = true;\n    Grid_1.Inject(Selection);\n    setValue('mergePersistData', _this.mergePersistGridData, _this);\n    return _this;\n  }\n\n  Grid_1 = Grid;\n  /**\n   * Get the properties to be maintained in the persisted state.\n   *\n   * @returns {string} returns the persist data\n   */\n\n  Grid.prototype.getPersistData = function () {\n    var keyEntity = ['pageSettings', 'sortSettings', 'filterSettings', 'groupSettings', 'columns', 'searchSettings', 'selectedRowIndex', 'scrollPosition'];\n    var ignoreOnPersist = {\n      pageSettings: ['template', 'pageSizes', 'enableQueryString', 'totalRecordsCount', 'pageCount'],\n      filterSettings: ['type', 'mode', 'showFilterBarStatus', 'immediateModeDelay', 'ignoreAccent'],\n      groupSettings: ['showDropArea', 'showToggleButton', 'showGroupedColumn', 'showUngroupButton', 'disablePageWiseAggregates', 'hideCaptionCount'],\n      searchSettings: ['fields', 'operator', 'ignoreCase'],\n      sortSettings: [],\n      columns: [],\n      selectedRowIndex: [],\n      scrollPosition: []\n    };\n\n    for (var i = 0; i < keyEntity.length; i++) {\n      var currentObject = this[keyEntity[i]];\n\n      for (var _i = 0, _a = ignoreOnPersist[keyEntity[i]]; _i < _a.length; _i++) {\n        var val = _a[_i];\n        delete currentObject[val];\n      }\n    }\n\n    var temp = this.pageSettings.template;\n    var settings = Object.assign({\n      template: undefined\n    }, this.pageSettings);\n    this.setProperties({\n      pageSettings: settings\n    }, true); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    if (this.isAngular) {\n      delete this.groupSettings['properties']['captionTemplate'];\n    }\n\n    this.pageTemplateChange = !isNullOrUndefined(this.pagerTemplate);\n    var persistData = this.addOnPersist(keyEntity);\n    settings.template = temp;\n    this.setProperties({\n      pageSettings: settings\n    }, true);\n    return persistData;\n  };\n  /**\n   * To provide the array of modules needed for component rendering\n   *\n   * @returns {ModuleDeclaration[]} Returns the module Declaration\n   * @hidden\n   */\n\n\n  Grid.prototype.requiredModules = function () {\n    this.setFrozenCount();\n    this.enableInfiniteAggrgate();\n    var modules = [];\n\n    if (this.isDestroyed) {\n      return modules;\n    }\n\n    if (this.allowFiltering) {\n      modules.push({\n        member: 'filter',\n        args: [this, this.filterSettings, this.serviceLocator]\n      });\n    }\n\n    if (this.allowExcelExport) {\n      modules.push({\n        member: 'ExcelExport',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.allowPdfExport) {\n      modules.push({\n        member: 'PdfExport',\n        args: [this]\n      });\n    }\n\n    if (this.allowSorting) {\n      modules.push({\n        member: 'sort',\n        args: [this, this.sortSettings, this.sortedColumns, this.serviceLocator]\n      });\n    }\n\n    if (this.allowPaging) {\n      modules.push({\n        member: 'pager',\n        args: [this, this.pageSettings]\n      });\n    }\n\n    if (this.allowSelection) {\n      modules.push({\n        member: 'selection',\n        args: [this, this.selectionSettings, this.serviceLocator]\n      });\n    }\n\n    modules.push({\n      member: 'resize',\n      args: [this]\n    });\n\n    if (this.allowReordering) {\n      modules.push({\n        member: 'reorder',\n        args: [this]\n      });\n    }\n\n    if (this.allowRowDragAndDrop) {\n      modules.push({\n        member: 'rowDragAndDrop',\n        args: [this]\n      });\n    }\n\n    if (this.allowGrouping) {\n      modules.push({\n        member: 'group',\n        args: [this, this.groupSettings, this.sortedColumns, this.serviceLocator]\n      });\n    }\n\n    if (this.aggregates.length) {\n      modules.push({\n        member: 'aggregate',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.isDetail()) {\n      modules.push({\n        member: 'detailRow',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.toolbar || this.toolbarTemplate) {\n      modules.push({\n        member: 'toolbar',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.enableVirtualization || this.enableColumnVirtualization) {\n      modules.push({\n        member: 'virtualscroll',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.getFrozenColumns() || this.frozenRows || this.frozenRightCount || this.frozenLeftCount) {\n      modules.push({\n        member: 'freeze',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.isCommandColumn(this.columns)) {\n      modules.push({\n        member: 'commandColumn',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.editSettings.allowAdding || this.editSettings.allowDeleting || this.editSettings.allowEditing) {\n      modules.push({\n        member: 'edit',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    this.extendRequiredModules(modules);\n    return modules;\n  };\n\n  Grid.prototype.extendRequiredModules = function (modules) {\n    if (this.enableInfiniteScrolling) {\n      modules.push({\n        member: 'infiniteScroll',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.groupSettings.enableLazyLoading) {\n      modules.push({\n        member: 'lazyLoadGroup',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.contextMenuItems) {\n      modules.push({\n        member: 'contextMenu',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.showColumnMenu) {\n      modules.push({\n        member: 'columnMenu',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.showColumnChooser) {\n      modules.push({\n        member: 'columnChooser',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.isForeignKeyEnabled(this.columns)) {\n      modules.push({\n        member: 'foreignKey',\n        args: [this, this.serviceLocator]\n      });\n    }\n\n    if (this.enableLogger) {\n      modules.push({\n        member: 'logger',\n        args: [this]\n      });\n    }\n  };\n  /**\n   * For internal use only - Initialize the event handler;\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  Grid.prototype.preRender = function () {\n    this.serviceLocator = new ServiceLocator();\n    this.initProperties();\n    this.initializeServices();\n  };\n\n  Grid.prototype.initProperties = function () {\n    this.isInitial = true;\n    this.sortedColumns = [];\n    this.inViewIndexes = [];\n    this.mediaCol = [];\n    this.isInitialLoad = false;\n    this.allowServerDataBinding = false;\n    this.ignoreCollectionWatch = true;\n    this.mergeCells = {};\n    this.isEdit = false;\n    this.checkAllRows = 'None';\n    this.isCheckBoxSelection = false;\n    this.isPersistSelection = false;\n    this.componentRefresh = Component.prototype.refresh;\n    this.filterOperators = {\n      contains: 'contains',\n      endsWith: 'endswith',\n      equal: 'equal',\n      greaterThan: 'greaterthan',\n      greaterThanOrEqual: 'greaterthanorequal',\n      lessThan: 'lessthan',\n      lessThanOrEqual: 'lessthanorequal',\n      notEqual: 'notequal',\n      startsWith: 'startswith'\n    };\n    this.defaultLocale = {\n      EmptyRecord: 'No records to display',\n      True: 'true',\n      False: 'false',\n      InvalidFilterMessage: 'Invalid Filter Data',\n      GroupDropArea: 'Drag a column header here to group its column',\n      UnGroup: 'Click here to ungroup',\n      UnGroupButton: 'Click here to ungroup',\n      GroupDisable: 'Grouping is disabled for this column',\n      FilterbarTitle: '\\'s filter bar cell',\n      EmptyDataSourceError: 'DataSource must not be empty at initial load since columns are generated from dataSource in AutoGenerate Column Grid',\n      // Toolbar Items\n      Add: 'Add',\n      Edit: 'Edit',\n      Cancel: 'Cancel',\n      Update: 'Update',\n      Delete: 'Delete',\n      Print: 'Print',\n      Pdfexport: 'PDF Export',\n      Excelexport: 'Excel Export',\n      Wordexport: 'Word Export',\n      Csvexport: 'CSV Export',\n      Search: 'Search',\n      Columnchooser: 'Columns',\n      Save: 'Save',\n      Item: 'item',\n      Items: 'items',\n      EditOperationAlert: 'No records selected for edit operation',\n      DeleteOperationAlert: 'No records selected for delete operation',\n      SaveButton: 'Save',\n      OKButton: 'OK',\n      CancelButton: 'Cancel',\n      EditFormTitle: 'Details of ',\n      AddFormTitle: 'Add New Record',\n      BatchSaveConfirm: 'Are you sure you want to save changes?',\n      BatchSaveLostChanges: 'Unsaved changes will be lost. Are you sure you want to continue?',\n      ConfirmDelete: 'Are you sure you want to Delete Record?',\n      CancelEdit: 'Are you sure you want to Cancel the changes?',\n      ChooseColumns: 'Choose Column',\n      SearchColumns: 'search columns',\n      Matchs: 'No matches found',\n      FilterButton: 'Filter',\n      ClearButton: 'Clear',\n      StartsWith: 'Starts With',\n      EndsWith: 'Ends With',\n      Contains: 'Contains',\n      Equal: 'Equal',\n      NotEqual: 'Not Equal',\n      LessThan: 'Less Than',\n      LessThanOrEqual: 'Less Than Or Equal',\n      GreaterThan: 'Greater Than',\n      GreaterThanOrEqual: 'Greater Than Or Equal',\n      ChooseDate: 'Choose a Date',\n      EnterValue: 'Enter the value',\n      Copy: 'Copy',\n      Group: 'Group by this column',\n      Ungroup: 'Ungroup by this column',\n      GroupButton: 'Group button',\n      UnGroupAria: 'ungroup button',\n      GroupSeperator: 'Separator for the grouped columns',\n      UnGroupIcon: 'ungroup the grouped column ',\n      GroupedSortIcon: 'sort the grouped column ',\n      GroupedDrag: 'Drag the grouped column',\n      GroupCaption: ' is groupcaption cell',\n      CheckBoxLabel: 'checkbox',\n      autoFitAll: 'Autofit all columns',\n      autoFit: 'Autofit this column',\n      AutoFitAll: 'Autofit all columns',\n      AutoFit: 'Autofit this column',\n      Export: 'Export',\n      FirstPage: 'First Page',\n      LastPage: 'Last Page',\n      PreviousPage: 'Previous Page',\n      NextPage: 'Next Page',\n      SortAscending: 'Sort Ascending',\n      SortDescending: 'Sort Descending',\n      EditRecord: 'Edit Record',\n      DeleteRecord: 'Delete Record',\n      FilterMenu: 'Filter',\n      SelectAll: 'Select All',\n      Blanks: 'Blanks',\n      FilterTrue: 'True',\n      FilterFalse: 'False',\n      NoResult: 'No matches found',\n      ClearFilter: 'Clear Filter',\n      Clear: 'Clear',\n      NumberFilter: 'Number Filters',\n      TextFilter: 'Text Filters',\n      DateFilter: 'Date Filters',\n      DateTimeFilter: 'DateTime Filters',\n      MatchCase: 'Match Case',\n      Between: 'Between',\n      CustomFilter: 'Custom Filter',\n      CustomFilterPlaceHolder: 'Enter the value',\n      CustomFilterDatePlaceHolder: 'Choose a date',\n      AND: 'AND',\n      OR: 'OR',\n      ShowRowsWhere: 'Show rows where:',\n      FilterMenuDialogARIA: 'Filter menu dialog',\n      ExcelFilterDialogARIA: 'Excel filter dialog',\n      DialogEditARIA: 'Edit dialog',\n      ColumnChooserDialogARIA: 'Column chooser dialog',\n      ColumnMenuDialogARIA: 'Column menu dialog',\n      CustomFilterDialogARIA: 'Customer filter dialog',\n      SortAtoZ: 'Sort A to Z',\n      SortZtoA: 'Sort Z to A',\n      SortByOldest: 'Sort by Oldest',\n      SortByNewest: 'Sort by Newest',\n      SortSmallestToLargest: 'Sort Smallest to Largest',\n      SortLargestToSmallest: 'Sort Largest to Smallest',\n      Sort: 'Sort',\n      FilterDescription: 'Press Alt Down to open filter Menu',\n      SortDescription: 'Press Enter to sort',\n      ColumnMenuDescription: 'Press Alt Down to open Column Menu',\n      GroupDescription: 'Press Ctrl space to group',\n      ColumnHeader: ' column header ',\n      TemplateCell: ' is template cell',\n      CommandColumnAria: 'is Command column column header ',\n      DialogEdit: 'Dialog edit',\n      ClipBoard: 'clipboard'\n    };\n    this.keyConfigs = {\n      downArrow: 'downarrow',\n      upArrow: 'uparrow',\n      rightArrow: 'rightarrow',\n      leftArrow: 'leftarrow',\n      shiftDown: 'shift+downarrow',\n      shiftUp: 'shift+uparrow',\n      shiftRight: 'shift+rightarrow',\n      shiftLeft: 'shift+leftarrow',\n      home: 'home',\n      end: 'end',\n      escape: 'escape',\n      ctrlHome: 'ctrl+home',\n      ctrlEnd: 'ctrl+end',\n      pageUp: 'pageup',\n      pageDown: 'pagedown',\n      ctrlAltPageUp: 'ctrl+alt+pageup',\n      ctrlAltPageDown: 'ctrl+alt+pagedown',\n      altPageUp: 'alt+pageup',\n      altPageDown: 'alt+pagedown',\n      altDownArrow: 'alt+downarrow',\n      altUpArrow: 'alt+uparrow',\n      ctrlDownArrow: 'ctrl+downarrow',\n      ctrlUpArrow: 'ctrl+uparrow',\n      ctrlPlusA: 'ctrl+A',\n      ctrlPlusP: 'ctrl+P',\n      insert: 'insert',\n      delete: 'delete',\n      f2: 'f2',\n      enter: 'enter',\n      ctrlEnter: 'ctrl+enter',\n      shiftEnter: 'shift+enter',\n      tab: 'tab',\n      shiftTab: 'shift+tab',\n      space: 'space',\n      ctrlPlusC: 'ctrl+C',\n      ctrlShiftPlusH: 'ctrl+shift+H',\n      ctrlSpace: 'ctrl+space',\n      ctrlLeftArrow: 'ctrl+leftarrow',\n      ctrlRightArrow: 'ctrl+rightarrow'\n    };\n  };\n  /**\n   * For internal use only - To Initialize the component rendering.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  Grid.prototype.render = function () {\n    this.log(['module_missing', 'promise_enabled', 'locale_missing', 'check_datasource_columns']);\n    this.ariaService.setOptions(this.element, {\n      datarole: 'grid'\n    });\n    createSpinner({\n      target: this.element,\n      cssClass: this.cssClass ? this.cssClass : null\n    }, this.createElement);\n    this.renderModule = new Render(this, this.serviceLocator);\n    this.searchModule = new Search(this);\n    this.scrollModule = new Scroll(this);\n    this.notify(initialLoad, {});\n\n    if (this.getDataModule().dataManager.dataSource.offline === true || this.getDataModule().dataManager.dataSource.url === undefined) {\n      this.isVirtualAdaptive = true;\n    }\n\n    this.trigger(load);\n    prepareColumns(this.columns, this.enableColumnVirtualization, this);\n\n    if (this.enablePersistence) {\n      this.notify(columnsPrepared, {});\n    }\n\n    this.getMediaColumns();\n    setColumnIndex(this.columns);\n    this.checkLockColumns(this.columns);\n    this.getColumns();\n    this.processModel();\n    this.gridRender();\n    this.wireEvents();\n    this.addListener();\n    this.updateDefaultCursor();\n    this.updateStackedFilter();\n\n    if (this.loadingIndicator.indicatorType === 'Spinner') {\n      this.showSpinner();\n    }\n\n    this.notify(initialEnd, {});\n\n    if (this.loadingIndicator.indicatorType === 'Shimmer') {\n      this.refreshMaskRow();\n    }\n\n    if (this.refreshing) {\n      this.trigger('created');\n    }\n  };\n  /**\n   * By default, grid shows the spinner for all its actions. You can use this method to show spinner at your needed time.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.showSpinner = function () {\n    if (!this.isExportGrid) {\n      showSpinner(this.element);\n    }\n  };\n  /**\n   * By default, grid shows the spinner for all its actions. You can use this method to show spinner at your needed time.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.hideSpinner = function () {\n    if (!this.isExportGrid) {\n      hideSpinner(this.element);\n    }\n  };\n\n  Grid.prototype.showMaskRow = function (axisDirection, dialogElement) {\n    var gridHeader$$1 = this.getHeaderContent().firstChild;\n    var gridContent$$1 = this.getContent().firstChild;\n    var gridFooter$$1 = this.getFooterContent();\n\n    if (dialogElement) {\n      var dialogHolder = dialogElement.querySelector('.e-checkboxlist');\n      var maskRowCount = Math.floor(dialogHolder.getBoundingClientRect().height / this.getRowHeight());\n      var maskTemplate = '<div class=\"e-ftrchk e-mask-ftrchk\" style=\"width: 100%;\">' + '<div class=\"e-checkbox-wrapper\" style=\"width: 100%;\"><input class=\"e-chk-hidden\">' + this.getShimmerTemplate() + this.getShimmerTemplate() + '</div></div>';\n      dialogHolder.innerHTML = '';\n\n      for (var i = 0; i < maskRowCount; i++) {\n        dialogHolder.innerHTML += maskTemplate;\n        var maskSpan = [].slice.call(dialogHolder.querySelectorAll('.e-mask:not(.e-mask-checkbox-filter-intent):not(.e-mask-checkbox-filter-span-intent)'));\n        maskSpan[0].classList.add('e-mask-checkbox-filter-intent');\n        maskSpan[1].classList.add('e-mask-checkbox-filter-span-intent');\n      }\n\n      return;\n    }\n\n    if (!this.enableRtl && !this.getHeaderContent().style.paddingRight || this.enableRtl && !this.getHeaderContent().style.paddingLeft) {\n      gridContent$$1.style.overflowY = 'hidden';\n    }\n\n    if (!this.isInitialLoad && !this.getColumns().length) {\n      var contentHeight = gridContent$$1.getBoundingClientRect().height;\n      var maskTableHeight = contentHeight === 0 ? this.allowPaging ? this.pageSettings.pageSize * this.getRowHeight() : window.innerHeight : contentHeight;\n      var contentRowCount = Math.ceil(maskTableHeight / this.getRowHeight());\n\n      if (this.rowRenderingMode !== 'Vertical') {\n        this.headerMaskTable = this.createEmptyMaskTable(gridHeader$$1, 1);\n      }\n\n      this.contentMaskTable = this.createEmptyMaskTable(gridContent$$1, contentRowCount);\n      return;\n    }\n\n    this.maskRowContentScroll = this.enableVirtualization && axisDirection ? true : false;\n\n    if (!this.contentMaskTable && !(this.isFrozenGrid() && this.enableColumnVirtualization && axisDirection === 'X')) {\n      var content$$1 = gridContent$$1;\n\n      if (this.isFrozenGrid()) {\n        if (!this.isInitialLoad && !this.enableVirtualization && this.frozenRows && this.height !== 'auto') {\n          var contentHeight = content$$1.getBoundingClientRect().height - this.frozenRows * this.getRowHeight();\n          content$$1.style.height = contentHeight + 'px';\n        }\n\n        content$$1 = content$$1.querySelector('.e-frozen-left-content, .e-frozen-right-content');\n      } else if (this.enableVirtualization) {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.contentMaskTable = this.createMaskTable(content$$1, this.getContentMaskColumns(), axisDirection);\n    }\n\n    if (!this.headerMaskTable && (this.isFrozenGrid() || this.enableColumnVirtualization && axisDirection === 'X') && !(this.isFrozenGrid() && (this.enableVirtualization && axisDirection === 'Y' || this.enableColumnVirtualization && axisDirection === 'X' || this.enableInfiniteScrolling && axisDirection === 'down'))) {\n      var content$$1 = gridHeader$$1;\n\n      if (this.isFrozenGrid()) {\n        content$$1 = content$$1.querySelector('.e-frozen-left-header, .e-frozen-right-header');\n      } else if (this.enableColumnVirtualization && axisDirection === 'X') {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.headerMaskTable = this.createMaskTable(content$$1, this.getContentMaskColumns(), axisDirection);\n    }\n\n    if (!this.movableHeaderMaskTable && this.isFrozenGrid() && !(this.enableVirtualization && axisDirection === 'Y' || this.enableInfiniteScrolling && axisDirection === 'down')) {\n      var content$$1 = gridHeader$$1.querySelector('.e-movableheader');\n\n      if (this.enableColumnVirtualization) {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.movableHeaderMaskTable = this.createMaskTable(content$$1, this.getMovableContentMaskColumns(), axisDirection);\n    }\n\n    if (!this.rightHeaderMaskTable && this.isFrozenGrid() && this.getFrozenMode() === 'Left-Right' && !(this.enableVirtualization && axisDirection === 'Y' || this.enableInfiniteScrolling && axisDirection === 'down')) {\n      this.rightHeaderMaskTable = this.createMaskTable(gridHeader$$1.querySelector('.e-frozen-right-header'), this.getRightContentMaskColumns(), axisDirection);\n    }\n\n    if (!this.movableContentMaskTable && this.isFrozenGrid()) {\n      var content$$1 = gridContent$$1.querySelector('.e-movablecontent');\n\n      if (this.enableColumnVirtualization) {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.movableContentMaskTable = this.createMaskTable(content$$1, this.getMovableContentMaskColumns(), axisDirection);\n    }\n\n    if (!this.rightContentMaskTable && this.isFrozenGrid() && this.getFrozenMode() === 'Left-Right') {\n      this.rightContentMaskTable = this.createMaskTable(gridContent$$1.querySelector('.e-frozen-right-content'), this.getRightContentMaskColumns(), axisDirection);\n    }\n\n    if (gridFooter$$1 && gridFooter$$1.querySelector('.e-summaryrow')) {\n      var gridFooterContent = gridFooter$$1.firstChild;\n\n      if (!this.footerContentMaskTable) {\n        var footerContent = gridFooterContent;\n\n        if (this.isFrozenGrid()) {\n          footerContent = footerContent.querySelector('.e-frozen-left-footercontent, .e-frozen-right-footercontent');\n        }\n\n        this.footerContentMaskTable = this.createMaskTable(footerContent);\n      }\n\n      if (this.isFrozenGrid()) {\n        if (!this.movableFooterContentMaskTable) {\n          this.movableFooterContentMaskTable = this.createMaskTable(gridFooterContent.querySelector('.e-movablefootercontent'));\n        }\n\n        if (this.getFrozenMode() === 'Left-Right' && !this.rightFooterContentMaskTable) {\n          this.rightFooterContentMaskTable = this.createMaskTable(gridFooterContent.querySelector('.e-frozen-right-footercontent'));\n        }\n      }\n    }\n\n    if (!(this.enableVirtualization && axisDirection)) {\n      EventHandler.add(gridContent$$1, 'scroll', this.translateMaskRow, this);\n    }\n  };\n\n  Grid.prototype.getContentMaskColumns = function () {\n    var columns = this.getColumns();\n\n    if (this.isFrozenGrid()) {\n      if (this.getFrozenMode() === 'Left' || this.getFrozenMode() === 'Left-Right') {\n        columns = this.frozenColumns ? columns.slice(0, this.frozenColumns) : this.getFrozenLeftColumns();\n      } else if (this.getFrozenMode() === 'Right') {\n        columns = this.getFrozenRightColumns();\n      }\n    }\n\n    return columns;\n  };\n\n  Grid.prototype.getMovableContentMaskColumns = function () {\n    var gridColumns = this.getColumns();\n    var columns = this.frozenColumns ? gridColumns.slice(this.frozenColumns, gridColumns.length) : this.getMovableColumns();\n    return columns;\n  };\n\n  Grid.prototype.getRightContentMaskColumns = function () {\n    return this.getFrozenRightColumns();\n  };\n\n  Grid.prototype.createEmptyMaskTable = function (maskElement, rowCount) {\n    var table$$1 = this.createElement('table', {\n      className: 'e-table e-masked-table'\n    });\n    var tbody$$1 = this.createElement('tbody', {\n      className: 'e-masked-tbody'\n    });\n    var row$$1 = this.createElement('tr', {\n      className: 'e-masked-row e-row',\n      attrs: {\n        style: 'height: ' + this.getRowHeight() + 'px;'\n      }\n    });\n    var cell = this.createElement('td', {\n      className: 'e-masked-cell e-rowcell'\n    });\n    cell.innerHTML = this.getShimmerTemplate();\n    row$$1.appendChild(cell);\n\n    for (var i = 0; i < rowCount; i++) {\n      tbody$$1.appendChild(row$$1.cloneNode(true));\n    }\n\n    table$$1.appendChild(tbody$$1);\n    maskElement.appendChild(table$$1);\n    return table$$1;\n  };\n\n  Grid.prototype.createMaskTable = function (element, columns, axisDirection) {\n    var parentElement = element;\n    var header = closest(parentElement, '.e-gridheader') ? true : false;\n    var content$$1 = closest(parentElement, '.e-gridcontent') ? true : false;\n    var footer = closest(parentElement, '.e-gridfooter') ? true : false;\n    var gridContent$$1 = this.getContent().firstChild;\n    var gridContentScrollHeight = gridContent$$1.scrollHeight;\n    var table$$1 = parentElement.querySelector('table');\n\n    if (this.isFrozenGrid()) {\n      if (content$$1) {\n        parentElement.style.overflow = 'hidden';\n      }\n\n      parentElement.style.position = 'relative';\n    }\n\n    var maskTable = table$$1.cloneNode();\n    maskTable.removeAttribute('role');\n    maskTable.removeAttribute('id');\n    maskTable.removeAttribute('aria-multiselectable');\n    maskTable.removeAttribute('aria-colcount');\n    maskTable.removeAttribute('aria-rowcount');\n    maskTable.style.position = 'absolute';\n    maskTable.style.zIndex = '1';\n    maskTable.style.width = table$$1.getBoundingClientRect().width + 'px';\n\n    if (header && !(this.enableColumnVirtualization && axisDirection === 'X')) {\n      maskTable.style.transform = 'translate(0px,' + table$$1.querySelector('thead').getBoundingClientRect().height + 'px)';\n    }\n\n    maskTable.setAttribute('class', 'e-table e-masked-table');\n    var maskColgroup = table$$1.querySelector('colgroup').cloneNode(true);\n    maskColgroup.removeAttribute('id');\n    maskColgroup.setAttribute('class', 'e-masked-colgroup');\n    maskTable.appendChild(maskColgroup);\n\n    if (header && this.enableColumnVirtualization && axisDirection === 'X') {\n      var row$$1 = this.createMaskRow(maskColgroup, columns);\n      var thead = table$$1.querySelector('thead');\n      var rows = [].slice.call(thead.querySelectorAll('tr'));\n      var maskTHead = thead.cloneNode();\n      maskTHead.removeAttribute('role');\n      maskTHead.setAttribute('class', 'e-masked-thead');\n      var rowCount = rows.length;\n\n      for (var i = 0; i < rowCount; i++) {\n        maskTHead.appendChild(row$$1.cloneNode(true));\n        maskTHead.childNodes[i].style.height = rows[i].getBoundingClientRect().height + 'px';\n      }\n\n      maskTable.appendChild(maskTHead);\n    }\n\n    var maskTBody = table$$1.querySelector('tbody').cloneNode();\n    maskTBody.removeAttribute('role');\n    maskTBody.setAttribute('class', 'e-masked-tbody');\n    var tbody$$1 = table$$1.querySelector('tbody');\n\n    if (content$$1 || header && this.isFrozenGrid()) {\n      var rowCountElement = gridContent$$1;\n      var rowCount = header && this.isFrozenGrid() ? this.frozenRows : Math.ceil(rowCountElement.getBoundingClientRect().height / this.getRowHeight());\n\n      if (tbody$$1.querySelector('.e-emptyrow') || !tbody$$1.childNodes.length || content$$1 && this.childGrid) {\n        var row$$1 = this.createMaskRow(maskColgroup, columns);\n        var altRow = row$$1.cloneNode(true);\n        altRow.classList.add('e-altrow');\n\n        for (var i = 0; i < rowCount; i++) {\n          var altNumber = content$$1 && this.isFrozenGrid() && this.frozenRows ? this.frozenRows + 1 : 1;\n          maskTBody.appendChild((i + altNumber) % 2 === 0 ? altRow.cloneNode(true) : row$$1.cloneNode(true));\n        }\n      } else {\n        var rowsQuery = 'tr:not([style*=\"display:none\"]):not([style*=\"display: none\"])';\n        var rows = [].slice.call(tbody$$1.querySelectorAll(rowsQuery));\n        var addEditRow = tbody$$1.querySelector('.e-addedrow, .e-editedrow');\n        var addEditRowIndex = void 0;\n\n        if (addEditRow) {\n          addEditRowIndex = rows.indexOf(addEditRow);\n\n          if (addEditRow.classList.contains('e-addedrow')) {\n            rows.splice(addEditRowIndex, 2);\n          } else {\n            rows.splice(addEditRowIndex, 1);\n          }\n        }\n\n        rowCount = header && this.isFrozenGrid() || this.enableVirtualization && axisDirection ? rows.length : rowCount <= rows.length ? rowCount : rows.length;\n\n        for (var i = 0; i < rowCount; i++) {\n          maskTBody.appendChild(this.applyMaskRow(rows[i].cloneNode(true), rows[i].getBoundingClientRect().height));\n        }\n\n        if (addEditRow && addEditRow.classList.contains('e-editedrow')) {\n          var addEditMaskRow = maskTBody.childNodes[addEditRowIndex];\n          addEditMaskRow.style.height = this.getRowHeight() + 'px';\n          addEditMaskRow.classList.add('e-row');\n\n          if (addEditRow.classList.contains('e-altrow')) {\n            addEditMaskRow.classList.add('e-altrow');\n          }\n        }\n      }\n    }\n\n    maskTable.appendChild(maskTBody);\n\n    if (footer) {\n      var tfoot = table$$1.querySelector('tfoot');\n      var maskTFoot = tfoot.cloneNode();\n      maskTFoot.setAttribute('class', 'e-masked-tfoot');\n      var rows = [].slice.call(tfoot.querySelectorAll('tr'));\n\n      for (var i = 0; i < rows.length; i++) {\n        maskTFoot.appendChild(this.applyMaskRow(rows[i].cloneNode(true), rows[i].getBoundingClientRect().height));\n      }\n\n      maskTable.appendChild(maskTFoot);\n    }\n\n    parentElement.insertBefore(maskTable, parentElement.firstChild);\n\n    if (header && this.isFrozenGrid() && tbody$$1.getBoundingClientRect().height < maskTable.querySelector('tbody').getBoundingClientRect().height) {\n      var maskTableHolderHeight = maskTable.querySelector('tbody').getBoundingClientRect().height - tbody$$1.getBoundingClientRect().height;\n      var maskTableHolder = this.createElement('div', {\n        className: 'e-masked-table-holder',\n        attrs: {\n          style: 'height: ' + maskTableHolderHeight + 'px;'\n        }\n      });\n      parentElement.appendChild(maskTableHolder);\n    } else if (header && this.isFrozenGrid() && !(this.enableColumnVirtualization && axisDirection === 'X')) {\n      maskTable.style.height = parentElement.getBoundingClientRect().height - table$$1.querySelector('thead').getBoundingClientRect().height + 'px';\n    }\n\n    if (content$$1 && !(this.enableVirtualization && axisDirection)) {\n      var minScrollTop = gridContentScrollHeight - maskTable.getBoundingClientRect().height;\n      minScrollTop = minScrollTop < 0 ? 0 : minScrollTop;\n      var scrollTop = gridContent$$1.scrollTop <= minScrollTop ? gridContent$$1.scrollTop : minScrollTop;\n\n      if (this.enableVirtualization) {\n        scrollTop -= getTransformValues(closest(parentElement, '.e-virtualtable')).height;\n      }\n\n      maskTable.style.transform = 'translate(0px,' + scrollTop + 'px)';\n    }\n\n    return maskTable;\n  };\n\n  Grid.prototype.applyMaskRow = function (row$$1, rowHeight) {\n    var maskRow = row$$1;\n    maskRow.removeAttribute('role');\n    maskRow.removeAttribute('aria-rowindex');\n    maskRow.removeAttribute('data-rowindex');\n    maskRow.removeAttribute('data-uid');\n    maskRow.classList.add('e-masked-row');\n    maskRow.style.height = rowHeight + 'px';\n    var maskCells = [].slice.call(maskRow.childNodes);\n\n    for (var i = 0; i < maskCells.length; i++) {\n      var maskCell = maskCells[i];\n      var displayAsCheckBoxCell = maskCell.firstChild && maskCell.firstChild.classList && maskCell.firstChild.classList.contains('e-checkbox-wrapper');\n      maskCell.removeAttribute('role');\n      maskCell.removeAttribute('tabindex');\n      maskCell.removeAttribute('aria-label');\n      maskCell.removeAttribute('data-colindex');\n      maskCell.removeAttribute('aria-colindex');\n      maskCell.removeAttribute('index');\n      maskCell.removeAttribute('ej-mappingname');\n      maskCell.removeAttribute('ej-mappingvalue');\n      maskCell.removeAttribute('e-mappinguid');\n      maskCell.removeAttribute('aria-expanded');\n      maskCell.classList.add('e-masked-cell');\n      maskCell.innerHTML = this.getShimmerTemplate();\n\n      if (maskCell.classList.contains('e-recordplusexpand') || maskCell.classList.contains('e-recordpluscollapse')) {\n        maskCell.firstChild.classList.add('e-mask-group-intent');\n      } else if (maskCell.classList.contains('e-gridchkbox') || displayAsCheckBoxCell) {\n        maskCell.firstChild.classList.add('e-mask-checkbox-intent');\n      } else if (maskCell.classList.contains('e-rowdragdrop')) {\n        maskCell.firstChild.classList.add('e-mask-drag-intent');\n      } else if (maskCell.classList.contains('e-indentcell')) {\n        maskCell.innerHTML = '';\n      }\n    }\n\n    return maskRow;\n  };\n\n  Grid.prototype.createMaskRow = function (refColgroup, refColumns) {\n    var colgroup = refColgroup;\n    var columns = refColumns;\n    var row$$1 = this.createElement('tr', {\n      className: 'e-masked-row e-row'\n    });\n\n    if (this.rowRenderingMode !== 'Vertical') {\n      row$$1.style.height = this.getRowHeight() + 'px';\n    }\n\n    var td = this.createElement('td', {\n      className: 'e-masked-cell e-rowcell'\n    });\n\n    for (var i = 0, colIndex = 0; i < colgroup.childNodes.length; i++) {\n      var col = colgroup.childNodes[i];\n      var localTD = td.cloneNode();\n      localTD.innerHTML = this.getShimmerTemplate();\n\n      if (!(col.classList.contains('e-group-intent') || col.classList.contains('e-detail-intent') || col.classList.contains('e-drag-intent'))) {\n        if (this.rowRenderingMode === 'Vertical' && columns[colIndex]) {\n          localTD.setAttribute('data-cell', columns[colIndex].headerText ? columns[colIndex].headerText : columns[colIndex].field);\n        }\n\n        if (col.style.display === 'none') {\n          localTD.classList.add('e-hide');\n        } else {\n          localTD.style.textAlign = columns[colIndex] && columns[colIndex].textAlign ? columns[colIndex].textAlign.toLowerCase() : this.enableRtl ? 'right' : 'left';\n\n          if (columns[colIndex] && (columns[colIndex].type === 'checkbox' || columns[colIndex].displayAsCheckBox)) {\n            localTD.firstChild.classList.add('e-mask-checkbox-intent');\n          }\n        }\n\n        colIndex++;\n      } else {\n        if (col.classList.contains('e-group-intent')) {\n          localTD.firstChild.classList.add('e-mask-group-intent');\n        } else if (col.classList.contains('e-detail-intent')) {\n          localTD.firstChild.classList.add('e-mask-detail-intent');\n        } else if (col.classList.contains('e-drag-intent')) {\n          localTD.firstChild.classList.add('e-mask-drag-intent');\n        }\n      }\n\n      row$$1.appendChild(localTD);\n    }\n\n    return row$$1;\n  };\n\n  Grid.prototype.getShimmerTemplate = function () {\n    if (this.maskRowContentScroll) {\n      return '<span class=\"e-mask e-skeleton e-skeleton-text\"></span>';\n    }\n\n    return '<span class=\"e-mask e-skeleton e-skeleton-text e-shimmer-wave\"></span>';\n  };\n\n  Grid.prototype.addShimmerEffect = function () {\n    this.maskRowContentScroll = false;\n    var maskSpan = [].slice.call(this.element.querySelectorAll('.e-mask:not(.e-shimmer-wave)'));\n\n    for (var i = 0; i < maskSpan.length; i++) {\n      if (maskSpan[i]) {\n        maskSpan[i].classList.add('e-shimmer-wave');\n      }\n    }\n  };\n\n  Grid.prototype.translateMaskRow = function (e) {\n    var target = e.target;\n    var maskTables = target.querySelectorAll('.e-masked-table');\n\n    for (var i = 0; i < maskTables.length; i++) {\n      var maskTable = maskTables[i];\n\n      if (maskTable) {\n        var minScrollTop = target.scrollHeight - maskTable.getBoundingClientRect().height;\n        minScrollTop = minScrollTop < 0 ? 0 : minScrollTop;\n        var scrollTop = target.scrollTop <= minScrollTop ? target.scrollTop : minScrollTop;\n\n        if (this.enableVirtualization) {\n          scrollTop -= getTransformValues(closest(maskTable, '.e-virtualtable')).height;\n        }\n\n        maskTable.style.transform = 'translate(0px,' + scrollTop + 'px)';\n      }\n    }\n  };\n\n  Grid.prototype.removeMaskRow = function () {\n    var gridContent$$1 = this.getContent().firstChild;\n    EventHandler.remove(gridContent$$1, 'scroll', this.translateMaskRow);\n    var maskTables = [this.headerMaskTable, this.movableHeaderMaskTable, this.rightHeaderMaskTable, this.contentMaskTable, this.movableContentMaskTable, this.rightContentMaskTable, this.footerContentMaskTable, this.movableFooterContentMaskTable, this.rightFooterContentMaskTable];\n\n    for (var i = 0; i < maskTables.length; i++) {\n      var maskTable = maskTables[i];\n\n      if (maskTable) {\n        if (this.isFrozenGrid() && !closest(maskTable, '.e-gridfooter')) {\n          var parent_1 = maskTable.parentElement;\n          parent_1.style.overflow = '';\n          parent_1.style.position = '';\n\n          if (closest(maskTable, '.e-frozen-left-header') || closest(maskTable, '.e-movableheader') || closest(maskTable, '.e-frozen-right-header')) {\n            var maskTableHolder = parent_1.querySelector('.e-masked-table-holder');\n\n            if (maskTableHolder) {\n              remove(maskTableHolder);\n            }\n          }\n        }\n\n        remove(maskTable);\n      }\n    }\n\n    this.headerMaskTable = null;\n    this.movableHeaderMaskTable = null;\n    this.rightHeaderMaskTable = null;\n    this.contentMaskTable = null;\n    this.movableContentMaskTable = null;\n    this.rightContentMaskTable = null;\n    this.footerContentMaskTable = null;\n    this.movableFooterContentMaskTable = null;\n    this.rightFooterContentMaskTable = null;\n  };\n\n  Grid.prototype.refreshMaskRow = function () {\n    var gridHeader$$1 = this.getHeaderContent().firstChild;\n    var gridContent$$1 = this.getContent().firstChild;\n\n    if (!this.isInitialLoad && !this.getColumns().length) {\n      return;\n    }\n\n    if (this.contentMaskTable) {\n      var content$$1 = gridContent$$1;\n\n      if (this.isFrozenGrid()) {\n        content$$1 = content$$1.querySelector('.e-frozen-left-content, .e-frozen-right-content');\n      } else if (this.enableVirtualization) {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.refreshMaskRowColgroupWidth(content$$1);\n    }\n\n    if (this.headerMaskTable && this.isFrozenGrid()) {\n      this.refreshMaskRowColgroupWidth(gridHeader$$1.querySelector('.e-frozen-left-header, .e-frozen-right-header'));\n    }\n\n    if (this.movableHeaderMaskTable && this.isFrozenGrid()) {\n      var content$$1 = gridHeader$$1.querySelector('.e-movableheader');\n\n      if (this.enableColumnVirtualization) {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.refreshMaskRowColgroupWidth(content$$1);\n    }\n\n    if (this.rightHeaderMaskTable && this.isFrozenGrid() && this.getFrozenMode() === 'Left-Right') {\n      this.refreshMaskRowColgroupWidth(gridHeader$$1.querySelector('.e-frozen-right-header'));\n    }\n\n    if (this.movableContentMaskTable && this.isFrozenGrid()) {\n      var content$$1 = gridContent$$1.querySelector('.e-movablecontent');\n\n      if (this.enableColumnVirtualization) {\n        content$$1 = content$$1.querySelector('.e-virtualtable');\n      }\n\n      this.refreshMaskRowColgroupWidth(content$$1);\n    }\n\n    if (this.rightContentMaskTable && this.isFrozenGrid() && this.getFrozenMode() === 'Left-Right') {\n      this.refreshMaskRowColgroupWidth(gridContent$$1.querySelector('.e-frozen-right-content'));\n    }\n  };\n\n  Grid.prototype.refreshMaskRowColgroupWidth = function (content$$1) {\n    var table$$1 = content$$1.querySelector('table:not(.e-masked-table)');\n    var colgroup = table$$1.querySelector(colGroup).cloneNode(true);\n    var maskTable = content$$1.querySelector('.e-masked-table');\n    colgroup.removeAttribute('id');\n    colgroup.setAttribute('class', 'e-masked-colgroup');\n\n    for (var i = 0; i < colgroup.childNodes.length; i++) {\n      colgroup.childNodes[i].removeAttribute('class');\n    }\n\n    remove(maskTable.querySelector('.e-masked-colgroup'));\n    maskTable.insertBefore(colgroup, maskTable.firstChild);\n    maskTable.style.width = table$$1.getBoundingClientRect().width + 'px';\n  };\n\n  Grid.prototype.updateStackedFilter = function () {\n    if (this.allowFiltering && this.filterSettings.type === 'FilterBar' && this.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n      this.getHeaderContent().classList.add('e-stackedfilter');\n    } else {\n      this.getHeaderContent().classList.remove('e-stackedfilter');\n    }\n  };\n\n  Grid.prototype.getMediaColumns = function () {\n    if (!this.enableColumnVirtualization) {\n      var gcol = this.getColumns();\n      this.getShowHideService = this.serviceLocator.getService('showHideService');\n\n      if (!isNullOrUndefined(gcol)) {\n        for (var index = 0; index < gcol.length; index++) {\n          if (!isNullOrUndefined(gcol[index].hideAtMedia) && (isNullOrUndefined(gcol[index].visible) || gcol[index].visible)) {\n            this.pushMediaColumn(gcol[index], index);\n          }\n        }\n      }\n    }\n  };\n\n  Grid.prototype.pushMediaColumn = function (col, index) {\n    this.mediaCol.push(col);\n    this.media[col.uid] = window.matchMedia(col.hideAtMedia);\n    this.mediaQueryUpdate(index, this.media[col.uid]);\n    this.mediaBindInstance[index] = this.mediaQueryUpdate.bind(this, index);\n    this.media[col.uid].addListener(this.mediaBindInstance[index]);\n  };\n  /**\n   * @param {Column} col - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.updateMediaColumns = function (col) {\n    if (!this.enableColumnVirtualization) {\n      var index = this.getColumnIndexByUid(col.uid);\n\n      for (var i = 0; i < this.mediaCol.length; i++) {\n        if (col.uid === this.mediaCol[i].uid) {\n          this.mediaCol.splice(i, 1);\n          return;\n        }\n      }\n\n      this.pushMediaColumn(col, index);\n    }\n  };\n  /**\n   * @param {number} columnIndex - specifies the column index\n   * @param {MediaQueryList} e - specifies the MediaQueryList\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.mediaQueryUpdate = function (columnIndex, e) {\n    var col = this.getColumns()[columnIndex];\n\n    if (this.mediaCol.some(function (mediaColumn) {\n      return mediaColumn.uid === col.uid;\n    })) {\n      col.visible = e.matches;\n\n      if (this.isInitialLoad) {\n        this.invokedFromMedia = true;\n\n        if (col.visible) {\n          this.showHider.show(col.headerText, 'headerText');\n        } else {\n          this.showHider.hide(col.headerText, 'headerText');\n        }\n      }\n    }\n  };\n\n  Grid.prototype.refreshMediaCol = function () {\n    this.isInitialLoad = true;\n    var footerContent = this.element.querySelector('.' + gridFooter);\n\n    if (this.aggregates.length && this.element.scrollHeight > this.height && footerContent) {\n      addClass([footerContent], ['e-footerpadding']);\n    }\n\n    var checkboxColumn = this.getColumns().filter(function (col) {\n      return col.type === 'checkbox';\n    });\n\n    if (checkboxColumn.length && this.selectionSettings.checkboxMode === 'ResetOnRowClick') {\n      this.isCheckBoxSelection = false;\n    }\n\n    if (this.rowRenderingMode === 'Vertical') {\n      if (this.enableHover) {\n        this.setProperties({\n          enableAdaptiveUI: true,\n          enableHover: false\n        }, true);\n        removeClass([this.element], 'e-gridhover');\n      }\n    }\n\n    if (this.enableAdaptiveUI && this.scrollModule) {\n      this.scrollModule.refresh();\n    }\n  };\n\n  Grid.prototype.removeMediaListener = function () {\n    for (var i = 0; i < this.mediaCol.length; i++) {\n      this.media[this.mediaCol[i].uid].removeListener(this.mediaBindInstance[this.mediaCol[i].index]);\n    }\n  };\n  /**\n   * For internal use only - Initialize the event handler\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  Grid.prototype.eventInitializer = function () {//eventInitializer\n  };\n  /**\n   * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).\n   *\n   * @function destroy\n   * @returns {void}\n   */\n\n\n  Grid.prototype.destroy = function () {\n    var gridElement = this.element;\n\n    if (!gridElement) {\n      return;\n    }\n\n    var hasGridChild = gridElement.querySelector('.' + gridHeader) && gridElement.querySelector('.' + gridContent) ? true : false;\n\n    if (hasGridChild) {\n      this.unwireEvents();\n    }\n\n    this.removeListener();\n    this.removeMediaListener();\n    this.notify(destroy, {});\n    this.destroyDependentModules();\n\n    if (this.isReact || this.isVue) {\n      this.destroyTemplate(['template']);\n    }\n\n    if (hasGridChild) {\n      _super.prototype.destroy.call(this);\n    }\n\n    this.toolTipObj.destroy();\n\n    if (this.isReact && !Browser.isIE) {\n      this.element.innerHTML = '';\n    }\n\n    var modules = ['renderModule', 'headerModule', 'contentModule', 'valueFormatterService', 'serviceLocator', 'ariaService', 'keyboardModule', 'widthService', 'searchModule', 'showHider', 'scrollModule', 'printModule', 'clipboardModule', 'focusModule'];\n\n    for (var i = 0; i < modules.length; i++) {\n      if (this[modules[i]]) {\n        this[modules[i]] = null;\n      }\n    }\n\n    this.element.innerHTML = '';\n    classList(this.element, [], ['e-rtl', 'e-gridhover', 'e-responsive', 'e-default', 'e-device', 'e-grid-min-height']);\n    this.isFreezeRefresh = false;\n  };\n\n  Grid.prototype.destroyDependentModules = function () {\n    var gridElement = this.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.scrollModule.destroy();\n    this.keyboardModule.destroy();\n    this.focusModule.destroy();\n    this.clipboardModule.destroy();\n    this.printModule.destroy();\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Grid.prototype.getModuleName = function () {\n    return 'grid';\n  };\n\n  Grid.prototype.enableBoxSelection = function () {\n    if (this.enableAutoFill) {\n      this.selectionSettings.cellSelectionMode = 'BoxWithBorder';\n      this.element.classList.add('e-afenabled');\n    } else {\n      this.element.classList.remove('e-afenabled');\n    }\n  };\n\n  Grid.prototype.setCSSClass = function (oldCSSClass) {\n    if (this.cssClass) {\n      addClass([this.element], this.cssClass.split(' '));\n    }\n\n    if (oldCSSClass) {\n      removeClass([this.element], oldCSSClass.split(' '));\n    }\n  };\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {GridModel} newProp - Defines new properties\n   * @param {GridModel} oldProp - Defines old properties\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.onPropertyChanged = function (newProp, oldProp) {\n    var requireRefresh = false;\n    var requireGridRefresh = false;\n    var freezeRefresh$$1 = false;\n    var checkCursor;\n    var args = {\n      requestType: 'refresh'\n    };\n\n    if (this.isDestroyed) {\n      return;\n    }\n\n    this.log('module_missing');\n\n    if (this.isEllipsisTooltip()) {\n      this.toolTipObj.close();\n    }\n\n    var properties = Object.keys(newProp);\n\n    if (properties.indexOf('columns') > -1) {\n      if (this.enableColumnVirtualization) {\n        this.columnModel = [];\n      }\n\n      this.updateColumnObject();\n      requireGridRefresh = true;\n    }\n\n    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n      var prop = properties_1[_i];\n\n      switch (prop) {\n        case 'allowPaging':\n          this.notify(uiUpdate, {\n            module: 'pager',\n            enable: this.allowPaging\n          });\n          requireRefresh = true;\n          break;\n\n        case 'pageSettings':\n          if (this.pageTemplateChange) {\n            this.pageTemplateChange = false;\n            this.notify(inBoundModelChanged, {\n              module: 'pager',\n              properties: newProp.pageSettings\n            });\n            break;\n          }\n\n          this.notify(inBoundModelChanged, {\n            module: 'pager',\n            properties: newProp.pageSettings\n          });\n\n          if (isNullOrUndefined(newProp.pageSettings.currentPage) && isNullOrUndefined(newProp.pageSettings.pageSize) && isNullOrUndefined(newProp.pageSettings.totalRecordsCount) || !isNullOrUndefined(oldProp.pageSettings) && newProp.pageSettings.currentPage !== oldProp.pageSettings.currentPage && !this.enableColumnVirtualization && !this.enableVirtualization && this.pageSettings.totalRecordsCount <= this.pageSettings.pageSize) {\n            requireRefresh = true;\n          }\n\n          break;\n\n        case 'allowSorting':\n          this.notify(uiUpdate, {\n            module: 'sort',\n            enable: this.allowSorting\n          });\n          requireRefresh = true;\n          checkCursor = true;\n          break;\n\n        case 'allowFiltering':\n          this.updateStackedFilter();\n          this.notify(uiUpdate, {\n            module: 'filter',\n            enable: this.allowFiltering\n          });\n          requireRefresh = true;\n\n          if (this.filterSettings.type !== 'FilterBar') {\n            this.refreshHeader();\n          }\n\n          break;\n\n        case 'height':\n        case 'width':\n          this.notify(uiUpdate, {\n            module: 'scroll',\n            properties: {\n              width: newProp.width,\n              height: newProp.height\n            }\n          });\n          break;\n\n        case 'allowReordering':\n          this.headerModule.refreshUI();\n          checkCursor = true;\n          break;\n\n        case 'allowRowDragAndDrop':\n          this.notify(uiUpdate, {\n            module: 'rowDragAndDrop',\n            enable: this.allowRowDragAndDrop\n          });\n          this.renderModule.refresh();\n          this.headerModule.refreshUI();\n          break;\n\n        case 'allowSelection':\n          this.notify(uiUpdate, {\n            module: 'selection',\n            enable: this.allowSelection\n          });\n          break;\n\n        case 'cssClass':\n          this.setCSSClass(oldProp.cssClass);\n          break;\n\n        case 'enableAutoFill':\n          if (this.selectionModule) {\n            this.enableBoxSelection();\n            this.selectionModule.updateAutoFillPosition();\n          }\n\n          break;\n\n        case 'rowTemplate':\n          this.rowTemplateFn = templateCompiler(this.rowTemplate);\n          requireRefresh = true;\n          break;\n\n        case 'detailTemplate':\n          this.detailTemplateFn = templateCompiler(this.detailTemplate);\n          requireRefresh = true;\n          break;\n\n        case 'allowGrouping':\n          this.notify(uiUpdate, {\n            module: 'group',\n            enable: this.allowGrouping\n          });\n          this.headerModule.refreshUI();\n          requireRefresh = true;\n          checkCursor = true;\n          break;\n\n        case 'enableInfiniteScrolling':\n        case 'childGrid':\n          requireRefresh = true;\n          break;\n\n        case 'toolbar':\n          this.notify(uiUpdate, {\n            module: 'toolbar'\n          });\n          break;\n\n        case 'groupSettings':\n          this.notify(inBoundModelChanged, {\n            module: 'group',\n            properties: newProp.groupSettings,\n            oldProperties: oldProp.groupSettings\n          });\n          break;\n\n        case 'aggregates':\n          if (!this.aggregates.length && this.allowGrouping && this.groupSettings.columns.length) {\n            requireRefresh = true;\n          }\n\n          this.notify(uiUpdate, {\n            module: 'aggregate',\n            properties: newProp\n          });\n          break;\n\n        case 'frozenColumns':\n        case 'frozenRows':\n        case 'enableVirtualization':\n        case 'currencyCode':\n        case 'locale':\n          this.log('frozen_rows_columns');\n          freezeRefresh$$1 = true;\n          requireGridRefresh = true;\n          break;\n\n        case 'query':\n          if (!this.getDataModule().isQueryInvokedFromData) {\n            requireRefresh = true;\n          }\n\n          this.getDataModule().isQueryInvokedFromData = false;\n          break;\n\n        default:\n          this.extendedPropertyChange(prop, newProp, requireGridRefresh);\n      }\n    }\n\n    if (checkCursor) {\n      this.updateDefaultCursor();\n    }\n\n    if (requireGridRefresh) {\n      if (freezeRefresh$$1 || this.getFrozenColumns() || this.frozenRows) {\n        this.freezeRefresh();\n      } else {\n        this.refresh();\n      }\n    } else if (requireRefresh) {\n      this.notify(modelChanged, args);\n      requireRefresh = false;\n      this.maintainSelection(newProp.selectedRowIndex);\n    }\n  };\n\n  Grid.prototype.extendedPropertyChange = function (prop, newProp, requireGridRefresh) {\n    switch (prop) {\n      case 'enableRtl':\n        this.updateRTL();\n\n        if (this.allowPaging) {\n          this.element.querySelector('.e-gridpager').ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.element.querySelector('.e-gridpager').ej2_instances[0].dataBind();\n        }\n\n        if (this.height !== 'auto') {\n          this.scrollModule.removePadding(!newProp.enableRtl);\n          this.scrollModule.setPadding();\n        }\n\n        if (this.toolbar && this.toolbarModule) {\n          this.toolbarModule.getToolbar().ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.toolbarModule.getToolbar().ej2_instances[0].dataBind();\n        }\n\n        if (this.contextMenuItems && this.contextMenuModule) {\n          this.contextMenuModule.getContextMenu().ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.contextMenuModule.getContextMenu().ej2_instances[0].dataBind();\n        }\n\n        if (this.showColumnMenu && this.columnMenuModule) {\n          this.columnMenuModule.getColumnMenu().ej2_instances[0].enableRtl = newProp.enableRtl;\n          this.columnMenuModule.getColumnMenu().ej2_instances[0].dataBind();\n        }\n\n        if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator) {\n          this.refreshHeader();\n        }\n\n        this.notify(rtlUpdated, {});\n        break;\n\n      case 'enableAltRow':\n        this.renderModule.refresh();\n        break;\n\n      case 'allowResizing':\n        this.headerModule.refreshUI();\n        this.updateResizeLines();\n        break;\n\n      case 'rowHeight':\n        if (this.rowHeight) {\n          addClass([this.element], 'e-grid-min-height');\n        } else {\n          removeClass([this.element], 'e-grid-min-height');\n        }\n\n        this.renderModule.refresh();\n        this.headerModule.refreshUI();\n        break;\n\n      case 'gridLines':\n        this.updateGridLines();\n        break;\n\n      case 'showColumnMenu':\n        this.headerModule.refreshUI();\n        this.notify(uiUpdate, {\n          module: 'columnMenu',\n          enable: true\n        });\n        break;\n\n      case 'columnMenuItems':\n        this.notify(uiUpdate, {\n          module: 'columnMenu',\n          enable: this.columnMenuItems\n        });\n        break;\n\n      case 'contextMenuItems':\n        this.notify(uiUpdate, {\n          module: 'contextMenu',\n          enable: this.contextMenuItems\n        });\n        break;\n\n      case 'showColumnChooser':\n        this.notify(uiUpdate, {\n          module: 'columnChooser',\n          enable: this.showColumnChooser\n        });\n        break;\n\n      case 'filterSettings':\n        this.updateStackedFilter();\n        this.notify(inBoundModelChanged, {\n          module: 'filter',\n          properties: newProp.filterSettings\n        });\n        break;\n\n      case 'searchSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'search',\n          properties: newProp.searchSettings\n        });\n        break;\n\n      case 'sortSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'sort'\n        });\n        break;\n\n      case 'selectionSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'selection',\n          properties: newProp.selectionSettings\n        });\n        break;\n\n      case 'editSettings':\n        this.notify(inBoundModelChanged, {\n          module: 'edit',\n          properties: newProp.editSettings\n        });\n        break;\n\n      case 'allowTextWrap':\n      case 'textWrapSettings':\n        if (this.allowTextWrap) {\n          this.applyTextWrap();\n        } else {\n          this.removeTextWrap();\n        }\n\n        this.notify(freezeRender, {\n          case: 'textwrap',\n          isModeChg: prop === 'textWrapSettings'\n        });\n        break;\n\n      case 'dataSource':\n        // eslint-disable-next-line no-case-declarations\n        var pending_1 = this.getDataModule().getState();\n\n        if (Object.getPrototypeOf(newProp).deepWatch) {\n          var pKeyField = this.getPrimaryKeyFieldNames()[0];\n\n          for (var i = 0, props = Object.keys(newProp.dataSource); i < props.length; i++) {\n            this.setRowData(getValue(pKeyField, this.dataSource[props[i]]), this.dataSource[props[i]]);\n          }\n        } else if (pending_1.isPending) {\n          var gResult = !isNullOrUndefined(this.dataSource) ? this.dataSource.result : [];\n          var names = pending_1.group || [];\n\n          for (var i = 0; i < names.length; i++) {\n            gResult = DataUtil.group(gResult, names[i], pending_1.aggregates || []);\n          }\n\n          this.dataSource = {\n            result: gResult,\n            count: this.dataSource.count,\n            aggregates: this.dataSource.aggregates\n          };\n          this.getDataModule().setState({});\n          pending_1.resolver(this.dataSource);\n        } else {\n          this.getDataModule().setState({\n            isDataChanged: false\n          });\n          this.notify(dataSourceModified, {});\n\n          if (!requireGridRefresh) {\n            this.renderModule.refresh();\n\n            if (this.isCheckBoxSelection) {\n              this.notify(beforeRefreshOnDataChange, {});\n            }\n          }\n        }\n\n        this.scrollRefresh();\n        break;\n\n      case 'enableHover':\n        // eslint-disable-next-line no-case-declarations\n        var action = newProp.enableHover ? addClass : removeClass;\n        action([this.element], 'e-gridhover');\n        break;\n\n      case 'selectedRowIndex':\n        if (!this.isSelectedRowIndexUpdating) {\n          this.selectRow(newProp.selectedRowIndex);\n        }\n\n        this.isSelectedRowIndexUpdating = false;\n        break;\n\n      case 'resizeSettings':\n        this.widthService.setWidthToTable();\n        break;\n\n      case 'enableAdaptiveUI':\n        this.notify(setFullScreenDialog, {});\n        break;\n\n      case 'rowRenderingMode':\n        this.enableVerticalRendering();\n        this.notify(rowModeChange, {});\n        this.refresh();\n        break;\n\n      case 'enableStickyHeader':\n        this.scrollModule.addStickyListener(newProp.enableStickyHeader);\n        break;\n    }\n  };\n\n  Grid.prototype.maintainSelection = function (index) {\n    var _this = this;\n\n    if (index !== -1) {\n      var fn_1 = function () {\n        _this.selectRow(index);\n\n        _this.off(contentReady, fn_1);\n      };\n\n      this.on(contentReady, fn_1, this);\n    }\n  };\n  /**\n   * @param {Object} prop - Defines the property\n   * @param {boolean} muteOnChange - Defines the mute on change\n   * @returns {void}\n   * @private\n   */\n\n\n  Grid.prototype.setProperties = function (prop, muteOnChange) {\n    _super.prototype.setProperties.call(this, prop, muteOnChange);\n\n    var filterSettings = 'filterSettings';\n\n    if (prop[filterSettings] && this.filterModule && muteOnChange) {\n      this.filterModule.refreshFilter();\n    }\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setTablesCount = function () {\n    var frozenCols = this.getFrozenColumns();\n    var frozenLeft$$1 = this.getFrozenLeftColumnsCount();\n    var frozenRight$$1 = this.getFrozenRightColumnsCount();\n\n    if (frozenCols && !frozenLeft$$1 && !frozenRight$$1) {\n      this.tablesCount = 2;\n    } else if (!frozenCols && (frozenLeft$$1 || frozenRight$$1)) {\n      if (frozenLeft$$1 && !frozenRight$$1 || frozenRight$$1 && !frozenLeft$$1) {\n        this.tablesCount = 2;\n      } else if (frozenLeft$$1 && frozenRight$$1) {\n        this.tablesCount = 3;\n      }\n    }\n  };\n  /**\n   * @hidden\n   * @returns {number} - Returns the tables count\n   */\n\n\n  Grid.prototype.getTablesCount = function () {\n    return this.tablesCount;\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.updateDefaultCursor = function () {\n    var headerCells = [].slice.call(this.getHeaderContent().querySelectorAll('.e-headercell:not(.e-stackedheadercell)'));\n    var stdHdrCell = [].slice.call(this.getHeaderContent().getElementsByClassName('e-stackedheadercell'));\n    var cols = this.getColumns();\n\n    if (this.enableColumnVirtualization && this.getFrozenColumns()) {\n      var cells = this.contentModule.getHeaderCells();\n      headerCells = cells.length ? cells : headerCells;\n    }\n\n    for (var i = 0; i < headerCells.length; i++) {\n      var cell = headerCells[i];\n\n      if (this.allowGrouping || this.allowReordering || this.allowSorting) {\n        if (!cols[i].allowReordering || !cols[i].allowSorting || !cols[i].allowGrouping) {\n          cell.classList.add('e-defaultcursor');\n        } else {\n          cell.classList.add('e-mousepointer');\n        }\n      }\n    }\n\n    for (var count = 0; count < stdHdrCell.length; count++) {\n      if (this.allowReordering) {\n        stdHdrCell[count].classList.add('e-mousepointer');\n      }\n    }\n  };\n\n  Grid.prototype.updateColumnModel = function (columns) {\n    for (var i = 0, len = columns.length; i < len; i++) {\n      if (columns[i].columns) {\n        this.updateColumnModel(columns[i].columns);\n      } else {\n        this.columnModel.push(columns[i]);\n      }\n    }\n\n    this.updateColumnLevelFrozen();\n    this.updateFrozenColumns();\n    this.updateLockableColumns();\n  };\n\n  Grid.prototype.updateColumnLevelFrozen = function () {\n    var cols = this.columnModel;\n    var leftCols = [];\n    var rightCols = [];\n    var movableCols = [];\n\n    if (this.frozenLeftCount || this.frozenRightCount) {\n      for (var i = 0, len = cols.length; i < len; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var col = cols[i];\n\n        if (col.freeze === 'Left') {\n          col.freezeTable = frozenLeft;\n          leftCols.push(col);\n        } else if (col.freeze === 'Right') {\n          col.freezeTable = frozenRight;\n          rightCols.push(col);\n        } else {\n          col.freezeTable = 'movable';\n          movableCols.push(col);\n        }\n      }\n\n      this.columnModel = leftCols.concat(movableCols).concat(rightCols);\n    }\n  };\n\n  Grid.prototype.updateFrozenColumns = function () {\n    if (this.frozenLeftCount || this.frozenRightCount) {\n      return;\n    }\n\n    var cols = this.columnModel;\n    var directFrozenCount = this.frozenColumns;\n    var totalFrozenCount = this.getFrozenColumns();\n    var count = 0;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var col = cols[i];\n\n      if (directFrozenCount) {\n        if (i < directFrozenCount) {\n          col.freezeTable = frozenLeft;\n        } else {\n          col.freezeTable = 'movable';\n        }\n      }\n\n      if (col.isFrozen && i >= directFrozenCount) {\n        col.freezeTable = frozenLeft;\n        cols.splice(this.frozenColumns + count, 0, cols.splice(i, 1)[0]);\n        count++;\n      } else if (totalFrozenCount && !directFrozenCount) {\n        col.freezeTable = 'movable';\n      }\n    }\n  };\n\n  Grid.prototype.getFrozenLeftCount = function () {\n    return this.getFrozenColumns() || this.getFrozenLeftColumnsCount();\n  };\n\n  Grid.prototype.isFrozenGrid = function () {\n    return this.getFrozenColumns() !== 0 || this.getFrozenLeftColumnsCount() !== 0 || this.getFrozenRightColumnsCount() !== 0;\n  };\n\n  Grid.prototype.getFrozenMode = function () {\n    return this.frozenName;\n  };\n\n  Grid.prototype.updateLockableColumns = function () {\n    var cols = this.columnModel;\n    var frozenCount = 0;\n    var movableCount = 0;\n    var frozenColumns = this.getFrozenColumns();\n\n    for (var i = 0; i < cols.length; i++) {\n      if (cols[i].lockColumn) {\n        if (i < frozenColumns) {\n          cols.splice(frozenCount, 0, cols.splice(i, 1)[0]);\n          frozenCount++;\n        } else {\n          cols.splice(frozenColumns + movableCount, 0, cols.splice(i, 1)[0]);\n          movableCount++;\n        }\n      }\n    }\n  };\n\n  Grid.prototype.checkLockColumns = function (cols) {\n    for (var i = 0; i < cols.length; i++) {\n      if (cols[i].columns) {\n        this.checkLockColumns(cols[i].columns);\n      } else if (cols[i].lockColumn) {\n        this.lockcolPositionCount++;\n      }\n    }\n  };\n  /**\n   * Gets the columns from the Grid.\n   *\n   * @param {boolean} isRefresh - Defines the boolean whether to refresh\n   * @returns {Column[]} - returns the column\n   */\n\n\n  Grid.prototype.getColumns = function (isRefresh) {\n    var _this = this;\n\n    var inview = this.inViewIndexes.map(function (v) {\n      return v - _this.groupSettings.columns.length;\n    }).filter(function (v) {\n      return v > -1;\n    });\n    var vLen = inview.length;\n\n    if (!this.enableColumnVirtualization || isNullOrUndefined(this.columnModel) || this.columnModel.length === 0 || isRefresh) {\n      this.columnModel = [];\n      this.updateColumnModel(this.columns);\n    }\n\n    var columns = vLen === 0 ? this.columnModel : this.columnModel.slice(inview[0], inview[vLen - 1] + 1);\n\n    if (this.contentModule && this.enableColumnVirtualization && this.isFrozenGrid() && inview.length && inview[0] > 0) {\n      var frozenCols = this.contentModule.ensureFrozenCols(columns);\n      columns = frozenCols;\n    }\n\n    return columns;\n  };\n  /**\n   * @private\n   * @param {string} stackedHeader - Defines the stacked header\n   * @param {Column[]} col - Defines the column\n   * @returns {Column} Returns the Column\n   */\n\n\n  Grid.prototype.getStackedHeaderColumnByHeaderText = function (stackedHeader, col) {\n    for (var i = 0; i < col.length; i++) {\n      var individualColumn = col[i];\n\n      if (individualColumn.field === stackedHeader || individualColumn.headerText === stackedHeader) {\n        this.stackedColumn = individualColumn;\n        break;\n      } else if (individualColumn.columns) {\n        this.getStackedHeaderColumnByHeaderText(stackedHeader, individualColumn.columns);\n      }\n    }\n\n    return this.stackedColumn;\n  };\n  /**\n   * @private\n   * @returns {number[]} Returns the column indexes\n   */\n\n\n  Grid.prototype.getColumnIndexesInView = function () {\n    return this.inViewIndexes;\n  };\n  /**\n   * @private\n   * @returns {Query} - returns the query\n   */\n\n\n  Grid.prototype.getQuery = function () {\n    return this.query;\n  };\n  /**\n   * @private\n   * @returns {object} - returns the locale constants\n   */\n\n\n  Grid.prototype.getLocaleConstants = function () {\n    return this.defaultLocale;\n  };\n  /**\n   * @param {number[]} indexes - specifies the indexes\n   * @returns {void}\n   * @private\n   */\n\n\n  Grid.prototype.setColumnIndexesInView = function (indexes) {\n    this.inViewIndexes = indexes;\n  };\n  /**\n   * Gets the visible columns from the Grid.\n   *\n   * @returns {Column[]} returns the column\n   */\n\n\n  Grid.prototype.getVisibleColumns = function () {\n    return this.getCurrentVisibleColumns();\n  };\n  /**\n   * Gets the header div of the Grid.\n   *\n   * @returns {Element} - Returns the element\n   */\n\n\n  Grid.prototype.getHeaderContent = function () {\n    return this.headerModule.getPanel();\n  };\n  /**\n   * Sets the header div of the Grid to replace the old header.\n   *\n   * @param  {Element} element - Specifies the Grid header.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setGridHeaderContent = function (element) {\n    this.headerModule.setPanel(element);\n  };\n  /**\n   * Gets the content table of the Grid.\n   *\n   * @returns {Element} - Returns the element\n   */\n\n\n  Grid.prototype.getContentTable = function () {\n    return this.contentModule.getTable();\n  };\n  /**\n   * Sets the content table of the Grid to replace the old content table.\n   *\n   * @param  {Element} element - Specifies the Grid content table.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setGridContentTable = function (element) {\n    this.contentModule.setTable(element);\n  };\n  /**\n   * Gets the content div of the Grid.\n   *\n   * @returns {Element} Returns the element\n   */\n\n\n  Grid.prototype.getContent = function () {\n    return this.contentModule.getPanel();\n  };\n  /**\n   * Sets the content div of the Grid to replace the old Grid content.\n   *\n   * @param  {Element} element - Specifies the Grid content.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setGridContent = function (element) {\n    this.contentModule.setPanel(element);\n  };\n  /**\n   * Gets the header table element of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getHeaderTable = function () {\n    return this.headerModule.getTable();\n  };\n  /**\n   * Sets the header table of the Grid to replace the old one.\n   *\n   * @param  {Element} element - Specifies the Grid header table.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setGridHeaderTable = function (element) {\n    this.headerModule.setTable(element);\n  };\n  /**\n   * Gets the footer div of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getFooterContent = function () {\n    this.footerElement = this.element.getElementsByClassName(gridFooter)[0];\n    return this.footerElement;\n  };\n  /**\n   * Gets the footer table element of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getFooterContentTable = function () {\n    this.footerElement = this.element.getElementsByClassName(gridFooter)[0];\n    return this.footerElement.firstChild.firstChild;\n  };\n  /**\n   * Gets the pager of the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getPager = function () {\n    return this.gridPager; //get element from pager\n  };\n  /**\n   * Sets the pager of the Grid to replace the old pager.\n   *\n   * @param  {Element} element - Specifies the Grid pager.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setGridPager = function (element) {\n    this.gridPager = element;\n  };\n  /**\n   * Gets a row by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getRowByIndex = function (index) {\n    return this.contentModule.getRowByIndex(index);\n  };\n  /**\n   * Gets a movable tables row by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getMovableRowByIndex = function (index) {\n    return this.contentModule.getMovableRowByIndex(index);\n  };\n  /**\n   * Gets a frozen tables row by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getFrozenRowByIndex = function (index) {\n    return this.getFrozenDataRows()[index];\n  };\n  /**\n   * Gets all the data rows of the Grid.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  Grid.prototype.getRows = function () {\n    return this.contentModule.getRowElements();\n  };\n  /**\n   * Gets a frozen right tables row element by index.\n   *\n   * @param  {number} index - Specifies the row index.\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getFrozenRightRowByIndex = function (index) {\n    return this.contentModule.getFrozenRightRowByIndex(index);\n  };\n  /**\n   * Get a row information based on cell\n   *\n   * @param {Element | EventTarget} target - specifies the element\n   * @returns {RowInfo} returns the row info\n   */\n\n\n  Grid.prototype.getRowInfo = function (target) {\n    var ele = target;\n    var args = {\n      target: target\n    };\n\n    if (!isNullOrUndefined(target) && isNullOrUndefined(parentsUntil(ele, 'e-detailrowcollapse') && isNullOrUndefined(parentsUntil(ele, 'e-recordplusexpand')))) {\n      var cell = closest(ele, '.' + rowCell);\n\n      if (!cell) {\n        var row$$1 = closest(ele, '.' + row);\n\n        if (!isNullOrUndefined(row$$1) && !row$$1.classList.contains('e-addedrow')) {\n          var rowObj = this.getRowObjectFromUID(row$$1.getAttribute('data-uid'));\n          var rowIndex = parseInt(row$$1.getAttribute(dataRowIndex), 10);\n          args = {\n            row: row$$1,\n            rowData: rowObj.data,\n            rowIndex: rowIndex\n          };\n        }\n\n        return args;\n      }\n\n      var cellIndex = parseInt(cell.getAttribute(dataColIndex), 10);\n\n      if (!isNullOrUndefined(cell) && !isNaN(cellIndex)) {\n        var row_1 = closest(cell, '.' + row);\n        var rowIndex = parseInt(row_1.getAttribute(dataRowIndex), 10);\n        var frzCols = this.getFrozenColumns();\n        var tableName = this.columnModel[cellIndex].getFreezeTableName();\n        var rows = this.contentModule.getRows();\n        var index = cellIndex + this.getIndentCount();\n\n        if (this.isFrozenGrid()) {\n          if (tableName === frozenLeft) {\n            rows = this.contentModule.getRows();\n          } else if (tableName === 'movable') {\n            index = cellIndex - frzCols - this.frozenLeftCount;\n            rows = this.contentModule.getMovableRows();\n          } else if (tableName === frozenRight) {\n            index = cellIndex - (this.frozenLeftCount + this.movableCount);\n            rows = this.contentModule.getFrozenRightRows();\n          }\n        }\n\n        var rowsObject = rows.filter(function (r) {\n          return r.uid === row_1.getAttribute('data-uid');\n        });\n        var rowData = {};\n        var column = void 0;\n\n        if (Object.keys(rowsObject).length) {\n          rowData = rowsObject[0].data;\n          column = rowsObject[0].cells[index].column;\n        }\n\n        args = {\n          cell: cell,\n          cellIndex: cellIndex,\n          row: row_1,\n          rowIndex: rowIndex,\n          rowData: rowData,\n          column: column,\n          target: target\n        };\n      }\n    }\n\n    return args;\n  };\n  /**\n   * Gets the Grid's movable content rows from frozen grid.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  Grid.prototype.getMovableRows = function () {\n    return this.contentModule.getMovableRowElements();\n  };\n  /**\n   * Gets the Grid's frozen right content rows from frozen grid.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  Grid.prototype.getFrozenRightRows = function () {\n    return this.contentModule.getFrozenRightRowElements();\n  };\n  /**\n   * Gets all the Grid's data rows.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  Grid.prototype.getDataRows = function () {\n    return this.getAllDataRows();\n  };\n  /**\n   * @param {boolean} includeAdd - specifies includeAdd\n   * @returns {Element[]} returns the element\n   * @hidden\n   */\n\n\n  Grid.prototype.getAllDataRows = function (includeAdd) {\n    if (isNullOrUndefined(this.getContentTable().querySelector(tbody))) {\n      return [];\n    }\n\n    var tbody$$1 = this.isFrozenGrid() ? this.getFrozenLeftContentTbody() : this.getContentTable().querySelector(tbody);\n    var rows = [].slice.call(tbody$$1.children);\n\n    if (this.frozenRows) {\n      var hdrTbody = this.isFrozenGrid() ? this.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody) : this.getHeaderTable().querySelector(tbody);\n      var freezeRows = [].slice.call(hdrTbody.children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    var dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  };\n  /**\n   * @param {HTMLElement[]} fRows - Defines the frozen Rows\n   * @param {HTMLElement[]} mrows - Defines the movable Rows\n   * @returns {HTMLElement[]} Returns the element\n   * @hidden\n   */\n\n\n  Grid.prototype.addMovableRows = function (fRows, mrows) {\n    for (var i = 0, len = mrows.length; i < len; i++) {\n      fRows.push(mrows[i]);\n    }\n\n    return fRows;\n  };\n\n  Grid.prototype.generateDataRows = function (rows, includAdd) {\n    var dRows = [];\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      if (rows[i].classList.contains(row) && (!rows[i].classList.contains('e-hiddenrow') || includAdd)) {\n        if (this.isCollapseStateEnabled()) {\n          dRows[parseInt(rows[i].getAttribute('data-rowindex'), 10)] = rows[i];\n        } else {\n          dRows.push(rows[i]);\n        }\n      }\n    }\n\n    return dRows;\n  };\n  /**\n   * Gets all the Grid's movable table data rows.\n   *\n   * @returns {Element[]} Returns the element\n   */\n\n\n  Grid.prototype.getMovableDataRows = function () {\n    return this.getAllMovableDataRows();\n  };\n  /**\n   * @param {boolean} includeAdd Defines the include add in boolean\n   * @returns {Element[]} Returns the element\n   * @hidden\n   */\n\n\n  Grid.prototype.getAllMovableDataRows = function (includeAdd) {\n    if (!this.isFrozenGrid()) {\n      return [];\n    }\n\n    var rows = [].slice.call(this.getContent().querySelector('.' + movableContent).querySelector(tbody).children);\n\n    if (this.frozenRows) {\n      var freezeRows = [].slice.call(this.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody).children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    var dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  };\n  /**\n   * Gets all the Grid's frozen table data rows.\n   *\n   * @returns {Element[]} returns the element\n   */\n\n\n  Grid.prototype.getFrozenDataRows = function () {\n    return this.getAllFrozenDataRows();\n  };\n  /**\n   * @param {boolean} includeAdd Defines the include add in boolean\n   * @returns {Element[]} Returns the element\n   * @hidden\n   */\n\n\n  Grid.prototype.getAllFrozenDataRows = function (includeAdd) {\n    var rows = [].slice.call(this.getContent().querySelector('.' + frozenContent).querySelector(tbody).children);\n\n    if (this.frozenRows) {\n      var freezeRows = [].slice.call(this.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody).children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    var dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  };\n  /**\n   * Gets all the Grid's frozen right table data rows.\n   *\n   * @returns {Element[]} Returns the Element\n   */\n\n\n  Grid.prototype.getFrozenRightDataRows = function () {\n    return this.getAllFrozenRightDataRows();\n  };\n  /**\n   * @param {boolean} includeAdd Defines the include add in boolean\n   * @returns {Element[]} Returns the element\n   * @hidden\n   */\n\n\n  Grid.prototype.getAllFrozenRightDataRows = function (includeAdd) {\n    if (this.getFrozenMode() !== 'Right' && this.getFrozenMode() !== 'Left-Right') {\n      return [];\n    }\n\n    var rows = [].slice.call(this.getContent().querySelector('.e-frozen-right-content').querySelector(tbody).children);\n\n    if (this.frozenRows) {\n      var freezeRows = [].slice.call(this.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody).children);\n      rows = this.addMovableRows(freezeRows, rows);\n    }\n\n    var dataRows = this.generateDataRows(rows, includeAdd);\n    return dataRows;\n  };\n  /**\n   * Updates particular cell value based on the given primary key value.\n   * > Primary key column must be specified using `columns.isPrimaryKey` property.\n   *\n   * @param {string| number} key - Specifies the PrimaryKey value of dataSource.\n   * @param {string } field - Specifies the field name which you want to update.\n   * @param {string | number | boolean | Date} value - To update new value for the particular cell.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setCellValue = function (key, field, value) {\n    var cells = 'cells';\n    var rowData = 'data';\n    var rowIdx = 'index';\n    var rowuID = 'uid';\n    var isRight = this.getFrozenMode() === 'Right';\n    var pkName = this.getPrimaryKeyFieldNames()[0];\n    var cell = new CellRenderer(this, this.serviceLocator);\n    var fieldIdx = this.getColumnIndexByField(field);\n    var col = this.getColumnByField(field);\n    var rowObjects = col.getFreezeTableName() === 'movable' ? this.contentModule.getMovableRows() : col.getFreezeTableName() === 'frozen-right' ? this.getFrozenRightRowsObject() : this.contentModule.getRows();\n    var selectedRow = rowObjects.filter(function (r) {\n      return getValue(pkName, r.data) === key;\n    })[0];\n    var tr = selectedRow ? this.element.querySelector('[data-uid=' + selectedRow[rowuID] + ']') : null;\n\n    if (!isNullOrUndefined(tr)) {\n      setValue(field, value, selectedRow[rowData]);\n      var left = this.getFrozenLeftColumnsCount() || this.getFrozenColumns();\n      var movable = this.getMovableColumnsCount();\n\n      if (this.isRowDragable() && !isRight) {\n        left++;\n      }\n\n      var frIdx = left + movable;\n      var td = this.getCellFromIndex(selectedRow[rowIdx], fieldIdx);\n\n      if (!isNullOrUndefined(td)) {\n        var Idx = col.getFreezeTableName() === 'movable' ? left : col.getFreezeTableName() === 'frozen-right' ? frIdx : 0;\n\n        if (this.groupSettings.columns.length) {\n          fieldIdx = fieldIdx + this.groupSettings.columns.length;\n        }\n\n        if (this.childGrid || this.detailTemplate) {\n          fieldIdx++;\n        }\n\n        if (this.isRowDragable() && !isRight) {\n          fieldIdx++;\n        }\n\n        var sRow = selectedRow[cells][fieldIdx - Idx];\n        cell.refreshTD(td, sRow, selectedRow[rowData], {\n          index: selectedRow[rowIdx]\n        });\n\n        if (this.aggregates.length > 0) {\n          this.notify(refreshFooterRenderer, {});\n\n          if (this.groupSettings.columns.length > 0) {\n            this.notify(groupAggregates, {});\n          }\n        }\n        /* tslint:disable:no-string-literal */\n\n\n        if (!isNullOrUndefined(selectedRow) && !isNullOrUndefined(selectedRow['changes'])) {\n          selectedRow['changes'][field] = value;\n        }\n        /* tslint:disable:no-string-literal */\n\n\n        this.trigger(queryCellInfo, {\n          cell: td,\n          column: col,\n          data: selectedRow[rowData]\n        });\n      }\n    } else {\n      return;\n    }\n  };\n  /**\n   * @param {string} columnUid - Defines column uid\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.refreshReactColumnTemplateByUid = function (columnUid) {\n    var _this = this;\n\n    if (this.isReact) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.clearTemplate(['columnTemplate'], undefined, function () {\n        var cells = 'cells';\n        var rowIdx = 'index';\n\n        var rows = _this.getDataRows();\n\n        var indent = _this.getIndentCount();\n\n        var cellIndex = _this.getNormalizedColumnIndex(columnUid);\n\n        for (var j = 0; j < rows.length; j++) {\n          var rowsObj = _this.getRowObjectFromUID(rows[j].getAttribute('data-uid'));\n\n          for (var i = 0; i < rowsObj[cells].length; i++) {\n            var cell = rowsObj[cells][i];\n\n            if (cell.isTemplate) {\n              var cellRenderer = new CellRenderer(_this, _this.serviceLocator);\n\n              var td = _this.getCellFromIndex(j, i - indent);\n\n              cellRenderer.refreshTD(td, cell, rowsObj.data, {\n                index: rowsObj[rowIdx]\n              });\n            }\n          }\n        }\n      });\n    }\n  };\n  /**\n   * @param {string} columnUid - Defines column uid\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.refreshReactHeaderTemplateByUid = function (columnUid) {\n    if (this.isReact) {\n      var cells = 'cells';\n      var rowsObj = this.headerModule.rows;\n      var cellIndex = this.getNormalizedColumnIndex(columnUid);\n\n      for (var j = 0; j < rowsObj.length; j++) {\n        var cell = rowsObj[j][cells][cellIndex];\n\n        if (cell && cell.column.uid === columnUid) {\n          var headerCellRenderer = new HeaderCellRenderer(this, this.serviceLocator);\n          var td = parentsUntil(this.element.querySelectorAll('[e-mappinguid=' + columnUid + ']')[0], 'e-templatecell');\n          headerCellRenderer.refresh(cell, td);\n        }\n      }\n    }\n  };\n  /**\n   * Updates and refresh the particular row values based on the given primary key value.\n   * > Primary key column must be specified using `columns.isPrimaryKey` property.\n   *\n   * @param {string| number} key - Specifies the PrimaryKey value of dataSource.\n   * @param {Object} rowData - To update new data for the particular row.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setRowData = function (key, rowData) {\n    var rowuID = 'uid';\n    var rowObjects = this.contentModule.getRows();\n    var pkName = this.getPrimaryKeyFieldNames()[0];\n\n    if (this.groupSettings.columns.length > 0 && this.aggregates.length > 0) {\n      rowObjects = rowObjects.filter(function (row$$1) {\n        return row$$1.isDataRow;\n      });\n    }\n\n    var selectedRow = rowObjects.filter(function (r) {\n      return getValue(pkName, r.data) === key;\n    })[0];\n    var selectRowEle = selectedRow ? [].slice.call(this.element.querySelectorAll('[data-uid=' + selectedRow[rowuID] + ']')) : undefined;\n\n    if (!isNullOrUndefined(selectedRow) && selectRowEle.length) {\n      selectedRow.changes = rowData;\n\n      if (this.isFrozenGrid()) {\n        var currentTbl = parentsUntil(selectRowEle[0], 'e-table');\n        var currentTblName = currentTbl.parentElement.matches('.e-frozen-left-header,.e-frozen-left-content') ? 'left' : currentTbl.parentElement.matches('.e-frozen-right-header,.e-frozen-right-content') ? 'right' : 'movable';\n        var mTr = this.getMovableRowsObject()[selectedRow.index];\n        this.setFrozenRowData(mTr, rowData);\n\n        if (currentTblName === 'left') {\n          var lTr = this.getRowsObject()[selectedRow.index];\n          this.setFrozenRowData(lTr, rowData);\n        }\n\n        if (currentTblName === 'right' || this.frozenRightColumns.length > 0) {\n          var rTr = this.getFrozenRightRowsObject()[selectedRow.index];\n          this.setFrozenRowData(rTr, rowData);\n        }\n      } else if (this.frozenRows) {\n        var fRowTr = this.getRowsObject()[selectedRow.index];\n        this.setFrozenRowData(fRowTr, rowData);\n      } else {\n        this.setFrozenRowData(selectedRow, rowData);\n      }\n\n      if (this.aggregates.length > 0) {\n        this.notify(refreshFooterRenderer, {});\n\n        if (this.groupSettings.columns.length > 0) {\n          this.notify(groupAggregates, {});\n        }\n      }\n    } else {\n      return;\n    }\n  };\n\n  Grid.prototype.setFrozenRowData = function (fTr, rowData) {\n    var rowRenderer = new RowRenderer(this.serviceLocator, null, this);\n    fTr.changes = rowData;\n    refreshForeignData(fTr, this.getForeignKeyColumns(), fTr.changes);\n    rowRenderer.refresh(fTr, this.getColumns(), true);\n  };\n  /**\n   * Gets a cell by row and column index.\n   *\n   * @param  {number} rowIndex - Specifies the row index.\n   * @param  {number} columnIndex - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getCellFromIndex = function (rowIndex, columnIndex) {\n    var col = this.getColumnByIndex(columnIndex);\n    return getCellByColAndRowIndex(this, col, rowIndex, columnIndex);\n  };\n  /**\n   * Gets a movable table cell by row and column index.\n   *\n   * @param  {number} rowIndex - Specifies the row index.\n   * @param  {number} columnIndex - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getMovableCellFromIndex = function (rowIndex, columnIndex) {\n    if (this.frozenName === 'Left-Right' && columnIndex >= this.movableCount) {\n      return undefined;\n    }\n\n    var index = this.getFrozenColumns() || this.getFrozenLeftColumnsCount();\n    return this.getMovableDataRows()[rowIndex] && this.getMovableDataRows()[rowIndex].getElementsByClassName(rowCell)[columnIndex - index];\n  };\n  /**\n   * Gets a frozen right table cell by row and column index.\n   *\n   * @param  {number} rowIndex - Specifies the row index.\n   * @param  {number} columnIndex - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getFrozenRightCellFromIndex = function (rowIndex, columnIndex) {\n    var index = this.getFrozenLeftColumnsCount() + this.getMovableColumnsCount();\n    var rows = this.getFrozenRightDataRows();\n    return rows[rowIndex] && rows[rowIndex].getElementsByClassName(rowCell)[columnIndex - index];\n  };\n  /**\n   * Gets a column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getColumnHeaderByIndex = function (index) {\n    return this.getHeaderTable().getElementsByClassName('e-headercell')[index];\n  };\n  /**\n   * Gets a movable column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getMovableColumnHeaderByIndex = function (index) {\n    var left = this.getFrozenColumns() || this.getFrozenLeftColumnsCount();\n    return this.getMovableVirtualHeader().getElementsByClassName('e-headercell')[index - left];\n  };\n  /**\n   * Gets a frozen right column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getFrozenRightColumnHeaderByIndex = function (index) {\n    var left = this.getFrozenLeftColumnsCount() + this.getMovableColumnsCount();\n    return this.getFrozenRightHeader().getElementsByClassName('e-headercell')[index - left];\n  };\n  /**\n   * Gets a frozen left column header by column index.\n   *\n   * @param  {number} index - Specifies the column index.\n   * @returns {Element} Returns the Element\n   */\n\n\n  Grid.prototype.getFrozenLeftColumnHeaderByIndex = function (index) {\n    return this.getFrozenVirtualHeader().getElementsByClassName('e-headercell')[index];\n  };\n  /**\n   * @param {string} uid - Defines the uid\n   * @param {boolean} isMovable - Defines isMovable\n   * @param {boolean} isFrozenRight - Defines isFrozenRight\n   * @returns {Row<Column>} Returns the row object\n   * @hidden\n   */\n\n\n  Grid.prototype.getRowObjectFromUID = function (uid, isMovable, isFrozenRight) {\n    var rows = this.contentModule.getRows();\n    var row$$1 = this.rowObject(rows, uid);\n\n    if (this.isFrozenGrid()) {\n      if (!row$$1 || isMovable || isFrozenRight) {\n        row$$1 = this.rowObject(this.contentModule.getMovableRows(), uid);\n\n        if (!row$$1 && this.getFrozenMode() === 'Left-Right' || isFrozenRight) {\n          row$$1 = this.rowObject(this.contentModule.getFrozenRightRows(), uid);\n        }\n\n        return row$$1;\n      }\n    }\n\n    if (isNullOrUndefined(row$$1) && this.enableVirtualization && this.groupSettings.columns.length > 0) {\n      row$$1 = this.rowObject(this.vRows, uid);\n      return row$$1;\n    }\n\n    return row$$1;\n  };\n\n  Grid.prototype.rowObject = function (rows, uid) {\n    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n      var row$$1 = rows_1[_i];\n\n      if (row$$1.uid === uid) {\n        return row$$1;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @hidden\n   * @returns {Row<Column>[]} Returns the Row object\n   */\n\n\n  Grid.prototype.getRowsObject = function () {\n    return this.contentModule.getRows();\n  };\n  /**\n   * @hidden\n   * @returns {Row<Column>[]} Returns the Row object\n   */\n\n\n  Grid.prototype.getMovableRowsObject = function () {\n    var rows = [];\n\n    if (this.isFrozenGrid()) {\n      rows = this.contentModule.getMovableRows();\n    }\n\n    return rows;\n  };\n  /**\n   * @hidden\n   * @returns {Row<Column>[]} Returns the Row object\n   */\n\n\n  Grid.prototype.getFrozenRightRowsObject = function () {\n    var rows = [];\n\n    if (this.getFrozenMode() === 'Right' || this.getFrozenMode() === 'Left-Right') {\n      rows = this.contentModule.getFrozenRightRows();\n    }\n\n    return rows;\n  };\n  /**\n   * Gets a column header by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {Element} - Returns the element\n   */\n\n\n  Grid.prototype.getColumnHeaderByField = function (field) {\n    var column = this.getColumnByField(field);\n    return column ? this.getColumnHeaderByUid(column.uid) : undefined;\n  };\n  /**\n   * Gets a column header by UID.\n   *\n   * @param {string} uid - Specifies the column uid.\n   * @returns {Element} - Returns the element\n   */\n\n\n  Grid.prototype.getColumnHeaderByUid = function (uid) {\n    var element = this.getHeaderContent().querySelector('[e-mappinguid=' + uid + ']');\n    return element ? element.parentElement : undefined;\n  };\n  /**\n   * @hidden\n   * @param {number} index - Defines the index\n   * @returns {Column} Returns the column\n   */\n\n\n  Grid.prototype.getColumnByIndex = function (index) {\n    var column;\n    this.getColumns().some(function (col, i) {\n      column = col;\n      return i === index;\n    });\n    return column;\n  };\n  /**\n   * Gets a Column by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {Column} Returns the column\n   */\n\n\n  Grid.prototype.getColumnByField = function (field) {\n    return iterateArrayOrObject(this.getColumns(), function (item) {\n      if (item.field === field) {\n        return item;\n      }\n\n      return undefined;\n    })[0];\n  };\n  /**\n   * Gets a column index by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {number} Returns the index by field\n   */\n\n\n  Grid.prototype.getColumnIndexByField = function (field) {\n    var cols = this.getColumns();\n\n    for (var i = 0; i < cols.length; i++) {\n      if (cols[i].field === field) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Gets a column by UID.\n   *\n   * @param  {string} uid - Specifies the column UID.\n   * @returns {Column} Returns the column\n   */\n\n\n  Grid.prototype.getColumnByUid = function (uid) {\n    return iterateArrayOrObject(this.getColumns().concat(this.getStackedColumns(this.columns)), function (item) {\n      if (item.uid === uid) {\n        return item;\n      }\n\n      return undefined;\n    })[0];\n  };\n  /**\n   * @param {Column[]} columns - Defines the columns\n   * @param {Column[]} stackedColumn - Defines the stacked columns\n   * @returns {Column[]} Returns the columns\n   * @hidden\n   */\n\n\n  Grid.prototype.getStackedColumns = function (columns, stackedColumn) {\n    if (stackedColumn === void 0) {\n      stackedColumn = [];\n    }\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var column = columns_1[_i];\n\n      if (column.columns) {\n        stackedColumn.push(column);\n        this.getStackedColumns(column.columns, stackedColumn);\n      }\n    }\n\n    return stackedColumn;\n  };\n  /**\n   * Gets a column index by UID.\n   *\n   * @param  {string} uid - Specifies the column UID.\n   * @returns {number} Returns the column by index\n   */\n\n\n  Grid.prototype.getColumnIndexByUid = function (uid) {\n    var index = iterateArrayOrObject(this.getColumns(), function (item, index) {\n      if (item.uid === uid) {\n        return index;\n      }\n\n      return undefined;\n    })[0];\n    return !isNullOrUndefined(index) ? index : -1;\n  };\n  /**\n   * Gets UID by column name.\n   *\n   * @param  {string} field - Specifies the column name.\n   * @returns {string} Returns the column by field\n   */\n\n\n  Grid.prototype.getUidByColumnField = function (field) {\n    return iterateArrayOrObject(this.getColumns(), function (item) {\n      if (item.field === field) {\n        return item.uid;\n      }\n\n      return undefined;\n    })[0];\n  };\n  /**\n   * Gets column index by column uid value.\n   *\n   * @private\n   * @param  {string} uid - Specifies the column uid.\n   * @returns {number} Returns the column by field\n   */\n\n\n  Grid.prototype.getNormalizedColumnIndex = function (uid) {\n    var index = this.getColumnIndexByUid(uid);\n    return index + this.getIndentCount();\n  };\n  /**\n   * Gets indent cell count.\n   *\n   * @private\n   * @returns {number} Returns the indent count\n   */\n\n\n  Grid.prototype.getIndentCount = function () {\n    var index = 0;\n\n    if (this.allowGrouping) {\n      index += this.groupSettings.columns.length;\n    }\n\n    if (this.isDetail()) {\n      index++;\n    }\n\n    if (this.isRowDragable() && isNullOrUndefined(this.rowDropSettings.targetID)) {\n      index++;\n    }\n    /**\n     * TODO: index normalization based on the stacked header, grouping and detailTemplate\n     * and frozen should be handled here\n     */\n\n\n    return index;\n  };\n  /**\n   * Gets the collection of column fields.\n   *\n   * @returns {string[]} Returns the Field names\n   */\n\n\n  Grid.prototype.getColumnFieldNames = function () {\n    var columnNames = [];\n    var column;\n\n    for (var i = 0, len = this.getColumns().length; i < len; i++) {\n      column = this.getColumns()[i];\n\n      if (column.visible) {\n        columnNames.push(column.field);\n      }\n    }\n\n    return columnNames;\n  };\n  /**\n   * Gets a compiled row template.\n   *\n   * @returns {Function} Returns the row TEmplate\n   * @private\n   */\n\n\n  Grid.prototype.getRowTemplate = function () {\n    return this.rowTemplateFn;\n  };\n  /**\n   * Gets a compiled detail row template.\n   *\n   * @private\n   * @returns {Function} Returns the Detail template\n   */\n\n\n  Grid.prototype.getDetailTemplate = function () {\n    return this.detailTemplateFn;\n  };\n  /**\n   * Gets a compiled detail row template.\n   *\n   * @private\n   * @returns {Function}Returns the Edit template\n   */\n\n\n  Grid.prototype.getEditTemplate = function () {\n    return this.editTemplateFn;\n  };\n  /**\n   * Gets a compiled dialog edit header template.\n   *\n   * @private\n   * @returns {Function} returns template function\n   */\n\n\n  Grid.prototype.getEditHeaderTemplate = function () {\n    return this.editHeaderTemplateFn;\n  };\n  /**\n   * Gets a compiled dialog edit footer template.\n   *\n   * @private\n   * @returns {Function} Returns the Footer template\n   */\n\n\n  Grid.prototype.getEditFooterTemplate = function () {\n    return this.editFooterTemplateFn;\n  };\n  /**\n   * Get the names of the primary key columns of the Grid.\n   *\n   * @returns {string[]} Returns the field names\n   */\n\n\n  Grid.prototype.getPrimaryKeyFieldNames = function () {\n    var keys = [];\n\n    for (var k = 0; k < this.columnModel.length; k++) {\n      if (this.columnModel[k].isPrimaryKey) {\n        keys.push(this.columnModel[k].field);\n      }\n    }\n\n    return keys;\n  };\n  /**\n   * Refreshes the Grid header and content.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.refresh = function () {\n    if (!this.isDestroyed) {\n      this.isManualRefresh = true;\n      this.headerModule.refreshUI();\n      this.updateStackedFilter();\n      this.renderModule.refresh();\n    }\n  };\n  /**\n   * Refreshes the Grid header.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.refreshHeader = function () {\n    this.headerModule.refreshUI();\n  };\n  /**\n   * Gets the collection of selected rows.\n   *\n   * @returns {Element[]} Returns the element\n   */\n\n\n  Grid.prototype.getSelectedRows = function () {\n    return this.selectionModule ? this.selectionModule.selectedRecords : [];\n  };\n  /**\n   * Gets the collection of selected row indexes.\n   *\n   * @returns {number[]} Returns the Selected row indexes\n   */\n\n\n  Grid.prototype.getSelectedRowIndexes = function () {\n    return this.selectionModule ? this.selectionModule.selectedRowIndexes : [];\n  };\n  /**\n   * Gets the collection of selected row and cell indexes.\n   *\n   * @returns {number[]} Returns the Selected row cell indexes\n   */\n\n\n  Grid.prototype.getSelectedRowCellIndexes = function () {\n    return this.selectionModule ? this.selectionModule.selectedRowCellIndexes : [];\n  };\n  /**\n   * Gets the collection of selected records.\n   *\n   * @returns {Object[]} Returns the selected records\n   * @isGenericType true\n   */\n\n\n  Grid.prototype.getSelectedRecords = function () {\n    return this.selectionModule ? this.selectionModule.getSelectedRecords() : [];\n  };\n  /**\n   * Gets the collection of selected columns uid.\n   *\n   * @returns {string[]} Returns the selected column uid\n   * @isGenericType true\n   */\n\n\n  Grid.prototype.getSelectedColumnsUid = function () {\n    var _this = this;\n\n    var uid = [];\n\n    if (this.selectionModule) {\n      this.selectionModule.selectedColumnsIndexes.filter(function (i) {\n        return uid.push(_this.getColumns()[i].uid);\n      });\n    }\n\n    return uid;\n  };\n  /**\n   * Gets the data module.\n   *\n   * @returns {Data} Returns the data\n   */\n\n\n  Grid.prototype.getDataModule = function () {\n    return this.renderModule.data;\n  };\n  /**\n   * Shows a column by its column name.\n   *\n   * @param  {string|string[]} keys - Defines a single or collection of column names.\n   * @param  {string} showBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.showColumns = function (keys, showBy) {\n    showBy = showBy ? showBy : 'headerText';\n    this.showHider.show(keys, showBy);\n  };\n  /**\n   * Hides a column by column name.\n   *\n   * @param  {string|string[]} keys - Defines a single or collection of column names.\n   * @param  {string} hideBy - Defines the column key either as field name or header text.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.hideColumns = function (keys, hideBy) {\n    hideBy = hideBy ? hideBy : 'headerText';\n    this.showHider.hide(keys, hideBy);\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the Frozen column\n   */\n\n\n  Grid.prototype.getFrozenColumns = function () {\n    return this.frozenColumns + this.getFrozenCount(this.columns, 0, 0);\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the Frozen Right column count\n   */\n\n\n  Grid.prototype.getFrozenRightColumnsCount = function () {\n    return this.frozenRightCount;\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the Frozen Left column\n   */\n\n\n  Grid.prototype.getFrozenLeftColumnsCount = function () {\n    return this.frozenLeftCount;\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the movable column count\n   */\n\n\n  Grid.prototype.getMovableColumnsCount = function () {\n    return this.movableCount;\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setFrozenCount = function () {\n    this.frozenLeftCount = this.frozenRightCount = this.movableCount = 0;\n    this.visibleFrozenLeft = this.visibleFrozenRight = this.visibleMovable = 0;\n    this.frozenLeftColumns = [];\n    this.frozenRightColumns = [];\n    this.movableColumns = [];\n    this.splitFrozenCount(this.columns);\n\n    if (this.frozenColumns && (this.frozenLeftCount || this.frozenRightCount)) {\n      this.setProperties({\n        frozenColumns: 0\n      }, true);\n    }\n\n    this.setTablesCount();\n\n    if (this.frozenLeftCount && !this.frozenRightCount) {\n      this.frozenName = 'Left';\n    } else if (this.frozenRightCount && !this.frozenLeftCount) {\n      this.frozenName = 'Right';\n    } else if (this.frozenLeftCount && this.frozenRightCount) {\n      this.frozenName = 'Left-Right';\n    } else if (this.frozenColumns && this.frozenRows) {\n      this.frozenName = 'Left';\n    } else {\n      this.frozenName = undefined;\n    }\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the visible Frozen left count\n   */\n\n\n  Grid.prototype.getVisibleFrozenLeftCount = function () {\n    return this.visibleFrozenLeft;\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the visible Frozen Right count\n   */\n\n\n  Grid.prototype.getVisibleFrozenRightCount = function () {\n    return this.visibleFrozenRight;\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the visible movable count\n   */\n\n\n  Grid.prototype.getVisibleMovableCount = function () {\n    return this.visibleMovable;\n  };\n  /**\n   * @hidden\n   * @returns {Column[]} Returns the column\n   */\n\n\n  Grid.prototype.getFrozenRightColumns = function () {\n    return this.frozenRightColumns;\n  };\n  /**\n   * @hidden\n   * @returns {Column[]} Returns the column\n   */\n\n\n  Grid.prototype.getFrozenLeftColumns = function () {\n    return this.frozenLeftColumns;\n  };\n  /**\n   * @hidden\n   * @returns {Column[]} Returns the column\n   */\n\n\n  Grid.prototype.getMovableColumns = function () {\n    return this.movableColumns;\n  };\n\n  Grid.prototype.splitFrozenCount = function (columns) {\n    for (var i = 0; i < columns.length; i++) {\n      if (columns[i].columns) {\n        this.splitFrozenCount(columns[i].columns);\n      } else {\n        if (columns[i].freeze === 'Right') {\n          if (columns[i].visible !== false) {\n            this.visibleFrozenRight++;\n          }\n\n          this.frozenRightColumns.push(columns[i]);\n          this.frozenRightCount++;\n        } else if (columns[i].freeze === 'Left') {\n          if (columns[i].visible !== false) {\n            this.visibleFrozenLeft++;\n          }\n\n          this.frozenLeftColumns.push(columns[i]);\n          this.frozenLeftCount++;\n        } else {\n          if (columns[i].visible !== false) {\n            this.visibleMovable++;\n          }\n\n          this.movableColumns.push(columns[i]);\n          this.movableCount++;\n        }\n      }\n    }\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns the visible frozen columns count\n   */\n\n\n  Grid.prototype.getVisibleFrozenColumns = function () {\n    return this.getVisibleFrozenColumnsCount() + this.getVisibleFrozenCount(this.columns, 0);\n  };\n  /**\n   * Get the current Filter operator and field.\n   *\n   * @returns {FilterUI} Returns the filter UI\n   */\n\n\n  Grid.prototype.getFilterUIInfo = function () {\n    return this.filterModule ? this.filterModule.getFilterUIInfo() : {};\n  };\n\n  Grid.prototype.getVisibleFrozenColumnsCount = function () {\n    var visibleFrozenColumns = 0;\n    var columns = this.columnModel;\n\n    for (var i = 0; i < this.frozenColumns; i++) {\n      if (columns[i].visible) {\n        visibleFrozenColumns++;\n      }\n    }\n\n    if (this.frozenLeftCount || this.frozenRightCount) {\n      for (var i = 0; i < columns.length; i++) {\n        if (columns[i].visible && (columns[i].freeze === 'Left' || columns[i].freeze === 'Right')) {\n          visibleFrozenColumns++;\n        }\n      }\n    }\n\n    return visibleFrozenColumns;\n  };\n\n  Grid.prototype.getVisibleFrozenCount = function (cols, cnt) {\n    if (!this.frozenLeftCount && !this.frozenRightCount) {\n      for (var i = 0, len = cols.length; i < len; i++) {\n        if (cols[i].columns) {\n          cnt = this.getVisibleFrozenCount(cols[i].columns, cnt);\n        } else {\n          if (cols[i].isFrozen && cols[i].visible) {\n            cnt++;\n          }\n        }\n      }\n    }\n\n    return cnt;\n  };\n\n  Grid.prototype.getFrozenCount = function (cols, cnt, index) {\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].columns) {\n        cnt = this.getFrozenCount(cols[i].columns, cnt, index);\n      } else {\n        if (cols[i].isFrozen && index > this.frozenColumns - 1) {\n          cnt++;\n        }\n\n        index++;\n      }\n    }\n\n    return cnt;\n  };\n  /**\n   * Navigates to the specified target page.\n   *\n   * @param  {number} pageNo - Defines the page number to navigate.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.goToPage = function (pageNo) {\n    if (this.pagerModule) {\n      this.pagerModule.goToPage(pageNo);\n    }\n  };\n  /**\n   * Defines the text of external message.\n   *\n   * @param  {string} message - Defines the message to update.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.updateExternalMessage = function (message) {\n    if (this.pagerModule) {\n      this.pagerModule.updateExternalMessage(message);\n    }\n  };\n  /**\n   * Sorts a column with the given options.\n   *\n   * @param {string} columnName - Defines the column name to be sorted.\n   * @param {SortDirection} direction - Defines the direction of sorting field.\n   * @param {boolean} isMultiSort - Specifies whether the previous sorted columns are to be maintained.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.sortColumn = function (columnName, direction, isMultiSort) {\n    if (this.sortModule) {\n      this.sortModule.sortColumn(columnName, direction, isMultiSort);\n    }\n  };\n  /**\n   * Clears all the sorted columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearSorting = function () {\n    if (this.sortModule) {\n      this.sortModule.clearSorting();\n    }\n  };\n  /**\n   * Remove sorted column by field name.\n   *\n   * @param {string} field - Defines the column field name to remove sort.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.removeSortColumn = function (field) {\n    if (this.sortModule) {\n      this.sortModule.removeSortColumn(field);\n    }\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearGridActions = function () {\n    this.setProperties({\n      sortSettings: {\n        columns: []\n      }\n    }, true);\n    this.setProperties({\n      filterSettings: {\n        columns: []\n      }\n    }, true);\n    this.setProperties({\n      searchSettings: {\n        key: ''\n      }\n    }, true);\n\n    if (this.allowGrouping) {\n      this.setProperties({\n        groupSettings: {\n          columns: []\n        }\n      }, false);\n    } else {\n      this.freezeRefresh();\n    }\n  };\n  /**\n   * Filters grid row by column name with the given options.\n   *\n   * @param  {string} fieldName - Defines the field name of the column.\n   * @param  {string} filterOperator - Defines the operator to filter records.\n   * @param  {string | number | Date | boolean} filterValue - Defines the value used to filter records.\n   * @param  {string} predicate - Defines the relationship between one filter query and another by using AND or OR predicate.\n   * @param  {boolean} matchCase - If match case is set to true, the grid filters the records with exact match. if false, it filters case\n   * insensitive records (uppercase and lowercase letters treated the same).\n   * @param  {boolean} ignoreAccent - If ignoreAccent set to true,\n   * then filter ignores the diacritic characters or accents while filtering.\n   * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.\n   * @param  {string} actualOperator - Defines the actual filter operator for the filter column.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.filterByColumn = function (fieldName, filterOperator, filterValue, predicate, matchCase, ignoreAccent, actualFilterValue, actualOperator) {\n    if (this.filterModule) {\n      this.filterModule.filterByColumn(fieldName, filterOperator, filterValue, predicate, matchCase, ignoreAccent, actualFilterValue, actualOperator);\n    }\n  };\n  /**\n   * Clears all the filtered rows of the Grid.\n   *\n   * @param {string[]} fields - Defines the Fields\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearFiltering = function (fields) {\n    if (this.filterModule) {\n      this.filterModule.clearFiltering(fields);\n    }\n  };\n  /**\n   * Removes filtered column by field name.\n   *\n   * @param  {string} field - Defines column field name to remove filter.\n   * @param  {boolean} isClearFilterBar -  Specifies whether the filter bar value needs to be cleared.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.removeFilteredColsByField = function (field, isClearFilterBar) {\n    if (this.filterModule) {\n      this.filterModule.removeFilteredColsByField(field, isClearFilterBar);\n    }\n  };\n  /**\n   * Selects a row by given index.\n   *\n   * @param  {number} index - Defines the row index.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.selectRow = function (index, isToggle) {\n    if (this.selectionModule) {\n      this.selectionModule.selectRow(index, isToggle);\n    }\n  };\n  /**\n   * Selects a collection of rows by indexes.\n   *\n   * @param  {number[]} rowIndexes - Specifies the row indexes.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.selectRows = function (rowIndexes) {\n    if (this.selectionModule) {\n      this.selectionModule.selectRows(rowIndexes);\n    }\n  };\n  /**\n   * Deselects the current selected rows and cells.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearSelection = function () {\n    if (this.selectionModule) {\n      this.selectionModule.clearSelection();\n    }\n  };\n  /**\n   * Selects a cell by the given index.\n   *\n   * @param  {IIndex} cellIndex - Defines the row and column indexes.\n   * @param  {boolean} isToggle - If set to true, then it toggles the selection.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.selectCell = function (cellIndex, isToggle) {\n    if (this.selectionModule) {\n      this.selectionModule.selectCell(cellIndex, isToggle);\n    }\n  };\n  /**\n   * Selects a range of cells from start and end indexes.\n   *\n   * @param  {IIndex} startIndex - Specifies the row and column's start index.\n   * @param  {IIndex} endIndex - Specifies the row and column's end index.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.selectCellsByRange = function (startIndex, endIndex) {\n    this.selectionModule.selectCellsByRange(startIndex, endIndex);\n  };\n  /**\n   * Searches Grid records using the given key.\n   * You can customize the default search option by using the\n   * [`searchSettings`](./#searchsettings/).\n   *\n   * @param  {string} searchString - Defines the key.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.search = function (searchString) {\n    if (this.searchModule) {\n      this.searchModule.search(searchString);\n    }\n  };\n  /**\n   * By default, prints all the pages of the Grid and hides the pager.\n   * > You can customize print options using the\n   * [`printMode`](./#printmode).\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.print = function () {\n    if (this.printModule) {\n      this.printModule.print();\n    }\n  };\n  /**\n   * Delete a record with Given options. If fieldname and data is not given then grid will delete the selected record.\n   * > `editSettings.allowDeleting` should be true.\n   *\n   * @param {string} fieldname - Defines the primary key field, 'Name of the column'.\n   * @param {Object} data - Defines the JSON data of the record to be deleted.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.deleteRecord = function (fieldname, data) {\n    if (this.editModule) {\n      this.editModule.deleteRecord(fieldname, data);\n    }\n  };\n  /**\n   * Starts edit the selected row. At least one row must be selected before invoking this method.\n   * `editSettings.allowEditing` should be true.\n   * {% codeBlock src='grid/startEdit/index.md' %}{% endcodeBlock %}\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.startEdit = function () {\n    if (this.editModule) {\n      this.editModule.startEdit();\n    }\n  };\n  /**\n   * If Grid is in editable state, you can save a record by invoking endEdit.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.endEdit = function () {\n    if (this.editModule) {\n      this.editModule.endEdit();\n    }\n  };\n  /**\n   * Cancels edited state.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.closeEdit = function () {\n    if (this.editModule) {\n      this.editModule.closeEdit();\n    }\n  };\n  /**\n   * Adds a new record to the Grid. Without passing parameters, it adds empty rows.\n   * > `editSettings.allowEditing` should be true.\n   *\n   * @param {Object} data - Defines the new add record data.\n   * @param {number} index - Defines the row index to be added\n   * @returns {void}\n   */\n\n\n  Grid.prototype.addRecord = function (data, index) {\n    if (this.editModule) {\n      this.editModule.addRecord(data, index);\n    }\n  };\n  /**\n   * Delete any visible row by TR element.\n   *\n   * @param {HTMLTableRowElement} tr - Defines the table row element.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.deleteRow = function (tr) {\n    if (this.editModule) {\n      this.editModule.deleteRow(tr);\n    }\n  };\n  /**\n   * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.\n   *\n   * @param {number} index - Defines row index to edit a particular cell.\n   * @param {string} field - Defines the field name of the column to perform batch edit.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.editCell = function (index, field) {\n    if (this.editModule) {\n      this.editModule.editCell(index, field);\n    }\n  };\n  /**\n   * Saves the cell that is currently edited. It does not save the value to the DataSource.\n   *\n   * @returns {void}\n   * {% codeBlock src='grid/saveCell/index.md' %}{% endcodeBlock %}\n   */\n\n\n  Grid.prototype.saveCell = function () {\n    if (this.editModule) {\n      this.editModule.saveCell();\n    }\n  };\n  /**\n   * To update the specified cell by given value without changing into edited state.\n   *\n   * @param {number} rowIndex Defines the row index.\n   * @param {string} field Defines the column field.\n   * @param {string | number | boolean | Date} value - Defines the value to be changed.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.updateCell = function (rowIndex, field, value) {\n    if (this.editModule) {\n      this.editModule.updateCell(rowIndex, field, value);\n    }\n  };\n  /**\n   * To update the specified row by given values without changing into edited state.\n   *\n   * {% codeBlock src='grid/updateRow/index.md' %}{% endcodeBlock %}\n   *\n   * @param {number} index Defines the row index.\n   * @param {Object} data Defines the data object to be updated.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.updateRow = function (index, data) {\n    if (this.editModule) {\n      this.editModule.updateRow(index, data);\n    }\n  };\n  /**\n   * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.\n   *\n   * @returns {Object} Returns the batch changes\n   */\n\n\n  Grid.prototype.getBatchChanges = function () {\n    if (this.editModule) {\n      return this.editModule.getBatchChanges();\n    }\n\n    return {};\n  };\n  /**\n   * Enables or disables ToolBar items.\n   *\n   * @param {string[]} items - Defines the collection of itemID of ToolBar items.\n   * @param {boolean} isEnable - Defines the items to be enabled or disabled.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.enableToolbarItems = function (items, isEnable) {\n    if (this.toolbarModule) {\n      this.toolbarModule.enableItems(items, isEnable);\n    }\n  };\n  /**\n   * Copy the selected rows or cells data into clipboard.\n   *\n   * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.copy = function (withHeader) {\n    if (this.clipboardModule) {\n      this.clipboardModule.copy(withHeader);\n    }\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.recalcIndentWidth = function () {\n    var _this = this;\n\n    if (!this.getHeaderTable().querySelector('.e-emptycell')) {\n      return;\n    }\n\n    if (!this.groupSettings.columns.length && !this.isDetail() && !this.isRowDragable() || this.getHeaderTable().querySelector('.e-emptycell').getAttribute('indentRefreshed') || !this.getContentTable()) {\n      return;\n    }\n\n    var indentWidth = this.getHeaderTable().querySelector('.e-emptycell').parentElement.offsetWidth;\n    var headerCol = [].slice.call(this.getHeaderTable().querySelector(colGroup).childNodes);\n    var contentCol = [].slice.call(this.getContentTable().querySelector(colGroup).childNodes);\n    var perPixel = indentWidth / 30;\n    var i = this.getFrozenMode() === 'Right' ? this.frozenRightCount : 0;\n    var parentOffset = this.element.offsetWidth;\n\n    var applyWidth = function (index, width) {\n      if (ispercentageWidth(_this)) {\n        var newWidth = (width / parentOffset * 100).toFixed(1) + '%';\n        headerCol[index].style.width = newWidth;\n        contentCol[index].style.width = newWidth;\n      } else {\n        headerCol[index].style.width = width + 'px';\n        contentCol[index].style.width = width + 'px';\n      }\n\n      _this.notify(columnWidthChanged, {\n        index: index,\n        width: width\n      });\n    };\n\n    if (perPixel >= 1) {\n      indentWidth = 30 / perPixel;\n    }\n\n    if (indentWidth < 1) {\n      indentWidth = 1;\n    }\n\n    if (this.enableColumnVirtualization || this.isAutoGen || this.columns.length === this.groupSettings.columns.length) {\n      indentWidth = 30;\n    }\n\n    while (i < this.groupSettings.columns.length) {\n      applyWidth(i, indentWidth);\n      i++;\n    }\n\n    if (this.isDetail()) {\n      applyWidth(i, indentWidth);\n      i++;\n    }\n\n    if (this.isRowDragable()) {\n      applyWidth(i, indentWidth);\n    }\n\n    this.isAutoGen = false;\n    this.getHeaderTable().querySelector('.e-emptycell').setAttribute('indentRefreshed', 'true');\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.resetIndentWidth = function () {\n    if (ispercentageWidth(this)) {\n      this.getHeaderTable().querySelector('.e-emptycell').removeAttribute('indentRefreshed');\n      this.widthService.setWidthToColumns();\n      this.recalcIndentWidth();\n    }\n\n    if ((this.width === 'auto' || typeof this.width === 'string' && this.width.indexOf('%') !== -1) && this.getColumns().filter(function (col) {\n      return (!col.width || col.width === 'auto') && col.minWidth;\n    }).length > 0) {\n      var tgridWidth = this.widthService.getTableWidth(this.getColumns());\n      this.widthService.setMinwidthBycalculation(tgridWidth);\n    }\n\n    if (this.isFrozenGrid() && this.widthService) {\n      this.widthService.refreshFrozenScrollbar();\n    }\n\n    if (this.allowTextWrap && this.textWrapSettings.wrapMode !== 'Content') {\n      this.notify(refreshHandlers, {});\n    }\n  };\n  /**\n   * @hidden\n   * @returns {boolean} Returns isRowDragable\n   */\n\n\n  Grid.prototype.isRowDragable = function () {\n    return this.allowRowDragAndDrop && !this.rowDropSettings.targetID;\n  };\n  /**\n   * Changes the Grid column positions by field names.\n   *\n   * @param  {string} fromFName - Defines the origin field name.\n   * @param  {string} toFName - Defines the destination field name.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.reorderColumns = function (fromFName, toFName) {\n    if (this.reorderModule) {\n      this.reorderModule.reorderColumns(fromFName, toFName);\n    }\n  };\n  /**\n   * Changes the Grid column positions by field index. If you invoke reorderColumnByIndex multiple times,\n   * then you won't get the same results every time.\n   *\n   * @param  {number} fromIndex - Defines the origin field index.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.reorderColumnByIndex = function (fromIndex, toIndex) {\n    if (this.reorderModule) {\n      this.reorderModule.reorderColumnByIndex(fromIndex, toIndex);\n    }\n  };\n  /**\n   * Changes the Grid column positions by field index. If you invoke reorderColumnByTargetIndex multiple times,\n   * then you will get the same results every time.\n   *\n   * @param  {string} fieldName - Defines the field name.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.reorderColumnByTargetIndex = function (fieldName, toIndex) {\n    if (this.reorderModule) {\n      this.reorderModule.reorderColumnByTargetIndex(fieldName, toIndex);\n    }\n  };\n  /**\n   * Changes the Grid Row position with given indexes.\n   *\n   * @param  {number} fromIndexes - Defines the origin Indexes.\n   * @param  {number} toIndex - Defines the destination Index.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.reorderRows = function (fromIndexes, toIndex) {\n    if (this.rowDragAndDropModule) {\n      this.rowDragAndDropModule.reorderRows(fromIndexes, toIndex);\n    }\n  };\n  /**\n   * @param {ReturnType} e - Defines the Return type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.refreshDataSource = function (e) {\n    this.notify('refreshdataSource', e);\n  };\n  /**\n   * @param {boolean} enable -Defines the enable\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.disableRowDD = function (enable) {\n    var headerTable = this.getHeaderTable();\n    var contentTable = this.getContentTable();\n    var headerRows = headerTable.querySelectorAll('th.e-rowdragheader, th.e-mastercell');\n    var rows = this.getRows();\n    var disValue = enable ? 'none' : '';\n    setStyleAttribute(headerTable.querySelector(colGroup).childNodes[0], {\n      'display': disValue\n    });\n    setStyleAttribute(contentTable.querySelector(colGroup).childNodes[0], {\n      'display': disValue\n    });\n\n    for (var i = 0; i < this.getRows().length; i++) {\n      var ele = rows[i].firstElementChild;\n\n      if (enable) {\n        addClass([ele], 'e-hide');\n      } else {\n        removeClass([ele], ['e-hide']);\n      }\n    }\n\n    for (var j = 0; j < headerTable.querySelectorAll('th.e-rowdragheader, th.e-mastercell').length; j++) {\n      var ele = headerRows[j];\n\n      if (enable) {\n        addClass([ele], 'e-hide');\n      } else {\n        removeClass([ele], ['e-hide']);\n      }\n    }\n  };\n  /**\n   * Changes the column width to automatically fit its content to ensure that the width shows the content without wrapping/hiding.\n   * > * This method ignores the hidden columns.\n   * > * Uses the `autoFitColumns` method in the `dataBound` event to resize at initial rendering.\n   *\n   * @param  {string |string[]} fieldNames - Defines the column names.\n   * @returns {void}\n   *\n   *\n   * ```typescript\n   * <div id=\"Grid\"></div>\n   * <script>\n   * let gridObj: Grid = new Grid({\n   *     dataSource: employeeData,\n   *     columns: [\n   *         { field: 'OrderID', headerText: 'Order ID', width:100 },\n   *         { field: 'EmployeeID', headerText: 'Employee ID' }],\n   *     dataBound: () => gridObj.autoFitColumns('EmployeeID')\n   * });\n   * gridObj.appendTo('#Grid');\n   * </script>\n   * ```\n   *\n   */\n\n\n  Grid.prototype.autoFitColumns = function (fieldNames) {\n    if (this.resizeModule) {\n      this.resizeModule.autoFitColumns(fieldNames);\n    }\n  };\n  /**\n   * @param {number} x - Defines the number\n   * @param {number} y - Defines the number\n   * @param {Element} target - Defines the Element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.createColumnchooser = function (x, y, target) {\n    if (this.columnChooserModule) {\n      this.columnChooserModule.renderColumnChooser(x, y, target);\n    }\n  };\n\n  Grid.prototype.initializeServices = function () {\n    this.serviceLocator.register('widthService', this.widthService = new ColumnWidthService(this));\n    this.serviceLocator.register('cellRendererFactory', new CellRendererFactory());\n    this.serviceLocator.register('rendererFactory', new RendererFactory());\n    this.serviceLocator.register('localization', this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale));\n    this.serviceLocator.register('valueFormatter', this.valueFormatterService = new ValueFormatter(this.locale));\n    this.serviceLocator.register('showHideService', this.showHider = new ShowHide(this));\n    this.serviceLocator.register('ariaService', this.ariaService = new AriaService());\n    this.serviceLocator.register('focus', this.focusModule = new FocusStrategy(this));\n  };\n\n  Grid.prototype.processModel = function () {\n    var gCols = this.groupSettings.columns;\n    var sCols = this.sortSettings.columns;\n    var flag;\n    var j;\n\n    if (this.allowGrouping) {\n      var _loop_1 = function (i, len) {\n        j = 0;\n\n        for (var sLen = sCols.length; j < sLen; j++) {\n          if (sCols[j].field === gCols[i]) {\n            flag = true;\n            break;\n          }\n        }\n\n        if (!flag) {\n          sCols.push({\n            field: gCols[i],\n            direction: 'Ascending',\n            isFromGroup: true\n          });\n        } else {\n          if (this_1.allowSorting) {\n            this_1.sortedColumns.push(sCols[j].field);\n          } else {\n            sCols[j].direction = 'Ascending';\n          }\n        }\n\n        if (!this_1.groupSettings.showGroupedColumn) {\n          var column = this_1.enableColumnVirtualization ? this_1.columns.filter(function (c) {\n            return c.field === gCols[i];\n          })[0] : this_1.getColumnByField(gCols[i]);\n\n          if (column) {\n            column.visible = false;\n          } else {\n            this_1.log('initial_action', {\n              moduleName: 'group',\n              columnName: gCols[i]\n            });\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      for (var i = 0, len = gCols.length; i < len; i++) {\n        _loop_1(i, len);\n      }\n    }\n\n    if (!gCols.length) {\n      for (var i = 0; i < sCols.length; i++) {\n        this.sortedColumns.push(sCols[i].field);\n      }\n    }\n\n    this.rowTemplateFn = templateCompiler(this.rowTemplate);\n    this.detailTemplateFn = templateCompiler(this.detailTemplate);\n    this.editTemplateFn = templateCompiler(this.editSettings.template);\n    this.editHeaderTemplateFn = templateCompiler(this.editSettings.headerTemplate);\n    this.editFooterTemplateFn = templateCompiler(this.editSettings.footerTemplate);\n\n    if (!isNullOrUndefined(this.parentDetails)) {\n      var value = isNullOrUndefined(this.parentDetails.parentKeyFieldValue) ? 'undefined' : this.parentDetails.parentKeyFieldValue;\n      this.query.where(this.queryString, 'equal', value, true);\n    }\n\n    this.initForeignColumn();\n  };\n\n  Grid.prototype.initForeignColumn = function () {\n    if (this.isForeignKeyEnabled(this.getColumns())) {\n      this.notify(initForeignKeyColumn, this.getForeignKeyColumns());\n    }\n  };\n\n  Grid.prototype.enableVerticalRendering = function () {\n    if (this.rowRenderingMode === 'Vertical') {\n      this.element.classList.add('e-row-responsive');\n    } else {\n      this.element.classList.remove('e-row-responsive');\n    }\n  };\n\n  Grid.prototype.gridRender = function () {\n    this.updateRTL();\n\n    if (this.rowRenderingMode === 'Vertical') {\n      this.element.classList.add('e-row-responsive');\n    }\n\n    if (this.enableHover) {\n      this.element.classList.add('e-gridhover');\n    }\n\n    if (Browser.isDevice) {\n      this.element.classList.add('e-device');\n    }\n\n    if (this.rowHeight) {\n      this.element.classList.add('e-grid-min-height');\n    }\n\n    if (this.cssClass) {\n      this.element.classList.add(this.cssClass);\n    }\n\n    classList(this.element, ['e-responsive', 'e-default'], []);\n    var rendererFactory = this.serviceLocator.getService('rendererFactory');\n    this.headerModule = rendererFactory.getRenderer(RenderType.Header);\n    this.contentModule = rendererFactory.getRenderer(RenderType.Content);\n    this.printModule = new Print(this, this.scrollModule);\n    this.clipboardModule = new Clipboard(this, this.serviceLocator);\n    this.renderModule.render();\n    this.eventInitializer();\n    this.createGridPopUpElement();\n    this.widthService.setWidthToColumns();\n    this.updateGridLines();\n    this.applyTextWrap();\n    this.createTooltip(); //for clip mode ellipsis\n\n    this.enableBoxSelection();\n  };\n\n  Grid.prototype.dataReady = function () {\n    this.scrollModule.setWidth();\n    this.scrollModule.setHeight();\n\n    if (this.height !== 'auto') {\n      this.scrollModule.setPadding();\n    }\n  };\n\n  Grid.prototype.updateRTL = function () {\n    if (this.enableRtl) {\n      this.element.classList.add('e-rtl');\n    } else {\n      this.element.classList.remove('e-rtl');\n    }\n  };\n\n  Grid.prototype.createGridPopUpElement = function () {\n    var popup = this.createElement('div', {\n      className: 'e-gridpopup',\n      styles: 'display:none;'\n    });\n    var content$$1 = this.createElement('div', {\n      className: content,\n      attrs: {\n        tabIndex: '-1'\n      }\n    });\n    append([content$$1, this.createElement('div', {\n      className: 'e-uptail e-tail'\n    })], popup);\n    content$$1.appendChild(this.createElement('span'));\n    append([content$$1, this.createElement('div', {\n      className: 'e-downtail e-tail'\n    })], popup);\n    this.element.appendChild(popup);\n  };\n\n  Grid.prototype.updateGridLines = function () {\n    classList(this.element, [], ['e-verticallines', 'e-horizontallines', 'e-hidelines', 'e-bothlines']);\n\n    switch (this.gridLines) {\n      case 'Horizontal':\n        this.element.classList.add('e-horizontallines');\n        break;\n\n      case 'Vertical':\n        this.element.classList.add('e-verticallines');\n        break;\n\n      case 'None':\n        this.element.classList.add('e-hidelines');\n        break;\n\n      case 'Both':\n        this.element.classList.add('e-bothlines');\n        break;\n    }\n\n    this.updateResizeLines();\n  };\n\n  Grid.prototype.updateResizeLines = function () {\n    if (this.allowResizing && !(this.gridLines === 'Vertical' || this.gridLines === 'Both')) {\n      this.element.classList.add('e-resize-lines');\n    } else {\n      this.element.classList.remove('e-resize-lines');\n    }\n  };\n  /**\n   * The function is used to apply text wrap\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.applyTextWrap = function () {\n    if (this.allowTextWrap) {\n      var headerRows = [].slice.call(this.element.getElementsByClassName('e-columnheader'));\n\n      switch (this.textWrapSettings.wrapMode) {\n        case 'Header':\n          wrap(this.element, false);\n          wrap(this.getContent(), false);\n          wrap(headerRows, true);\n          break;\n\n        case 'Content':\n          wrap(this.getContent(), true);\n          wrap(this.element, false);\n          wrap(headerRows, false);\n          break;\n\n        default:\n          wrap(this.element, true);\n          wrap(this.getContent(), false);\n          wrap(headerRows, false);\n      }\n\n      if (this.textWrapSettings.wrapMode !== 'Content') {\n        this.notify(refreshHandlers, {});\n      }\n    }\n  };\n  /**\n   * The function is used to remove text wrap\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.removeTextWrap = function () {\n    wrap(this.element, false);\n    var headerRows = [].slice.call(this.element.getElementsByClassName('e-columnheader'));\n    wrap(headerRows, false);\n    wrap(this.getContent(), false);\n\n    if (this.textWrapSettings.wrapMode !== 'Content') {\n      this.notify(refreshHandlers, {});\n    }\n  };\n  /**\n   * The function is used to add Tooltip to the grid cell that has ellipsiswithtooltip clip mode.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.createTooltip = function () {\n    this.toolTipObj = new Tooltip({\n      opensOn: 'custom',\n      content: '',\n      cssClass: this.cssClass ? this.cssClass : null\n    }, this.element);\n  };\n  /** @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.freezeRefresh = function () {\n    this.isFreezeRefresh = true;\n\n    if (this.enableVirtualization) {\n      this.pageSettings.currentPage = 1;\n    }\n\n    this.componentRefresh();\n  };\n\n  Grid.prototype.getTooltipStatus = function (element) {\n    var headerTable = this.getHeaderTable();\n    var headerDivTag = 'e-gridheader';\n    var htable = this.createTable(headerTable, headerDivTag, 'header');\n    var ctable = this.createTable(headerTable, headerDivTag, 'content');\n    var table$$1 = element.classList.contains('e-headercell') ? htable : ctable;\n    var ele = element.classList.contains('e-headercell') ? 'th' : 'tr';\n    table$$1.querySelector(ele).className = element.className;\n    table$$1.querySelector(ele).innerHTML = element.innerHTML;\n    var width = table$$1.querySelector(ele).getBoundingClientRect().width;\n    document.body.removeChild(htable);\n    document.body.removeChild(ctable);\n\n    if (width > element.getBoundingClientRect().width) {\n      return true;\n    }\n\n    return false;\n  };\n\n  Grid.prototype.mouseMoveHandler = function (e) {\n    if (this.isEllipsisTooltip()) {\n      var element = parentsUntil(e.target, 'e-ellipsistooltip');\n\n      if (this.prevElement !== element || e.type === 'mouseout') {\n        this.toolTipObj.close();\n      }\n\n      var tagName = e.target.tagName;\n      var elemNames = ['A', 'BUTTON', 'INPUT'];\n\n      if (element && e.type !== 'mouseout' && !(Browser.isDevice && elemNames.indexOf(tagName) !== -1)) {\n        if (element.getAttribute('aria-describedby')) {\n          return;\n        }\n\n        if (this.getTooltipStatus(element)) {\n          if (element.getElementsByClassName('e-headertext').length) {\n            this.toolTipObj.content = element.getElementsByClassName('e-headertext')[0].innerText;\n          } else {\n            this.toolTipObj.content = element.innerText;\n          }\n\n          this.prevElement = element;\n          var col = this.getColumns()[parseInt(element.getAttribute(dataColIndex), 10)];\n\n          if (col.disableHtmlEncode) {\n            this.toolTipObj.enableHtmlParse = false;\n          }\n\n          this.toolTipObj.open(element);\n        }\n      }\n    }\n\n    this.hoverFrozenRows(e);\n  };\n  /**\n   * @param {MouseEvent} e - Defines the mouse event\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.hoverFrozenRows = function (e) {\n    if (this.isFrozenGrid()) {\n      var row$$1 = parentsUntil(e.target, row);\n\n      if ([].slice.call(this.element.getElementsByClassName('e-frozenhover')).length && e.type === 'mouseout') {\n        var rows = [].slice.call(this.element.getElementsByClassName('e-frozenhover'));\n\n        for (var i = 0; i < rows.length; i++) {\n          rows[i].classList.remove('e-frozenhover');\n        }\n      } else if (row$$1) {\n        var rows = [].slice.call(this.element.querySelectorAll('tr[data-rowindex=\"' + row$$1.getAttribute(dataRowIndex) + '\"]'));\n        rows.splice(rows.indexOf(row$$1), 1);\n\n        for (var i = 0; i < rows.length; i++) {\n          if (row$$1.getAttribute('aria-selected') !== 'true' && rows[i]) {\n            rows[i].classList.add('e-frozenhover');\n          } else if (rows[i]) {\n            rows[i].classList.remove('e-frozenhover');\n          }\n        }\n      }\n    }\n  };\n\n  Grid.prototype.isEllipsisTooltip = function () {\n    var cols = this.getColumns();\n\n    if (this.clipMode === 'EllipsisWithTooltip') {\n      return true;\n    }\n\n    for (var i = 0; i < cols.length; i++) {\n      if (cols[i].clipMode === 'EllipsisWithTooltip') {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Grid.prototype.scrollHandler = function () {\n    if (this.isEllipsisTooltip()) {\n      this.toolTipObj.close();\n    }\n  };\n  /**\n   * To create table for ellipsiswithtooltip\n   *\n   * @param {Element} table - Defines the table\n   * @param {string} tag - Defines the tag\n   * @param {string} type - Defines the type\n   * @returns {HTMLDivElement} Returns the HTML div ELement\n   * @hidden\n   */\n\n\n  Grid.prototype.createTable = function (table$$1, tag, type) {\n    var myTableDiv = this.createElement('div');\n    myTableDiv.className = this.element.className;\n    myTableDiv.style.cssText = 'display: inline-block;visibility:hidden;position:absolute';\n    var mySubDiv = this.createElement('div');\n    mySubDiv.className = tag;\n    var myTable = this.createElement('table', {\n      attrs: {\n        role: 'grid'\n      }\n    });\n    myTable.className = table$$1.className;\n    myTable.style.cssText = 'table-layout: auto;width: auto';\n    var ele = type === 'header' ? 'th' : 'td';\n    var myTr = this.createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    var mytd = this.createElement(ele);\n    myTr.appendChild(mytd);\n    myTable.appendChild(myTr);\n    mySubDiv.appendChild(myTable);\n    myTableDiv.appendChild(mySubDiv);\n    document.body.appendChild(myTableDiv);\n    return myTableDiv;\n  };\n\n  Grid.prototype.onKeyPressed = function (e) {\n    if (e.action === 'tab' || e.action === 'shiftTab') {\n      this.toolTipObj.close();\n    }\n  };\n  /**\n   * Binding events to the element while component creation.\n   *\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.wireEvents = function () {\n    EventHandler.add(this.element, 'click', this.mouseClickHandler, this);\n    EventHandler.add(this.element, 'touchend', this.mouseClickHandler, this);\n    EventHandler.add(this.element, 'focusout', this.focusOutHandler, this);\n    EventHandler.add(this.element, 'dblclick', this.dblClickHandler, this);\n    EventHandler.add(this.element, 'keydown', this.keyPressHandler, this); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    EventHandler.add(window, 'resize', this.resetIndentWidth, this);\n\n    if (this.allowKeyboard) {\n      this.element.tabIndex = this.element.tabIndex === -1 ? 0 : this.element.tabIndex;\n    }\n\n    this.keyboardModule = new KeyboardEvents(this.element, {\n      keyAction: this.keyActionHandler.bind(this),\n      keyConfigs: this.keyConfigs,\n      eventName: 'keydown'\n    });\n    EventHandler.add(this.getContent().firstElementChild, 'scroll', this.scrollHandler, this);\n    EventHandler.add(this.element, 'mousemove', this.mouseMoveHandler, this);\n    EventHandler.add(this.element, 'mouseout', this.mouseMoveHandler, this);\n    EventHandler.add(this.getContent(), 'touchstart', this.tapEvent, this);\n    EventHandler.add(document.body, 'keydown', this.keyDownHandler, this);\n  };\n  /**\n   * Unbinding events from the element while component destroy.\n   *\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.unwireEvents = function () {\n    EventHandler.remove(this.element, 'click', this.mouseClickHandler);\n    EventHandler.remove(this.element, 'touchend', this.mouseClickHandler);\n    EventHandler.remove(this.element, 'focusout', this.focusOutHandler);\n    EventHandler.remove(this.element, 'dblclick', this.dblClickHandler);\n    EventHandler.remove(this.getContent().firstElementChild, 'scroll', this.scrollHandler);\n    EventHandler.remove(this.element, 'mousemove', this.mouseMoveHandler);\n    EventHandler.remove(this.element, 'mouseout', this.mouseMoveHandler);\n    EventHandler.remove(this.element, 'keydown', this.keyPressHandler);\n    EventHandler.remove(this.getContent(), 'touchstart', this.tapEvent);\n    EventHandler.remove(document.body, 'keydown', this.keyDownHandler); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    EventHandler.remove(window, 'resize', this.resetIndentWidth);\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.addListener = function () {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    this.on(dataReady, this.dataReady, this);\n    this.on(contentReady, this.recalcIndentWidth, this);\n    this.on(headerRefreshed, this.recalcIndentWidth, this);\n    this.dataBoundFunction = this.refreshMediaCol.bind(this);\n    this.addEventListener(dataBound, this.dataBoundFunction);\n    this.on(keyPressed, this.onKeyPressed, this);\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.removeListener = function () {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    this.off(dataReady, this.dataReady);\n    this.off(contentReady, this.recalcIndentWidth);\n    this.off(headerRefreshed, this.recalcIndentWidth);\n    this.removeEventListener(dataBound, this.dataBoundFunction);\n    this.off(keyPressed, this.onKeyPressed);\n  };\n  /**\n   * Get current visible data of grid.\n   *\n   * @returns {Object[]} Returns the current view records\n   * @isGenericType true\n   */\n\n\n  Grid.prototype.getCurrentViewRecords = function () {\n    if (isGroupAdaptive(this)) {\n      return isNullOrUndefined(this.currentViewData.records) ? this.currentViewData : this.currentViewData.records;\n    }\n\n    if (this.groupSettings.enableLazyLoading) {\n      return this.currentViewData;\n    }\n\n    return this.allowGrouping && this.groupSettings.columns.length && this.currentViewData.length && this.currentViewData.records ? this.currentViewData.records : this.currentViewData;\n  };\n\n  Grid.prototype.mouseClickHandler = function (e) {\n    if (this.isChildGrid(e) || parentsUntil(e.target, 'e-gridpopup') && e.touches || this.element.getElementsByClassName('e-cloneproperties').length || this.checkEdit(e)) {\n      return;\n    }\n\n    if ((!this.allowRowDragAndDrop && (parentsUntil(e.target, gridContent) || e.target.tagName === 'TD') || !(this.allowGrouping || this.allowReordering) && parentsUntil(e.target, 'e-gridheader')) && e.touches) {\n      return;\n    }\n\n    if (parentsUntil(e.target, 'e-gridheader') && this.allowRowDragAndDrop && !parentsUntil(e.target, 'e-filterbarcell')) {\n      e.preventDefault();\n    }\n\n    var args = this.getRowInfo(e.target);\n    var cancel = 'cancel';\n    args[cancel] = false;\n    var isDataRow = false;\n    var tr = closest(e.target, 'tr');\n\n    if (tr && tr.getAttribute('data-uid')) {\n      var rowObj = this.getRowObjectFromUID(tr.getAttribute('data-uid'));\n      isDataRow = rowObj ? rowObj.isDataRow : false;\n    }\n\n    if (isDataRow) {\n      this.trigger(recordClick, args);\n    }\n\n    this.notify(click, e);\n  };\n\n  Grid.prototype.checkEdit = function (e) {\n    var tr = parentsUntil(e.target, row);\n    var isEdit = this.editSettings.mode !== 'Batch' && this.isEdit && tr && (tr.classList.contains(editedRow) || tr.classList.contains(addedRow));\n    return !parentsUntil(e.target, 'e-unboundcelldiv') && (isEdit || parentsUntil(e.target, rowCell) && parentsUntil(e.target, rowCell).classList.contains('e-editedbatchcell'));\n  };\n\n  Grid.prototype.dblClickHandler = function (e) {\n    var grid = parentsUntil(e.target, 'e-grid');\n\n    if (isNullOrUndefined(grid) || grid.id !== this.element.id || closest(e.target, '.e-unboundcelldiv')) {\n      return;\n    }\n\n    var dataRow = false;\n    var tr = closest(e.target, 'tr');\n\n    if (tr && tr.getAttribute('data-uid')) {\n      var rowObj = this.getRowObjectFromUID(tr.getAttribute('data-uid'));\n      dataRow = rowObj ? rowObj.isDataRow : false;\n    }\n\n    var args = this.getRowInfo(e.target);\n    args.target = e.target;\n\n    if (dataRow) {\n      this.trigger(recordDoubleClick, args);\n    }\n\n    this.notify(dblclick, e);\n  };\n\n  Grid.prototype.focusOutHandler = function (e) {\n    if (this.isChildGrid(e)) {\n      return;\n    }\n\n    if (!parentsUntil(e.target, 'e-grid')) {\n      this.element.querySelector('.e-gridpopup').style.display = 'None';\n    }\n\n    var filterClear = this.element.querySelector('.e-cancel:not(.e-hide)');\n\n    if (filterClear) {\n      filterClear.classList.add('e-hide');\n    }\n\n    var relatedTarget = e.relatedTarget;\n    var ariaOwns = relatedTarget ? relatedTarget.getAttribute('aria-owns') : null;\n\n    if ((!relatedTarget || !parentsUntil(relatedTarget, 'e-grid') && (!isNullOrUndefined(ariaOwns) && ariaOwns) !== e.target.getAttribute('aria-owns')) && !this.keyPress && this.isEdit && !Browser.isDevice) {\n      if (this.editSettings.mode === 'Batch' && !((parentsUntil(relatedTarget, 'e-ddl') || parentsUntil(relatedTarget, 'e-ddt')) && parentsUntil(relatedTarget, 'e-input-group'))) {\n        this.editModule.saveCell();\n        this.notify(editNextValCell, {});\n      }\n\n      if (this.editSettings.mode === 'Normal') {\n        this.editModule.editFormValidate();\n      }\n    }\n\n    this.keyPress = false;\n  };\n\n  Grid.prototype.isChildGrid = function (e) {\n    var gridElement = parentsUntil(e.target, 'e-grid');\n\n    if (gridElement && gridElement.id !== this.element.id || parentsUntil(e.target, 'e-unboundcelldiv') && isNullOrUndefined(gridElement)) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @param {Object} persistedData - Defines the persisted data\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.mergePersistGridData = function (persistedData) {\n    var data = this.getLocalData();\n\n    if (!(isNullOrUndefined(data) || data === '') || !isNullOrUndefined(persistedData)) {\n      var dataObj = !isNullOrUndefined(persistedData) ? persistedData : JSON.parse(data);\n\n      if (this.enableVirtualization && dataObj.pageSettings) {\n        dataObj.pageSettings.currentPage = 1;\n      }\n\n      var keys = Object.keys(dataObj);\n      this.isProtectedOnChange = true;\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n\n        if (typeof this[key] === 'object' && !isNullOrUndefined(this[key])) {\n          if (Array.isArray(this[key]) && key === 'columns') {\n            setColumnIndex(this[key]);\n            this.mergeColumns(dataObj[key], this[key]);\n            this[key] = dataObj[key];\n          } else {\n            extend(this[key], dataObj[key]);\n          }\n        } else {\n          this[key] = dataObj[key];\n        }\n      }\n\n      this.isProtectedOnChange = false;\n    }\n  };\n\n  Grid.prototype.mergeColumns = function (storedColumn, columns) {\n    var storedColumns = storedColumn;\n\n    var _loop_2 = function (i) {\n      var localCol = columns.filter(function (tCol) {\n        return tCol.index === storedColumns[i].index;\n      })[0];\n\n      if (!isNullOrUndefined(localCol)) {\n        if (localCol.columns && localCol.columns.length) {\n          this_2.mergeColumns(storedColumns[i].columns, localCol.columns);\n          storedColumns[i] = extend(localCol, storedColumns[i], {}, true);\n        } else {\n          storedColumns[i] = extend(localCol, storedColumns[i], {}, true);\n        }\n      }\n    };\n\n    var this_2 = this;\n\n    for (var i = 0; i < storedColumns.length; i++) {\n      _loop_2(i);\n    }\n  };\n  /**\n   * @hidden\n   * @returns {boolean} Returns the isDetail\n   */\n\n\n  Grid.prototype.isDetail = function () {\n    return !isNullOrUndefined(this.detailTemplate) || !isNullOrUndefined(this.childGrid);\n  };\n\n  Grid.prototype.isCommandColumn = function (columns) {\n    var _this = this;\n\n    return columns.some(function (col) {\n      if (col.columns) {\n        return _this.isCommandColumn(col.columns);\n      }\n\n      return !!(col.commands || col.commandsTemplate);\n    });\n  };\n\n  Grid.prototype.isForeignKeyEnabled = function (columns) {\n    var _this = this;\n\n    return columns.some(function (col) {\n      if (col.columns) {\n        return _this.isForeignKeyEnabled(col.columns);\n      }\n\n      return !!(col.dataSource && col.foreignKeyValue);\n    });\n  };\n\n  Grid.prototype.keyPressHandler = function (e) {\n    var presskey = extend(e, {\n      cancel: false\n    });\n    this.trigger('keyPressed', presskey);\n\n    if (presskey.cancel === true) {\n      e.stopImmediatePropagation();\n    }\n  };\n\n  Grid.prototype.keyDownHandler = function (e) {\n    if (e.altKey) {\n      if (e.keyCode === 74) {\n        //alt j\n        if (this.keyA) {\n          //alt A J\n          this.notify(groupCollapse, {\n            target: e.target,\n            collapse: false\n          });\n          this.keyA = false;\n        } else {\n          if (this.focusModule && this.focusModule.currentInfo && this.focusModule.currentInfo.element) {\n            removeClass([this.focusModule.currentInfo.element, this.focusModule.currentInfo.elementToFocus], ['e-focused', 'e-focus']);\n            this.focusModule.currentInfo.element.tabIndex = -1;\n          }\n\n          if (!this.element.classList.contains('e-childgrid')) {\n            this.element.focus();\n          }\n        }\n      }\n\n      if (e.keyCode === 87) {\n        //alt w\n        var focusModule = this.focusModule;\n\n        if (focusModule) {\n          if (!this.currentViewData.length) {\n            return;\n          }\n\n          focusModule.focusContent();\n          focusModule.addOutline();\n        }\n      }\n\n      if (e.keyCode === 65) {\n        //alt A\n        this.keyA = true;\n      }\n\n      if (e.keyCode === 72 && this.keyA) {\n        //alt A H\n        this.notify(groupCollapse, {\n          target: e.target,\n          collapse: true\n        });\n        this.keyA = false;\n      }\n    }\n\n    if (e.keyCode === 13) {\n      this.notify(enterKeyHandler, e);\n    }\n  };\n\n  Grid.prototype.keyActionHandler = function (e) {\n    if (this.isChildGrid(e) || this.isEdit && e.action !== 'escape' && e.action !== 'enter' && e.action !== 'shiftEnter' && e.action !== 'tab' && e.action !== 'shiftTab') {\n      return;\n    } else {\n      this.keyPress = true;\n    }\n\n    if (this.allowKeyboard) {\n      if (e.action === 'ctrlPlusP') {\n        e.preventDefault();\n        this.print();\n      }\n\n      this.notify(keyPressed, e);\n    }\n  };\n  /**\n   * @param {Function[]} modules - Defines the modules\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.setInjectedModules = function (modules) {\n    this.injectedModules = modules;\n  };\n\n  Grid.prototype.updateColumnObject = function () {\n    prepareColumns(this.columns, this.enableColumnVirtualization, this);\n    setColumnIndex(this.columns);\n    this.initForeignColumn();\n    this.notify(autoCol, {});\n  };\n  /**\n   * Gets the foreign columns from Grid.\n   *\n   * @returns {Column[]} Returns Foreign key column\n   */\n\n\n  Grid.prototype.getForeignKeyColumns = function () {\n    return this.getColumns().filter(function (col) {\n      return col.isForeignColumn();\n    });\n  };\n  /**\n   * @hidden\n   * @returns {number} Returns row height\n   */\n\n\n  Grid.prototype.getRowHeight = function () {\n    return this.rowHeight ? this.rowHeight : getRowHeight(this.element);\n  };\n  /**\n   * Refreshes the Grid column changes.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.refreshColumns = function () {\n    this.setFrozenCount();\n    var fCnt = this.getContent().querySelector('.e-frozen-left-content');\n    var frCnt = this.getContent().querySelector('.e-frozen-right-content');\n    var isColFrozen = !this.frozenRightCount && !this.frozenLeftCount;\n    var isFrozen = this.getFrozenColumns() !== 0;\n\n    if (!isFrozen && (!fCnt && this.frozenLeftCount || !frCnt && this.frozenRightCount || fCnt && !this.frozenLeftCount || frCnt && !this.frozenRightCount)) {\n      this.tableIndex = 0;\n      this.tablesCount = 1;\n\n      if (this.enableColumnVirtualization) {\n        this.columnModel = [];\n        this.updateColumnModel(this.columns);\n      }\n\n      this.freezeRefresh();\n    } else if (isColFrozen && (this.getFrozenColumns() === 1 && !fCnt || this.getFrozenColumns() === 0 && fCnt)) {\n      this.tableIndex = 0;\n      this.tablesCount = 1;\n\n      if (this.enableColumnVirtualization) {\n        this.columnModel = [];\n        this.updateColumnModel(this.columns);\n      }\n\n      this.freezeRefresh();\n    } else {\n      this.isPreventScrollEvent = true;\n      this.updateColumnObject();\n      this.checkLockColumns(this.getColumns());\n      this.refresh();\n\n      if (this.isFrozenGrid()) {\n        var mTbl = this.contentModule.getMovableContent().querySelector('.' + table);\n        remove(mTbl.querySelector(colGroup));\n        var colGroup$$1 = this.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n        mTbl.insertBefore(colGroup$$1, mTbl.querySelector(tbody));\n\n        if (this.getFrozenMode() === 'Left-Right') {\n          var frTbl = this.contentModule.getFrozenRightContent().querySelector('.' + table);\n          remove(frTbl.querySelector(colGroup));\n          var colGrp = this.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup).cloneNode(true);\n          frTbl.insertBefore(colGrp, frTbl.querySelector(tbody));\n        }\n      }\n    }\n\n    if (this.isFrozenGrid()) {\n      var left = this.getContent().querySelector('.e-movablescrollbar').scrollLeft;\n      this.headerModule.getMovableHeader().scrollLeft = left;\n      this.contentModule.getMovableContent().scrollLeft = left;\n    }\n  };\n  /**\n   * Export Grid data to Excel file(.xlsx).\n   *\n   * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.\n   * @param  {boolean} isMultipleExport - Define to enable multiple export.\n   * @param  {Workbook} workbook - Defines the Workbook if multiple export is enabled.\n   * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.\n   * @returns {Promise<any>} Returns the excelexport\n   */\n\n\n  Grid.prototype.excelExport = function (excelExportProperties, isMultipleExport, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  workbook, isBlob) {\n    return this.excelExportModule ? this.excelExportModule.Map(this, excelExportProperties, isMultipleExport, workbook, false, isBlob) : null;\n  };\n  /**\n   * Export Grid data to CSV file.\n   *\n   * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.\n   * @param  {boolean} isMultipleExport - Define to enable multiple export.\n   * @param  {Workbook} workbook - Defines the Workbook if multiple export is enabled.\n   * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.\n   * @returns {Promise<any>} Returns csv export\n   */\n\n\n  Grid.prototype.csvExport = function (excelExportProperties, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isMultipleExport, workbook, isBlob) {\n    return this.excelExportModule ? this.excelExportModule.Map(this, excelExportProperties, isMultipleExport, workbook, true, isBlob) : null;\n  };\n  /**\n   * Export Grid data to PDF document.\n   *\n   * @param {pdfExportProperties} pdfExportProperties - Defines the export properties of the Grid.\n   * @param {isMultipleExport} isMultipleExport - Define to enable multiple export.\n   * @param {pdfDoc} pdfDoc - Defined the Pdf Document if multiple export is enabled.\n   * @param {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.\n   * @returns {Promise<any>} Returns pdfexport\n   */\n\n\n  Grid.prototype.pdfExport = function (pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {\n    return this.pdfExportModule ? this.pdfExportModule.Map(this, pdfExportProperties, isMultipleExport, pdfDoc, isBlob) : null;\n  };\n  /**\n   * Groups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to group.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.groupColumn = function (columnName) {\n    if (this.groupModule) {\n      this.groupModule.groupColumn(columnName);\n    }\n  };\n  /**\n   * Expands all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.groupExpandAll = function () {\n    if (this.groupModule) {\n      this.groupModule.expandAll();\n    }\n  };\n  /**\n   * Collapses all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.groupCollapseAll = function () {\n    if (this.groupModule) {\n      this.groupModule.collapseAll();\n    }\n  };\n  /**\n   * Expands or collapses grouped rows by target element.\n   *\n   * @param  {Element} target - Defines the target element of the grouped row.\n   * @returns {void}\n   */\n  // public expandCollapseRows(target: Element): void {\n  //     if (this.groupModule) {\n  //         this.groupModule.expandCollapseRows(target);\n  //     }\n  // }\n\n  /**\n   * Clears all the grouped columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearGrouping = function () {\n    if (this.groupModule) {\n      this.groupModule.clearGrouping();\n    }\n  };\n  /**\n   * Ungroups a column by column name.\n   *\n   * {% codeBlock src='grid/ungroupColumn/index.md' %}{% endcodeBlock %}\n   *\n   * @param  {string} columnName - Defines the column name to ungroup.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.ungroupColumn = function (columnName) {\n    if (this.groupModule) {\n      this.groupModule.ungroupColumn(columnName);\n    }\n  };\n  /**\n   * Column chooser can be displayed on screen by given position(X and Y axis).\n   *\n   * @param {number} x - Defines the X axis.\n   * @param {number} y - Defines the Y axis.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.openColumnChooser = function (x, y) {\n    if (this.columnChooserModule) {\n      this.columnChooserModule.openColumnChooser(x, y);\n    }\n  };\n\n  Grid.prototype.scrollRefresh = function () {\n    var _this = this;\n\n    var refresh = function () {\n      _this.scrollModule.refresh();\n\n      _this.off(contentReady, refresh);\n    };\n\n    this.on(contentReady, refresh, this);\n  };\n  /**\n   * Collapses a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the expanded element to collapse.\n   * @returns {void}\n   */\n  // public detailCollapse(target: number | Element): void {\n  //     if (this.detailRowModule) {\n  //         this.detailRowModule.collapse(target);\n  //     }\n  // }\n\n  /**\n   * Collapses all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.detailCollapseAll = function () {\n    if (this.detailRowModule) {\n      this.detailRowModule.collapseAll();\n    }\n  };\n  /**\n   * Expands a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the collapsed element to expand.\n   * @returns {void}\n   */\n  // public detailExpand(target: number | Element): void {\n  //     if (this.detailRowModule) {\n  //         this.detailRowModule.expand(target);\n  //     }\n  // }\n\n  /**\n   * Expands all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.detailExpandAll = function () {\n    if (this.detailRowModule) {\n      this.detailRowModule.expandAll();\n    }\n  };\n  /**\n   * Deselects the currently selected cells.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearCellSelection = function () {\n    if (this.selectionModule) {\n      this.selectionModule.clearCellSelection();\n    }\n  };\n  /**\n   * Deselects the currently selected rows.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.clearRowSelection = function () {\n    if (this.selectionModule) {\n      this.selectionModule.clearRowSelection();\n    }\n  };\n  /**\n   * Selects a collection of cells by row and column indexes.\n   *\n   * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.selectCells = function (rowCellIndexes) {\n    if (this.selectionModule) {\n      this.selectionModule.selectCells(rowCellIndexes);\n    }\n  };\n  /**\n   * Selects a range of rows from start and end row indexes.\n   *\n   * @param  {number} startIndex - Specifies the start row index.\n   * @param  {number} endIndex - Specifies the end row index.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.selectRowsByRange = function (startIndex, endIndex) {\n    if (this.selectionModule) {\n      this.selectionModule.selectRowsByRange(startIndex, endIndex);\n    }\n  };\n  /**\n   * @hidden\n   * @returns {boolean} Returns whether context menu is open or not\n   */\n\n\n  Grid.prototype.isContextMenuOpen = function () {\n    return this.contextMenuModule && this.contextMenuModule.isOpen;\n  };\n  /**\n   * @param {Function} module - Defines the module\n   * @returns {boolean} return the injected modules\n   * @hidden\n   */\n\n\n  Grid.prototype.ensureModuleInjected = function (module) {\n    return this.getInjectedModules().indexOf(module) >= 0;\n  };\n  /**\n   * Destroys the given template reference.\n   *\n   * @param {string[]} propertyNames - Defines the collection of template name.\n   * @param {any} index - specifies the index\n   */\n  // eslint-disable-next-line\n\n\n  Grid.prototype.destroyTemplate = function (propertyNames, index) {\n    this.clearTemplate(propertyNames, index);\n  };\n  /**\n   * @param {string | string[]} type - Defines the type\n   * @param {Object} args - Defines the arguments\n   * @returns {void}\n   * @hidden\n   * @private\n   */\n\n\n  Grid.prototype.log = function (type, args) {\n    // eslint-disable-next-line\n    this.loggerModule ? this.loggerModule.log(type, args) : function () {\n      return 0;\n    }();\n  };\n  /**\n   * @param {Element} element - Defines the element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.applyBiggerTheme = function (element) {\n    if (this.element.classList.contains('e-bigger')) {\n      element.classList.add('e-bigger');\n    }\n  };\n  /**\n   * @hidden\n   * @returns {Object} Returns the previous row data\n   */\n\n\n  Grid.prototype.getPreviousRowData = function () {\n    var previousRowData = this.getRowsObject()[this.getRows().length - 1].data;\n    return previousRowData;\n  };\n  /**\n   * Hides the scrollbar placeholder of Grid content when grid content is not overflown.\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.hideScroll = function () {\n    var content$$1 = this.getContent().querySelector('.' + content);\n    var scrollBar = this.getContent().querySelector('.e-scrollbar');\n\n    if (content$$1.scrollHeight <= content$$1.clientHeight) {\n      this.scrollModule.removePadding();\n      content$$1.style.overflowY = 'auto';\n    }\n\n    if (this.isFrozenGrid() && scrollBar) {\n      var mvblScrollBar = this.getContent().querySelector('.e-movablescrollbar');\n      var mvblChild = this.getContent().querySelector('.e-movablechild');\n      scrollBar.style.display = 'flex';\n\n      if (mvblScrollBar.offsetWidth >= mvblChild.offsetWidth) {\n        scrollBar.style.display = 'none';\n        this.notify(frozenHeight, 0);\n      }\n    }\n  };\n  /**\n   * Get row index by primary key or row data.\n   *\n   * @param  {string | Object} value - Defines the primary key value.\n   * @returns {number} Returns the index\n   */\n\n\n  Grid.prototype.getRowIndexByPrimaryKey = function (value) {\n    var pkName = this.getPrimaryKeyFieldNames()[0];\n    value = typeof value === 'object' ? value[pkName] : value;\n    var rows = this.getRowsObject();\n\n    for (var i = 0; i < rows.length; i++) {\n      if (rows[i].isDetailRow || rows[i].isCaptionRow) {\n        continue;\n      }\n\n      var pKvalue = rows[i].data[pkName];\n\n      if (pkName.split('.').length > 1) {\n        pKvalue = performComplexDataOperation(pkName, rows[i].data);\n      }\n\n      if (pKvalue === value) {\n        return rows[i].index;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * @param {string} field - Defines the field name\n   * @returns {Column} returns the column\n   * @hidden\n   */\n  // Need to have all columns while filtering with ColumnVirtualization.\n\n\n  Grid.prototype.grabColumnByFieldFromAllCols = function (field) {\n    var column;\n    this.columnModel = [];\n    this.updateColumnModel(this.columns);\n    var gCols = this.columnModel;\n\n    for (var i = 0; i < gCols.length; i++) {\n      if (field === gCols[i].field) {\n        column = gCols[i];\n      }\n    }\n\n    return column;\n  };\n  /**\n   * @param {string} uid - Defines the uid\n   * @returns {Column} returns the column\n   * @hidden\n   */\n  // Need to have all columns while filtering with ColumnVirtualization.\n\n\n  Grid.prototype.grabColumnByUidFromAllCols = function (uid) {\n    var column;\n    this.columnModel = [];\n    this.updateColumnModel(this.columns);\n    var gCols = this.columnModel;\n\n    for (var i = 0; i < gCols.length; i++) {\n      if (uid === gCols[i].uid) {\n        column = gCols[i];\n      }\n    }\n\n    return column;\n  };\n  /**\n   * Get all filtered records from the Grid and it returns array of objects for the local dataSource, returns a promise object if the Grid has remote data.\n   *\n   * @returns {Object[] | Promise<Object>} Returns the filtered records\n   */\n\n\n  Grid.prototype.getFilteredRecords = function () {\n    if (this.allowFiltering && this.filterSettings.columns.length) {\n      var query = this.renderModule.data.generateQuery(true);\n\n      if (this.dataSource && this.renderModule.data.isRemote() && this.dataSource instanceof DataManager) {\n        return this.renderModule.data.getData(this.dataSource, query);\n      } else {\n        if (this.dataSource instanceof DataManager) {\n          return this.dataSource.executeLocal(query);\n        } else {\n          return new DataManager(this.dataSource, query).executeLocal(query);\n        }\n      }\n    }\n\n    return [];\n  };\n\n  Grid.prototype.getUserAgent = function () {\n    var userAgent = Browser.userAgent.toLowerCase();\n    return /iphone|ipod|ipad/.test(userAgent);\n  };\n  /**\n   * @param {TouchEventArgs} e - Defines the TouchEventArgs\n   * @returns {void}\n   * @hidden\n   */\n  // Need to have all columns while filtering with ColumnVirtualization.\n  // eslint-disable-next-line\n\n\n  Grid.prototype.tapEvent = function (e) {\n    if (this.getUserAgent()) {\n      if (!Global.timer) {\n        Global.timer = setTimeout(function () {\n          Global.timer = null;\n        }, 300);\n      } else {\n        clearTimeout(Global.timer);\n        Global.timer = null;\n        this.dblClickHandler(e);\n        this.notify(doubleTap, e);\n      }\n    }\n  };\n  /**\n   * @param {string} prefix - specifies the prefix\n   * @returns {string} returns the row uid\n   * @hidden\n   */\n\n\n  Grid.prototype.getRowUid = function (prefix) {\n    return \"\" + prefix + this.rowUid++;\n  };\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getMovableVirtualContent = function () {\n    return this.getContent().querySelector('.' + movableContent);\n  };\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getFrozenVirtualContent = function () {\n    return this.getContent().querySelector('.' + frozenContent);\n  };\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getMovableVirtualHeader = function () {\n    return this.getHeaderContent().querySelector('.' + movableHeader);\n  };\n  /**\n   * @hidden\n   * @returns {Element} returns the element\n   */\n\n\n  Grid.prototype.getFrozenVirtualHeader = function () {\n    return this.getHeaderContent().querySelector('.' + frozenHeader);\n  };\n  /**\n   * @param {string} uid - specifies the uid\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  Grid.prototype.getRowElementByUID = function (uid) {\n    var rowEle;\n    var rows = [];\n\n    if (this.isFrozenGrid()) {\n      var fRows = [].slice.call(this.getFrozenVirtualContent().querySelector(tbody).children);\n      var mRows = [].slice.call(this.getMovableVirtualContent().querySelector(tbody).children);\n      var frozenRigtRows = [];\n\n      if (this.tablesCount === 3) {\n        frozenRigtRows = [].slice.call(this.getContent().querySelector('.e-frozen-right-content').querySelector(tbody).children);\n      }\n\n      if (this.frozenRows) {\n        rows = [].slice.call(this.getFrozenVirtualHeader().querySelector(tbody).children);\n        rows = rows.concat([].slice.call(this.getMovableVirtualHeader().querySelector(tbody).children));\n\n        if (this.tablesCount === 3) {\n          var frHdr = this.getHeaderContent().querySelector('.e-frozen-right-header');\n          rows = rows.concat([].slice.call(frHdr.querySelector(tbody).children)).concat(frozenRigtRows);\n        }\n\n        rows = rows.concat(fRows).concat(mRows);\n      } else {\n        rows = fRows.concat(mRows).concat(frozenRigtRows);\n      }\n    } else {\n      var cntRows = [].slice.call(this.getContent().querySelector(tbody).children);\n\n      if (this.frozenRows) {\n        rows = [].slice.call(this.getHeaderContent().querySelector(tbody).children);\n        rows = rows.concat(cntRows);\n      } else {\n        rows = cntRows;\n      }\n    }\n\n    for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {\n      var row$$1 = rows_2[_i];\n\n      if (row$$1.getAttribute('data-uid') === uid) {\n        rowEle = row$$1;\n        break;\n      }\n    }\n\n    return rowEle;\n  };\n  /**\n   * Gets the hidden columns from the Grid.\n   *\n   * @returns {Column[]} Returns the Column\n   */\n\n\n  Grid.prototype.getHiddenColumns = function () {\n    var cols = [];\n\n    for (var _i = 0, _a = this.columnModel; _i < _a.length; _i++) {\n      var col = _a[_i];\n\n      if (col.visible === false) {\n        cols.push(col);\n      }\n    }\n\n    return cols;\n  };\n  /**\n   * calculatePageSizeByParentHeight\n   *\n   * @param {number | string } containerHeight - specifies the container height\n   * @returns {number} returns the page size\n   */\n\n\n  Grid.prototype.calculatePageSizeByParentHeight = function (containerHeight) {\n    if (this.allowPaging) {\n      if (this.allowTextWrap && this.textWrapSettings.wrapMode === 'Header' || !this.allowTextWrap) {\n        var pagesize = 0;\n\n        if (containerHeight.indexOf('%') !== -1) {\n          containerHeight = parseInt(containerHeight, 10) / 100 * this.element.clientHeight;\n        }\n\n        var nonContentHeight = this.getNoncontentHeight() + this.getRowHeight();\n\n        if (containerHeight > nonContentHeight) {\n          var contentHeight = 0;\n          contentHeight = containerHeight - this.getNoncontentHeight();\n          pagesize = contentHeight / this.getRowHeight();\n        }\n\n        if (pagesize > 0) {\n          return Math.floor(pagesize);\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  Grid.prototype.getNoncontentHeight = function () {\n    var height = 0;\n\n    if (!isNullOrUndefined(this.getHeaderContent().clientHeight)) {\n      height += this.getHeaderContent().clientHeight;\n    }\n\n    if (this.toolbar && !isNullOrUndefined(this.element.querySelector('.e-toolbar').clientHeight)) {\n      height += this.element.querySelector('.e-toolbar').clientHeight;\n    }\n\n    if (this.allowPaging && !isNullOrUndefined(this.element.querySelector('.e-gridpager').clientHeight)) {\n      height += this.element.querySelector('.e-gridpager').clientHeight;\n    }\n\n    if (this.showColumnChooser && !isNullOrUndefined(this.element.querySelector('.e-columnheader').clientHeight)) {\n      height += this.element.querySelector('.e-columnheader').clientHeight;\n    }\n\n    if (this.allowGrouping && this.groupSettings.showDropArea && !isNullOrUndefined(this.element.querySelector('.e-groupdroparea').clientHeight)) {\n      height += this.element.querySelector('.e-groupdroparea').clientHeight;\n    }\n\n    if (this.aggregates.length > 0 && !isNullOrUndefined(this.element.querySelector('.e-summaryrow').clientHeight)) {\n      for (var i = 0; i < this.element.getElementsByClassName('e-summaryrow').length; i++) {\n        height += this.element.getElementsByClassName('e-summaryrow')[i].clientHeight;\n      }\n    }\n\n    return height;\n  };\n  /**\n   *To perform aggregate operation on a column.\n   *\n   * @param  {AggregateColumnModel} summaryCol - Pass Aggregate Column details.\n   * @param  {Object} summaryData - Pass JSON Array for which its field values to be calculated.\n   * @returns {number} returns the summary values\n   */\n\n\n  Grid.prototype.getSummaryValues = function (summaryCol, summaryData) {\n    return DataUtil.aggregates[summaryCol.type.toLowerCase()](summaryData, summaryCol.field);\n  };\n  /**\n   * Sends a Post request to export Grid to Excel file in server side.\n   *\n   * @param  {string} url - Pass Url for server side excel export action.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.serverExcelExport = function (url) {\n    this.isExcel = true;\n    this.exportGrid(url);\n  };\n  /**\n   * Sends a Post request to export Grid to Pdf file in server side.\n   *\n   * @param  {string} url - Pass Url for server side pdf export action.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.serverPdfExport = function (url) {\n    this.isExcel = false;\n    this.exportGrid(url);\n  };\n  /**\n   * Sends a Post request to export Grid to CSV file in server side.\n   *\n   * @param  {string} url - Pass Url for server side pdf export action.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.serverCsvExport = function (url) {\n    this.isExcel = true;\n    this.exportGrid(url);\n  };\n  /**\n   * @param {string} url - Defines exporting url\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.exportGrid = function (url) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    var grid = this;\n    var query = grid.getDataModule().generateQuery(true);\n    var state = new UrlAdaptor().processQuery(new DataManager({\n      url: ''\n    }), query);\n    var queries = JSON.parse(state.data); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var gridModel = JSON.parse(this.addOnPersist(['allowGrouping', 'allowPaging', 'pageSettings', 'sortSettings', 'allowPdfExport', 'allowExcelExport', 'aggregates', 'filterSettings', 'groupSettings', 'columns', 'locale', 'searchSettings']));\n    var include = ['field', 'headerText', 'type', 'format', 'visible', 'foreignKeyValue', 'foreignKeyField', 'template', 'index', 'width', 'textAlign', 'headerTextAlign', 'columns'];\n    gridModel.filterSettings.columns = queries.where;\n    gridModel.searchSettings.fields = queries.search && queries.search[0]['fields'] || [];\n    gridModel.sortSettings.columns = queries.sorted;\n    gridModel.columns = this.setHeaderText(gridModel.columns, include);\n    var form = this.createElement('form', {\n      id: 'ExportForm',\n      styles: 'display:none;'\n    });\n    var gridInput = this.createElement('input', {\n      id: 'gridInput',\n      attrs: {\n        name: 'gridModel'\n      }\n    });\n    gridInput.value = JSON.stringify(gridModel);\n    form.method = 'POST';\n    form.action = url;\n    form.appendChild(gridInput);\n    document.body.appendChild(form);\n    form.submit();\n    form.remove();\n  };\n  /**\n   * @param {Column[]} columns - Defines array of columns\n   * @param {string[]} include - Defines array of sting\n   * @returns {Column[]} returns array of columns\n   * @hidden\n   */\n\n\n  Grid.prototype.setHeaderText = function (columns, include) {\n    for (var i = 0; i < columns.length; i++) {\n      var column = this.getColumnByUid(columns[i].uid);\n      columns[i].headerText = column.headerText;\n\n      if (!isNullOrUndefined(column.template)) {\n        columns[i].template = 'true';\n      }\n\n      if (columns[i].format) {\n        columns[i].format = getNumberFormat(this.getFormat(columns[i].format), columns[i].type, this.isExcel);\n      }\n\n      if (columns[i].columns) {\n        this.setHeaderText(columns[i].columns, include);\n      }\n\n      var keys = Object.keys(columns[i]);\n\n      for (var j = 0; j < keys.length; j++) {\n        if (include.indexOf(keys[j]) < 0) {\n          delete columns[i][keys[j]];\n        }\n      }\n    }\n\n    return columns;\n  };\n\n  Grid.prototype.getFormat = function (format) {\n    return typeof format === 'object' ? !isNullOrUndefined(format.format) ? format.format : format.skeleton : format;\n  };\n  /**\n   * @hidden\n   * @returns {boolean} returns the isCollapseStateEnabled\n   */\n\n\n  Grid.prototype.isCollapseStateEnabled = function () {\n    var isExpanded = 'isExpanded';\n    return this[isExpanded] === false;\n  };\n  /**\n   * @param {number} key - Defines the primary key value.\n   * @param {Object} rowData - Defines the rowData\n   * @returns {void}\n   */\n\n\n  Grid.prototype.updateRowValue = function (key, rowData) {\n    var args = {\n      requestType: 'save',\n      data: rowData\n    };\n    this.showSpinner();\n    this.notify(updateData, args);\n    this.refresh();\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.setForeignKeyData = function () {\n    this.dataBind();\n    var colpending = this.getDataModule().getForeignKeyDataState();\n\n    if (colpending.isPending) {\n      this.getDataModule().setForeignKeyDataState({});\n      colpending.resolver();\n    } else {\n      this.getDataModule().setForeignKeyDataState({\n        isDataChanged: false\n      });\n\n      if (this.contentModule || this.headerModule) {\n        this.renderModule.render();\n      }\n    }\n  };\n  /**\n   * @param {string} field - specifies the field\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.resetFilterDlgPosition = function (field) {\n    var header = this.getColumnHeaderByField(field);\n\n    if (header) {\n      var target = header.querySelector('.e-filtermenudiv');\n      var filterDlg = this.element.querySelector('.e-filter-popup');\n\n      if (target && filterDlg) {\n        var gClient = this.element.getBoundingClientRect();\n        var fClient = target.getBoundingClientRect();\n\n        if (filterDlg) {\n          if (filterDlg.offsetWidth + fClient.right > gClient.right) {\n            filterDlg.style.left = (fClient.right - filterDlg.offsetWidth - gClient.left).toString() + 'px';\n          } else {\n            filterDlg.style.left = (fClient.right - gClient.left).toString() + 'px';\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.renderTemplates = function () {\n    var isReactChild = this.parentDetails && this.parentDetails.parentInstObj && this.parentDetails.parentInstObj.isReact;\n\n    if (isReactChild) {\n      this.parentDetails.parentInstObj['portals'] = this.parentDetails.parentInstObj['portals'].concat(this['portals']);\n      this.parentDetails.parentInstObj.renderTemplates();\n      this['portals'] = undefined;\n    } else {\n      var portals = 'portals';\n      this.notify('reactTemplateRender', this[portals]);\n      this.renderReactTemplates();\n    }\n  };\n  /**\n   * Apply the changes to the Grid without refreshing the rows.\n   *\n   * @param  {BatchChanges} changes - Defines changes to be updated.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.batchUpdate = function (changes) {\n    this.processRowChanges(changes);\n  };\n  /**\n   * Apply the changes to the Grid in one batch after 50ms without refreshing the rows.\n   *\n   * @param  {BatchChanges} changes - Defines changes to be updated.\n   * @returns {void}\n   */\n\n\n  Grid.prototype.batchAsyncUpdate = function (changes) {\n    this.processBulkRowChanges(changes);\n  };\n\n  Grid.prototype.processBulkRowChanges = function (changes) {\n    var _this = this;\n\n    if (!this.dataToBeUpdated) {\n      this.dataToBeUpdated = Object.assign({\n        addedRecords: [],\n        changedRecords: [],\n        deletedRecords: []\n      }, changes);\n      setTimeout(function () {\n        _this.processRowChanges(_this.dataToBeUpdated);\n\n        _this.dataToBeUpdated = null;\n      }, this.asyncTimeOut);\n    } else {\n      var loopstring = [addedRecords, changedRecords, deletedRecords];\n      var keyField = this.getPrimaryKeyFieldNames()[0];\n\n      for (var i = 0; i < loopstring.length; i++) {\n        if (changes[loopstring[i]]) {\n          compareChanges(this, changes, loopstring[i], keyField);\n        }\n      }\n    }\n  };\n\n  Grid.prototype.processRowChanges = function (changes) {\n    var _this = this;\n\n    var keyField = this.getPrimaryKeyFieldNames()[0];\n    changes = Object.assign({\n      addedRecords: [],\n      changedRecords: [],\n      deletedRecords: []\n    }, changes);\n    var promise = this.getDataModule().saveChanges(changes, keyField, {}, this.getDataModule().generateQuery().requiresCount());\n\n    if (this.getDataModule().isRemote()) {\n      promise.then(function () {\n        _this.setNewData();\n      });\n    } else {\n      this.setNewData();\n    }\n  };\n\n  Grid.prototype.setNewData = function () {\n    var _this = this;\n\n    var oldValues = JSON.parse(JSON.stringify(this.getCurrentViewRecords()));\n    var getData = this.getDataModule().getData({}, this.getDataModule().generateQuery().requiresCount());\n    getData.then(function (e) {\n      _this.bulkRefresh(e.result, oldValues, e.count);\n    });\n  };\n\n  Grid.prototype.deleteRowElement = function (row$$1) {\n    var tr = this.getRowElementByUID(row$$1.uid);\n    var index = parseInt(tr.getAttribute(dataRowIndex), 10);\n    remove(tr);\n\n    if (this.getFrozenColumns()) {\n      var mtr = this.getMovableRows()[index];\n      remove(mtr);\n    }\n  };\n\n  Grid.prototype.bulkRefresh = function (result, oldValues, count) {\n    var _this = this;\n\n    var rowObj = this.getRowsObject();\n    var keyField = this.getPrimaryKeyFieldNames()[0];\n\n    var _loop_3 = function (i) {\n      if (!result.filter(function (e) {\n        return e[keyField] === rowObj[i].data[keyField];\n      }).length) {\n        this_3.deleteRowElement(rowObj[i]);\n        rowObj.splice(i, 1);\n        i--;\n      }\n\n      out_i_1 = i;\n    };\n\n    var this_3 = this,\n        out_i_1;\n\n    for (var i = 0; i < rowObj.length; i++) {\n      _loop_3(i);\n\n      i = out_i_1;\n    }\n\n    var _loop_4 = function (i) {\n      var isRowExist;\n      oldValues.filter(function (e) {\n        if (e[keyField] === result[i][keyField]) {\n          if (e !== result[i]) {\n            _this.setRowData(result[i][keyField], result[i]);\n          }\n\n          isRowExist = true;\n        }\n      });\n\n      if (!isRowExist) {\n        this_4.renderRowElement(result[i], i);\n      }\n    };\n\n    var this_4 = this;\n\n    for (var i = 0; i < result.length; i++) {\n      _loop_4(i);\n    }\n\n    this.currentViewData = result;\n    var rows = [].slice.call(this.getContentTable().getElementsByClassName(row));\n    resetRowIndex(this, this.getRowsObject(), rows);\n    setRowElements(this);\n\n    if (this.allowPaging) {\n      this.notify(inBoundModelChanged, {\n        module: 'pager',\n        properties: {\n          totalRecordsCount: count\n        }\n      });\n    }\n  };\n\n  Grid.prototype.renderRowElement = function (data, index) {\n    var row$$1 = new RowRenderer(this.serviceLocator, null, this);\n    var model = new RowModelGenerator(this);\n    var modelData = model.generateRows([data]);\n    var tr = row$$1.render(modelData[0], this.getColumns());\n    var mTr;\n    var mTbody;\n    this.addRowObject(modelData[0], index);\n    var tbody$$1 = this.getContentTable().querySelector(tbody);\n\n    if (tbody$$1.querySelector('.e-emptyrow')) {\n      var emptyRow = tbody$$1.querySelector('.e-emptyrow');\n      emptyRow.parentNode.removeChild(emptyRow);\n\n      if (this.getFrozenColumns()) {\n        var moveTbody = this.getContent().querySelector('.' + movableContent).querySelector(tbody);\n        moveTbody.firstElementChild.parentNode.removeChild(moveTbody.firstElementChild);\n      }\n    }\n\n    if (this.getFrozenColumns()) {\n      mTr = renderMovable(tr, this.getFrozenColumns(), this);\n\n      if (this.frozenRows && index < this.frozenRows) {\n        mTbody = this.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody);\n      } else {\n        mTbody = this.getContent().querySelector('.' + movableContent).querySelector(tbody);\n      }\n\n      mTbody.appendChild(mTr);\n\n      if (this.height === 'auto') {\n        this.notify(frozenHeight, {});\n      }\n    }\n\n    if (this.frozenRows && index < this.frozenRows) {\n      tbody$$1 = this.getHeaderContent().querySelector(tbody);\n    } else {\n      tbody$$1 = this.getContent().querySelector(tbody);\n    }\n\n    tbody$$1 = this.getContent().querySelector(tbody);\n    tbody$$1.appendChild(tr);\n  };\n\n  Grid.prototype.addRowObject = function (row$$1, index) {\n    var frzCols = this.getFrozenColumns();\n\n    if (frzCols) {\n      var mRows = this.getMovableRowsObject();\n      var mRow = row$$1.clone();\n      mRow.cells = mRow.cells.slice(frzCols);\n      row$$1.cells = row$$1.cells.slice(0, frzCols);\n      mRows.splice(index, 1, mRow);\n    }\n\n    this.getRowsObject().splice(index, 1, row$$1);\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  Grid.prototype.updateVisibleExpandCollapseRows = function () {\n    var rows = this.getRowsObject();\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      if ((rows[i].isDataRow || rows[i].isAggregateRow) && this.getRowElementByUID(rows[i].uid).style.display === 'none') {\n        rows[i].visible = false;\n      } else {\n        rows[i].visible = true;\n      }\n    }\n  };\n  /**\n   * @param {string | number} height - specifies the height\n   * @returns {number | string} - specifies the height number\n   * @hidden\n   */\n\n\n  Grid.prototype.getHeight = function (height) {\n    if (!Number.isInteger(height) && height.indexOf('%') !== -1) {\n      height = parseInt(height, 10) / 100 * this.element.clientHeight;\n    } else if (!Number.isInteger(height) && this.height !== 'auto') {\n      height = parseInt(height, 10);\n    } else {\n      height = this.height;\n    }\n\n    return height;\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen right content\n   */\n\n\n  Grid.prototype.getFrozenRightContent = function () {\n    return this.getContent().querySelector('.e-frozen-right-content');\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen right header\n   */\n\n\n  Grid.prototype.getFrozenRightHeader = function () {\n    return this.getHeaderContent().querySelector('.e-frozen-right-header');\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns movable header tbody\n   */\n\n\n  Grid.prototype.getMovableHeaderTbody = function () {\n    return this.getMovableVirtualHeader().querySelector(tbody);\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns movable content tbody\n   */\n\n\n  Grid.prototype.getMovableContentTbody = function () {\n    return this.getMovableVirtualContent().querySelector(tbody);\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen header tbody\n   */\n\n\n  Grid.prototype.getFrozenHeaderTbody = function () {\n    return this.getFrozenVirtualHeader().querySelector(tbody);\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen left content tbody\n   */\n\n\n  Grid.prototype.getFrozenLeftContentTbody = function () {\n    return this.getFrozenVirtualContent().querySelector(tbody);\n  };\n  /**\n   * @hidden\n   * @returns {Element} - returns frozen right header tbody\n   */\n\n\n  Grid.prototype.getFrozenRightHeaderTbody = function () {\n    return this.getFrozenRightHeader().querySelector(tbody);\n  };\n  /**\n   * @returns {Element} returns frozen right content tbody\n   * @hidden\n   */\n\n\n  Grid.prototype.getFrozenRightContentTbody = function () {\n    var cnt = this.getFrozenRightContent();\n    var tbody$$1;\n\n    if (cnt) {\n      tbody$$1 = this.getFrozenRightContent().querySelector(tbody);\n    }\n\n    return tbody$$1;\n  };\n  /**\n   * @param {boolean} isCustom - Defines custom filter dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.showResponsiveCustomFilter = function (isCustom) {\n    if (this.filterModule) {\n      this.filterModule.showCustomFilter(isCustom || this.rowRenderingMode === 'Vertical');\n    }\n  };\n  /**\n   * @param {boolean} isCustom - Defines custom sort dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Grid.prototype.showResponsiveCustomSort = function (isCustom) {\n    if (this.sortModule) {\n      this.sortModule.showCustomSort(isCustom || this.rowRenderingMode === 'Vertical');\n    }\n  };\n  /**\n   * To manually show the vertical row mode filter dialog\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.showAdaptiveFilterDialog = function () {\n    if (this.enableAdaptiveUI) {\n      this.showResponsiveCustomFilter(true);\n    }\n  };\n  /**\n   * To manually show the vertical row sort filter dialog\n   *\n   * @returns {void}\n   */\n\n\n  Grid.prototype.showAdaptiveSortDialog = function () {\n    if (this.enableAdaptiveUI) {\n      this.showResponsiveCustomSort(true);\n    }\n  };\n  /**\n   * @param {boolean} isColVirtualization - Defines column virtualization\n   * @returns {Column[]} returns array of column models\n   * @hidden\n   */\n\n\n  Grid.prototype.getCurrentVisibleColumns = function (isColVirtualization) {\n    var cols = [];\n    var gridCols = isColVirtualization ? this.getColumns() : this.columnModel;\n\n    for (var _i = 0, gridCols_1 = gridCols; _i < gridCols_1.length; _i++) {\n      var col = gridCols_1[_i];\n\n      if (col.visible) {\n        cols.push(col);\n      }\n    }\n\n    return cols;\n  };\n\n  Grid.prototype.enableInfiniteAggrgate = function () {\n    if (this.enableInfiniteScrolling && this.groupSettings.columns.length && !this.groupSettings.disablePageWiseAggregates && !this.groupSettings.enableLazyLoading) {\n      this.setProperties({\n        groupSettings: {\n          disablePageWiseAggregates: true\n        }\n      }, true);\n    }\n  };\n\n  var Grid_1;\n\n  __decorate$1([Property()], Grid.prototype, \"parentDetails\", void 0);\n\n  __decorate$1([Property([])], Grid.prototype, \"columns\", void 0);\n\n  __decorate$1([Property(true)], Grid.prototype, \"enableAltRow\", void 0);\n\n  __decorate$1([Property(true)], Grid.prototype, \"enableHover\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableAutoFill\", void 0);\n\n  __decorate$1([Property(true)], Grid.prototype, \"allowKeyboard\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableStickyHeader\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowTextWrap\", void 0);\n\n  __decorate$1([Complex({}, TextWrapSettings)], Grid.prototype, \"textWrapSettings\", void 0);\n\n  __decorate$1([Complex({}, ResizeSettings)], Grid.prototype, \"resizeSettings\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowPaging\", void 0);\n\n  __decorate$1([Complex({}, PageSettings)], Grid.prototype, \"pageSettings\", void 0);\n\n  __decorate$1([Complex({}, LoadingIndicator)], Grid.prototype, \"loadingIndicator\", void 0);\n\n  __decorate$1([Property(true)], Grid.prototype, \"enableVirtualMaskRow\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableVirtualization\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableColumnVirtualization\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableInfiniteScrolling\", void 0);\n\n  __decorate$1([Complex({}, SearchSettings)], Grid.prototype, \"searchSettings\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowSorting\", void 0);\n\n  __decorate$1([Property('Ellipsis')], Grid.prototype, \"clipMode\", void 0);\n\n  __decorate$1([Property(true)], Grid.prototype, \"allowMultiSorting\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowExcelExport\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowPdfExport\", void 0);\n\n  __decorate$1([Complex({}, SortSettings)], Grid.prototype, \"sortSettings\", void 0);\n\n  __decorate$1([Complex({}, InfiniteScrollSettings)], Grid.prototype, \"infiniteScrollSettings\", void 0);\n\n  __decorate$1([Property(true)], Grid.prototype, \"allowSelection\", void 0);\n\n  __decorate$1([Property(-1)], Grid.prototype, \"selectedRowIndex\", void 0);\n\n  __decorate$1([Complex({}, SelectionSettings)], Grid.prototype, \"selectionSettings\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowFiltering\", void 0);\n\n  __decorate$1([Property('Horizontal')], Grid.prototype, \"rowRenderingMode\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableAdaptiveUI\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowReordering\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowResizing\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowRowDragAndDrop\", void 0);\n\n  __decorate$1([Complex({}, RowDropSettings)], Grid.prototype, \"rowDropSettings\", void 0);\n\n  __decorate$1([Complex({}, FilterSettings)], Grid.prototype, \"filterSettings\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"allowGrouping\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableImmutableMode\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"showColumnMenu\", void 0);\n\n  __decorate$1([Complex({}, GroupSettings)], Grid.prototype, \"groupSettings\", void 0);\n\n  __decorate$1([Complex({}, EditSettings)], Grid.prototype, \"editSettings\", void 0);\n\n  __decorate$1([Collection([], AggregateRow)], Grid.prototype, \"aggregates\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"showColumnChooser\", void 0);\n\n  __decorate$1([Complex({}, ColumnChooserSettings)], Grid.prototype, \"columnChooserSettings\", void 0);\n\n  __decorate$1([Property(false)], Grid.prototype, \"enableHeaderFocus\", void 0);\n\n  __decorate$1([Property('auto')], Grid.prototype, \"height\", void 0);\n\n  __decorate$1([Property('auto')], Grid.prototype, \"width\", void 0);\n\n  __decorate$1([Property('Default')], Grid.prototype, \"gridLines\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"rowTemplate\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"detailTemplate\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"childGrid\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"queryString\", void 0);\n\n  __decorate$1([Property('AllPages')], Grid.prototype, \"printMode\", void 0);\n\n  __decorate$1([Property('Expanded')], Grid.prototype, \"hierarchyPrintMode\", void 0);\n\n  __decorate$1([Property([])], Grid.prototype, \"dataSource\", void 0);\n\n  __decorate$1([Property(null)], Grid.prototype, \"rowHeight\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"query\", void 0);\n\n  __decorate$1([Property('USD')], Grid.prototype, \"currencyCode\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"toolbar\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"contextMenuItems\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"columnMenuItems\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"toolbarTemplate\", void 0);\n\n  __decorate$1([Property()], Grid.prototype, \"pagerTemplate\", void 0);\n\n  __decorate$1([Property(0)], Grid.prototype, \"frozenRows\", void 0);\n\n  __decorate$1([Property(0)], Grid.prototype, \"frozenColumns\", void 0);\n\n  __decorate$1([Property('')], Grid.prototype, \"cssClass\", void 0);\n\n  __decorate$1([Property('All')], Grid.prototype, \"columnQueryMode\", void 0);\n\n  __decorate$1([Property({})], Grid.prototype, \"currentAction\", void 0);\n\n  __decorate$1([Property('20.3.47')], Grid.prototype, \"ej2StatePersistenceVersion\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"created\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"destroyed\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"load\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDataBound\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"queryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"headerCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"actionBegin\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"actionComplete\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"actionFailure\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"dataBound\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"recordDoubleClick\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"recordClick\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowSelecting\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowSelected\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDeselecting\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDeselected\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellSelecting\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellSelected\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellDeselecting\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellDeselected\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnSelecting\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnSelected\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnDeselecting\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnDeselected\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnDragStart\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnDrag\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnDrop\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"printComplete\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforePrint\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"pdfQueryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"pdfHeaderQueryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"pdfAggregateQueryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"excelAggregateQueryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"exportDetailDataBound\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"excelQueryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"excelHeaderQueryCellInfo\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeExcelExport\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"excelExportComplete\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforePdfExport\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"pdfExportComplete\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDragStartHelper\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"detailDataBound\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDragStart\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDrag\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"rowDrop\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"toolbarClick\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeOpenColumnChooser\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeOpenAdaptiveDialog\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"batchAdd\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"batchDelete\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"batchCancel\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeBatchAdd\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeBatchDelete\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeBatchSave\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beginEdit\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"commandClick\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellEdit\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellSave\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"cellSaved\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"resizeStart\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"resizing\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"resizeStop\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"keyPressed\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeDataBound\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"contextMenuOpen\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"contextMenuClick\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnMenuOpen\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnMenuClick\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"checkBoxChange\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeCopy\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforePaste\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"beforeAutoFill\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"columnDataStateChange\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"dataStateChange\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"dataSourceChanged\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"exportGroupCaption\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"lazyLoadGroupExpand\", void 0);\n\n  __decorate$1([Event()], Grid.prototype, \"lazyLoadGroupCollapse\", void 0);\n\n  Grid = Grid_1 = __decorate$1([NotifyPropertyChanges], Grid);\n  return Grid;\n}(Component);\n/**\n * @returns {string[]} returns the cloned property\n * @hidden\n */\n\n\nfunction getCloneProperties() {\n  return ['aggregates', 'allowGrouping', 'allowFiltering', 'allowMultiSorting', 'allowReordering', 'allowSorting', 'allowTextWrap', 'childGrid', 'columns', 'currentViewData', 'dataSource', 'detailTemplate', 'enableAltRow', 'enableColumnVirtualization', 'filterSettings', 'gridLines', 'groupSettings', 'height', 'locale', 'pageSettings', 'printMode', 'query', 'queryString', 'enableRtl', 'rowHeight', 'rowTemplate', 'sortSettings', 'textWrapSettings', 'allowPaging', 'hierarchyPrintMode', 'searchSettings', 'queryCellInfo', 'beforeDataBound'];\n}\n/**\n *\n * The `Print` module is used to handle print action.\n */\n\n\nvar Print =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid print module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {Scroll} scrollModule - specifies the scroll module\n   * @hidden\n   */\n  function Print(parent, scrollModule) {\n    this.isAsyncPrint = false;\n    this.defered = new Deferred();\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(contentReady, this.isContentReady(), this);\n    this.actionBeginFunction = this.actionBegin.bind(this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.on(onEmpty, this.onEmpty.bind(this));\n    this.parent.on(hierarchyPrint, this.hierarchyPrint, this);\n    this.scrollModule = scrollModule;\n  }\n\n  Print.prototype.isContentReady = function () {\n    var _this = this;\n\n    if (this.isPrintGrid() && (this.parent.hierarchyPrintMode === 'None' || !this.parent.childGrid)) {\n      return this.contentReady;\n    }\n\n    return function () {\n      _this.defered.promise.then(function () {\n        _this.contentReady();\n      });\n\n      if (_this.isPrintGrid()) {\n        _this.hierarchyPrint();\n      }\n    };\n  };\n\n  Print.prototype.hierarchyPrint = function () {\n    this.removeColGroup(this.parent);\n    var printGridObj = window.printGridObj;\n\n    if (printGridObj && !printGridObj.element.querySelector('[aria-busy=true')) {\n      printGridObj.printModule.defered.resolve();\n    }\n  };\n  /**\n   * By default, prints all the Grid pages and hides the pager.\n   * > You can customize print options using the\n   * [`printMode`](grid/#printmode-string/).\n   *\n   * @returns {void}\n   */\n\n\n  Print.prototype.print = function () {\n    this.renderPrintGrid();\n  };\n\n  Print.prototype.onEmpty = function () {\n    if (this.isPrintGrid()) {\n      this.contentReady();\n    }\n  };\n\n  Print.prototype.actionBegin = function () {\n    if (this.isPrintGrid()) {\n      this.isAsyncPrint = true;\n    }\n  };\n\n  Print.prototype.renderPrintGrid = function () {\n    var gObj = this.parent;\n    var element = createElement('div', {\n      id: this.parent.element.id + '_print',\n      className: gObj.element.className + ' e-print-grid'\n    });\n    element.classList.remove('e-gridhover');\n    document.body.appendChild(element);\n    var printGrid = new Grid(getPrintGridModel(gObj, gObj.hierarchyPrintMode));\n\n    for (var i = 0; i < printGrid.columns.length; i++) {\n      printGrid.columns[i] = extend({}, printGrid.columns[i]);\n\n      if (gObj.isFrozenGrid() && !gObj.getFrozenColumns()) {\n        printGrid.columns[i].freeze = undefined;\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if (this.parent.isAngular) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      printGrid.viewContainerRef = this.parent.viewContainerRef;\n    } // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    printGrid.load = function () {};\n\n    printGrid.query = gObj.getQuery().clone();\n    window.printGridObj = printGrid;\n    printGrid.isPrinting = true;\n    var modules = printGrid.getInjectedModules();\n    var injectedModues = gObj.getInjectedModules();\n\n    if (!modules || modules.length !== injectedModues.length) {\n      printGrid.setInjectedModules(injectedModues);\n    }\n\n    gObj.notify(printGridInit, {\n      element: element,\n      printgrid: printGrid\n    });\n    this.parent.log('exporting_begin', this.getModuleName());\n    printGrid.registeredTemplate = this.parent.registeredTemplate;\n    printGrid.isVue = this.parent.isVue;\n    printGrid.appendTo(element);\n    printGrid.trigger = gObj.trigger;\n  };\n\n  Print.prototype.contentReady = function () {\n    if (this.isPrintGrid()) {\n      var gObj = this.parent;\n\n      if (this.isAsyncPrint) {\n        this.printGrid();\n        return;\n      }\n\n      var args = {\n        requestType: 'print',\n        element: gObj.element,\n        selectedRows: gObj.getContentTable().querySelectorAll('tr[aria-selected=\"true\"]'),\n        cancel: false,\n        hierarchyPrintMode: gObj.hierarchyPrintMode\n      };\n\n      if (!this.isAsyncPrint) {\n        gObj.trigger(beforePrint, args);\n      }\n\n      if (args.cancel) {\n        detach(gObj.element);\n        return;\n      }\n\n      if (!this.isAsyncPrint) {\n        this.printGrid();\n      }\n    }\n  };\n\n  Print.prototype.printGrid = function () {\n    var gObj = this.parent; // Height adjustment on print grid\n\n    if (gObj.height !== 'auto') {\n      // if scroller enabled\n      var cssProps = this.scrollModule.getCssProperties();\n      var contentDiv = gObj.element.querySelector('.' + content);\n      var headerDiv = gObj.element.querySelector('.' + gridHeader);\n      contentDiv.style.height = 'auto';\n      contentDiv.style.overflowY = 'auto';\n      headerDiv.style[cssProps.padding] = '';\n      headerDiv.firstElementChild.style[cssProps.border] = '';\n    } // Grid alignment adjustment on grouping\n\n\n    if (gObj.allowGrouping) {\n      if (!gObj.groupSettings.columns.length) {\n        gObj.element.querySelector('.e-groupdroparea').style.display = 'none';\n      } else {\n        this.removeColGroup(gObj);\n      }\n    } // hide horizontal scroll\n\n\n    for (var _i = 0, _a = [].slice.call(gObj.element.getElementsByClassName(content)); _i < _a.length; _i++) {\n      var element = _a[_i];\n      element.style.overflowX = 'hidden';\n    } // Hide the waiting popup\n\n\n    var waitingPop = [].slice.call(gObj.element.getElementsByClassName('e-spin-show'));\n\n    for (var _b = 0, _c = [].slice.call(waitingPop); _b < _c.length; _b++) {\n      var element = _c[_b];\n      classList(element, ['e-spin-hide'], ['e-spin-show']);\n    }\n\n    this.printGridElement(gObj);\n    gObj.isPrinting = false;\n    delete window.printGridObj;\n    var args = {\n      element: gObj.element\n    };\n    gObj.trigger(printComplete, args);\n    gObj.destroy();\n    this.parent.log('exporting_complete', this.getModuleName());\n  };\n\n  Print.prototype.printGridElement = function (gObj) {\n    classList(gObj.element, ['e-print-grid-layout'], ['e-print-grid']);\n\n    if (gObj.isPrinting) {\n      detach(gObj.element);\n    }\n\n    this.printWind = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');\n    this.printWind.moveTo(0, 0);\n    this.printWind.resizeTo(screen.availWidth, screen.availHeight);\n    this.printWind = print(gObj.element, this.printWind);\n  };\n\n  Print.prototype.removeColGroup = function (gObj) {\n    var depth = gObj.groupSettings.columns.length;\n    var element = gObj.element;\n    var id = '#' + gObj.element.id;\n\n    if (!depth) {\n      return;\n    }\n\n    var groupCaption = selectAll('.e-groupcaption', element);\n    var colSpan = groupCaption[depth - 1].getAttribute('colspan');\n\n    for (var i = 0; i < groupCaption.length; i++) {\n      groupCaption[i].setAttribute('colspan', colSpan);\n    }\n\n    var colGroups = selectAll(\"colgroup\" + id + \"colgroup\", element);\n    var contentColGroups = selectAll('.e-content colgroup', element);\n    this.hideColGroup(colGroups, depth);\n    this.hideColGroup(contentColGroups, depth);\n  };\n\n  Print.prototype.hideColGroup = function (colGroups, depth) {\n    for (var i = 0; i < colGroups.length; i++) {\n      for (var j = 0; j < depth; j++) {\n        colGroups[i].children[j].style.display = 'none';\n      }\n    }\n  };\n  /**\n   * To destroy the print\n   *\n   * @returns {boolean} returns the isPrintGrid or not\n   * @hidden\n   */\n\n\n  Print.prototype.isPrintGrid = function () {\n    return this.parent.element.id.indexOf('_print') > 0 && this.parent.isPrinting;\n  };\n  /**\n   * To destroy the print\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Print.prototype.destroy = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(contentReady, this.contentReady.bind(this));\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.off(onEmpty, this.onEmpty.bind(this));\n    this.parent.off(hierarchyPrint, this.hierarchyPrint);\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Print.prototype.getModuleName = function () {\n    return 'print';\n  };\n\n  Print.printGridProp = getCloneProperties().concat([beforePrint, printComplete, load]);\n  return Print;\n}(); //https://typescript.codeplex.com/discussions/401501\n\n/**\n * Function to check whether target object implement specific interface\n *\n * @param  {Object} target - specifies the target\n * @param  {string} checkFor - specifies the checkfors\n * @returns {boolean} returns the boolean\n * @hidden\n */\n\n\nfunction doesImplementInterface(target, checkFor) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return target.prototype && checkFor in target.prototype;\n}\n/**\n * Function to get value from provided data\n *\n * @param  {string} field - specifies the field\n * @param  {Object} data - specifies the data\n * @param  {ColumnModel} column - specifies the column\n * @returns {Object} returns the object\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction valueAccessor(field, data, column) {\n  return isNullOrUndefined(field) || field === '' ? '' : DataUtil.getObject(field, data);\n}\n/**\n * Defines the method used to apply custom header cell values from external function and display this on each header cell rendered.\n *\n * @param  {string} field - specifies the field\n * @param  {ColumnModel} column - specifies the column\n * @returns {object} headerValueAccessor\n * @hidden\n */\n\n\nfunction headerValueAccessor(field, column) {\n  return isNullOrUndefined(field) || field === '' ? '' : DataUtil.getObject(field, column);\n}\n/**\n * The function used to update Dom using requestAnimationFrame.\n *\n * @param {Function} updateFunction - Function that contains the actual action\n * @param {object} callBack - defines the callback\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction getUpdateUsingRaf(updateFunction, callBack) {\n  requestAnimationFrame(function () {\n    try {\n      callBack(null, updateFunction());\n    } catch (e) {\n      callBack(e);\n    }\n  });\n}\n/**\n * @hidden\n * @param {PdfExportProperties | ExcelExportProperties} exportProperties - Defines the export properties\n * @returns {boolean} Returns isExportColumns\n */\n\n\nfunction isExportColumns(exportProperties) {\n  return !isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.columns) && exportProperties.columns.length > 0;\n}\n/**\n * @param {PdfExportProperties | ExcelExportProperties} exportProperties - Defines the export properties\n * @param {IGrid} gObj - Defines the grid object\n * @returns {void}\n * @hidden\n */\n\n\nfunction updateColumnTypeForExportColumns(exportProperties, gObj) {\n  var exportColumns = exportProperties.columns;\n  var gridColumns = gObj.columns;\n\n  for (var i = 0; i < exportColumns.length; i++) {\n    if (gridColumns.length - 1 >= i) {\n      if (gridColumns[i].columns) {\n        for (var j = 0; j < gridColumns[i].columns.length; j++) {\n          exportColumns[i].columns[j].type = gridColumns[i].columns[j].type;\n        }\n      } else {\n        exportColumns[i].type = gridColumns[i].type;\n      }\n    }\n  }\n}\n/**\n * @hidden\n * @param {IGrid} grid - Defines the grid\n * @returns {void}\n */\n\n\nfunction updatecloneRow(grid) {\n  var nRows = [];\n  var actualRows = grid.vRows;\n\n  for (var i = 0; i < actualRows.length; i++) {\n    if (actualRows[i].isDataRow) {\n      nRows.push(actualRows[i]);\n    } else if (!actualRows[i].isDataRow) {\n      nRows.push(actualRows[i]);\n\n      if (!actualRows[i].isExpand && actualRows[i].isCaptionRow) {\n        i += getCollapsedRowsCount(actualRows[i], grid);\n      }\n    }\n  }\n\n  grid.vcRows = nRows;\n}\n\nvar count = 0;\n/**\n * @hidden\n * @param {Row<Column>} val - Defines the value\n * @param {IGrid} grid - Defines the grid\n * @returns {number} Returns the collapsed row count\n */\n\nfunction getCollapsedRowsCount(val, grid) {\n  count = 0;\n  var gSummary = 'gSummary';\n  var total = 'count';\n  var gLen = grid.groupSettings.columns.length;\n  var records = 'records';\n  var items = 'items';\n  var value = val[gSummary];\n  var dataRowCnt = 0;\n  var agrCnt = 'aggregatesCount';\n\n  if (value === val.data[total]) {\n    if (grid.groupSettings.columns.length && !isNullOrUndefined(val[agrCnt]) && val[agrCnt]) {\n      if (grid.groupSettings.columns.length !== 1) {\n        count += val.indent !== 0 && value < 2 ? val[gSummary] * (gLen - val.indent + (gLen - val.indent) * val[agrCnt]) : val[gSummary] * (gLen - val.indent + (gLen - val.indent - 1) * val[agrCnt]) + val[agrCnt];\n      } else if (grid.groupSettings.columns.length === 1) {\n        count += val[gSummary] * (gLen - val.indent) + val[agrCnt];\n      }\n    } else if (grid.groupSettings.columns.length) {\n      if (grid.groupSettings.columns.length !== 1) {\n        count += val[gSummary] * (grid.groupSettings.columns.length - val.indent);\n      } else {\n        count += val[gSummary];\n      }\n    }\n\n    return count;\n  } else {\n    for (var i = 0, len = val.data[items].length; i < len; i++) {\n      var gLevel = val.data[items][i];\n      count += gLevel[items].length + (gLen !== grid.columns.length && !isNullOrUndefined(gLevel[items][records]) ? gLevel[items][records].length : 0);\n      dataRowCnt += !isNullOrUndefined(gLevel[items][records]) && !isNullOrUndefined(val[agrCnt]) ? gLevel[items][records].length : gLevel[items].length;\n\n      if (gLevel[items].GroupGuid && gLevel[items].childLevels !== 0) {\n        recursive(gLevel);\n      }\n    }\n\n    count += val.data[items].length;\n\n    if (!isNullOrUndefined(val[agrCnt])) {\n      if (val[agrCnt] && count && dataRowCnt !== 0) {\n        count += (count - dataRowCnt) * val[agrCnt] + val[agrCnt];\n      }\n    }\n  }\n\n  return count;\n}\n/**\n * @param {Object[]} row - Defines the row\n * @returns {void}\n * @hidden\n */\n\n\nfunction recursive(row$$1) {\n  var items = 'items';\n  var rCount = 'count';\n\n  for (var j = 0, length_1 = row$$1[items].length; j < length_1; j++) {\n    var nLevel = row$$1[items][j];\n    count += nLevel[rCount];\n\n    if (nLevel[items].childLevels !== 0) {\n      recursive(nLevel);\n    }\n  }\n}\n/**\n * @param {Object[]} collection - Defines the array\n * @param {Object} predicate - Defines the predicate\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction iterateArrayOrObject(collection, predicate) {\n  var result = [];\n\n  for (var i = 0, len = collection.length; i < len; i++) {\n    var pred = predicate(collection[i], i);\n\n    if (!isNullOrUndefined(pred)) {\n      result.push(pred);\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Object[]} array - Defines the array\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction iterateExtend(array) {\n  var obj = [];\n\n  for (var i = 0; i < array.length; i++) {\n    obj.push(extend({}, getActualProperties(array[i]), {}, true));\n  }\n\n  return obj;\n}\n/**\n * @param {string} template - Defines the template\n * @returns {Function} Returns the function\n * @hidden\n */\n\n\nfunction templateCompiler(template) {\n  if (template) {\n    try {\n      if (document.querySelectorAll(template).length) {\n        return compile(document.querySelector(template).innerHTML.trim());\n      } else {\n        return compile(template);\n      }\n    } catch (e) {\n      return compile(template);\n    }\n  }\n\n  return undefined;\n}\n/**\n * @param {Element} node - Defines the column\n * @param {Object} customAttributes - Defines the index\n * @returns {void}\n * @hidden\n */\n\n\nfunction setStyleAndAttributes(node, customAttributes) {\n  var copyAttr = {};\n  var literals = ['style', 'class']; //Dont touch the original object - make a copy\n\n  extend(copyAttr, customAttributes, {});\n\n  if ('style' in copyAttr) {\n    setStyleAttribute(node, copyAttr[literals[0]]);\n    delete copyAttr[literals[0]];\n  }\n\n  if ('class' in copyAttr) {\n    addClass([node], copyAttr[literals[1]]);\n    delete copyAttr[literals[1]];\n  }\n\n  attributes(node, copyAttr);\n}\n/**\n * @param {Object} copied - Defines the column\n * @param {Object} first - Defines the inndex\n * @param {Object} second - Defines the second object\n * @param {string[]} exclude - Defines the exclude\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction extend$1(copied, first, second, exclude) {\n  var moved = extend(copied, first, second);\n  var values = Object.keys(moved);\n\n  for (var i = 0; i < values.length; i++) {\n    if (exclude && exclude.indexOf(values[i]) !== -1) {\n      delete moved[values[i]];\n    }\n  }\n\n  return moved;\n}\n/**\n * @param {Column[]} columnModel - Defines the column\n * @param {number} ind - Defines the inndex\n * @returns {number} - Returns the columnindex\n * @hidden\n */\n\n\nfunction setColumnIndex(columnModel, ind) {\n  if (ind === void 0) {\n    ind = 0;\n  }\n\n  for (var i = 0, len = columnModel.length; i < len; i++) {\n    if (columnModel[i].columns) {\n      columnModel[i].index = isNullOrUndefined(columnModel[i].index) ? ind : columnModel[i].index;\n      ind++;\n      ind = setColumnIndex(columnModel[i].columns, ind);\n    } else {\n      columnModel[i].index = isNullOrUndefined(columnModel[i].index) ? ind : columnModel[i].index;\n      ind++;\n    }\n  }\n\n  return ind;\n}\n/**\n * @param {Column[] | string[] | ColumnModel[]} columns - Defines the column\n * @param {boolean} autoWidth - Defines the autowidth\n * @param {IGrid} gObj - Defines the class name\n * @returns {Column} - Returns the columns\n * @hidden\n */\n\n\nfunction prepareColumns(columns, autoWidth, gObj) {\n  for (var c = 0, len = columns.length; c < len; c++) {\n    var column = void 0;\n\n    if (typeof columns[c] === 'string') {\n      column = new Column({\n        field: columns[c]\n      }, gObj);\n    } else if (!(columns[c] instanceof Column) || columns[c].columns) {\n      if (!columns[c].columns) {\n        column = new Column(columns[c], gObj);\n      } else {\n        columns[c].columns = prepareColumns(columns[c].columns, null, gObj);\n        column = new Column(columns[c], gObj);\n      }\n    } else {\n      column = columns[c];\n    }\n\n    if (column.type && column.type.toLowerCase() === 'checkbox') {\n      column.allowReordering = false;\n    }\n\n    column.headerText = isNullOrUndefined(column.headerText) ? column.foreignKeyValue || column.field || '' : column.headerText;\n    column.foreignKeyField = column.foreignKeyField || column.field;\n    column.valueAccessor = (typeof column.valueAccessor === 'string' ? getValue(column.valueAccessor, window) : column.valueAccessor) || valueAccessor;\n    column.width = autoWidth && isNullOrUndefined(column.width) ? 200 : column.width;\n\n    if (isNullOrUndefined(column.visible)) {\n      column.visible = true;\n    }\n\n    columns[c] = column;\n  }\n\n  return columns;\n}\n/**\n * @param {HTMLElement} popUp - Defines the popup element\n * @param {MouseEvent | TouchEvent} e - Defines the moouse event\n * @param {string} className - Defines the class name\n * @returns {void}\n * @hidden\n */\n\n\nfunction setCssInGridPopUp(popUp, e, className) {\n  var popUpSpan = popUp.querySelector('span');\n  var position = popUp.parentElement.getBoundingClientRect();\n  var targetPosition = e.target.getBoundingClientRect();\n  popUpSpan.className = className;\n  popUp.style.display = '';\n  var isBottomTail = (isNullOrUndefined(e.clientY) ? e.changedTouches[0].clientY : e.clientY) > popUp.offsetHeight + 10;\n  popUp.style.top = targetPosition.top - position.top + (isBottomTail ? -(popUp.offsetHeight + 10) : popUp.offsetHeight + 10) + 'px'; //10px for tail element\n\n  popUp.style.left = getPopupLeftPosition(popUp, e, targetPosition, position.left) + 'px';\n\n  if (isBottomTail) {\n    popUp.querySelector('.e-downtail').style.display = '';\n    popUp.querySelector('.e-uptail').style.display = 'none';\n  } else {\n    popUp.querySelector('.e-downtail').style.display = 'none';\n    popUp.querySelector('.e-uptail').style.display = '';\n  }\n}\n/**\n * @param {HTMLElement} popup - Defines the popup element\n * @param {MouseEvent | TouchEvent} e  - Defines the mouse event\n * @param {Object} targetPosition - Defines the target position\n * @param {number} targetPosition.top - Defines the top position\n * @param {number} targetPosition.left  - Defines the left position\n * @param {number} targetPosition.right  - Defines the right position\n * @param {number} left - Defines the left position\n * @returns {number} Returns the popup left position\n * @hidden\n */\n\n\nfunction getPopupLeftPosition(popup, e, targetPosition, left) {\n  var width = popup.offsetWidth / 2;\n  var x = getPosition(e).x;\n\n  if (x - targetPosition.left < width) {\n    return targetPosition.left - left;\n  } else if (targetPosition.right - x < width) {\n    return targetPosition.right - left - width * 2;\n  } else {\n    return x - left - width;\n  }\n}\n/**\n * @param {Object} obj - Defines the object\n * @returns {Object} Returns the Properties\n * @hidden\n */\n\n\nfunction getActualProperties(obj) {\n  if (obj instanceof ChildProperty) {\n    return getValue('properties', obj);\n  } else {\n    return obj;\n  }\n}\n/**\n * @param {Element} elem - Defines the element\n * @param {string} selector - Defines the string selector\n * @param {boolean} isID - Defines the isID\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction parentsUntil(elem, selector, isID) {\n  var parent = elem;\n\n  while (parent) {\n    if (isID ? parent.id === selector : parent.classList.contains(selector)) {\n      break;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return parent;\n}\n/**\n * @param {Element} element - Defines the element\n * @param {Element} elements - Defines the element\n * @returns {number} Returns the element index\n * @hidden\n */\n\n\nfunction getElementIndex(element, elements) {\n  var index = -1;\n\n  for (var i = 0, len = elements.length; i < len; i++) {\n    if (elements[i].isEqualNode(element)) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n/**\n * @param {Object} value - Defines the value\n * @param {Object} collection - defines the collection\n * @returns {number} Returns the array\n * @hidden\n */\n\n\nfunction inArray(value, collection) {\n  for (var i = 0, len = collection.length; i < len; i++) {\n    if (collection[i] === value) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * @param {Object} collection - Defines the collection\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction getActualPropFromColl(collection) {\n  var coll = [];\n\n  for (var i = 0, len = collection.length; i < len; i++) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (collection[i].hasOwnProperty('properties')) {\n      coll.push(collection[i].properties);\n    } else {\n      coll.push(collection[i]);\n    }\n  }\n\n  return coll;\n}\n/**\n * @param {Element} target - Defines the target element\n * @param {string} selector - Defines the selector\n * @returns {void}\n * @hidden\n */\n\n\nfunction removeElement(target, selector) {\n  var elements = [].slice.call(target.querySelectorAll(selector));\n\n  for (var i = 0; i < elements.length; i++) {\n    remove(elements[i]);\n  }\n}\n/**\n * @param {MouseEvent | TouchEvent} e Defines the mouse event\n * @returns {IPosition} Returns the position\n * @hidden\n */\n\n\nfunction getPosition(e) {\n  var position = {};\n  position.x = isNullOrUndefined(e.clientX) ? e.changedTouches[0].clientX : e.clientX;\n  position.y = isNullOrUndefined(e.clientY) ? e.changedTouches[0].clientY : e.clientY;\n  return position;\n}\n\nvar uid = 0;\n/**\n * @param {string} prefix - Defines the prefix string\n * @returns {string} Returns the uid\n * @hidden\n */\n\nfunction getUid(prefix) {\n  return prefix + uid++;\n}\n/**\n * @param {Element | DocumentFragment} elem - Defines the element\n * @param {Element[] | NodeList} children - Defines the Element\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction appendChildren(elem, children) {\n  for (var i = 0, len = children.length; i < len; i++) {\n    if (len === children.length) {\n      elem.appendChild(children[i]);\n    } else {\n      elem.appendChild(children[0]);\n    }\n  }\n\n  return elem;\n}\n/**\n * @param {Element} elem - Defines the element\n * @param {string} selector - Defines the selector\n * @param {boolean} isID - Defines isID\n * @returns {Element} Return the element\n * @hidden\n */\n\n\nfunction parents(elem, selector, isID) {\n  var parent = elem;\n  var parents = [];\n\n  while (parent) {\n    if (isID ? parent.id === selector : parent.classList.contains(selector)) {\n      parents.push(parent);\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return parents;\n}\n/**\n * @param {AggregateType | string} type - Defines the type\n * @param {Object} data - Defines the data\n * @param {AggregateColumnModel} column - Defines the column\n * @param {Object} context - Defines the context\n * @returns {Object} Returns the calculated aggragate\n * @hidden\n */\n\n\nfunction calculateAggregate(type, data, column, context) {\n  if (type === 'Custom') {\n    var temp = column.customAggregate;\n\n    if (typeof temp === 'string') {\n      temp = getValue(temp, window);\n    }\n\n    return temp ? temp.call(context, data, column) : '';\n  }\n\n  return column.field in data || data instanceof Array ? DataUtil.aggregates[type.toLowerCase()](data, column.field) : null;\n}\n/** @hidden */\n\n\nvar scrollWidth = null;\n/** @hidden\n * @returns {number} - Returns the scrollbarwidth\n */\n\nfunction getScrollBarWidth() {\n  if (scrollWidth !== null) {\n    return scrollWidth;\n  }\n\n  var divNode = document.createElement('div');\n  var value = 0;\n  divNode.style.cssText = 'width:100px;height: 100px;overflow: scroll;position: absolute;top: -9999px;';\n  document.body.appendChild(divNode);\n  value = divNode.offsetWidth - divNode.clientWidth | 0;\n  document.body.removeChild(divNode);\n  return scrollWidth = value;\n}\n/** @hidden */\n\n\nvar rowHeight;\n/**\n * @param {HTMLElement} element - Defines the element\n * @returns {number} Returns the roww height\n * @hidden\n */\n\nfunction getRowHeight(element) {\n  if (rowHeight !== undefined) {\n    return rowHeight;\n  }\n\n  var table$$1 = createElement('table', {\n    className: table,\n    styles: 'visibility: hidden',\n    attrs: {\n      role: 'grid'\n    }\n  });\n  table$$1.innerHTML = '<tr><td class=\"e-rowcell\">A<td></tr>';\n  element.appendChild(table$$1);\n  var rect = table$$1.querySelector('td').getBoundingClientRect();\n  element.removeChild(table$$1);\n  rowHeight = Math.ceil(rect.height);\n  return rowHeight;\n}\n/** @hidden */\n\n\nvar actualRowHeight;\n/**\n * @param {HTMLElement} element - Defines the HTMl element\n * @returns {number} Returns the row height\n * @hidden\n */\n\nfunction getActualRowHeight(element) {\n  if (actualRowHeight !== undefined) {\n    return rowHeight;\n  }\n\n  var table$$1 = createElement('table', {\n    className: table,\n    styles: 'visibility: hidden',\n    attrs: {\n      role: 'grid'\n    }\n  });\n  table$$1.innerHTML = '<tr><td class=\"e-rowcell\">A<td></tr>';\n  element.appendChild(table$$1);\n  var rect = table$$1.querySelector('tr').getBoundingClientRect();\n  element.removeChild(table$$1);\n  return rect.height;\n}\n/**\n * @param {string} field - Defines the field\n * @returns {boolean} - Returns is complex field\n * @hidden\n */\n\n\nfunction isComplexField(field) {\n  return field.split('.').length > 1;\n}\n/**\n * @param {string} field - Defines the field\n * @returns {string} - Returns the get complex field ID\n * @hidden\n */\n\n\nfunction getComplexFieldID(field) {\n  if (field === void 0) {\n    field = '';\n  }\n\n  return field.replace(/\\./g, '___');\n}\n/**\n * @param {string} field - Defines the field\n * @returns {string} - Returns the set complex field ID\n * @hidden\n */\n\n\nfunction setComplexFieldID(field) {\n  if (field === void 0) {\n    field = '';\n  }\n\n  return field.replace(/___/g, '.');\n}\n/**\n * @param {Column} col - Defines the column\n * @param {string} type - Defines the type\n * @param {Element} elem - Defines th element\n * @returns {boolean} Returns is Editable\n * @hidden\n */\n\n\nfunction isEditable(col, type, elem) {\n  var row$$1 = parentsUntil(elem, row);\n  var isOldRow = !row$$1 ? true : row$$1 && !row$$1.classList.contains('e-insertedrow');\n\n  if (type === 'beginEdit' && isOldRow) {\n    if (col.isIdentity || col.isPrimaryKey || !col.allowEditing) {\n      return false;\n    }\n\n    return true;\n  } else if (type === 'add' && col.isIdentity) {\n    return false;\n  } else {\n    if (isOldRow && !col.allowEditing && !col.isIdentity && !col.isPrimaryKey) {\n      return false;\n    }\n\n    return true;\n  }\n}\n/**\n * @param {IGrid} inst - Defines the IGrid\n * @returns {boolean} Returns is action prevent in boolean\n * @hidden\n */\n\n\nfunction isActionPrevent(inst) {\n  var dlg = select('#' + inst.element.id + 'EditConfirm', inst.element);\n  return inst.editSettings.mode === 'Batch' && selectAll('.e-updatedtd', inst.element).length && inst.editSettings.showConfirmDialog && (dlg ? dlg.classList.contains('e-popup-close') : true);\n}\n/**\n * @param {any} elem - Defines the element\n * @param {boolean} action - Defines the boolean for action\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction wrap(elem, action) {\n  var clName = 'e-wrap';\n  elem = elem instanceof Array ? elem : [elem];\n\n  for (var i = 0; i < elem.length; i++) {\n    if (action) {\n      elem[i].classList.add(clName);\n    } else {\n      elem[i].classList.remove(clName);\n    }\n  }\n}\n/**\n * @param {ServiceLocator} serviceLocator - Defines the service locator\n * @param {Column} column  - Defines the column\n * @returns {void}\n * @hidden\n */\n\n\nfunction setFormatter(serviceLocator, column) {\n  var fmtr = serviceLocator.getService('valueFormatter');\n  var format = 'format';\n  var args;\n\n  if (column.type === 'date' || column.type === 'datetime') {\n    args = {\n      type: column.type,\n      skeleton: column.format\n    };\n\n    if (typeof column.format === 'string' && column.format !== 'yMd') {\n      args[format] = column.format;\n    }\n  }\n\n  switch (column.type) {\n    case 'date':\n      column.setFormatter(fmtr.getFormatFunction(args));\n      column.setParser(fmtr.getParserFunction(args));\n      break;\n\n    case 'datetime':\n      column.setFormatter(fmtr.getFormatFunction(args));\n      column.setParser(fmtr.getParserFunction(args));\n      break;\n\n    case 'number':\n      column.setFormatter(fmtr.getFormatFunction({\n        format: column.format\n      }));\n      column.setParser(fmtr.getParserFunction({\n        format: column.format\n      }));\n      break;\n  }\n}\n/**\n * @param {Element} cells - Defines the cell element\n * @param {boolean} add - Defines the add\n * @param {string} args - Defines the args\n * @returns {void}\n * @hidden\n */\n\n\nfunction addRemoveActiveClasses(cells, add) {\n  var args = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    args[_i - 2] = arguments[_i];\n  }\n\n  for (var i = 0, len = cells.length; i < len; i++) {\n    if (add) {\n      classList(cells[i], args.slice(), []);\n      cells[i].setAttribute('aria-selected', 'true');\n    } else {\n      classList(cells[i], [], args.slice());\n      cells[i].removeAttribute('aria-selected');\n    }\n  }\n}\n/**\n * @param {string} result - Defines th string\n * @returns {string} Returns the distinct staing values\n * @hidden\n */\n\n\nfunction distinctStringValues(result) {\n  var temp = {};\n  var res = [];\n\n  for (var i = 0; i < result.length; i++) {\n    if (!(result[i] in temp)) {\n      res.push(result[i].toString());\n      temp[result[i]] = 1;\n    }\n  }\n\n  return res;\n}\n/**\n * @param {Element} target - Defines the target\n * @param {Dialog} dialogObj - Defines the dialog\n * @returns {void}\n * @hidden\n */\n\n\nfunction getFilterMenuPostion(target, dialogObj) {\n  var elementVisible = dialogObj.element.style.display;\n  dialogObj.element.style.display = 'block';\n  var dlgWidth = dialogObj.width;\n  var newpos = calculateRelativeBasedPosition(target, dialogObj.element);\n  dialogObj.element.style.display = elementVisible;\n  dialogObj.element.style.top = newpos.top + target.getBoundingClientRect().height - 5 + 'px';\n  var leftPos = newpos.left - dlgWidth + target.clientWidth;\n\n  if (leftPos < 1) {\n    dialogObj.element.style.left = dlgWidth + leftPos - 16 + 'px'; // right calculation\n  } else {\n    dialogObj.element.style.left = leftPos + -4 + 'px';\n  }\n}\n/**\n * @param {Object} args - Defines the args\n * @param {Popup} args.popup - Defines the args for popup\n * @param {Dialog} dialogObj - Defines the dialog obj\n * @returns {void}\n * @hidden\n */\n\n\nfunction getZIndexCalcualtion(args, dialogObj) {\n  args.popup.element.style.zIndex = (dialogObj.zIndex + 1).toString();\n}\n/**\n * @param {Element} elem - Defines the element\n * @returns {void}\n * @hidden\n */\n\n\nfunction toogleCheckbox(elem) {\n  var span = elem.querySelector('.e-frame');\n  var input = span.previousSibling;\n\n  if (span.classList.contains('e-check')) {\n    input.checked = false;\n    classList(span, ['e-uncheck'], ['e-check']);\n  } else {\n    input.checked = true;\n    classList(span, ['e-check'], ['e-uncheck']);\n  }\n}\n/**\n * @param {HTMLInputElement} elem - Defines the element\n * @param {boolean} checked - Defines is checked\n * @returns {void}\n * @hidden\n */\n\n\nfunction setChecked(elem, checked) {\n  elem.checked = checked;\n}\n/**\n * @param {string} uid - Defines the string\n * @param {Element} elem - Defines the Element\n * @param {string} className - Defines the classname\n * @returns {Element} Returns the box wrap\n * @hidden\n */\n\n\nfunction createCboxWithWrap(uid, elem, className) {\n  var div = createElement('div', {\n    className: className\n  });\n  div.appendChild(elem);\n  div.setAttribute('uid', uid);\n  return div;\n}\n/**\n * @param {Element} elem - Defines the element\n * @param {boolean} checked - Defines is checked\n * @returns {void}\n * @hidden\n */\n\n\nfunction removeAddCboxClasses(elem, checked) {\n  removeClass([elem], ['e-check', 'e-stop', 'e-uncheck']);\n\n  if (checked) {\n    elem.classList.add('e-check');\n  } else {\n    elem.classList.add('e-uncheck');\n  }\n}\n/**\n * Refresh the Row model's foreign data.\n *\n * @param {IRow<Column>} row - Grid Row model object.\n * @param {Column[]} columns - Foreign columns array.\n * @param {Object} data - Updated Row data.\n * @returns {void}\n * @hidden\n */\n\n\nfunction refreshForeignData(row$$1, columns, data) {\n  for (var i = 0; i < columns.length; i++) {\n    setValue(columns[i].field, getForeignData(columns[i], data), row$$1.foreignKeyData);\n  }\n\n  var cells = row$$1.cells;\n\n  for (var i = 0; i < cells.length; i++) {\n    if (cells[i].isForeignKey) {\n      setValue('foreignKeyData', getValue(cells[i].column.field, row$$1.foreignKeyData), cells[i]);\n    }\n  }\n}\n/**\n * Get the foreign data for the corresponding cell value.\n *\n * @param {Column} column - Foreign Key column\n * @param {Object} data - Row data.\n * @param {string | number} lValue - cell value.\n * @param {Object} foreignKeyData - foreign data source.\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction getForeignData(column, data, lValue, foreignKeyData) {\n  var fField = column.foreignKeyField;\n  var key = !isNullOrUndefined(lValue) ? lValue : valueAccessor(column.field, data, column);\n  key = isNullOrUndefined(key) ? '' : key;\n  var query = new Query();\n  var fdata = foreignKeyData || (column.dataSource instanceof DataManager && column.dataSource.dataSource.json.length ? column.dataSource.dataSource.json : column.columnData);\n\n  if (key.getDay) {\n    query.where(getDatePredicate({\n      field: fField,\n      operator: 'equal',\n      value: key,\n      matchCase: false\n    }));\n  } else {\n    query.where(fField, '==', key, false);\n  }\n\n  return new DataManager(fdata).executeLocal(query);\n}\n/**\n * To use to get the column's object by the foreign key value.\n *\n * @param {string} foreignKeyValue - Defines ForeignKeyValue.\n * @param {Column[]} columns - Array of column object.\n * @returns {Column} Returns the element\n * @hidden\n */\n\n\nfunction getColumnByForeignKeyValue(foreignKeyValue, columns) {\n  var column;\n  return columns.some(function (col) {\n    column = col;\n    return col.foreignKeyValue === foreignKeyValue;\n  }) && column;\n}\n/**\n * @param {PredicateModel} filterObject - Defines the filterObject\n * @param {string} type - Defines the type\n * @returns {Predicate} Returns the Predicate\n * @hidden\n */\n\n\nfunction getDatePredicate(filterObject, type) {\n  var datePredicate;\n  var prevDate;\n  var nextDate;\n  var prevObj = extend({}, getActualProperties(filterObject));\n  var nextObj = extend({}, getActualProperties(filterObject));\n\n  if (isNullOrUndefined(filterObject.value) || filterObject.value === '') {\n    datePredicate = new Predicate(prevObj.field, prevObj.operator, prevObj.value, false);\n    return datePredicate;\n  }\n\n  var value = new Date(filterObject.value);\n\n  if (filterObject.operator === 'equal' || filterObject.operator === 'notequal') {\n    if (type === 'datetime') {\n      prevDate = new Date(value.setSeconds(value.getSeconds() - 1));\n      nextDate = new Date(value.setSeconds(value.getSeconds() + 2));\n      filterObject.value = new Date(value.setSeconds(nextDate.getSeconds() - 1));\n    } else {\n      prevDate = new Date(value.setHours(0) - 1);\n      nextDate = new Date(value.setHours(24));\n    }\n\n    prevObj.value = prevDate;\n    nextObj.value = nextDate;\n\n    if (filterObject.operator === 'equal') {\n      prevObj.operator = 'greaterthan';\n      nextObj.operator = 'lessthan';\n    } else if (filterObject.operator === 'notequal') {\n      prevObj.operator = 'lessthanorequal';\n      nextObj.operator = 'greaterthanorequal';\n    }\n\n    var predicateSt = new Predicate(prevObj.field, prevObj.operator, prevObj.value, false);\n    var predicateEnd = new Predicate(nextObj.field, nextObj.operator, nextObj.value, false);\n    datePredicate = filterObject.operator === 'equal' ? predicateSt.and(predicateEnd) : predicateSt.or(predicateEnd);\n  } else {\n    if (type === 'date' && (filterObject.operator === 'lessthanorequal' || filterObject.operator === 'greaterthan')) {\n      prevObj.value = new Date(value.setHours(24) - 1);\n    }\n\n    if (typeof prevObj.value === 'string') {\n      prevObj.value = new Date(prevObj.value);\n    }\n\n    var predicates = new Predicate(prevObj.field, prevObj.operator, prevObj.value, false);\n    datePredicate = predicates;\n  }\n\n  if (filterObject.setProperties) {\n    filterObject.setProperties({\n      ejpredicate: datePredicate\n    }, true);\n  } else {\n    filterObject.ejpredicate = datePredicate;\n  }\n\n  return datePredicate;\n}\n/**\n * @param {Element} ele - Defines the element\n * @param {number} frzCols - Defines the frozen columns\n * @param {IGrid} gObj - Defines the IGrid\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction renderMovable(ele, frzCols, gObj) {\n  frzCols = frzCols && gObj && gObj.isRowDragable() ? frzCols + 1 : frzCols;\n  var mEle = ele.cloneNode(true);\n\n  for (var i = 0; i < frzCols; i++) {\n    mEle.removeChild(mEle.children[0]);\n  }\n\n  for (var i = frzCols, len = ele.childElementCount; i < len; i++) {\n    ele.removeChild(ele.children[ele.childElementCount - 1]);\n  }\n\n  return mEle;\n}\n/**\n * @param {IGrid} grid - Defines the IGrid\n * @returns {boolean} Returns true if group adaptive is true\n * @hidden\n */\n\n\nfunction isGroupAdaptive(grid) {\n  return grid.enableVirtualization && grid.groupSettings.columns.length > 0 && grid.isVirtualAdaptive;\n}\n/**\n * @param {string} field - Defines the Field\n * @param {Object} object - Defines the objec\n * @returns {any} Returns the object\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getObject(field, object) {\n  if (field === void 0) {\n    field = '';\n  }\n\n  if (field) {\n    var value = object;\n    var splits = field.split('.');\n\n    for (var i = 0; i < splits.length && !isNullOrUndefined(value); i++) {\n      value = value[splits[i]];\n    }\n\n    return value;\n  }\n}\n/**\n * @param {string | Object} format - defines the format\n * @param {string} colType - Defines the coltype\n * @returns {string} Returns the custom Data format\n * @hidden\n */\n\n\nfunction getCustomDateFormat(format, colType) {\n  var intl = new Internationalization();\n  var formatvalue;\n  var formatter = 'format';\n  var type = 'type';\n\n  if (colType === 'date') {\n    formatvalue = typeof format === 'object' ? intl.getDatePattern({\n      type: format[type] ? format[type] : 'date',\n      format: format[formatter]\n    }, false) : intl.getDatePattern({\n      type: 'dateTime',\n      skeleton: format\n    }, false);\n  } else {\n    formatvalue = typeof format === 'object' ? intl.getDatePattern({\n      type: format[type] ? format[type] : 'dateTime',\n      format: format[formatter]\n    }, false) : intl.getDatePattern({\n      type: 'dateTime',\n      skeleton: format\n    }, false);\n  }\n\n  return formatvalue;\n}\n/**\n * @param {IGrid} gObj - Defines the IGrid\n * @param {HierarchyGridPrintMode} hierarchyPrintMode - Defines the hierarchyPrintMode\n * @returns {Object} Returns the object\n * @hidden\n */\n\n\nfunction getExpandedState(gObj, hierarchyPrintMode) {\n  var rows = gObj.getRowsObject();\n  var obj = {};\n\n  for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n    var row$$1 = rows_1[_i];\n\n    if (row$$1.isExpand && !row$$1.isDetailRow) {\n      var index = gObj.allowPaging && gObj.printMode === 'AllPages' ? row$$1.index + gObj.pageSettings.currentPage * gObj.pageSettings.pageSize - gObj.pageSettings.pageSize : row$$1.index;\n      obj[index] = {};\n      obj[index].isExpand = true;\n      obj[index].gridModel = getPrintGridModel(row$$1.childGrid, hierarchyPrintMode);\n      obj[index].gridModel.query = gObj.childGrid.query;\n    }\n  }\n\n  return obj;\n}\n/**\n * @param {IGrid} gObj - Defines the grid objct\n * @param {HierarchyGridPrintMode} hierarchyPrintMode - Defines the hierarchyPrintMode\n * @returns {IGrid} Returns the IGrid\n * @hidden\n */\n\n\nfunction getPrintGridModel(gObj, hierarchyPrintMode) {\n  if (hierarchyPrintMode === void 0) {\n    hierarchyPrintMode = 'Expanded';\n  }\n\n  var printGridModel = {};\n\n  if (!gObj) {\n    return printGridModel;\n  }\n\n  var isFrozen = gObj.isFrozenGrid() && !gObj.getFrozenColumns();\n\n  for (var _i = 0, _a = Print.printGridProp; _i < _a.length; _i++) {\n    var key = _a[_i];\n\n    if (key === 'columns') {\n      printGridModel[key] = getActualPropFromColl(isFrozen ? gObj.getColumns() : gObj[key]);\n    } else if (key === 'allowPaging') {\n      printGridModel[key] = gObj.printMode === 'CurrentPage';\n    } else {\n      printGridModel[key] = getActualProperties(gObj[key]);\n    }\n  }\n\n  printGridModel['enableHover'] = false;\n\n  if (gObj.childGrid && hierarchyPrintMode !== 'None') {\n    printGridModel.expandedRows = getExpandedState(gObj, hierarchyPrintMode);\n  }\n\n  return printGridModel;\n}\n/**\n * @param {Object} copied - Defines the copied object\n * @param {Object} first - Defines the first object\n * @param {Object} second - Defines the second object\n * @param {boolean} deep - Defines the deep\n * @returns {Object} Returns the extended object\n * @hidden\n */\n\n\nfunction extendObjWithFn(copied, first, second, deep) {\n  var res = copied || {};\n  var len = arguments.length;\n\n  if (deep) {\n    len = len - 1;\n  }\n\n  for (var i = 1; i < len; i++) {\n    // eslint-disable-next-line prefer-rest-params\n    if (!arguments[i]) {\n      continue;\n    } // eslint-disable-next-line prefer-rest-params\n\n\n    var obj1 = arguments[i];\n    var keys = Object.keys(Object.getPrototypeOf(obj1)).length ? Object.keys(obj1).concat(getPrototypesOfObj(obj1)) : Object.keys(obj1);\n\n    for (var i_1 = 0; i_1 < keys.length; i_1++) {\n      var source = res[keys[i_1]];\n      var cpy = obj1[keys[i_1]];\n      var cln = void 0;\n\n      if (deep && (isObject(cpy) || Array.isArray(cpy))) {\n        if (isObject(cpy)) {\n          cln = source ? source : {};\n          res[keys[i_1]] = extend({}, cln, cpy, deep);\n        } else {\n          cln = source ? source : [];\n          res[keys[i_1]] = extend([], cln, cpy, deep);\n        }\n      } else {\n        res[keys[i_1]] = cpy;\n      }\n    }\n  }\n\n  return res;\n}\n/**\n * @param {Object} obj - Defines the obj\n * @returns {string[]} Returns the string\n * @hidden\n */\n\n\nfunction getPrototypesOfObj(obj) {\n  var keys = [];\n\n  while (Object.getPrototypeOf(obj) && Object.keys(Object.getPrototypeOf(obj)).length) {\n    keys = keys.concat(Object.keys(Object.getPrototypeOf(obj)));\n    obj = Object.getPrototypeOf(obj);\n  }\n\n  return keys;\n}\n/**\n * @param {Column[]} column - Defines the Column\n * @returns {number} Returns the column Depth\n * @hidden\n */\n\n\nfunction measureColumnDepth(column) {\n  var max = 0;\n\n  for (var i = 0; i < column.length; i++) {\n    var depth = checkDepth(column[i], 0);\n\n    if (max < depth) {\n      max = depth;\n    }\n  }\n\n  return max + 1;\n}\n/**\n * @param {Column} col - Defines the Column\n * @param {number} index - Defines the index\n * @returns {number} Returns the depth\n * @hidden\n */\n\n\nfunction checkDepth(col, index) {\n  var max = index;\n  var indices = [];\n\n  if (col.columns) {\n    index++;\n\n    for (var i = 0; i < col.columns.length; i++) {\n      indices[i] = checkDepth(col.columns[i], index);\n    }\n\n    for (var j = 0; j < indices.length; j++) {\n      if (max < indices[j]) {\n        max = indices[j];\n      }\n    }\n\n    index = max;\n  }\n\n  return index;\n}\n/**\n * @param {IGrid} gObj - Defines the IGrid\n * @param {PredicateModel[]} filteredCols - Defines the PredicateModel\n * @returns {void}\n * @hidden\n */\n\n\nfunction refreshFilteredColsUid(gObj, filteredCols) {\n  for (var i = 0; i < filteredCols.length; i++) {\n    filteredCols[i].uid = filteredCols[i].isForeignKey ? getColumnByForeignKeyValue(filteredCols[i].field, gObj.getForeignKeyColumns()).uid : gObj.enableColumnVirtualization ? getColumnModelByFieldName(gObj, filteredCols[i].field).uid : gObj.getColumnByField(filteredCols[i].field).uid;\n  }\n}\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/no-namespace\n\n\nvar Global = /*#__PURE__*/(() => {\n  (function (Global) {\n    // eslint-disable-next-line prefer-const\n    Global.timer = null;\n  })(Global || (Global = {}));\n\n  return Global;\n})();\n\n/**\n * @param {Element} element - Defines the element\n * @returns {Object} Returns the transform values\n * @hidden\n */\nfunction getTransformValues(element) {\n  var style = document.defaultView.getComputedStyle(element, null);\n  var transformV = style.getPropertyValue('transform');\n  var replacedTv = transformV.replace(/,/g, '');\n  var translateX = parseFloat(replacedTv.split(' ')[4]);\n  var translateY = parseFloat(replacedTv.split(' ')[5]);\n  return {\n    width: translateX,\n    height: translateY\n  };\n}\n/**\n * @param {Element} rootElement - Defines the root Element\n * @param {Element} element - Defines the element\n * @returns {void}\n * @hidden\n */\n\n\nfunction applyBiggerTheme(rootElement, element) {\n  if (rootElement.classList.contains('e-bigger')) {\n    element.classList.add('e-bigger');\n  }\n}\n/**\n * @param {HTMLElement} mTD - Defines the movable TD\n * @param {HTMLElement} fTD  - Defines the Frozen TD\n * @returns {void}\n * @hidden\n */\n\n\nfunction alignFrozenEditForm(mTD, fTD) {\n  if (mTD && fTD) {\n    var mHeight = closest(mTD, '.' + row).getBoundingClientRect().height;\n    var fHeight = closest(fTD, '.' + row).getBoundingClientRect().height;\n\n    if (mHeight > fHeight) {\n      fTD.style.height = mHeight + 'px';\n    } else {\n      mTD.style.height = fHeight + 'px';\n    }\n  }\n}\n/**\n * @param {Element} row - Defines row element\n * @param {IGrid} gridObj - Defines grid object\n * @returns {boolean} Returns isRowEnteredInGrid\n * @hidden\n */\n\n\nfunction ensureLastRow(row$$1, gridObj) {\n  var cntOffset = gridObj.getContent().firstElementChild.offsetHeight;\n  return row$$1 && row$$1.getBoundingClientRect().top > cntOffset;\n}\n/**\n * @param {Element} row - Defines row element\n * @param {number} rowTop - Defines row top number\n * @returns {boolean} Returns first row is true\n * @hidden\n */\n\n\nfunction ensureFirstRow(row$$1, rowTop) {\n  return row$$1 && row$$1.getBoundingClientRect().top < rowTop;\n}\n/**\n * @param {number} index - Defines index\n * @param {IGrid} gObj - Defines grid object\n * @returns {boolean} Returns isRowEnteredInGrid\n * @hidden\n */\n\n\nfunction isRowEnteredInGrid(index, gObj) {\n  var rowHeight = gObj.getRowHeight();\n  var startIndex = gObj.getContent().firstElementChild.scrollTop / rowHeight;\n  var endIndex = startIndex + gObj.getContent().firstElementChild.offsetHeight / rowHeight;\n  return index < endIndex && index > startIndex;\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @param {Object} data - Defines the query\n * @returns {number} Returns the edited data index\n * @hidden\n */\n\n\nfunction getEditedDataIndex(gObj, data) {\n  var keyField = gObj.getPrimaryKeyFieldNames()[0];\n  var dataIndex;\n  gObj.getCurrentViewRecords().filter(function (e, index) {\n    if (e[keyField] === data[keyField]) {\n      dataIndex = index;\n    }\n  });\n  return dataIndex;\n}\n/**\n * @param {Object} args - Defines the argument\n * @param {Query} query - Defines the query\n * @returns {FilterStateObj} Returns the filter state object\n * @hidden\n */\n\n\nfunction eventPromise(args, query) {\n  var state = getStateEventArgument(query);\n  var def = new Deferred();\n  state.dataSource = def.resolve;\n  state.action = args;\n  return {\n    state: state,\n    deffered: def\n  };\n}\n/**\n * @param {Query} query - Defines the query\n * @returns {Object} Returns the state event argument\n * @hidden\n */\n\n\nfunction getStateEventArgument(query) {\n  var adaptr = new UrlAdaptor();\n  var dm = new DataManager({\n    url: '',\n    adaptor: new UrlAdaptor()\n  });\n  var state = adaptr.processQuery(dm, query);\n  var data = JSON.parse(state.data);\n  return data;\n}\n/**\n * @param {IGrid} gObj - Defines the Igrid\n * @returns {boolean} Returns the ispercentageWidth\n * @hidden\n */\n\n\nfunction ispercentageWidth(gObj) {\n  var columns = gObj.getVisibleColumns();\n  var percentageCol = 0;\n  var undefinedWidthCol = 0;\n\n  for (var i = 0; i < columns.length; i++) {\n    if (isUndefined(columns[i].width)) {\n      undefinedWidthCol++;\n    } else if (columns[i].width.toString().indexOf('%') !== -1) {\n      percentageCol++;\n    }\n  }\n\n  return (gObj.width === 'auto' || typeof gObj.width === 'string' && gObj.width.indexOf('%') !== -1) && !gObj.groupSettings.showGroupedColumn && gObj.groupSettings.columns.length && percentageCol && !undefinedWidthCol;\n}\n/**\n * @param {IGrid} gObj - Defines the IGrid\n * @param {Row<Column>[]} rows - Defines the row\n * @param {HTMLTableRowElement[]} rowElms - Row elements\n * @param {number} index - Row index\n * @param {number} startRowIndex - Start Row Index\n * @returns {void}\n * @hidden\n */\n\n\nfunction resetRowIndex(gObj, rows, rowElms, index, startRowIndex) {\n  var startIndex = index ? index : 0;\n\n  for (var i = startRowIndex ? startRowIndex : 0; i < rows.length; i++) {\n    if (rows[i].isDataRow) {\n      rows[i].index = startIndex;\n      rows[i].isAltRow = gObj.enableAltRow ? startIndex % 2 !== 0 : false;\n      rowElms[i].setAttribute(dataRowIndex, startIndex.toString());\n      rowElms[i].setAttribute(ariaRowIndex, (startIndex + 1).toString());\n\n      if (rows[i].isAltRow) {\n        rowElms[i].classList.add('e-altrow');\n      } else {\n        rowElms[i].classList.remove('e-altrow');\n      }\n\n      for (var j = 0; j < rowElms[i].cells.length; j++) {\n        rowElms[i].cells[j].setAttribute('index', startIndex.toString());\n      }\n\n      startIndex++;\n    }\n  }\n\n  if (!rows.length) {\n    gObj.renderModule.emptyRow(true);\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @param {Object} changes - Defines the changes\n * @param {string} type - Defines the type\n * @param {string} keyField - Defines the keyfield\n * @returns {void}\n * @hidden\n */\n\n\nfunction compareChanges(gObj, changes, type, keyField) {\n  var newArray = gObj.dataToBeUpdated[type].concat(changes[type]).reduce(function (r, o) {\n    r[o[keyField]] = r[o[keyField]] === undefined ? o : Object.assign(r[o[keyField]], o);\n    return r;\n  }, {});\n  gObj.dataToBeUpdated[type] = Object.keys(newArray).map(function (k) {\n    return newArray[k];\n  });\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @returns {void}\n * @hidden\n */\n\n\nfunction setRowElements(gObj) {\n  if (gObj.isFrozenGrid()) {\n    gObj.contentModule.rowElements = [].slice.call(gObj.element.querySelectorAll('.e-movableheader .e-row, .e-movablecontent .e-row'));\n    var cls = gObj.getFrozenMode() === leftRight ? '.e-frozen-left-header .e-row, .e-frozen-left-content .e-row' : '.e-frozenheader .e-row, .e-frozencontent .e-row';\n    gObj.contentModule.freezeRowElements = [].slice.call(gObj.element.querySelectorAll(cls));\n\n    if (gObj.getFrozenMode() === leftRight) {\n      gObj.contentModule.frozenRightRowElements = [].slice.call(gObj.element.querySelectorAll('.e-frozen-right-header .e-row, .e-frozen-right-content .e-row'));\n    }\n  } else {\n    gObj.contentModule.rowElements = [].slice.call(gObj.element.querySelectorAll('.e-row:not(.e-addedrow)'));\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @param {Cell<Column>} cells - Defines the callback function\n * @param {freezeTable} tableName - Defines the row\n * @returns {Cell<Column>[]} Returns the cell\n * @hidden\n */\n\n\nfunction splitFrozenRowObjectCells(gObj, cells, tableName) {\n  var left = gObj.getFrozenLeftCount();\n  var movable = gObj.getMovableColumnsCount();\n  var right = gObj.getFrozenRightColumnsCount();\n  var frozenMode = gObj.getFrozenMode();\n  var drag = gObj.isRowDragable() ? 1 : 0;\n  var rightIndex = frozenMode === 'Right' ? left + movable : left + movable + drag;\n  var mvblIndex = frozenMode === 'Right' ? left : left + drag;\n  var mvblEndIdx = frozenMode === 'Right' ? cells.length - right - drag : right ? cells.length - right : cells.length;\n\n  if (tableName === frozenLeft) {\n    cells = cells.slice(0, left ? left + drag : cells.length);\n  } else if (tableName === frozenRight) {\n    cells = cells.slice(rightIndex, cells.length);\n  } else if (tableName === 'movable') {\n    cells = cells.slice(mvblIndex, mvblEndIdx);\n  }\n\n  return cells;\n} // eslint-disable-next-line\n\n/** @hidden */\n\n\nfunction gridActionHandler(gObj, callBack, rows, force, rowObj) {\n  if (rows[0].length || force) {\n    if (rowObj) {\n      callBack(frozenLeft, rows[0], rowObj[0]);\n    } else {\n      callBack(frozenLeft, rows[0]);\n    }\n  }\n\n  if (gObj.isFrozenGrid() && (rows[1].length || force)) {\n    if (rowObj) {\n      callBack('movable', rows[1], rowObj[1]);\n    } else {\n      callBack('movable', rows[1]);\n    }\n  }\n\n  if ((gObj.getFrozenMode() === leftRight || gObj.getFrozenMode() === 'Right') && (rows[2].length || force)) {\n    if (rowObj) {\n      callBack(frozenRight, rows[2], rowObj[2]);\n    } else {\n      callBack(frozenRight, rows[2]);\n    }\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid\n * @returns {Row<Column>} Returns the row\n * @hidden\n */\n\n\nfunction getGridRowObjects(gObj) {\n  return [gObj.getFrozenMode() !== 'Right' ? gObj.getRowsObject() : [], gObj.getMovableRowsObject(), gObj.getFrozenRightRowsObject()];\n}\n/**\n * @param {IGrid} gObj - Defines the grid\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction getGridRowElements(gObj) {\n  return [gObj.getFrozenMode() !== 'Right' ? gObj.getAllDataRows(true) : [], gObj.getAllMovableDataRows(true), gObj.getAllFrozenRightDataRows(true)];\n}\n/**\n * @param {Element} row - Defines the row\n * @param {number} start - Defines the start index\n * @param {number} end - Defines the end index\n * @returns {void}\n * @hidden\n */\n\n\nfunction sliceElements(row$$1, start, end) {\n  var cells = row$$1.children;\n  var len = cells.length;\n  var k = 0;\n\n  for (var i = 0; i < len; i++, k++) {\n    if (i >= start && i < end) {\n      continue;\n    }\n\n    row$$1.removeChild(row$$1.children[k]);\n    k--;\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid Object\n * @param {Column} col - Defines the column\n * @param {number} rowIndex - Defines the rowindex\n * @returns {Element} Returns the element\n * @hidden\n */\n\n\nfunction getCellsByTableName(gObj, col, rowIndex) {\n  if (col.getFreezeTableName() === 'movable') {\n    return [].slice.call(gObj.getMovableDataRows()[rowIndex].getElementsByClassName(rowCell));\n  } else if (col.getFreezeTableName() === frozenRight) {\n    return [].slice.call(gObj.getFrozenRightDataRows()[rowIndex].getElementsByClassName(rowCell));\n  } else {\n    return [].slice.call(gObj.getDataRows()[rowIndex].getElementsByClassName(rowCell));\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the column\n * @param {Column} col - Defines the index\n * @param {number} rowIndex - Defines the rules\n * @param {number} index - Defines the movable column rules\n * @returns {Element} Returns the Element\n * @hidden\n */\n\n\nfunction getCellByColAndRowIndex(gObj, col, rowIndex, index) {\n  var left = gObj.getFrozenLeftCount();\n  var movable = gObj.getMovableColumnsCount();\n  index = col.getFreezeTableName() === 'movable' ? index - left : col.getFreezeTableName() === frozenRight ? index - (left + movable) : index;\n  return getCellsByTableName(gObj, col, rowIndex)[index];\n}\n/**\n * @param {Column} col - Defines the column\n * @param {number} index - Defines the index\n * @param {Object} rules - Defines the rules\n * @param {Object} mRules - Defines the movable column rules\n * @param {Object} frRules - Defines the Frozen rules\n * @param {number} len - Defines the length\n * @param {boolean} isCustom - Defines custom form validation\n * @returns {void}\n * @hidden\n */\n\n\nfunction setValidationRuels(col, index, rules, mRules, frRules, len, isCustom) {\n  if (isCustom) {\n    rules[getComplexFieldID(col.field)] = col.validationRules;\n  } else {\n    if (col.getFreezeTableName() === frozenLeft || !index && col.getFreezeTableName() === frozenRight || len === 1) {\n      rules[getComplexFieldID(col.field)] = col.validationRules;\n    } else if (col.getFreezeTableName() === 'movable' || !col.getFreezeTableName()) {\n      mRules[getComplexFieldID(col.field)] = col.validationRules;\n    } else if (col.getFreezeTableName() === frozenRight) {\n      frRules[getComplexFieldID(col.field)] = col.validationRules;\n    }\n  }\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @returns {Element} Returns the Element\n * @hidden\n */\n\n\nfunction getMovableTbody(gObj) {\n  var tbody$$1;\n\n  if (gObj.isFrozenGrid()) {\n    tbody$$1 = gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top' ? gObj.getMovableHeaderTbody() : gObj.getMovableContentTbody();\n  }\n\n  return tbody$$1;\n}\n/**\n * @param {IGrid} gObj - Defines the grid object\n * @returns {Element} Returns the Element\n * @hidden\n */\n\n\nfunction getFrozenRightTbody(gObj) {\n  var tbody$$1;\n\n  if (gObj.getFrozenMode() === leftRight) {\n    tbody$$1 = gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top' ? gObj.getFrozenRightHeaderTbody() : gObj.getFrozenRightContentTbody();\n  }\n\n  return tbody$$1;\n}\n/**\n * @param {Element} tbody - Table body\n * @param {Element} mTbody - Movanle table body\n * @param {Element} frTbody - Frozen right table body\n * @param {Element[]} tr - Table rows\n * @param {Element[]} mTr - Movable table rows\n * @param {Element[]} frTr - Frozen right table rows\n * @param {Function} callBack - Callback function\n * @returns {void}\n * @hidden\n */\n\n\nfunction setRowsInTbody(tbody$$1, mTbody, frTbody, tr, mTr, frTr, callBack) {\n  if (tbody$$1 && tr) {\n    callBack(tbody$$1, tr);\n  }\n\n  if (mTbody && mTr) {\n    callBack(mTbody, mTr);\n  }\n\n  if (frTbody && frTr) {\n    callBack(frTbody, frTr);\n  }\n}\n/**\n * @param {string} numberFormat - Format\n * @param {string} type - Value type\n * @param {boolean} isExcel - Boolean property\n * @returns {string} returns formated value\n * @hidden\n */\n\n\nfunction getNumberFormat(numberFormat, type, isExcel) {\n  var format;\n  var intl = new Internationalization();\n\n  if (type === 'number') {\n    try {\n      format = intl.getNumberPattern({\n        format: numberFormat,\n        currency: this.currency,\n        useGrouping: true\n      }, true);\n    } catch (error) {\n      format = numberFormat;\n    }\n  } else if (type === 'date' || type === 'time' || type === 'datetime') {\n    try {\n      format = intl.getDatePattern({\n        skeleton: numberFormat,\n        type: type\n      }, isExcel);\n\n      if (isNullOrUndefined(format)) {\n        // eslint-disable-next-line\n        throw 'error';\n      }\n    } catch (error) {\n      try {\n        format = intl.getDatePattern({\n          format: numberFormat,\n          type: type\n        }, isExcel);\n      } catch (error) {\n        format = numberFormat;\n      }\n    }\n  } else {\n    format = numberFormat;\n  }\n\n  if (type !== 'number') {\n    var patternRegex = /G|H|c|'| a|yy|y|EEEE|E/g;\n    var mtch_1 = {\n      'G': '',\n      'H': 'h',\n      'c': 'd',\n      '\\'': '\"',\n      ' a': ' AM/PM',\n      'yy': 'yy',\n      'y': 'yyyy',\n      'EEEE': 'dddd',\n      'E': 'ddd'\n    };\n    format = format.replace(patternRegex, function (pattern) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return mtch_1[pattern];\n    });\n  }\n\n  return format;\n}\n/**\n * @param {IGrid} gObj - Grid instance\n * @returns {void}\n * @hidden\n */\n\n\nfunction addBiggerDialog(gObj) {\n  if (gObj.enableAdaptiveUI) {\n    var dialogs = document.getElementsByClassName('e-responsive-dialog');\n\n    for (var i = 0; i < dialogs.length; i++) {\n      dialogs[i].classList.add('e-bigger');\n    }\n  }\n}\n/**\n * @param {string} value - specifies the trr\n * @param {Object} mapObject - specifies the idx\n * @returns {Object | string} returns object or string\n * @hidden\n */\n\n\nfunction performComplexDataOperation(value, mapObject) {\n  var returnObj;\n  var length = value.split('.').length;\n  var splits = value.split('.');\n  var duplicateMap = mapObject;\n\n  for (var i = 0; i < length; i++) {\n    returnObj = duplicateMap[splits[i]];\n    duplicateMap = returnObj;\n  }\n\n  return returnObj;\n}\n/**\n * @param {Object} tr - specifies the trr\n * @param {number} idx - specifies the idx\n * @param {string} displayVal - specifies the displayval\n * @param {Row<Column>} rows - specifies the rows\n * @param {IGrid} parent - Grid instance\n * @param {boolean} isContent - check for content renderer\n * @returns {void}\n * @hidden\n */\n\n\nfunction setDisplayValue(tr, idx, displayVal, rows, parent, isContent) {\n  var trs = Object.keys(tr);\n\n  for (var i = 0; i < trs.length; i++) {\n    var td = tr[trs[i]].querySelectorAll('td.e-rowcell')[idx];\n\n    if (tr[trs[i]].querySelectorAll('td.e-rowcell').length && td) {\n      setStyleAttribute(tr[trs[i]].querySelectorAll('td.e-rowcell')[idx], {\n        'display': displayVal\n      });\n\n      if (tr[trs[i]].querySelectorAll('td.e-rowcell')[idx].classList.contains('e-hide')) {\n        removeClass([tr[trs[i]].querySelectorAll('td.e-rowcell')[idx]], ['e-hide']);\n      }\n\n      if (isContent && parent.isRowDragable()) {\n        var index = parent.getFrozenColumns() ? idx : idx + 1;\n        rows[trs[i]].cells[index].visible = displayVal === '' ? true : false;\n      } else {\n        rows[trs[i]].cells[idx].visible = displayVal === '' ? true : false;\n      }\n    }\n  }\n} // eslint-disable-next-line\n\n/** @hidden */\n\n\nfunction addRemoveEventListener(parent, evt, isOn, module) {\n  for (var _i = 0, evt_1 = evt; _i < evt_1.length; _i++) {\n    var inst = evt_1[_i];\n\n    if (isOn) {\n      parent.on(inst.event, inst.handler, module);\n    } else {\n      parent.off(inst.event, inst.handler);\n    }\n  }\n} // eslint-disable-next-line\n\n/** @hidden */\n\n\nfunction createEditElement(parent, column, classNames, attr) {\n  var complexFieldName = getComplexFieldID(column.field);\n  attr = Object.assign(attr, {\n    id: parent.element.id + complexFieldName,\n    name: complexFieldName,\n    'e-mappinguid': column.uid\n  });\n  return parent.createElement('input', {\n    className: classNames,\n    attrs: attr\n  });\n}\n/**\n * @param {IGrid} gObj - Grid instance\n * @param {string} uid - Defines column's uid\n * @returns {Column} returns column model\n * @hidden\n */\n\n\nfunction getColumnModelByUid(gObj, uid) {\n  var column;\n\n  for (var _i = 0, _a = gObj.columnModel; _i < _a.length; _i++) {\n    var col = _a[_i];\n\n    if (col.uid === uid) {\n      column = col;\n      break;\n    }\n  }\n\n  return column;\n}\n/**\n * @param {IGrid} gObj - Grid instance\n * @param {string} field - Defines column's uid\n * @returns {Column} returns column model\n * @hidden\n */\n\n\nfunction getColumnModelByFieldName(gObj, field) {\n  var column;\n\n  if (!gObj.columnModel) {\n    gObj.getColumns();\n  }\n\n  for (var _i = 0, _a = gObj.columnModel; _i < _a.length; _i++) {\n    var col = _a[_i];\n\n    if (col.field === field) {\n      column = col;\n      break;\n    }\n  }\n\n  return column;\n}\n/**\n * @param {string} id - Defines component id\n * @param {string[]} evts - Defines events\n * @param {object} handlers - Defines event handlers\n * @param {any} instance - Defines class instance\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction registerEventHandlers(id, evts, handlers, instance) {\n  instance.eventHandlers[id] = {};\n\n  for (var i = 0; i < evts.length; i++) {\n    instance.eventHandlers[id][evts[i]] = handlers[evts[i]];\n  }\n}\n/**\n * @param {any} component - Defines component instance\n * @param {string[]} evts - Defines events\n * @param {any} instance - Defines class instance\n * @returns {void}\n * @hidden\n */\n// eslint-disable-next-line\n\n\nfunction removeEventHandlers(component, evts, instance) {\n  for (var i = 0; i < evts.length; i++) {\n    if (component.isDestroyed) {\n      break;\n    }\n\n    component.removeEventListener(evts[i], instance.eventHandlers[component.element.id][evts[i]]);\n  }\n}\n/**\n * @param {IGrid | IXLFilter} parent - Defines parent instance\n * @param {string[]} templates - Defines the templates name which are needs to clear\n * @returns {void}\n * @hidden\n */\n\n\nfunction clearReactVueTemplates(parent, templates) {\n  parent.destroyTemplate(templates);\n\n  if (parent.isReact) {\n    parent.renderTemplates();\n  }\n}\n/**\n *\n * @param { Element } row - Defines row element\n * @returns { number } row index\n */\n\n\nfunction getRowIndexFromElement(row$$1) {\n  return parseInt(row$$1.getAttribute(dataRowIndex), 10);\n}\n/**\n *\n * @param { string[] } fields - Defines grouped fields\n * @param { values } values - Defines caption keys\n * @param { any } instance - Defines dynamic class instance\n * @returns { Predicate } returns filter predicate\n */\n// eslint-disable-next-line\n\n\nfunction generateExpandPredicates(fields, values, instance) {\n  var filterCols = [];\n\n  for (var i = 0; i < fields.length; i++) {\n    var column = instance.parent.getColumnByField(fields[i]);\n    var value = values[i] === 'null' ? null : values[i];\n    var pred = {\n      field: fields[i],\n      predicate: 'or',\n      uid: column.uid,\n      operator: 'equal',\n      type: column.type,\n      matchCase: instance.allowCaseSensitive,\n      ignoreAccent: instance.parent.filterSettings.ignoreAccent\n    };\n\n    if (value === '' || isNullOrUndefined(value)) {\n      filterCols = filterCols.concat(CheckBoxFilterBase.generateNullValuePredicates(pred));\n    } else {\n      filterCols.push(extend$1({}, {\n        value: value\n      }, pred));\n    }\n  }\n\n  return CheckBoxFilterBase.getPredicate(filterCols);\n}\n/**\n *\n * @param { Predicate } pred - Defines filter predicate\n * @returns { Predicate[] } Returns formed predicate\n */\n\n\nfunction getPredicates(pred) {\n  var predicateList = [];\n\n  for (var _i = 0, _a = Object.keys(pred); _i < _a.length; _i++) {\n    var prop = _a[_i];\n    predicateList.push(pred[prop]);\n  }\n\n  return predicateList;\n}\n/**\n *\n * @param { number } index - Defines group caption indent\n * @param { Row<Column>[] } rowsObject - Defines rows object\n * @returns { { fields: string[], keys: string[] } } Returns grouped keys and values\n */\n\n\nfunction getGroupKeysAndFields(index, rowsObject) {\n  var fields = [];\n  var keys = [];\n\n  for (var i = index; i >= 0; i--) {\n    if (rowsObject[i].isCaptionRow && fields.indexOf(rowsObject[i].data.field) === -1 && (rowsObject[i].indent < rowsObject[index].indent || i === index)) {\n      fields.push(rowsObject[i].data.field);\n      keys.push(rowsObject[i].data.key);\n\n      if (rowsObject[i].indent === 0) {\n        break;\n      }\n    }\n  }\n\n  return {\n    fields: fields,\n    keys: keys\n  };\n} // eslint-disable-next-line\n\n/**\n *\n * @param { number[][] } checkActiveMatrix - Defines matrix to check\n * @param { number[] } checkCellIndex - Defines index to check\n * @param { boolean } next - Defines select next or previous index\n * @returns { number[] } - Returns next active current index\n */\n\n\nfunction findCellIndex(checkActiveMatrix, checkCellIndex, next) {\n  var activeMatrix = checkActiveMatrix;\n  var cellIndex = checkCellIndex;\n  var currentCellIndexPass = false;\n\n  if (next) {\n    for (var i = cellIndex[0]; i < activeMatrix.length; i++) {\n      var rowCell$$1 = activeMatrix[i];\n\n      for (var j = 0; j < rowCell$$1.length; j++) {\n        if (currentCellIndexPass && activeMatrix[i][j] === 1) {\n          cellIndex = [i, j];\n          return cellIndex;\n        }\n\n        if (!currentCellIndexPass && cellIndex.toString() === [i, j].toString()) {\n          currentCellIndexPass = true;\n        }\n      }\n    }\n  } else {\n    for (var i = cellIndex[0]; i >= 0; i--) {\n      var rowCell$$1 = activeMatrix[i];\n\n      for (var j = rowCell$$1.length - 1; j >= 0; j--) {\n        if (currentCellIndexPass && activeMatrix[i][j] === 1) {\n          cellIndex = [i, j];\n          return cellIndex;\n        }\n\n        if (!currentCellIndexPass && cellIndex.toString() === [i, j].toString()) {\n          currentCellIndexPass = true;\n        }\n      }\n    }\n  }\n\n  return cellIndex;\n}\n/* tslint:disable-next-line:max-line-length */\n\n/**\n * @hidden\n * `CheckBoxFilterBase` module is used to handle filtering action.\n */\n\n\nvar CheckBoxFilterBase =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for checkbox filtering module\n   *\n   * @param {IXLFilter} parent - specifies the IXLFilter\n   * @hidden\n   */\n  function CheckBoxFilterBase(parent) {\n    this.existingPredicate = {};\n    this.foreignKeyQuery = new Query();\n    /** @hidden */\n\n    this.filterState = true;\n    this.values = {};\n    this.renderEmpty = false;\n    this.isCheckboxFilterTemplate = false;\n    this.parent = parent;\n    this.id = this.parent.element.id;\n    this.valueFormatter = new ValueFormatter(this.parent.locale);\n    this.cBoxTrue = createCheckBox(this.parent.createElement, false, {\n      checked: true,\n      label: ' '\n    });\n    this.cBoxFalse = createCheckBox(this.parent.createElement, false, {\n      checked: false,\n      label: ' '\n    });\n    this.cBoxTrue.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden',\n      attrs: {\n        type: 'checkbox'\n      }\n    }), this.cBoxTrue.firstChild);\n    this.cBoxFalse.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden',\n      attrs: {\n        'type': 'checkbox'\n      }\n    }), this.cBoxFalse.firstChild);\n    this.cBoxFalse.querySelector('.e-frame').classList.add('e-uncheck');\n\n    if (this.parent.enableRtl) {\n      addClass([this.cBoxTrue, this.cBoxFalse], ['e-rtl']);\n    }\n\n    if (this.parent.cssClass) {\n      addClass([this.cBoxTrue, this.cBoxFalse], [this.parent.cssClass]);\n    }\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  CheckBoxFilterBase.prototype.destroy = function () {\n    this.closeDialog();\n  };\n\n  CheckBoxFilterBase.prototype.wireEvents = function () {\n    EventHandler.add(this.dlg, 'click', this.clickHandler, this);\n    EventHandler.add(this.dlg, 'keyup', this.keyupHandler, this);\n    this.searchHandler = debounce(this.searchBoxKeyUp, 200);\n    var elem = this.dialogObj.element.querySelector('.e-searchinput');\n\n    if (elem) {\n      EventHandler.add(elem, 'keyup', this.searchHandler, this);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.unWireEvents = function () {\n    EventHandler.remove(this.dlg, 'click', this.clickHandler);\n    EventHandler.remove(this.dlg, 'keyup', this.keyupHandler);\n    var elem = this.dialogObj.element.querySelector('.e-searchinput');\n\n    if (elem) {\n      EventHandler.remove(elem, 'keyup', this.searchHandler);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.foreignKeyFilter = function (args, fColl, mPredicate) {\n    var _this = this;\n\n    var fPredicate = {};\n    var filterCollection = [];\n    var query = this.foreignKeyQuery.clone();\n    this.options.column.dataSource.executeQuery(query.where(mPredicate)).then(function (e) {\n      _this.options.column.columnData = e.result;\n\n      _this.parent.notify(generateQuery, {\n        predicate: fPredicate,\n        column: _this.options.column\n      });\n\n      args.ejpredicate = fPredicate.predicate.predicates;\n      var fpred = fPredicate.predicate.predicates;\n\n      for (var i = 0; i < fpred.length; i++) {\n        filterCollection.push({\n          field: fpred[i].field,\n          predicate: 'or',\n          matchCase: fpred[i].ignoreCase,\n          ignoreAccent: fpred[i].ignoreAccent,\n          operator: fpred[i].operator,\n          value: fpred[i].value,\n          type: _this.options.type\n        });\n      }\n\n      args.filterCollection = filterCollection.length ? filterCollection : fColl.filter(function (col) {\n        return col.field = _this.options.field;\n      });\n\n      _this.options.handler(args);\n    });\n  };\n\n  CheckBoxFilterBase.prototype.foreignFilter = function (args, value) {\n    var operator = this.options.isRemote ? this.options.column.type === 'string' ? 'contains' : 'equal' : this.options.column.type ? 'contains' : 'equal';\n    var initalPredicate = new Predicate(this.options.column.foreignKeyValue, operator, value, true, this.options.ignoreAccent);\n    this.foreignKeyFilter(args, [args.filterCollection], initalPredicate);\n  };\n\n  CheckBoxFilterBase.prototype.searchBoxClick = function (e) {\n    var target = e.target;\n\n    if (target.classList.contains('e-searchclear')) {\n      this.sInput.value = '';\n\n      if (this.isCheckboxFilterTemplate) {\n        this.parent.notify('refreshCheckbox', {\n          event: e\n        });\n      } else {\n        this.refreshCheckboxes();\n      }\n\n      this.updateSearchIcon();\n      this.sInput.focus();\n    }\n  };\n\n  CheckBoxFilterBase.prototype.searchBoxKeyUp = function (e) {\n    if (!isNullOrUndefined(this.parent.loadingIndicator) && this.parent.loadingIndicator.indicatorType === 'Shimmer') {\n      this.parent.showMaskRow(undefined, this.dialogObj.element);\n    }\n\n    if (this.isCheckboxFilterTemplate) {\n      this.parent.notify('refreshCheckbox', {\n        event: e\n      });\n    } else {\n      this.refreshCheckboxes();\n    }\n\n    this.updateSearchIcon();\n  };\n\n  CheckBoxFilterBase.prototype.updateSearchIcon = function () {\n    if (this.sInput.value.length) {\n      classList(this.sIcon, ['e-chkcancel-icon'], ['e-search-icon']);\n    } else {\n      classList(this.sIcon, ['e-search-icon'], ['e-chkcancel-icon']);\n    }\n  };\n  /**\n   * Gets the localized label by locale keyword.\n   *\n   * @param {string} key - Defines localization key\n   * @returns {string} - returns localization label\n   */\n\n\n  CheckBoxFilterBase.prototype.getLocalizedLabel = function (key) {\n    return this.localeObj.getConstant(key);\n  };\n\n  CheckBoxFilterBase.prototype.updateDataSource = function () {\n    var dataSource = this.options.dataSource;\n    var str = 'object';\n\n    if (!(dataSource instanceof DataManager)) {\n      for (var i = 0; i < dataSource.length; i++) {\n        // eslint-disable-next-line valid-typeof\n        if (typeof dataSource !== str) {\n          var obj = {};\n          obj[this.options.field] = dataSource[i];\n          dataSource[i] = obj;\n        }\n      }\n    }\n  };\n\n  CheckBoxFilterBase.prototype.updateModel = function (options) {\n    this.options = options;\n    this.existingPredicate = options.actualPredicate || {};\n    this.options.dataSource = options.dataSource;\n    this.options.dataManager = options.dataManager ? options.dataManager : options.dataSource;\n    this.updateDataSource();\n    this.options.type = options.type;\n    this.options.format = options.format || '';\n    this.options.ignoreAccent = options.ignoreAccent || false;\n    this.options.filteredColumns = options.filteredColumns || this.parent.filterSettings.columns;\n    this.options.query = options.query || new Query();\n    this.options.allowCaseSensitive = options.allowCaseSensitive || false;\n    this.options.uid = options.column.uid;\n    this.options.disableHtmlEncode = options.column.disableHtmlEncode || false;\n    this.values = {};\n    this.localeObj = options.localeObj;\n    this.isFiltered = options.filteredColumns.length;\n  };\n\n  CheckBoxFilterBase.prototype.getAndSetChkElem = function (options) {\n    this.dlg = this.parent.createElement('div', {\n      id: this.id + this.options.type + '_excelDlg',\n      attrs: {\n        uid: this.options.column.uid\n      },\n      className: 'e-checkboxfilter e-filter-popup'\n    });\n    this.sBox = this.parent.createElement('div', {\n      className: 'e-searchcontainer'\n    });\n\n    if (!options.hideSearchbox) {\n      this.sInput = this.parent.createElement('input', {\n        id: this.id + '_SearchBox',\n        className: 'e-searchinput'\n      });\n      this.sIcon = this.parent.createElement('span', {\n        className: 'e-searchclear e-search-icon e-icons e-input-group-icon',\n        attrs: {\n          type: 'text',\n          title: this.getLocalizedLabel('Search')\n        }\n      });\n      this.searchBox = this.parent.createElement('span', {\n        className: 'e-searchbox e-fields'\n      });\n      this.searchBox.appendChild(this.sInput);\n      this.sBox.appendChild(this.searchBox);\n      var inputargs = {\n        element: this.sInput,\n        floatLabelType: 'Never',\n        properties: {\n          placeholder: this.getLocalizedLabel('Search'),\n          cssClass: this.parent.cssClass\n        }\n      };\n      Input.createInput(inputargs, this.parent.createElement);\n      this.searchBox.querySelector('.e-input-group').appendChild(this.sIcon);\n    }\n\n    this.spinner = this.parent.createElement('div', {\n      className: 'e-spinner'\n    }); //for spinner\n\n    this.cBox = this.parent.createElement('div', {\n      id: this.id + this.options.type + '_CheckBoxList',\n      className: 'e-checkboxlist e-fields'\n    });\n    this.spinner.appendChild(this.cBox);\n    this.sBox.appendChild(this.spinner);\n    return this.sBox;\n  };\n\n  CheckBoxFilterBase.prototype.showDialog = function (options) {\n    var args = {\n      requestType: filterBeforeOpen,\n      columnName: this.options.field,\n      columnType: this.options.type,\n      cancel: false\n    };\n    var filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.notify(cBoxFltrBegin, args);\n\n    if (args.cancel) {\n      options.cancel = args.cancel;\n      return;\n    }\n\n    this.dialogObj = new Dialog({\n      visible: false,\n      content: this.sBox,\n      close: this.closeDialog.bind(this),\n      enableRtl: this.parent.enableRtl,\n      width: !isNullOrUndefined(parentsUntil(options.target, 'e-bigger')) || this.parent.element.classList.contains('e-device') ? 260 : 255,\n      target: this.parent.element,\n      animationSettings: {\n        effect: 'None'\n      },\n      buttons: [{\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          content: this.getLocalizedLabel(this.isExcel ? 'OKButton' : 'FilterButton'),\n          cssClass: this.parent.cssClass ? 'e-primary' + ' ' + this.parent.cssClass : 'e-primary',\n          isPrimary: true\n        }\n      }, {\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          cssClass: this.parent.cssClass ? 'e-flat' + ' ' + this.parent.cssClass : 'e-flat',\n          content: this.getLocalizedLabel(this.isExcel ? 'CancelButton' : 'ClearButton')\n        }\n      }],\n      created: this.dialogCreated.bind(this),\n      open: this.dialogOpen.bind(this),\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    var isStringTemplate = 'isStringTemplate';\n    this.dialogObj[isStringTemplate] = true;\n    this.renderResponsiveFilter(options);\n    this.dlg.setAttribute('aria-label', this.getLocalizedLabel('ExcelFilterDialogARIA'));\n\n    if (options.isResponsiveFilter) {\n      var responsiveCnt = document.querySelector('.e-responsive-dialog > .e-dlg-content > .e-mainfilterdiv');\n      responsiveCnt.appendChild(this.dlg);\n    } else {\n      this.parent.element.appendChild(this.dlg);\n    }\n\n    this.dialogObj.appendTo(this.dlg);\n    this.dialogObj.element.style.maxHeight = options.isResponsiveFilter ? 'none' : this.options.height + 'px';\n    this.dialogObj.show();\n    var content = this.dialogObj.element.querySelector('.e-dlg-content');\n    content.appendChild(this.sBox);\n    this.wireEvents();\n\n    if (!isNullOrUndefined(this.parent.loadingIndicator) && this.parent.loadingIndicator.indicatorType === 'Shimmer') {\n      this.parent.showMaskRow(undefined, this.dialogObj.element);\n    } else {\n      createSpinner({\n        target: this.spinner,\n        cssClass: this.parent.cssClass ? this.parent.cssClass : null\n      }, this.parent.createElement);\n      showSpinner(this.spinner);\n    }\n\n    this.getAllData();\n  };\n\n  CheckBoxFilterBase.prototype.renderResponsiveFilter = function (options) {\n    if (options.isResponsiveFilter) {\n      this.dialogObj.buttons = [{}];\n      this.dialogObj.position = {\n        X: '',\n        Y: ''\n      };\n      this.dialogObj.target = document.querySelector('.e-resfilter > .e-dlg-content > .e-mainfilterdiv');\n      this.dialogObj.width = '100%';\n    }\n  };\n\n  CheckBoxFilterBase.prototype.dialogCreated = function (e) {\n    if (this.options.isResponsiveFilter) {\n      this.dialogObj.element.style.left = '0px';\n    } else {\n      if (!Browser.isDevice) {\n        getFilterMenuPostion(this.options.target, this.dialogObj);\n      } else {\n        this.dialogObj.position = {\n          X: 'center',\n          Y: 'center'\n        };\n      }\n    }\n\n    if (this.options.column.showColumnMenu) {\n      this.parent.notify(filterDialogCreated, e);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.openDialog = function (options) {\n    this.updateModel(options);\n    this.getAndSetChkElem(options);\n    this.showDialog(options);\n  };\n\n  CheckBoxFilterBase.prototype.closeDialog = function () {\n    if (this.dialogObj && !this.dialogObj.isDestroyed) {\n      this.isBlanks = false;\n      var filterTemplateCol = this.options.columns.filter(function (col) {\n        return col.getFilterItemTemplate();\n      }); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var registeredTemplate = this.parent.registeredTemplate;\n\n      if (filterTemplateCol.length && !isNullOrUndefined(registeredTemplate) && registeredTemplate.filterItemTemplate) {\n        this.parent.destroyTemplate(['filterItemTemplate']);\n      }\n\n      if ((this.parent.isReact || this.parent.isVue) && this.parent.destroyTemplate !== undefined) {\n        clearReactVueTemplates(this.parent, ['filterItemTemplate']);\n      }\n\n      this.parent.notify(filterMenuClose, {\n        field: this.options.field\n      });\n      this.dialogObj.destroy();\n      this.unWireEvents();\n      remove(this.dlg);\n      this.dlg = null;\n      this.parent.notify(filterDialogClose, {});\n    }\n  };\n  /**\n   * @param {Column} col - Defines column details\n   * @returns {void}\n   * @hidden\n   */\n\n\n  CheckBoxFilterBase.prototype.clearFilter = function (col) {\n    // eslint-disable-next-line max-len\n    var args = {\n      instance: this,\n      handler: this.clearFilter,\n      cancel: false\n    };\n    this.parent.notify(fltrPrevent, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    this.options.handler({\n      action: 'clear-filter',\n      field: col ? col.field : this.options.field\n    });\n  };\n\n  CheckBoxFilterBase.prototype.btnClick = function (e) {\n    if (this.filterState) {\n      if (e.target.tagName.toLowerCase() === 'input' && e.target.classList.contains('e-searchinput') || e.keyCode === 13) {\n        if (!this.isCheckboxFilterTemplate) {\n          this.fltrBtnHandler();\n        }\n      } else {\n        var text = e.target.firstChild.textContent.toLowerCase();\n\n        if (this.getLocalizedLabel(this.isExcel ? 'OKButton' : 'FilterButton').toLowerCase() === text) {\n          if (!this.isCheckboxFilterTemplate) {\n            this.fltrBtnHandler();\n          }\n        } else if (this.getLocalizedLabel('ClearButton').toLowerCase() === text) {\n          this.clearFilter();\n        }\n      }\n\n      this.closeDialog();\n    } else if (!(e.target.tagName.toLowerCase() === 'input')) {\n      this.clearFilter();\n      this.closeDialog();\n    }\n\n    if (this.options.column.showColumnMenu) {\n      this.parent.notify(afterFilterColumnMenuClose, {});\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  CheckBoxFilterBase.prototype.fltrBtnHandler = function () {\n    var _this = this;\n\n    var checked = [].slice.call(this.cBox.querySelectorAll('.e-check:not(.e-selectall)'));\n    var check = checked;\n    var optr = 'equal';\n    var ddlValue = this.dialogObj.element.querySelector('.e-dropdownlist');\n\n    if (ddlValue) {\n      this.options.operator = optr = ddlValue.ej2_instances[0].value;\n    }\n\n    this.isMenuNotEqual = this.options.operator === 'notequal';\n    var searchInput;\n\n    if (!this.options.hideSearchbox) {\n      searchInput = this.searchBox.querySelector('.e-searchinput');\n    }\n\n    var caseSen = this.options.allowCaseSensitive;\n    var defaults = {\n      field: this.options.field,\n      predicate: this.isMenuNotEqual ? 'and' : 'or',\n      uid: this.options.uid,\n      operator: optr,\n      type: this.options.type,\n      matchCase: caseSen,\n      ignoreAccent: this.options.ignoreAccent\n    };\n    var isNotEqual = this.itemsCnt !== checked.length && this.itemsCnt - checked.length < checked.length;\n\n    if (isNotEqual && searchInput && searchInput.value === '') {\n      optr = this.isMenuNotEqual ? 'equal' : 'notequal';\n      checked = [].slice.call(this.cBox.querySelectorAll('.e-uncheck:not(.e-selectall)'));\n      defaults.predicate = this.isMenuNotEqual ? 'or' : 'and';\n      defaults.operator = optr;\n    }\n\n    var value;\n    var val;\n    var length;\n    var fObj;\n    var coll = [];\n\n    if (checked.length !== this.itemsCnt || searchInput && searchInput.value && searchInput.value !== '') {\n      for (var i = 0; i < checked.length; i++) {\n        value = this.values[parentsUntil(checked[i], 'e-ftrchk').getAttribute('uid')];\n        fObj = extend({}, {\n          value: value\n        }, defaults);\n\n        if (value && !value.toString().length) {\n          fObj.operator = isNotEqual ? 'notequal' : 'equal';\n        }\n\n        if (value === '' || isNullOrUndefined(value)) {\n          coll = coll.concat(CheckBoxFilterBase.generateNullValuePredicates(defaults));\n        } else {\n          coll.push(fObj);\n        }\n\n        var args = {\n          instance: this,\n          handler: this.fltrBtnHandler,\n          arg1: fObj.field,\n          arg2: fObj.predicate,\n          arg3: fObj.operator,\n          arg4: fObj.matchCase,\n          arg5: fObj.ignoreAccent,\n          arg6: fObj.value,\n          cancel: false\n        };\n        this.parent.notify(fltrPrevent, args);\n\n        if (args.cancel) {\n          return;\n        }\n      }\n\n      if (this.options.type === 'date' || this.options.type === 'datetime') {\n        length = check.length - 1;\n        val = this.values[parentsUntil(check[length], 'e-ftrchk').getAttribute('uid')];\n\n        if (isNullOrUndefined(val) && isNotEqual) {\n          coll.push({\n            field: defaults.field,\n            matchCase: defaults.matchCase,\n            operator: 'equal',\n            predicate: 'and',\n            value: null\n          });\n        }\n      }\n\n      this.initiateFilter(coll);\n    } else {\n      var isClearFilter = this.options.filteredColumns.some(function (value) {\n        return _this.options.field === value.field;\n      });\n\n      if (isClearFilter) {\n        this.clearFilter();\n      }\n    }\n  }; // eslint-disable-next-line\n\n  /** @hidden */\n\n\n  CheckBoxFilterBase.generateNullValuePredicates = function (defaults) {\n    var coll = [];\n\n    if (defaults.type === 'string') {\n      coll.push({\n        field: defaults.field,\n        ignoreAccent: defaults.ignoreAccent,\n        matchCase: defaults.matchCase,\n        operator: defaults.operator,\n        predicate: defaults.predicate,\n        value: ''\n      });\n    }\n\n    coll.push({\n      field: defaults.field,\n      matchCase: defaults.matchCase,\n      operator: defaults.operator,\n      predicate: defaults.predicate,\n      value: null\n    });\n    coll.push({\n      field: defaults.field,\n      matchCase: defaults.matchCase,\n      operator: defaults.operator,\n      predicate: defaults.predicate,\n      value: undefined\n    });\n    return coll;\n  }; // eslint-disable-next-line\n\n  /** @hidden */\n\n\n  CheckBoxFilterBase.prototype.initiateFilter = function (fColl) {\n    var firstVal = fColl[0];\n    var predicate;\n\n    if (!isNullOrUndefined(firstVal)) {\n      predicate = firstVal.ejpredicate ? firstVal.ejpredicate : new Predicate(firstVal.field, firstVal.operator, firstVal.value, !firstVal.matchCase, firstVal.ignoreAccent);\n\n      for (var j = 1; j < fColl.length; j++) {\n        predicate = fColl[j].ejpredicate !== undefined ? predicate[fColl[j].predicate](fColl[j].ejpredicate) : predicate[fColl[j].predicate](fColl[j].field, fColl[j].operator, fColl[j].value, !fColl[j].matchCase, fColl[j].ignoreAccent);\n      }\n\n      var args = {\n        action: 'filtering',\n        filterCollection: fColl,\n        field: this.options.field,\n        ejpredicate: Predicate.or(predicate)\n      };\n      this.options.handler(args);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.isForeignColumn = function (col) {\n    return col.isForeignColumn ? col.isForeignColumn() : false;\n  };\n\n  CheckBoxFilterBase.prototype.refreshCheckboxes = function () {\n    var _this = this;\n\n    var val = this.sInput.value;\n    var column = this.options.column;\n    var query = this.isForeignColumn(column) ? this.foreignKeyQuery.clone() : this.options.query.clone();\n    var foreignQuery = this.options.query.clone();\n    var pred = query.queries.filter(function (e) {\n      return e && e.fn === 'onWhere';\n    })[0];\n    query.queries = [];\n    foreignQuery.queries = [];\n    var parsed = this.options.type !== 'string' && parseFloat(val) ? parseFloat(val) : val;\n    var operator = this.options.isRemote ? this.options.type === 'string' ? 'contains' : 'equal' : this.options.type ? 'contains' : 'equal';\n    var matchCase = true;\n    var ignoreAccent = this.options.ignoreAccent;\n    var field = this.isForeignColumn(column) ? column.foreignKeyValue : column.field;\n    parsed = parsed === '' || parsed === undefined ? undefined : parsed;\n    var coll = [];\n    var defaults = {\n      field: field,\n      predicate: 'or',\n      uid: this.options.uid,\n      operator: 'equal',\n      type: this.options.type,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent\n    };\n    var predicte;\n    var moduleName = this.options.dataManager.adaptor.getModuleName;\n\n    if (this.options.type === 'boolean') {\n      if (parsed !== undefined && this.getLocalizedLabel('FilterTrue').toLowerCase().indexOf(parsed.toLowerCase()) !== -1) {\n        parsed = 'true';\n      } else if (parsed !== undefined && this.getLocalizedLabel('FilterFalse').toLowerCase().indexOf(parsed.toLowerCase()) !== -1) {\n        parsed = 'false';\n      }\n\n      if (parsed !== undefined && this.getLocalizedLabel('FilterTrue').toLowerCase().indexOf(parsed.toLowerCase()) !== -1 && moduleName) {\n        // eslint-disable-next-line no-constant-condition\n        parsed = moduleName() === 'ODataAdaptor' || 'ODataV4Adaptor' ? true : 'true';\n      } else if (parsed !== undefined && this.getLocalizedLabel('FilterFalse').toLowerCase().indexOf(parsed.toLowerCase()) !== -1 && moduleName) {\n        // eslint-disable-next-line no-constant-condition\n        parsed = moduleName() === 'ODataAdaptor' || 'ODataV4Adaptor' ? false : 'false';\n      }\n\n      operator = 'equal';\n    }\n\n    if ((this.options.type === 'date' || this.options.type === 'datetime') && this.options.format) {\n      var intl = new Internationalization();\n      var format = typeof this.options.format === 'string' ? this.options.format : this.options.format.format;\n\n      if (format) {\n        parsed = intl.parseDate(val, {\n          format: format\n        }) || new Date(val);\n      } else {\n        parsed = new Date(val);\n      }\n    }\n\n    this.addDistinct(query);\n    var args = {\n      requestType: filterSearchBegin,\n      filterModel: this,\n      columnName: field,\n      column: column,\n      operator: operator,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      filterChoiceCount: null,\n      query: query,\n      value: parsed\n    };\n    this.parent.trigger(actionBegin, args, function (filterargs) {\n      // eslint-disable-next-line no-self-assign\n      filterargs.operator = filterargs.operator;\n      predicte = new Predicate(field, filterargs.operator, parsed, filterargs.matchCase, filterargs.ignoreAccent);\n\n      if (_this.options.type === 'date' || _this.options.type === 'datetime') {\n        operator = 'equal';\n        var filterObj = {\n          field: field,\n          operator: operator,\n          value: parsed,\n          matchCase: matchCase,\n          ignoreAccent: ignoreAccent\n        };\n\n        if (!isNullOrUndefined(parsed)) {\n          predicte = getDatePredicate(filterObj, _this.options.type);\n        }\n      }\n\n      if (val && typeof val === 'string' && _this.isBlanks && _this.getLocalizedLabel('Blanks').toLowerCase().indexOf(val.toLowerCase()) >= 0) {\n        coll = coll.concat(CheckBoxFilterBase.generateNullValuePredicates(defaults));\n        var emptyValPredicte = CheckBoxFilterBase.generatePredicate(coll);\n        emptyValPredicte.predicates.push(predicte);\n        query.where(emptyValPredicte);\n      } else if (val.length) {\n        predicte = !isNullOrUndefined(pred) ? predicte.and(pred.e) : predicte;\n        query.where(predicte);\n      } else if (!isNullOrUndefined(pred)) {\n        query.where(pred.e);\n      }\n\n      filterargs.filterChoiceCount = !isNullOrUndefined(filterargs.filterChoiceCount) ? filterargs.filterChoiceCount : 1000;\n      var fPredicate = {};\n      showSpinner(_this.spinner);\n      _this.renderEmpty = false;\n\n      if (_this.isForeignColumn(column) && val.length) {\n        var colData = 'result' in column.dataSource ? new DataManager(column.dataSource.result) : column.dataSource; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        colData.executeQuery(query).then(function (e) {\n          var columnData = _this.options.column.columnData;\n          _this.options.column.columnData = e.result;\n\n          _this.parent.notify(generateQuery, {\n            predicate: fPredicate,\n            column: column\n          });\n\n          if (fPredicate.predicate.predicates.length) {\n            foreignQuery.where(fPredicate.predicate);\n          } else {\n            _this.renderEmpty = true;\n          }\n\n          _this.options.column.columnData = columnData;\n          foreignQuery.take(filterargs.filterChoiceCount);\n\n          _this.search(filterargs, foreignQuery);\n        });\n      } else {\n        query.take(filterargs.filterChoiceCount);\n\n        _this.search(filterargs, query);\n      }\n    });\n  };\n\n  CheckBoxFilterBase.prototype.search = function (args, query) {\n    if (this.parent.dataSource && 'result' in this.parent.dataSource) {\n      this.filterEvent(args, query);\n    } else {\n      this.processSearch(query);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.getPredicateFromCols = function (columns) {\n    var predicates = CheckBoxFilterBase.getPredicate(columns);\n    var predicateList = [];\n    var fPredicate = {};\n    var isGrid = this.parent.getForeignKeyColumns !== undefined;\n    var foreignColumn = isGrid ? this.parent.getForeignKeyColumns() : [];\n\n    for (var _i = 0, _a = Object.keys(predicates); _i < _a.length; _i++) {\n      var prop = _a[_i];\n      var col = void 0;\n\n      if (isGrid && !this.parent.getColumnByField(prop)) {\n        col = getColumnByForeignKeyValue(prop, foreignColumn);\n      }\n\n      if (col) {\n        this.parent.notify(generateQuery, {\n          predicate: fPredicate,\n          column: col\n        });\n\n        if (fPredicate.predicate.predicates.length) {\n          predicateList.push(Predicate.or(fPredicate.predicate.predicates));\n        }\n      } else {\n        predicateList.push(predicates[prop]);\n      }\n    }\n\n    return predicateList.length && Predicate.and(predicateList);\n  };\n\n  CheckBoxFilterBase.prototype.getQuery = function () {\n    return this.parent.getQuery ? this.parent.getQuery().clone() : new Query();\n  };\n\n  CheckBoxFilterBase.prototype.getAllData = function () {\n    var _this = this;\n\n    this.customQuery = false;\n    var query = this.getQuery();\n    query.requiresCount(); //consider take query\n\n    this.addDistinct(query);\n    var args = {\n      requestType: filterChoiceRequest,\n      query: query,\n      filterChoiceCount: null\n    };\n    var filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.trigger(actionBegin, args, function (args) {\n      args.filterChoiceCount = !isNullOrUndefined(args.filterChoiceCount) ? args.filterChoiceCount : 1000;\n      query.take(args.filterChoiceCount);\n\n      if (!args.query.distincts.length) {\n        _this.customQuery = true;\n\n        _this.queryGenerate(query);\n      }\n\n      if (_this.parent.dataSource && 'result' in _this.parent.dataSource) {\n        _this.filterEvent(args, query);\n      } else {\n        _this.processDataOperation(query, true);\n      }\n    });\n  };\n\n  CheckBoxFilterBase.prototype.addDistinct = function (query) {\n    var filteredColumn = DataUtil.distinct(this.options.filteredColumns, 'field');\n\n    if (filteredColumn.indexOf(this.options.column.field) <= -1) {\n      filteredColumn = filteredColumn.concat(this.options.column.field);\n    }\n\n    query.distinct(filteredColumn);\n    return query;\n  };\n\n  CheckBoxFilterBase.prototype.filterEvent = function (args, query) {\n    var _this = this;\n\n    var defObj = eventPromise(args, query);\n    this.parent.trigger(dataStateChange, defObj.state);\n    var def = defObj.deffered;\n    def.promise.then(function (e) {\n      _this.dataSuccess(e);\n    });\n  };\n\n  CheckBoxFilterBase.prototype.processDataOperation = function (query, isInitial) {\n    var _this = this;\n\n    this.options.dataSource = this.options.dataSource instanceof DataManager ? this.options.dataSource : new DataManager(this.options.dataSource);\n    var allPromise = [];\n    var runArray = [];\n\n    if (this.isForeignColumn(this.options.column) && isInitial) {\n      var colData = 'result' in this.options.column.dataSource ? new DataManager(this.options.column.dataSource.result) : this.options.column.dataSource;\n      this.foreignKeyQuery.params = query.params;\n      allPromise.push(colData.executeQuery(this.foreignKeyQuery));\n      runArray.push(function (data) {\n        return _this.foreignKeyData = data;\n      });\n    }\n\n    allPromise.push(this.options.dataSource.executeQuery(query));\n    runArray.push(this.dataSuccess.bind(this));\n    var i = 0;\n    Promise.all(allPromise).then(function (e) {\n      for (var j = 0; j < e.length; j++) {\n        runArray[i++](e[j].result);\n      }\n    });\n  };\n\n  CheckBoxFilterBase.prototype.dataSuccess = function (e) {\n    this.fullData = e;\n    var args1 = {\n      dataSource: this.fullData,\n      executeQuery: true,\n      field: this.options.field\n    };\n    this.parent.notify(beforeCheckboxRenderer, args1);\n\n    if (args1.executeQuery) {\n      var query = new Query();\n\n      if (!this.customQuery) {\n        this.queryGenerate(query);\n      } // query.select(this.options.field);\n\n\n      var result = new DataManager(args1.dataSource).executeLocal(query);\n      var col = this.options.column;\n      this.filteredData = CheckBoxFilterBase.getDistinct(result, this.options.field, col, this.foreignKeyData).records || [];\n    }\n\n    var data = args1.executeQuery ? this.filteredData : args1.dataSource;\n    this.processDataSource(null, true, data, args1);\n\n    if (this.sInput) {\n      this.sInput.focus();\n    }\n\n    var args = {\n      requestType: filterAfterOpen,\n      columnName: this.options.field,\n      columnType: this.options.type\n    };\n    var filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.notify(cBoxFltrComplete, args);\n\n    if (this.isCheckboxFilterTemplate) {\n      hideSpinner(this.spinner);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.queryGenerate = function (query) {\n    if (this.parent.searchSettings && this.parent.searchSettings.key.length) {\n      var sSettings = this.parent.searchSettings;\n      var fields = sSettings.fields.length ? sSettings.fields : this.options.columns.map(function (f) {\n        return f.field;\n      });\n      query.search(sSettings.key, fields, sSettings.operator, sSettings.ignoreCase, sSettings.ignoreAccent);\n    }\n\n    if (this.options.filteredColumns.length) {\n      var cols = [];\n\n      for (var i = 0; i < this.options.filteredColumns.length; i++) {\n        var filterColumn = this.options.filteredColumns[i];\n\n        if (this.options.uid) {\n          filterColumn.uid = filterColumn.uid || this.parent.getColumnByField(filterColumn.field).uid;\n\n          if (filterColumn.uid !== this.options.uid) {\n            cols.push(this.options.filteredColumns[i]);\n          }\n        } else {\n          if (filterColumn.field !== this.options.field) {\n            cols.push(this.options.filteredColumns[i]);\n          }\n        }\n      }\n\n      var predicate = this.getPredicateFromCols(cols);\n\n      if (predicate) {\n        query.where(predicate);\n      }\n    }\n  };\n\n  CheckBoxFilterBase.prototype.processDataSource = function (query, isInitial, dataSource, args) {\n    showSpinner(this.spinner); // query = query ? query : this.options.query.clone();\n    // query.requiresCount();\n    // let result: Object = new DataManager(dataSource as JSON[]).executeLocal(query);\n    // let res: { result: Object[] } = result as { result: Object[] };\n\n    this.updateResult();\n    var args1 = {\n      dataSource: this.fullData,\n      isCheckboxFilterTemplate: false,\n      column: this.options.column,\n      element: this.cBox,\n      type: this.options.type,\n      format: this.options.type,\n      btnObj: this.options.isResponsiveFilter ? null : this.dialogObj.btnObj[0],\n      searchBox: this.searchBox\n    };\n    this.parent.notify(beforeCheckboxfilterRenderer, args1);\n    this.isCheckboxFilterTemplate = args1.isCheckboxFilterTemplate;\n\n    if (!this.isCheckboxFilterTemplate) {\n      this.createFilterItems(dataSource, isInitial, args);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.processSearch = function (query) {\n    this.processDataOperation(query);\n  };\n\n  CheckBoxFilterBase.prototype.updateResult = function () {\n    this.result = {};\n    var predicate = this.getPredicateFromCols(this.options.filteredColumns);\n    var query = new Query();\n\n    if (predicate) {\n      query.where(predicate);\n    }\n\n    this.parent.notify(beforeCheckboxRendererQuery, {\n      query: query\n    });\n    var result = new DataManager(this.fullData).executeLocal(query);\n\n    for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n      var res = result_1[_i];\n      this.result[getObject(this.options.field, res)] = true;\n    }\n  };\n\n  CheckBoxFilterBase.prototype.clickHandler = function (e) {\n    var target = e.target;\n\n    if (!isNullOrUndefined(this.parent.loadingIndicator) && this.parent.loadingIndicator.indicatorType === 'Shimmer' && parentsUntil(target, 'e-mask-ftrchk')) {\n      return;\n    }\n\n    var elem = parentsUntil(target, 'e-checkbox-wrapper');\n\n    if (parentsUntil(target, 'e-searchbox')) {\n      this.searchBoxClick(e);\n    }\n\n    if (elem && !this.isCheckboxFilterTemplate) {\n      var selectAll$$1 = elem.querySelector('.e-selectall');\n\n      if (selectAll$$1) {\n        this.updateAllCBoxes(!selectAll$$1.classList.contains('e-check'));\n      } else {\n        toogleCheckbox(elem.parentElement);\n      }\n\n      this.updateIndeterminatenBtn();\n      elem.querySelector('.e-chk-hidden').focus();\n    }\n\n    this.setFocus(parentsUntil(elem, 'e-ftrchk'));\n  };\n\n  CheckBoxFilterBase.prototype.keyupHandler = function (e) {\n    this.setFocus(parentsUntil(e.target, 'e-ftrchk'));\n  };\n\n  CheckBoxFilterBase.prototype.setFocus = function (elem) {\n    var prevElem = this.dlg.querySelector('.e-chkfocus');\n\n    if (prevElem) {\n      prevElem.classList.remove('e-chkfocus');\n    }\n\n    if (elem) {\n      elem.classList.add('e-chkfocus');\n    }\n  };\n\n  CheckBoxFilterBase.prototype.updateAllCBoxes = function (checked) {\n    var cBoxes = [].slice.call(this.cBox.getElementsByClassName('e-frame'));\n\n    for (var _i = 0, cBoxes_1 = cBoxes; _i < cBoxes_1.length; _i++) {\n      var cBox = cBoxes_1[_i];\n      removeAddCboxClasses(cBox, checked);\n      setChecked(cBox.previousSibling, checked);\n    }\n  };\n\n  CheckBoxFilterBase.prototype.dialogOpen = function () {\n    if (this.parent.element.classList.contains('e-device')) {\n      this.dialogObj.element.querySelector('.e-input-group').classList.remove('e-input-focus');\n\n      if (!this.options.isResponsiveFilter) {\n        this.dialogObj.element.querySelector('.e-btn').focus();\n      }\n    }\n  };\n\n  CheckBoxFilterBase.prototype.createCheckbox = function (value, checked, data) {\n    var elem = checked ? this.cBoxTrue.cloneNode(true) : this.cBoxFalse.cloneNode(true);\n    setChecked(elem.querySelector('input'), checked);\n    var label = elem.querySelector('.e-label');\n    var dummyData = extendObjWithFn({}, data, {\n      column: this.options.column,\n      parent: this.parent\n    });\n    var innerText = this.options.disableHtmlEncode ? 'textContent' : 'innerHTML';\n    label[innerText] = !isNullOrUndefined(value) && value.toString().length ? value : this.getLocalizedLabel('Blanks');\n\n    if (label.innerHTML === this.getLocalizedLabel('Blanks')) {\n      this.isBlanks = true;\n    }\n\n    if (typeof value === 'boolean') {\n      label.innerHTML = value === true ? this.getLocalizedLabel('FilterTrue') : this.getLocalizedLabel('FilterFalse');\n    }\n\n    addClass([label], ['e-checkboxfiltertext']);\n\n    if (this.options.template && data[this.options.column.field] !== this.getLocalizedLabel('SelectAll')) {\n      label.innerHTML = '';\n      var isReactCompiler = this.parent.isReact && this.options.column.filter && typeof this.options.column.filter.itemTemplate !== 'string'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n\n      if (isReactCompiler || isReactChild) {\n        this.options.template(dummyData, this.parent, 'filterItemTemplate', null, null, null, label);\n        this.parent.renderTemplates();\n      } else {\n        appendChildren(label, this.options.template(dummyData, this.parent, 'filterItemTemplate'));\n      }\n    }\n\n    return elem;\n  };\n\n  CheckBoxFilterBase.prototype.updateIndeterminatenBtn = function () {\n    var cnt = this.cBox.children.length - 1;\n    var className = [];\n    var disabled = false;\n    var elem = this.cBox.querySelector('.e-selectall');\n    var selected = this.cBox.querySelectorAll('.e-check:not(.e-selectall)').length;\n    var btn;\n\n    if (!this.options.isResponsiveFilter) {\n      btn = this.dialogObj.btnObj[0];\n      btn.disabled = false;\n    }\n\n    var input = elem.previousSibling;\n    setChecked(input, false);\n    input.indeterminate = false;\n\n    if (cnt === selected) {\n      className = ['e-check'];\n      setChecked(input, true);\n    } else if (selected) {\n      className = ['e-stop'];\n      input.indeterminate = true;\n    } else {\n      className = ['e-uncheck'];\n      disabled = true;\n\n      if (btn) {\n        btn.disabled = true;\n      }\n    }\n\n    if (btn) {\n      this.filterState = !btn.disabled;\n      btn.dataBind();\n    }\n\n    removeClass([elem], ['e-check', 'e-stop', 'e-uncheck']);\n    addClass([elem], className);\n    this.parent.notify(refreshCustomFilterOkBtn, {\n      disabled: disabled\n    });\n  };\n\n  CheckBoxFilterBase.prototype.createFilterItems = function (data, isInitial, args1) {\n    var _a;\n\n    var cBoxes = this.parent.createElement('div');\n    var btn;\n    var disabled = false;\n\n    if (!this.options.isResponsiveFilter) {\n      btn = this.dialogObj.btnObj[0];\n    }\n\n    var nullCounter = -1;\n    var key = 'ejValue';\n\n    if (!args1.executeQuery) {\n      key = args1.field;\n    }\n\n    for (var i = 0; i < data.length; i++) {\n      var val = getValue(key, data[i]);\n\n      if (val === '' || isNullOrUndefined(val)) {\n        nullCounter = nullCounter + 1;\n      }\n    }\n\n    this.itemsCnt = nullCounter !== -1 ? data.length - nullCounter : data.length;\n\n    if (data.length && !this.renderEmpty) {\n      var selectAllValue = this.getLocalizedLabel('SelectAll');\n      var innerDiv = this.cBox.querySelector('.e-checkfltrnmdiv');\n\n      if (innerDiv) {\n        innerDiv.classList.remove('e-checkfltrnmdiv');\n      }\n\n      var checkBox = this.createCheckbox(selectAllValue, false, (_a = {}, _a[this.options.field] = selectAllValue, _a));\n\n      if (this.parent.cssClass) {\n        addClass([checkBox], [this.parent.cssClass]);\n      }\n\n      var selectAll$$1 = createCboxWithWrap(getUid('cbox'), checkBox, 'e-ftrchk');\n      selectAll$$1.querySelector('.e-frame').classList.add('e-selectall');\n      cBoxes.appendChild(selectAll$$1);\n      var predicate = new Predicate('field', 'equal', this.options.field);\n\n      if (this.options.foreignKeyValue) {\n        predicate = predicate.or('field', 'equal', this.options.foreignKeyValue);\n      }\n\n      var isColFiltered = new DataManager(this.options.filteredColumns).executeLocal(new Query().where(predicate)).length;\n      var isRndere = void 0;\n\n      for (var i = 0; i < data.length; i++) {\n        var uid = getUid('cbox');\n        this.values[uid] = getValue(key, data[i]);\n        var value = getValue(this.options.field, data[i]);\n\n        if (this.options.formatFn) {\n          value = this.valueFormatter.toView(value, this.options.formatFn);\n        }\n\n        var args_1 = {\n          value: value,\n          column: this.options.column,\n          data: data[i]\n        };\n        this.parent.notify(filterCboxValue, args_1);\n        value = args_1.value;\n\n        if (value === '' || isNullOrUndefined(value)) {\n          if (isRndere) {\n            continue;\n          }\n\n          isRndere = true;\n        }\n\n        var checkbox = this.createCheckbox(value, this.getCheckedState(isColFiltered, this.values[uid]), getValue('dataObj', data[i]));\n        cBoxes.appendChild(createCboxWithWrap(uid, checkbox, 'e-ftrchk'));\n      }\n\n      this.cBox.innerHTML = '';\n      appendChildren(this.cBox, [].slice.call(cBoxes.children));\n      this.updateIndeterminatenBtn();\n\n      if (btn) {\n        btn.disabled = false;\n      }\n\n      disabled = false;\n    } else {\n      cBoxes.appendChild(this.parent.createElement('span', {\n        innerHTML: this.getLocalizedLabel('NoResult')\n      }));\n      this.cBox.innerHTML = '';\n      this.cBox.appendChild(this.parent.createElement('div', {\n        className: 'e-checkfltrnmdiv'\n      }));\n      appendChildren(this.cBox.children[0], [].slice.call(cBoxes.children));\n\n      if (btn) {\n        btn.disabled = true;\n      }\n\n      disabled = true;\n    }\n\n    if (btn && data.length) {\n      this.filterState = !btn.disabled;\n      btn.dataBind();\n    }\n\n    var args = {\n      requestType: filterChoiceRequest,\n      dataSource: this.renderEmpty ? [] : data\n    };\n    var filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.notify(cBoxFltrComplete, args);\n    this.parent.notify(refreshCustomFilterOkBtn, {\n      disabled: disabled\n    });\n    hideSpinner(this.spinner);\n  };\n\n  CheckBoxFilterBase.prototype.getCheckedState = function (isColFiltered, value) {\n    if (!this.isFiltered || !isColFiltered) {\n      return true;\n    } else {\n      var checkState = this.result[value];\n      return this.options.operator === 'notequal' ? !checkState : checkState;\n    }\n  };\n\n  CheckBoxFilterBase.getDistinct = function (json, field, column, foreignKeyData$$1) {\n    var len = json.length;\n    var result = [];\n    var value;\n    var ejValue = 'ejValue';\n    var lookup = {};\n    var isForeignKey = column && column.isForeignColumn ? column.isForeignColumn() : false;\n\n    while (len--) {\n      value = json[len];\n      value = getObject(field, value); //local remote diff, check with mdu\n\n      if (!(value in lookup)) {\n        var obj = {};\n        obj[ejValue] = value;\n        lookup[value] = true;\n\n        if (isForeignKey) {\n          var foreignDataObj = getForeignData(column, {}, value, foreignKeyData$$1)[0];\n          setValue(foreignKeyData, foreignDataObj, json[len]);\n          value = getValue(column.foreignKeyValue, foreignDataObj);\n        }\n\n        setValue(field, isNullOrUndefined(value) ? null : value, obj);\n        setValue('dataObj', json[len], obj);\n        result.push(obj);\n      }\n    }\n\n    return DataUtil.group(DataUtil.sort(result, field, DataUtil.fnAscending), 'ejValue');\n  };\n\n  CheckBoxFilterBase.getPredicate = function (columns) {\n    var cols = DataUtil.distinct(columns, 'field', true) || [];\n    var collection = [];\n    var pred = {};\n\n    for (var i = 0; i < cols.length; i++) {\n      collection = new DataManager(columns).executeLocal(new Query().where('field', 'equal', cols[i].field));\n\n      if (collection.length !== 0) {\n        pred[cols[i].field] = CheckBoxFilterBase.generatePredicate(collection);\n      }\n    }\n\n    return pred;\n  };\n\n  CheckBoxFilterBase.generatePredicate = function (cols) {\n    var len = cols ? cols.length : 0;\n    var predicate;\n    var operate = 'or';\n    var first = CheckBoxFilterBase.updateDateFilter(cols[0]);\n    first.ignoreAccent = !isNullOrUndefined(first.ignoreAccent) ? first.ignoreAccent : false;\n\n    if (first.type === 'date' || first.type === 'datetime') {\n      predicate = getDatePredicate(first, first.type);\n    } else {\n      predicate = first.ejpredicate ? first.ejpredicate : new Predicate(first.field, first.operator, first.value, !CheckBoxFilterBase.getCaseValue(first), first.ignoreAccent);\n    }\n\n    for (var p = 1; p < len; p++) {\n      cols[p] = CheckBoxFilterBase.updateDateFilter(cols[p]);\n\n      if (len > 2 && p > 1 && cols[p].predicate === 'or') {\n        if (cols[p].type === 'date' || cols[p].type === 'datetime') {\n          predicate.predicates.push(getDatePredicate(cols[p], cols[p].type));\n        } else {\n          predicate.predicates.push(new Predicate(cols[p].field, cols[p].operator, cols[p].value, !CheckBoxFilterBase.getCaseValue(cols[p]), cols[p].ignoreAccent));\n        }\n      } else {\n        if (cols[p].type === 'date' || cols[p].type === 'datetime') {\n          if (cols[p].predicate === 'and' && cols[p].operator === 'equal') {\n            predicate = predicate[operate](getDatePredicate(cols[p], cols[p].type), cols[p].type, cols[p].ignoreAccent);\n          } else {\n            predicate = predicate[cols[p].predicate](getDatePredicate(cols[p], cols[p].type), cols[p].type, cols[p].ignoreAccent);\n          }\n        } else {\n          predicate = cols[p].ejpredicate ? predicate[cols[p].predicate](cols[p].ejpredicate) : predicate[cols[p].predicate](cols[p].field, cols[p].operator, cols[p].value, !CheckBoxFilterBase.getCaseValue(cols[p]), cols[p].ignoreAccent);\n        }\n      }\n    }\n\n    return predicate || null;\n  };\n\n  CheckBoxFilterBase.getCaseValue = function (filter) {\n    if (isNullOrUndefined(filter.matchCase)) {\n      if (filter.type === 'string' || isNullOrUndefined(filter.type) && typeof filter.value === 'string') {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      return filter.matchCase;\n    }\n  };\n\n  CheckBoxFilterBase.updateDateFilter = function (filter) {\n    if (filter.type === 'date' || filter.type === 'datetime' || filter.value instanceof Date) {\n      filter.type = filter.type || 'date';\n    }\n\n    return filter;\n  };\n\n  return CheckBoxFilterBase;\n}();\n\nvar __extends$18 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @hidden\n * `ExcelFilter` module is used to handle filtering action.\n */\n\n\nvar ExcelFilterBase =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$18(ExcelFilterBase, _super);\n  /**\n   * Constructor for excel filtering module\n   *\n   * @param {IXLFilter} parent - parent details\n   * @param {Object} customFltrOperators - operator details\n   * @hidden\n   */\n\n\n  function ExcelFilterBase(parent, customFltrOperators) {\n    var _this = _super.call(this, parent) || this;\n\n    _this.childRefs = [];\n    _this.eventHandlers = {};\n    _this.isDevice = false;\n    _this.customFilterOperators = customFltrOperators;\n    _this.isExcel = true;\n    return _this;\n  }\n\n  ExcelFilterBase.prototype.getCMenuDS = function (type, operator) {\n    var options = {\n      number: ['Equal', 'NotEqual', '', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'Between', '', 'CustomFilter'],\n      string: ['Equal', 'NotEqual', '', 'StartsWith', 'EndsWith', '', 'Contains', '', 'CustomFilter']\n    };\n    options.date = options.number;\n    options.datetime = options.number;\n    var model = [];\n\n    for (var i = 0; i < options[type].length; i++) {\n      if (options[type][i].length) {\n        if (operator) {\n          model.push({\n            text: this.getLocalizedLabel(options[type][i]) + '...',\n            iconCss: 'e-icons e-icon-check ' + (operator === options[type][i].toLowerCase() ? '' : 'e-emptyicon')\n          });\n        } else {\n          model.push({\n            text: this.getLocalizedLabel(options[type][i]) + '...'\n          });\n        }\n      } else {\n        model.push({\n          separator: true\n        });\n      }\n    }\n\n    return model;\n  };\n  /**\n   * To destroy the filter bar.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ExcelFilterBase.prototype.destroy = function () {\n    if (this.dlg) {\n      this.unwireExEvents();\n\n      _super.prototype.closeDialog.call(this);\n    }\n\n    if (!this.isDevice && this.menuObj) {\n      var li = this.menuObj.element.querySelector('li.e-focused');\n\n      if (!(li && parentsUntil(li, 'e-excel-menu'))) {\n        this.destroyCMenu();\n      }\n    }\n\n    if (this.dlgObj && !this.dlgObj.isDestroyed) {\n      this.removeDialog();\n    }\n  };\n\n  ExcelFilterBase.prototype.createMenu = function (type, isFiltered, isCheckIcon, eleOptions) {\n    var options = {\n      string: 'TextFilter',\n      date: 'DateFilter',\n      datetime: 'DateTimeFilter',\n      number: 'NumberFilter'\n    };\n    this.menu = this.parent.createElement('div', {\n      className: 'e-contextmenu-wrapper'\n    });\n\n    if (this.parent.enableRtl) {\n      this.menu.classList.add('e-rtl');\n    } else {\n      this.menu.classList.remove('e-rtl');\n    }\n\n    if (this.parent.cssClass) {\n      this.menu.classList.add(this.parent.cssClass);\n    }\n\n    var ul = this.parent.createElement('ul');\n    var icon = isFiltered ? 'e-excl-filter-icon e-filtered' : 'e-excl-filter-icon'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    if (this.parent.allowSorting && this.parent.getModuleName() === 'grid' && !this.options.isResponsiveFilter) {\n      var hdrele = this.parent.getColumnHeaderByUid(eleOptions.uid).getAttribute('aria-sort');\n      var colIsSort = this.parent.getColumnByField(eleOptions.field).allowSorting;\n      var isAsc = !colIsSort || hdrele === 'ascending' ? 'e-disabled e-excel-ascending' : 'e-excel-ascending';\n      var isDesc = !colIsSort || hdrele === 'descending' ? 'e-disabled e-excel-descending' : 'e-excel-descending';\n      var ascName = type === 'string' ? this.getLocalizedLabel('SortAtoZ') : type === 'datetime' || type === 'date' ? this.getLocalizedLabel('SortByOldest') : this.getLocalizedLabel('SortSmallestToLargest');\n      var descName = type === 'string' ? this.getLocalizedLabel('SortZtoA') : type === 'datetime' || type === 'date' ? this.getLocalizedLabel('SortByNewest') : this.getLocalizedLabel('SortLargestToSmallest');\n      ul.appendChild(this.createMenuElem(ascName, isAsc, 'e-sortascending'));\n      ul.appendChild(this.createMenuElem(descName, isDesc, 'e-sortdescending'));\n      var separator = this.parent.createElement('li', {\n        className: 'e-separator e-menu-item e-excel-separator'\n      });\n      ul.appendChild(separator);\n    }\n\n    if (!this.options.isResponsiveFilter) {\n      ul.appendChild(this.createMenuElem(this.getLocalizedLabel('ClearFilter'), isFiltered ? '' : 'e-disabled', icon));\n    }\n\n    if (type !== 'boolean') {\n      ul.appendChild(this.createMenuElem(this.getLocalizedLabel(options[type]), 'e-submenu', isCheckIcon && this.ensureTextFilter() ? 'e-icon-check' : icon + ' e-emptyicon', true));\n    }\n\n    this.menu.appendChild(ul);\n    this.parent.notify(beforeFltrcMenuOpen, {\n      element: this.menu\n    });\n    this.parent.notify(refreshCustomFilterClearBtn, {\n      isFiltered: isFiltered\n    });\n  };\n\n  ExcelFilterBase.prototype.createMenuElem = function (val, className, iconName, isSubMenu) {\n    var li = this.parent.createElement('li', {\n      className: className + ' e-menu-item'\n    });\n    li.innerHTML = val;\n    li.insertBefore(this.parent.createElement('span', {\n      className: 'e-menu-icon e-icons ' + iconName,\n      attrs: {\n        'aria-hidden': 'true'\n      }\n    }), li.firstChild);\n\n    if (isSubMenu) {\n      li.appendChild(this.parent.createElement('span', {\n        className: 'e-icons e-caret'\n      }));\n    }\n\n    return li;\n  };\n\n  ExcelFilterBase.prototype.wireExEvents = function () {\n    EventHandler.add(this.dlg, 'mouseover', this.hoverHandler, this);\n    EventHandler.add(this.dlg, 'click', this.clickExHandler, this);\n  };\n\n  ExcelFilterBase.prototype.unwireExEvents = function () {\n    EventHandler.remove(this.dlg, 'mouseover', this.hoverHandler);\n    EventHandler.remove(this.dlg, 'click', this.clickExHandler);\n  };\n\n  ExcelFilterBase.prototype.clickExHandler = function (e) {\n    var options = {\n      string: 'TextFilter',\n      date: 'DateFilter',\n      datetime: 'DateTimeFilter',\n      number: 'NumberFilter'\n    };\n    var menuItem = parentsUntil(e.target, 'e-menu-item');\n\n    if (menuItem) {\n      if (this.getLocalizedLabel('ClearFilter') === menuItem.innerText.trim()) {\n        this.clearFilter();\n        this.closeDialog();\n      } else if (this.options.isResponsiveFilter && this.getLocalizedLabel(options[this.options.type]) === menuItem.innerText.trim()) {\n        this.hoverHandler(e);\n      }\n    }\n  };\n\n  ExcelFilterBase.prototype.destroyCMenu = function () {\n    this.isCMenuOpen = false;\n\n    if (this.menuObj && !this.menuObj.isDestroyed) {\n      this.menuObj.destroy();\n      remove(this.cmenu);\n      this.parent.notify(renderResponsiveCmenu, {\n        target: null,\n        header: '',\n        isOpen: false,\n        col: this.options.column\n      });\n    }\n  };\n\n  ExcelFilterBase.prototype.hoverHandler = function (e) {\n    if (this.options.isResponsiveFilter && e.type === 'mouseover') {\n      return;\n    }\n\n    var target = e.target.querySelector('.e-contextmenu');\n    var li = parentsUntil(e.target, 'e-menu-item');\n    var focused = this.menu.querySelector('.e-focused');\n    var isSubMenu;\n\n    if (focused) {\n      focused.classList.remove('e-focused');\n    }\n\n    if (li) {\n      li.classList.add('e-focused');\n      isSubMenu = li.classList.contains('e-submenu');\n    }\n\n    if (target) {\n      return;\n    }\n\n    if (!isSubMenu) {\n      var submenu = this.menu.querySelector('.e-submenu');\n\n      if (!isNullOrUndefined(submenu)) {\n        submenu.classList.remove('e-selected');\n      }\n\n      this.destroyCMenu();\n    }\n\n    var selectedMenu = this.ensureTextFilter();\n\n    if (!this.isCMenuOpen && isSubMenu) {\n      li.classList.add('e-selected');\n      this.isCMenuOpen = true;\n      var menuOptions = {\n        items: this.getCMenuDS(this.options.type, selectedMenu ? selectedMenu.replace(/\\s/g, '') : undefined),\n        select: this.selectHandler.bind(this),\n        onClose: this.destroyCMenu.bind(this),\n        enableRtl: this.parent.enableRtl,\n        beforeClose: this.preventClose.bind(this),\n        cssClass: this.options.isResponsiveFilter && this.parent.cssClass ? 'e-res-contextmenu-wrapper' + ' ' + this.parent.cssClass : this.options.isResponsiveFilter ? 'e-res-contextmenu-wrapper' : this.parent.cssClass ? this.parent.cssClass : ''\n      };\n      this.parent.element.appendChild(this.cmenu);\n      this.menuObj = new ContextMenu(menuOptions, this.cmenu);\n      var client = this.menu.querySelector('.e-submenu').getBoundingClientRect();\n      var pos = {\n        top: 0,\n        left: 0\n      };\n\n      if (this.options.isResponsiveFilter) {\n        var options = {\n          string: 'TextFilter',\n          date: 'DateFilter',\n          datetime: 'DateTimeFilter',\n          number: 'NumberFilter'\n        };\n        var content$$1 = document.querySelector('.e-responsive-dialog > .e-dlg-header-content');\n        var height = content$$1.offsetHeight + 4;\n        this.menuObj.element.style.height = 'calc(100% - ' + height + 'px)';\n        this.menuObj.open(height, 0, document.body);\n        var header = this.getLocalizedLabel(options[this.options.type]);\n        this.parent.notify(renderResponsiveCmenu, {\n          target: this.menuObj.element.parentElement,\n          header: header,\n          isOpen: true\n        });\n      } else {\n        if (Browser.isDevice) {\n          this.isDevice = true;\n          var contextRect = this.getContextBounds();\n          pos.top = (window.innerHeight - contextRect.height) / 2;\n          pos.left = (window.innerWidth - contextRect.width) / 2;\n          this.closeDialog();\n          this.isDevice = false;\n        } else {\n          pos.top = Browser.isIE ? window.pageYOffset + client.top : window.scrollY + client.top;\n          pos.left = this.getCMenuYPosition(this.dlg);\n        }\n\n        this.menuObj.open(pos.top, pos.left, e.target);\n      }\n\n      applyBiggerTheme(this.parent.element, this.menuObj.element.parentElement);\n    }\n  };\n\n  ExcelFilterBase.prototype.ensureTextFilter = function () {\n    var selectedMenu;\n    var predicates = this.existingPredicate[this.options.field];\n\n    if (predicates && predicates.length === 2) {\n      if (predicates[0].operator === 'greaterthanorequal' && predicates[1].operator === 'lessthanorequal') {\n        selectedMenu = 'between';\n      } else {\n        selectedMenu = 'customfilter';\n      }\n    } else {\n      if (predicates && predicates.length === 1) {\n        this.optrData = this.customFilterOperators[this.options.type + 'Operator'];\n        selectedMenu = predicates[0].operator;\n      }\n    }\n\n    return selectedMenu;\n  };\n\n  ExcelFilterBase.prototype.preventClose = function (args) {\n    if (this.options && this.options.isResponsiveFilter && args.event) {\n      var target = args.event.target;\n      var isFilterBack = target.classList.contains('e-resfilterback') || target.classList.contains('e-res-back-btn') || target.classList.contains('e-menu-item');\n      args.cancel = !isFilterBack;\n    } else {\n      if (args.event instanceof MouseEvent && args.event.target.classList.contains('e-submenu')) {\n        args.cancel = true;\n      }\n    }\n  };\n\n  ExcelFilterBase.prototype.getContextBounds = function () {\n    this.menuObj.element.style.display = 'block';\n    return this.menuObj.element.getBoundingClientRect();\n  };\n\n  ExcelFilterBase.prototype.getCMenuYPosition = function (target) {\n    var contextWidth = this.getContextBounds().width;\n    var targetPosition = target.getBoundingClientRect();\n    var leftPos = targetPosition.right + contextWidth - this.parent.element.clientWidth;\n    var targetBorder = target.offsetWidth - target.clientWidth;\n    targetBorder = targetBorder ? targetBorder + 1 : 0;\n    return leftPos < 1 ? targetPosition.right + 1 - targetBorder : targetPosition.left - contextWidth - 1 + targetBorder;\n  };\n\n  ExcelFilterBase.prototype.openDialog = function (options) {\n    var _this = this;\n\n    this.updateModel(options);\n    this.getAndSetChkElem(options);\n    this.showDialog(options);\n\n    if (options.cancel) {\n      return;\n    }\n\n    this.dialogObj.dataBind();\n    var filterLength = this.existingPredicate[options.field] && this.existingPredicate[options.field].length || this.options.filteredColumns.filter(function (col) {\n      return _this.options.field === col.field;\n    }).length;\n    this.createMenu(options.type, filterLength > 0, filterLength === 1 || filterLength === 2, options);\n    this.dlg.insertBefore(this.menu, this.dlg.firstChild);\n    this.dlg.classList.add('e-excelfilter');\n\n    if (this.parent.enableRtl) {\n      this.dlg.classList.add('e-rtl');\n    }\n\n    this.dlg.classList.remove('e-checkboxfilter');\n    this.cmenu = this.parent.createElement('ul', {\n      className: 'e-excel-menu'\n    });\n\n    if (options.column.showColumnMenu) {\n      this.parent.notify(filterDialogCreated, {});\n    }\n\n    this.wireExEvents();\n  };\n\n  ExcelFilterBase.prototype.closeDialog = function () {\n    this.destroy();\n  };\n\n  ExcelFilterBase.prototype.selectHandler = function (e) {\n    if (e.item) {\n      this.parent.notify(filterCmenuSelect, {});\n      this.menuItem = e.item;\n      this.renderDialogue(e);\n    }\n  };\n  /**\n   * @hidden\n   * @param {MenuEventArgs} e - event args\n   * @returns {void}\n   */\n\n\n  ExcelFilterBase.prototype.renderDialogue = function (e) {\n    var _this = this;\n\n    var target = e ? e.element : undefined;\n    var column = this.options.field;\n    var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    var complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    var mainDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-maindiv',\n      id: isComplex ? complexFieldName + '-xlflmenu' : column + '-xlflmenu'\n    });\n    this.dlgDiv = this.parent.createElement('div', {\n      className: 'e-xlflmenu',\n      id: isComplex ? complexFieldName + '-xlfldlg' : column + '-xlfldlg'\n    });\n\n    if (this.options.isResponsiveFilter) {\n      var responsiveCnt = document.querySelector('.e-resfilter > .e-dlg-content > .e-xl-customfilterdiv');\n      responsiveCnt.appendChild(this.dlgDiv);\n    } else {\n      this.parent.element.appendChild(this.dlgDiv);\n    }\n\n    this.dlgObj = new Dialog({\n      header: this.getLocalizedLabel('CustomFilter'),\n      isModal: true,\n      overlayClick: this.removeDialog.bind(this),\n      showCloseIcon: true,\n      closeOnEscape: false,\n      target: document.body,\n      // target: this.parent.element,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      open: function () {\n        var row$$1 = _this.dlgObj.element.querySelector('table.e-xlfl-table>tr');\n\n        if (_this.options.column.filterTemplate) {\n          var templateField = isComplexField(_this.options.column.field) ? getComplexFieldID(_this.options.column.field) : _this.options.column.field;\n          row$$1.querySelector('#' + templateField + '-xlfl-frstvalue').focus();\n        } else {//(row.cells[1].querySelector('input:not([type=hidden])') as HTMLElement).focus();\n        }\n      },\n      close: this.removeDialog.bind(this),\n      created: this.createdDialog.bind(this, target, column),\n      buttons: [{\n        click: this.filterBtnClick.bind(this, column),\n        buttonModel: {\n          content: this.getLocalizedLabel('OKButton'),\n          isPrimary: true,\n          cssClass: this.parent.cssClass ? 'e-xlfl-okbtn' + ' ' + this.parent.cssClass : 'e-xlfl-okbtn'\n        }\n      }, {\n        click: this.removeDialog.bind(this),\n        buttonModel: {\n          content: this.getLocalizedLabel('CancelButton'),\n          cssClass: this.parent.cssClass ? 'e-xlfl-cancelbtn' + ' ' + this.parent.cssClass : 'e-xlfl-cancelbtn'\n        }\n      }],\n      content: mainDiv,\n      width: 430,\n      animationSettings: {\n        effect: 'None'\n      },\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    var isStringTemplate = 'isStringTemplate';\n    this.dlgObj[isStringTemplate] = true;\n    this.renderResponsiveDialog();\n    this.dlgDiv.setAttribute('aria-label', this.getLocalizedLabel('CustomFilterDialogARIA'));\n    this.childRefs.push(this.dlgObj);\n    this.dlgObj.appendTo(this.dlgDiv);\n  };\n\n  ExcelFilterBase.prototype.renderResponsiveDialog = function () {\n    if (this.options.isResponsiveFilter) {\n      var rowResponsiveDlg = document.querySelector('.e-row-responsive-filter');\n\n      if (rowResponsiveDlg) {\n        rowResponsiveDlg.classList.remove('e-row-responsive-filter');\n      }\n\n      this.dlgObj.buttons = [{}];\n      this.dlgObj.header = undefined;\n      this.dlgObj.position = {\n        X: '',\n        Y: ''\n      };\n      this.dlgObj.target = document.querySelector('.e-resfilter > .e-dlg-content > .e-xl-customfilterdiv');\n      this.dlgObj.width = '100%';\n      this.dlgObj.isModal = false;\n      this.dlgObj.showCloseIcon = false;\n    }\n  };\n  /**\n   * @hidden\n   * @returns {void}\n   */\n\n\n  ExcelFilterBase.prototype.removeDialog = function () {\n    this.parent.notify(customFilterClose, {});\n\n    if ((this.parent.isReact || this.parent.isVue) && this.parent.destroyTemplate !== undefined) {\n      clearReactVueTemplates(this.parent, ['filterTemplate']);\n    }\n\n    this.removeObjects(this.childRefs);\n    remove(this.dlgDiv);\n    this.parent.notify(filterDialogClose, {});\n  };\n\n  ExcelFilterBase.prototype.createdDialog = function (target, column) {\n    this.renderCustomFilter(target, column);\n    this.dlgObj.element.style.left = '0px';\n\n    if (!this.options.isResponsiveFilter) {\n      this.dlgObj.element.style.top = '0px';\n    } else {\n      var content$$1 = document.querySelector('.e-responsive-dialog > .e-dlg-header-content');\n      var height = content$$1.offsetHeight + 4;\n      this.dlgObj.element.style.top = height + 'px';\n    }\n\n    if (!this.options.isResponsiveFilter && Browser.isDevice && window.innerWidth < 440) {\n      this.dlgObj.element.style.width = '90%';\n    }\n\n    this.parent.notify(beforeCustomFilterOpen, {\n      column: column,\n      dialog: this.dialogObj\n    });\n    this.dlgObj.show();\n    applyBiggerTheme(this.parent.element, this.dlgObj.element.parentElement);\n  };\n\n  ExcelFilterBase.prototype.renderCustomFilter = function (target, column) {\n    var dlgConetntEle = this.dlgObj.element.querySelector('.e-xlfl-maindiv');\n    var dlgFields = this.parent.createElement('div', {\n      innerHTML: this.getLocalizedLabel('ShowRowsWhere'),\n      className: 'e-xlfl-dlgfields'\n    });\n    dlgConetntEle.appendChild(dlgFields); //column name\n\n    var fieldSet = this.parent.createElement('div', {\n      innerHTML: this.options.displayName,\n      className: 'e-xlfl-fieldset'\n    });\n    dlgConetntEle.appendChild(fieldSet);\n    this.renderFilterUI(column, dlgConetntEle);\n  };\n  /**\n   * @hidden\n   * @param {string} col - Defines column details\n   * @returns {void}\n   */\n\n\n  ExcelFilterBase.prototype.filterBtnClick = function (col) {\n    var isComplex = !isNullOrUndefined(col) && isComplexField(col);\n    var complexFieldName = !isNullOrUndefined(col) && getComplexFieldID(col);\n    var colValue = isComplex ? complexFieldName : col;\n    var fValue = this.dlgDiv.querySelector('#' + colValue + '-xlfl-frstvalue').ej2_instances[0];\n    var fOperator = this.dlgDiv.querySelector('#' + colValue + '-xlfl-frstoptr').ej2_instances[0];\n    var sValue = this.dlgDiv.querySelector('#' + colValue + '-xlfl-secndvalue').ej2_instances[0];\n    var sOperator = this.dlgDiv.querySelector('#' + colValue + '-xlfl-secndoptr').ej2_instances[0];\n    var checkBoxValue;\n\n    if (this.options.type === 'string') {\n      var checkBox = this.dlgDiv.querySelector('#' + colValue + '-xlflmtcase').ej2_instances[0];\n      checkBoxValue = checkBox.checked;\n    }\n\n    var andRadio = this.dlgDiv.querySelector('#' + colValue + 'e-xlfl-frstpredicate').ej2_instances[0];\n    var predicate = andRadio.checked ? 'and' : 'or';\n\n    if (sValue.value === null) {\n      predicate = 'or';\n    }\n\n    this.filterByColumn(this.options.field, fOperator.value, fValue.value, predicate, checkBoxValue, this.options.ignoreAccent, sOperator.value, sValue.value);\n    this.removeDialog();\n  };\n  /**\n   * @hidden\n   * Filters grid row by column name with given options.\n   *\n   * @param {string} fieldName - Defines the field name of the filter column.\n   * @param {string} firstOperator - Defines the first operator by how to filter records.\n   * @param {string | number | Date | boolean} firstValue - Defines the first value which is used to filter records.\n   * @param  {string} predicate - Defines the relationship between one filter query with another by using AND or OR predicate.\n   * @param {boolean} matchCase - If ignore case set to true, then filter records with exact match or else\n   * filter records with case insensitive(uppercase and lowercase letters treated as same).\n   * @param {boolean} ignoreAccent - If ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.\n   * @param {string} secondOperator - Defines the second operator by how to filter records.\n   * @param {string | number | Date | boolean} secondValue - Defines the first value which is used to filter records.\n   * @returns {void}\n   */\n\n\n  ExcelFilterBase.prototype.filterByColumn = function (fieldName, firstOperator, firstValue, predicate, matchCase, ignoreAccent, secondOperator, secondValue) {\n    var col = this.parent.getColumnByField ? this.parent.getColumnByField(fieldName) : this.options.column;\n    var field = this.isForeignColumn(col) ? col.foreignKeyValue : fieldName;\n    var fColl = [];\n    var mPredicate;\n    fColl.push({\n      field: field,\n      predicate: predicate,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      operator: firstOperator,\n      value: firstValue,\n      type: this.options.type\n    });\n    var arg = {\n      instance: this,\n      handler: this.filterByColumn,\n      arg1: fieldName,\n      arg2: firstOperator,\n      arg3: firstValue,\n      arg4: predicate,\n      arg5: matchCase,\n      arg6: ignoreAccent,\n      arg7: secondOperator,\n      arg8: secondValue,\n      cancel: false\n    };\n    this.parent.notify(fltrPrevent, arg);\n\n    if (arg.cancel) {\n      return;\n    }\n\n    mPredicate = new Predicate(field, firstOperator.toLowerCase(), firstValue, !matchCase, ignoreAccent);\n\n    if (!isNullOrUndefined(secondValue) && !isNullOrUndefined(secondOperator)) {\n      fColl.push({\n        field: field,\n        predicate: predicate,\n        matchCase: matchCase,\n        ignoreAccent: ignoreAccent,\n        operator: secondOperator,\n        value: secondValue,\n        type: this.options.type\n      }); // eslint-disable-next-line max-len\n\n      mPredicate = mPredicate[predicate](field, secondOperator.toLowerCase(), secondValue, !matchCase, ignoreAccent);\n    }\n\n    var args = {\n      action: 'filtering',\n      filterCollection: fColl,\n      field: this.options.field,\n      ejpredicate: mPredicate,\n      actualPredicate: fColl\n    };\n\n    if (this.isForeignColumn(col)) {\n      this.foreignKeyFilter(args, fColl, mPredicate);\n    } else {\n      this.options.handler(args);\n    }\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderOperatorUI = function (column, table$$1, elementID, predicates, isFirst) {\n    var fieldElement = this.parent.createElement('tr', {\n      className: 'e-xlfl-fields',\n      attrs: {\n        role: 'row'\n      }\n    });\n    table$$1.appendChild(fieldElement);\n    var xlfloptr = this.parent.createElement('td', {\n      className: 'e-xlfl-optr'\n    });\n    fieldElement.appendChild(xlfloptr);\n    var optrDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-optrdiv'\n    });\n    var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    var complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    var optrInput = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + elementID : column + elementID\n    });\n    optrDiv.appendChild(optrInput);\n    xlfloptr.appendChild(optrDiv);\n    var optr = this.options.type + 'Operator';\n    var dropDatasource = this.customFilterOperators[optr];\n    this.optrData = dropDatasource;\n    var selectedValue = this.dropSelectedVal(this.options.column, predicates, isFirst); //Trailing three dots are sliced.\n\n    var menuText = '';\n\n    if (this.menuItem) {\n      menuText = this.menuItem.text.slice(0, -3);\n\n      if (menuText !== this.getLocalizedLabel('CustomFilter')) {\n        selectedValue = isFirst ? menuText : undefined;\n      }\n\n      if (menuText === this.getLocalizedLabel('Between')) {\n        selectedValue = this.getLocalizedLabel(isFirst ? 'GreaterThanOrEqual' : 'LessThanOrEqual');\n      }\n    }\n\n    var col = this.options.column;\n    var dropOptr = new DropDownList(extend$1({\n      dataSource: dropDatasource,\n      fields: {\n        text: 'text',\n        value: 'value'\n      },\n      text: selectedValue,\n      enableRtl: this.parent.enableRtl,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, col.filter.params));\n    this.childRefs.push(dropOptr);\n    var evt = {\n      'open': this.dropDownOpen.bind(this),\n      'change': this.dropDownValueChange.bind(this)\n    };\n    registerEventHandlers(optrInput.id, [open, change], evt, this);\n    dropOptr.addEventListener(open, this.eventHandlers[optrInput.id][open]);\n    dropOptr.addEventListener(change, this.eventHandlers[optrInput.id][change]);\n    dropOptr.appendTo(optrInput);\n    var operator = this.getSelectedValue(selectedValue);\n    return {\n      fieldElement: fieldElement,\n      operator: operator\n    };\n  };\n\n  ExcelFilterBase.prototype.removeHandlersFromComponent = function (component) {\n    if (component.element.classList.contains('e-dropdownlist')) {\n      removeEventHandlers(component, [open, change], this);\n    } else if (component.element.classList.contains('e-autocomplete')) {\n      removeEventHandlers(component, [actionComplete, focus], this);\n    }\n  };\n\n  ExcelFilterBase.prototype.dropDownOpen = function (args) {\n    args.popup.element.style.zIndex = (this.dialogObj.zIndex + 1).toString();\n  };\n\n  ExcelFilterBase.prototype.dropDownValueChange = function (args) {\n    if (args.element.id.includes('-xlfl-frstoptr')) {\n      this.firstOperator = args.value.toString();\n    } else {\n      this.secondOperator = args.value.toString();\n    }\n  };\n  /**\n   * @hidden\n   * @returns {FilterUI} returns filter UI\n   */\n\n\n  ExcelFilterBase.prototype.getFilterUIInfo = function () {\n    return {\n      firstOperator: this.firstOperator,\n      secondOperator: this.secondOperator,\n      field: this.options.field\n    };\n  };\n\n  ExcelFilterBase.prototype.getSelectedValue = function (text) {\n    var selectedField = new DataManager(this.optrData).executeLocal(new Query().where('text', 'equal', text));\n    return !isNullOrUndefined(selectedField[0]) ? selectedField[0].value : '';\n  };\n\n  ExcelFilterBase.prototype.dropSelectedVal = function (col, predicates, isFirst) {\n    var operator;\n\n    if (predicates && predicates.length > 0) {\n      operator = predicates.length === 2 ? isFirst ? predicates[0].operator : predicates[1].operator : isFirst ? predicates[0].operator : undefined;\n    } else if (isFirst && col.type === 'string' && !col.filter.operator) {\n      operator = 'startswith';\n    } else {\n      operator = isFirst ? col.filter.operator || 'equal' : undefined;\n    }\n\n    return this.getSelectedText(operator);\n  };\n\n  ExcelFilterBase.prototype.getSelectedText = function (operator) {\n    var selectedField = new DataManager(this.optrData).executeLocal(new Query().where('value', 'equal', operator));\n    return !isNullOrUndefined(selectedField[0]) ? selectedField[0].text : '';\n  };\n\n  ExcelFilterBase.prototype.renderFilterUI = function (column, dlgConetntEle) {\n    var predicates = this.existingPredicate[column];\n    var table$$1 = this.parent.createElement('table', {\n      className: 'e-xlfl-table',\n      attrs: {\n        role: 'grid'\n      }\n    });\n    dlgConetntEle.appendChild(table$$1);\n    var colGroup$$1 = this.parent.createElement(colGroup);\n    colGroup$$1.innerHTML = '<col style=\"width: 50%\"></col><col style=\"width: 50%\"></col>';\n    table$$1.appendChild(colGroup$$1); //Renders first dropdown\n\n    var optr = this.renderOperatorUI(column, table$$1, '-xlfl-frstoptr', predicates, true);\n    this.firstOperator = optr.operator; //Renders first value\n\n    this.renderFlValueUI(column, optr, '-xlfl-frstvalue', predicates, true);\n    var predicate = this.parent.createElement('tr', {\n      className: 'e-xlfl-predicate',\n      attrs: {\n        role: 'row'\n      }\n    });\n    table$$1.appendChild(predicate); //Renders first radion button\n\n    this.renderRadioButton(column, predicate, predicates); //Renders second dropdown\n\n    optr = this.renderOperatorUI(column, table$$1, '-xlfl-secndoptr', predicates, false);\n    this.secondOperator = optr.operator; //Renders second text box\n\n    this.renderFlValueUI(column, optr, '-xlfl-secndvalue', predicates, false);\n  };\n\n  ExcelFilterBase.prototype.renderRadioButton = function (column, tr, predicates) {\n    var td = this.parent.createElement('td', {\n      className: 'e-xlfl-radio',\n      attrs: {\n        'colSpan': '2'\n      }\n    });\n    tr.appendChild(td);\n    var radioDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-radiodiv',\n      attrs: {\n        'style': 'display: inline-block'\n      }\n    });\n    var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    var complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    var frstpredicate = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + 'e-xlfl-frstpredicate' : column + 'e-xlfl-frstpredicate',\n      attrs: {\n        'type': 'radio'\n      }\n    });\n    var secndpredicate = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + 'e-xlfl-secndpredicate' : column + 'e-xlfl-secndpredicate',\n      attrs: {\n        'type': 'radio'\n      }\n    }); //appends into div\n\n    radioDiv.appendChild(frstpredicate);\n    radioDiv.appendChild(secndpredicate);\n    td.appendChild(radioDiv);\n\n    if (this.options.type === 'string') {\n      this.renderMatchCase(column, tr, td, '-xlflmtcase', predicates);\n    } // Initialize AND RadioButton component.\n\n\n    var andRadio = new RadioButton({\n      label: this.getLocalizedLabel('AND'),\n      name: 'default',\n      checked: true,\n      enableRtl: this.parent.enableRtl,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    this.childRefs.push(andRadio); // Initialize OR RadioButton component.\n\n    var orRadio = new RadioButton({\n      label: this.getLocalizedLabel('OR'),\n      name: 'default',\n      enableRtl: this.parent.enableRtl,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    this.childRefs.push(orRadio);\n    var flValue = predicates && predicates.length === 2 ? predicates[1].predicate : 'and';\n\n    if (flValue === 'and') {\n      andRadio.checked = true;\n      orRadio.checked = false;\n    } else {\n      orRadio.checked = true;\n      andRadio.checked = false;\n    } // Render initialized RadioButton.\n\n\n    andRadio.appendTo(frstpredicate);\n    orRadio.appendTo(secndpredicate);\n    andRadio.element.nextElementSibling.classList.add('e-xlfl-radio-and');\n    orRadio.element.nextElementSibling.classList.add('e-xlfl-radio-or');\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  ExcelFilterBase.prototype.removeObjects = function (elements) {\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var obj = elements_1[_i];\n\n      if (obj && !obj.isDestroyed) {\n        this.removeHandlersFromComponent(obj);\n        obj.destroy();\n      }\n    }\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderFlValueUI = function (column, optr, elementId, predicates, isFirst) {\n    var value = this.parent.createElement('td', {\n      className: 'e-xlfl-value'\n    });\n    optr.fieldElement.appendChild(value);\n    var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    var complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    var valueDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-valuediv'\n    });\n    var isFilteredCol = this.options.filteredColumns.some(function (col) {\n      return column === col.field;\n    });\n    var fltrPredicates = this.options.filteredColumns.filter(function (col) {\n      return col.field === column;\n    });\n\n    if (this.options.column.filterTemplate) {\n      var data = {};\n      var columnObj = this.options.column;\n\n      if (isFilteredCol && elementId) {\n        data = this.getExcelFilterData(elementId, data, columnObj, predicates, fltrPredicates);\n      }\n\n      var isReactCompiler = this.parent.isReact && typeof this.options.column.filterTemplate !== 'string'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n      var tempID = this.parent.element.id + columnObj.uid + 'filterTemplate';\n\n      if (isReactCompiler || isReactChild) {\n        this.options.column.getFilterTemplate()(data, this.parent, 'filterTemplate', tempID, null, null, valueDiv);\n        this.parent.renderTemplates();\n      } else {\n        var element = this.options.column.getFilterTemplate()(data, this.parent, 'filterTemplate', tempID);\n        appendChildren(valueDiv, element);\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      (this.parent.isAngular ? valueDiv.children[0] : valueDiv.querySelector('input')).id = isComplex ? complexFieldName + elementId : column + elementId;\n      value.appendChild(valueDiv);\n    } else {\n      var valueInput = this.parent.createElement('input', {\n        id: isComplex ? complexFieldName + elementId : column + elementId\n      });\n      valueDiv.appendChild(valueInput);\n      value.appendChild(valueDiv);\n      var flValue = void 0;\n      var predicate = void 0;\n\n      if (predicates && predicates.length > 0) {\n        predicate = predicates.length === 2 ? isFirst ? predicates[0] : predicates[1] : isFirst ? predicates[0] : undefined;\n        flValue = predicate && predicate.operator === optr.operator ? predicate.value : undefined;\n\n        if (isNullOrUndefined(flValue)) {\n          flValue = undefined;\n        }\n      }\n\n      var types = {\n        'string': this.renderAutoComplete.bind(this),\n        'number': this.renderNumericTextBox.bind(this),\n        'date': this.renderDate.bind(this),\n        'datetime': this.renderDateTime.bind(this)\n      };\n      types[this.options.type](this.options, column, valueInput, flValue, this.parent.enableRtl);\n    }\n  };\n\n  ExcelFilterBase.prototype.getExcelFilterData = function (elementId, data, columnObj, predicates, fltrPredicates) {\n    var predIndex = elementId === '-xlfl-frstvalue' ? 0 : 1;\n\n    if (elementId === '-xlfl-frstvalue' || fltrPredicates.length > 1) {\n      data = {\n        column: predicates instanceof Array ? predicates[predIndex] : predicates\n      };\n      var indx = this.options.column.columnData && fltrPredicates.length > 1 ? this.options.column.columnData.length === 1 ? 0 : 1 : predIndex;\n      data[this.options.field] = columnObj.foreignKeyValue ? this.options.column.columnData[indx][columnObj.foreignKeyValue] : fltrPredicates[indx].value;\n\n      if (this.options.foreignKeyValue) {\n        data[this.options.foreignKeyValue] = this.options.column.columnData[indx][columnObj.foreignKeyValue];\n      }\n    }\n\n    return data;\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderMatchCase = function (column, tr, matchCase, elementId, predicates) {\n    var matchCaseDiv = this.parent.createElement('div', {\n      className: 'e-xlfl-matchcasediv',\n      attrs: {\n        'style': 'display: inline-block'\n      }\n    });\n    var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n    var complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n    var matchCaseInput = this.parent.createElement('input', {\n      id: isComplex ? complexFieldName + elementId : column + elementId,\n      attrs: {\n        'type': 'checkbox'\n      }\n    });\n    matchCaseDiv.appendChild(matchCaseInput);\n    matchCase.appendChild(matchCaseDiv);\n    var flValue = predicates && predicates.length > 0 ? predicates && predicates.length === 2 ? predicates[1].matchCase : predicates[0].matchCase : false; // Initialize Match Case check box.\n\n    var checkbox = new CheckBox({\n      label: this.getLocalizedLabel('MatchCase'),\n      enableRtl: this.parent.enableRtl,\n      checked: flValue,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    this.childRefs.push(checkbox); // Render initialized CheckBox.\n\n    checkbox.appendTo(matchCaseInput);\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderDate = function (options, column, inputValue, fValue, isRtl) {\n    var format = getCustomDateFormat(options.format, options.type) || options.format;\n    var datePicker = new DatePicker(extend$1({\n      format: format,\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      placeholder: this.getLocalizedLabel('CustomFilterDatePlaceHolder'),\n      width: '100%',\n      enableRtl: isRtl,\n      value: new Date(fValue),\n      locale: this.parent.locale\n    }, options.column.filter.params));\n    this.childRefs.push(datePicker);\n    datePicker.appendTo(inputValue);\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderDateTime = function (options, column, inputValue, fValue, isRtl) {\n    var format = getCustomDateFormat(options.format, options.type);\n    var dateTimePicker = new DateTimePicker(extend$1({\n      format: format,\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      placeholder: this.getLocalizedLabel('CustomFilterDatePlaceHolder'),\n      width: '100%',\n      enableRtl: isRtl,\n      value: new Date(fValue),\n      locale: this.parent.locale\n    }, options.column.filter.params));\n    this.childRefs.push(dateTimePicker);\n    dateTimePicker.appendTo(inputValue);\n  };\n\n  ExcelFilterBase.prototype.completeAction = function (e) {\n    e.result = distinctStringValues(e.result);\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderNumericTextBox = function (options, column, inputValue, fValue, isRtl) {\n    var numericTextBox = new NumericTextBox(extend$1({\n      format: options.format,\n      placeholder: this.getLocalizedLabel('CustomFilterPlaceHolder'),\n      enableRtl: isRtl,\n      value: fValue,\n      locale: this.parent.locale,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, options.column.filter.params));\n    this.childRefs.push(numericTextBox);\n    numericTextBox.appendTo(inputValue);\n  }; // eslint-disable-next-line max-len\n\n\n  ExcelFilterBase.prototype.renderAutoComplete = function (options, column, inputValue, fValue, isRtl) {\n    var colObj = this.options.column;\n    var isForeignColumn = this.isForeignColumn(colObj);\n    var dataSource = isForeignColumn ? colObj.dataSource : options.dataSource;\n    var fields = {\n      value: isForeignColumn ? colObj.foreignKeyValue : column\n    };\n    var actObj = new AutoComplete(extend$1({\n      dataSource: dataSource instanceof DataManager ? dataSource : new DataManager(dataSource),\n      fields: fields,\n      query: this.getQuery(),\n      sortOrder: 'Ascending',\n      locale: this.parent.locale,\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      autofill: true,\n      placeholder: this.getLocalizedLabel('CustomFilterPlaceHolder'),\n      enableRtl: isRtl,\n      text: fValue\n    }, colObj.filter.params));\n\n    if (dataSource && 'result' in dataSource) {\n      var defObj = eventPromise({\n        requestType: 'stringfilterrequest'\n      }, this.getQuery());\n      this.parent.trigger(dataStateChange, defObj.state);\n      var def = defObj.deffered;\n      def.promise.then(function (e) {\n        actObj.dataSource = new DataManager(e);\n      });\n    }\n\n    this.childRefs.push(actObj);\n    var evt = {\n      'actionComplete': this.acActionComplete(actObj, column),\n      'focus': this.acFocus(actObj, column, options, inputValue)\n    };\n    registerEventHandlers(inputValue.id, [actionComplete, focus], evt, this);\n    actObj.addEventListener(focus, this.eventHandlers[inputValue.id][focus]);\n    actObj.addEventListener(actionComplete, this.eventHandlers[inputValue.id][actionComplete]);\n    actObj.appendTo(inputValue);\n  };\n\n  ExcelFilterBase.prototype.acActionComplete = function (actObj, column) {\n    return function (e) {\n      var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n      e.result = e.result.filter(function (obj, index, arr) {\n        return arr.map(function (mapObject) {\n          return isComplex ? performComplexDataOperation(actObj.fields.value, mapObject) : mapObject[actObj.fields.value];\n        }).indexOf(isComplex ? performComplexDataOperation(actObj.fields.value, obj) : obj[actObj.fields.value]) === index;\n      });\n    };\n  };\n\n  ExcelFilterBase.prototype.acFocus = function (actObj, column, options, inputValue) {\n    var _this = this;\n\n    return function () {\n      var isComplex = !isNullOrUndefined(column) && isComplexField(column);\n      var complexFieldName = !isNullOrUndefined(column) && getComplexFieldID(column);\n      var columnvalue = isComplex ? complexFieldName : column;\n      actObj.filterType = _this.dlgDiv.querySelector('#' + columnvalue + (inputValue.id === columnvalue + '-xlfl-frstvalue' ? '-xlfl-frstoptr' : '-xlfl-secndoptr')).ej2_instances[0].value;\n      actObj.ignoreCase = options.type === 'string' ? !_this.dlgDiv.querySelector('#' + columnvalue + '-xlflmtcase').ej2_instances[0].checked : true;\n      actObj.filterType = !isNullOrUndefined(actObj.filterType) ? actObj.filterType : 'equal';\n    };\n  };\n\n  return ExcelFilterBase;\n}(CheckBoxFilterBase);\n/**\n * Common export\n */\n\n/**\n * Base export\n */\n\n/**\n *\n * The `Sort` module is used to handle sorting action.\n */\n\n\nvar Sort =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for Grid sorting module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {SortSettings} sortSettings - specifies the SortSettings\n   * @param {string[]} sortedColumns - specifies the string\n   * @param {ServiceLocator} locator - specifies the ServiceLocator\n   * @hidden\n   */\n  function Sort(parent, sortSettings, sortedColumns, locator) {\n    this.contentRefresh = true;\n    this.isModelChanged = true;\n    this.aria = new AriaService();\n    this.currentTarget = null;\n    this.parent = parent;\n    this.sortSettings = sortSettings;\n    this.sortedColumns = sortedColumns;\n    this.serviceLocator = locator;\n    this.focus = locator.getService('focus');\n    this.addEventListener();\n    this.setFullScreenDialog();\n  }\n  /**\n   * The function used to update sortSettings\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.updateModel = function () {\n    var sortedColumn = {\n      field: this.columnName,\n      direction: this.direction\n    };\n    var index;\n    var gCols = this.parent.groupSettings.columns;\n    var flag = false;\n\n    if (!this.isMultiSort) {\n      if (!gCols.length) {\n        this.sortSettings.columns = [sortedColumn];\n      } else {\n        var sortedCols = [];\n\n        for (var i = 0, len = gCols.length; i < len; i++) {\n          index = this.getSortedColsIndexByField(gCols[i], sortedCols);\n\n          if (this.columnName === gCols[i]) {\n            flag = true;\n            sortedCols.push(sortedColumn);\n          } else {\n            var sCol = this.getSortColumnFromField(gCols[i]);\n            sortedCols.push({\n              field: sCol.field,\n              direction: sCol.direction,\n              isFromGroup: sCol.isFromGroup\n            });\n          }\n        }\n\n        if (!flag) {\n          sortedCols.push(sortedColumn);\n        }\n\n        this.sortSettings.columns = sortedCols;\n      }\n    } else {\n      index = this.getSortedColsIndexByField(this.columnName);\n\n      if (index > -1) {\n        this.sortSettings.columns.splice(index, 1);\n      }\n\n      this.sortSettings.columns.push(sortedColumn); // eslint-disable-next-line no-self-assign\n\n      this.sortSettings.columns = this.sortSettings.columns;\n    }\n\n    this.parent.dataBind();\n    this.lastSortedCol = this.columnName;\n  };\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.onActionComplete = function (e) {\n    var args = !this.isRemove ? {\n      columnName: this.columnName,\n      direction: this.direction,\n      requestType: 'sorting',\n      type: actionComplete\n    } : {\n      requestType: 'sorting',\n      type: actionComplete\n    };\n    this.isRemove = false;\n    this.parent.trigger(actionComplete, extend(e, args));\n  };\n  /**\n   * Sorts a column with the given options.\n   *\n   * @param {string} columnName - Defines the column name to sort.\n   * @param {SortDirection} direction - Defines the direction of sorting field.\n   * @param {boolean} isMultiSort - Specifies whether the previously sorted columns are to be maintained.\n   * @returns {void}\n   */\n\n\n  Sort.prototype.sortColumn = function (columnName, direction, isMultiSort) {\n    var gObj = this.parent;\n\n    if (this.parent.getColumnByField(columnName).allowSorting === false || this.parent.isContextMenuOpen()) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        columnName: columnName\n      });\n      return;\n    }\n\n    if (!gObj.allowMultiSorting) {\n      isMultiSort = gObj.allowMultiSorting;\n    }\n\n    if (this.isActionPrevent()) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.sortColumn,\n        arg1: columnName,\n        arg2: direction,\n        arg3: isMultiSort\n      });\n      return;\n    }\n\n    this.backupSettings();\n    this.columnName = columnName;\n    this.direction = direction;\n    this.isMultiSort = isMultiSort;\n    this.removeSortIcons();\n    this.updateSortedCols(columnName, isMultiSort);\n    this.updateModel();\n  };\n\n  Sort.prototype.setFullScreenDialog = function () {\n    if (this.serviceLocator) {\n      this.serviceLocator.registerAdaptiveService(this, this.parent.enableAdaptiveUI, ResponsiveDialogAction.isSort);\n    }\n  };\n\n  Sort.prototype.backupSettings = function () {\n    this.lastSortedCols = iterateExtend(this.sortSettings.columns);\n    this.lastCols = this.sortedColumns;\n  };\n\n  Sort.prototype.restoreSettings = function () {\n    this.isModelChanged = false;\n    this.isMultiSort = true;\n    this.parent.setProperties({\n      sortSettings: {\n        columns: this.lastSortedCols\n      }\n    }, true); //this.parent.sortSettings.columns =  this.lastSortedCols;\n\n    this.sortedColumns = this.lastCols;\n    this.isModelChanged = true;\n  };\n\n  Sort.prototype.updateSortedCols = function (columnName, isMultiSort) {\n    if (!isMultiSort) {\n      if (this.parent.allowGrouping) {\n        for (var i = 0, len = this.sortedColumns.length; i < len; i++) {\n          if (this.parent.groupSettings.columns.indexOf(this.sortedColumns[i]) < 0) {\n            this.sortedColumns.splice(i, 1);\n            len--;\n            i--;\n          }\n        }\n      } else {\n        this.sortedColumns.splice(0, this.sortedColumns.length);\n      }\n    }\n\n    if (this.sortedColumns.indexOf(columnName) < 0) {\n      this.sortedColumns.push(columnName);\n    }\n  };\n  /**\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    if (this.contentRefresh) {\n      var args = this.sortSettings.columns.length ? {\n        columnName: this.columnName,\n        direction: this.direction,\n        requestType: 'sorting',\n        type: actionBegin,\n        target: this.currentTarget,\n        cancel: false\n      } : {\n        requestType: 'sorting',\n        type: actionBegin,\n        cancel: false,\n        target: this.currentTarget\n      };\n      this.parent.notify(modelChanged, args);\n    }\n\n    this.refreshSortSettings();\n    this.removeSortIcons();\n    this.addSortIcons();\n  };\n\n  Sort.prototype.refreshSortSettings = function () {\n    this.sortedColumns.length = 0;\n    var sortColumns = this.sortSettings.columns;\n\n    for (var i = 0; i < sortColumns.length; i++) {\n      if (!sortColumns[i].isFromGroup) {\n        this.sortedColumns.push(sortColumns[i].field);\n      }\n    }\n  };\n  /**\n   * Clears all the sorted columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Sort.prototype.clearSorting = function () {\n    var cols = getActualPropFromColl(this.sortSettings.columns);\n\n    if (this.isActionPrevent()) {\n      this.parent.notify(preventBatch, {\n        instance: this,\n        handler: this.clearSorting\n      });\n      return;\n    }\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      this.removeSortColumn(cols[i].field);\n    }\n  };\n\n  Sort.prototype.isActionPrevent = function () {\n    return isActionPrevent(this.parent);\n  };\n  /**\n   * Remove sorted column by field name.\n   *\n   * @param {string} field - Defines the column field name to remove sort.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.removeSortColumn = function (field) {\n    var gObj = this.parent;\n    var cols = this.sortSettings.columns;\n\n    if (cols.length === 0 && this.sortedColumns.indexOf(field) < 0) {\n      return;\n    }\n\n    if (this.isActionPrevent()) {\n      this.parent.notify(preventBatch, {\n        instance: this,\n        handler: this.removeSortColumn,\n        arg1: field\n      });\n      return;\n    }\n\n    this.backupSettings();\n    this.removeSortIcons();\n    var args = {\n      requestType: 'sorting',\n      type: actionBegin,\n      target: this.currentTarget\n    };\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].field === field) {\n        if (gObj.allowGrouping && gObj.groupSettings.columns.indexOf(cols[i].field) > -1) {\n          continue;\n        }\n\n        this.sortedColumns.splice(this.sortedColumns.indexOf(cols[i].field), 1);\n        cols.splice(i, 1);\n        this.isRemove = true;\n\n        if (this.isModelChanged) {\n          this.parent.notify(modelChanged, args);\n        }\n\n        break;\n      }\n    }\n\n    if (!args.cancel) {\n      this.addSortIcons();\n    }\n  };\n\n  Sort.prototype.getSortedColsIndexByField = function (field, sortedColumns) {\n    var cols = sortedColumns ? sortedColumns : this.sortSettings.columns;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].field === field) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Sort.prototype.getModuleName = function () {\n    return 'sort';\n  };\n\n  Sort.prototype.initialEnd = function () {\n    this.parent.off(contentReady, this.initialEnd);\n\n    if (this.parent.getColumns().length && this.sortSettings.columns.length) {\n      var gObj = this.parent;\n      this.contentRefresh = false;\n      this.isMultiSort = this.sortSettings.columns.length > 1;\n\n      for (var _i = 0, _a = gObj.sortSettings.columns.slice(); _i < _a.length; _i++) {\n        var col = _a[_i];\n\n        if (this.sortedColumns.indexOf(col.field) > -1) {\n          this.sortColumn(col.field, col.direction, true);\n        }\n      }\n\n      this.isMultiSort = false;\n      this.contentRefresh = true;\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: setFullScreenDialog,\n      handler: this.setFullScreenDialog\n    }, {\n      event: contentReady,\n      handler: this.initialEnd\n    }, {\n      event: sortComplete,\n      handler: this.onActionComplete\n    }, {\n      event: inBoundModelChanged,\n      handler: this.onPropertyChanged\n    }, {\n      event: click,\n      handler: this.clickHandler\n    }, {\n      event: headerRefreshed,\n      handler: this.refreshSortIcons\n    }, {\n      event: keyPressed,\n      handler: this.keyPressed\n    }, {\n      event: cancelBegin,\n      handler: this.cancelBeginEvent\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  };\n  /**\n   * To destroy the sorting\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.destroy = function () {\n    this.isModelChanged = false;\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    if (this.parent.element.querySelector('.e-gridpopup').getElementsByClassName('e-sortdirect').length) {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if (!this.parent.refreshing && (this.parent.isDestroyed || !this.parent.allowSorting)) {\n      this.clearSorting();\n    }\n\n    this.isModelChanged = true;\n    this.removeEventListener();\n  };\n\n  Sort.prototype.cancelBeginEvent = function (e) {\n    if (e.requestType === 'sorting') {\n      this.restoreSettings();\n      this.refreshSortIcons();\n      this.isMultiSort = true;\n    }\n  };\n\n  Sort.prototype.clickHandler = function (e) {\n    var gObj = this.parent;\n    this.currentTarget = null;\n    this.popUpClickHandler(e);\n    var target = closest(e.target, '.e-headercell');\n\n    if (target && !e.target.classList.contains('e-grptogglebtn') && !target.classList.contains('e-resized') && !e.target.classList.contains('e-rhandler') && !e.target.classList.contains('e-columnmenu') && !e.target.classList.contains('e-filtermenudiv') && !parentsUntil(e.target, 'e-stackedheadercell') && !(gObj.allowSelection && gObj.selectionSettings.allowColumnSelection && e.target.classList.contains('e-headercell'))) {\n      var gObj_1 = this.parent;\n      var colObj = gObj_1.getColumnByUid(target.querySelector('.e-headercelldiv').getAttribute('e-mappinguid'));\n\n      if (colObj.type !== 'checkbox') {\n        this.initiateSort(target, e, colObj);\n\n        if (Browser.isDevice) {\n          this.showPopUp(e);\n        }\n      }\n    }\n\n    if (target) {\n      target.classList.remove('e-resized');\n    }\n\n    if (parentsUntil(e.target, 'e-excel-ascending') || parentsUntil(e.target, 'e-excel-descending')) {\n      var colUid = closest(e.target, '.e-filter-popup').getAttribute('uid');\n      var direction = isNullOrUndefined(parentsUntil(e.target, 'e-excel-descending')) ? 'Ascending' : 'Descending';\n      this.sortColumn(gObj.getColumnByUid(colUid).field, direction, false);\n    }\n  };\n\n  Sort.prototype.keyPressed = function (e) {\n    var ele = e.target;\n\n    if (!this.parent.isEdit && (e.action === 'enter' || e.action === 'ctrlEnter' || e.action === 'shiftEnter') && closest(ele, '.e-headercell')) {\n      var target = this.focus.getFocusedElement();\n\n      if (isNullOrUndefined(target) || !target.classList.contains('e-headercell') || !target.querySelector('.e-headercelldiv')) {\n        return;\n      }\n\n      var col = this.parent.getColumnByUid(target.querySelector('.e-headercelldiv').getAttribute('e-mappinguid'));\n      this.initiateSort(target, e, col);\n    }\n  };\n\n  Sort.prototype.initiateSort = function (target, e, column) {\n    var gObj = this.parent;\n    var field = column.field;\n    this.currentTarget = e.target;\n    var direction = !target.getElementsByClassName('e-ascending').length ? 'Ascending' : 'Descending';\n    this.isMultiSort = e.ctrlKey || this.enableSortMultiTouch || navigator.userAgent.indexOf('Mac OS') !== -1 && e.metaKey;\n\n    if (e.shiftKey || this.sortSettings.allowUnsort && target.getElementsByClassName('e-descending').length && !(gObj.groupSettings.columns.indexOf(field) > -1)) {\n      this.removeSortColumn(field);\n    } else {\n      this.sortColumn(field, direction, this.isMultiSort);\n    }\n  };\n\n  Sort.prototype.showPopUp = function (e) {\n    var target = closest(e.target, '.e-headercell');\n\n    if (this.parent.allowMultiSorting && (!isNullOrUndefined(target) || this.parent.isContextMenuOpen())) {\n      setCssInGridPopUp(this.parent.element.querySelector('.e-gridpopup'), e, 'e-sortdirect e-icons e-icon-sortdirect' + (this.sortedColumns.length > 1 ? ' e-spanclicked' : ''));\n    }\n  };\n\n  Sort.prototype.popUpClickHandler = function (e) {\n    var target = e.target;\n\n    if (closest(target, '.e-headercell') || e.target.classList.contains(rowCell) || closest(target, '.e-gridpopup')) {\n      if (target.classList.contains('e-sortdirect')) {\n        if (!target.classList.contains('e-spanclicked')) {\n          target.classList.add('e-spanclicked');\n          this.enableSortMultiTouch = true;\n        } else {\n          target.classList.remove('e-spanclicked');\n          this.enableSortMultiTouch = false;\n          this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n        }\n      }\n    } else {\n      this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    }\n  };\n\n  Sort.prototype.addSortIcons = function () {\n    var gObj = this.parent;\n    var header;\n    var filterElement;\n    var cols = this.sortSettings.columns;\n    var fieldNames = this.parent.getColumns().map(function (c) {\n      return c.field;\n    });\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      header = gObj.getColumnHeaderByField(cols[i].field);\n\n      if (fieldNames.indexOf(cols[i].field) === -1 || isNullOrUndefined(header)) {\n        continue;\n      }\n\n      this.aria.setSort(header, cols[i].direction.toLowerCase());\n\n      if (cols.length > 1) {\n        header.querySelector('.e-headercelldiv').insertBefore(this.parent.createElement('span', {\n          className: 'e-sortnumber',\n          innerHTML: (i + 1).toString()\n        }), header.querySelector('.e-headertext'));\n      }\n\n      filterElement = header.querySelector('.e-sortfilterdiv');\n\n      if (cols[i].direction === 'Ascending') {\n        classList(filterElement, ['e-ascending', 'e-icon-ascending'], []);\n      } else {\n        classList(filterElement, ['e-descending', 'e-icon-descending'], []);\n      }\n    }\n  };\n\n  Sort.prototype.removeSortIcons = function (position) {\n    var gObj = this.parent;\n    var header;\n    var cols = this.sortSettings.columns;\n    var fieldNames = this.parent.getColumns().map(function (c) {\n      return c.field;\n    });\n\n    for (var i = position ? position : 0, len = !isNullOrUndefined(position) ? position + 1 : cols.length; i < len; i++) {\n      header = gObj.getColumnHeaderByField(cols[i].field);\n\n      if (isNullOrUndefined(header) || gObj.allowGrouping && gObj.groupSettings.columns.indexOf(cols[i].field) > -1 && !header.querySelector('.e-sortfilterdiv')) {\n        continue;\n      }\n\n      if (fieldNames.indexOf(cols[i].field) === -1) {\n        continue;\n      }\n\n      this.aria.setSort(header, 'none');\n      classList(header.querySelector('.e-sortfilterdiv'), [], ['e-descending', 'e-icon-descending', 'e-ascending', 'e-icon-ascending']);\n\n      if (header.querySelector('.e-sortnumber')) {\n        header.querySelector('.e-headercelldiv').removeChild(header.querySelector('.e-sortnumber'));\n      }\n    }\n  };\n\n  Sort.prototype.getSortColumnFromField = function (field) {\n    for (var i = 0, len = this.sortSettings.columns.length; i < len; i++) {\n      if (this.sortSettings.columns[i].field === field) {\n        return this.sortSettings.columns[i];\n      }\n    }\n\n    return false;\n  };\n\n  Sort.prototype.updateAriaAttr = function () {\n    var fieldNames = this.parent.getColumns().map(function (c) {\n      return c.field;\n    });\n\n    for (var _i = 0, _a = this.sortedColumns; _i < _a.length; _i++) {\n      var col = _a[_i];\n\n      if (fieldNames.indexOf(col) === -1) {\n        continue;\n      }\n\n      var header = this.parent.getColumnHeaderByField(col);\n      this.aria.setSort(header, this.getSortColumnFromField(col).direction);\n    }\n  };\n\n  Sort.prototype.refreshSortIcons = function (params) {\n    if (params === void 0) {\n      params = {\n        args: {\n          isFrozen: false\n        }\n      };\n    }\n\n    if (!params.args.isFrozen) {\n      this.removeSortIcons();\n      this.isMultiSort = true;\n      this.removeSortIcons();\n      this.addSortIcons();\n      this.isMultiSort = false;\n      this.updateAriaAttr();\n    }\n  };\n  /**\n   * To show the responsive custom sort dialog\n   *\n   * @param {boolean} enable - specifes dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Sort.prototype.showCustomSort = function (enable) {\n    this.responsiveDialogRenderer.isCustomDialog = enable;\n    this.responsiveDialogRenderer.showResponsiveDialog();\n  };\n\n  return Sort;\n}();\n/**\n * `NumericContainer` module handles rendering and refreshing numeric container.\n */\n\n\nvar NumericContainer =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for numericContainer module\n   *\n   * @param {Pager} pagerModule - specifies the pagerModule\n   * @hidden\n   */\n  function NumericContainer(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * The function is used to render numericContainer\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NumericContainer.prototype.render = function () {\n    this.pagerElement = this.pagerModule.element;\n    this.renderNumericContainer();\n    this.refreshNumericLinks();\n    this.wireEvents();\n  };\n  /**\n   * Refreshes the numeric container of Pager.\n   *\n   * @returns {void}\n   */\n\n\n  NumericContainer.prototype.refresh = function () {\n    this.pagerModule.updateTotalPages();\n\n    if (this.links.length) {\n      this.updateLinksHtml();\n    }\n\n    this.refreshAriaAttrLabel();\n    this.updateStyles();\n  };\n  /**\n   * The function is used to refresh refreshNumericLinks\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NumericContainer.prototype.refreshNumericLinks = function () {\n    var link;\n    var pagerObj = this.pagerModule;\n    var div = pagerObj.element.querySelector('.e-numericcontainer');\n    var frag = document.createDocumentFragment();\n    div.innerHTML = '';\n\n    for (var i = 1; i <= pagerObj.pageCount; i++) {\n      link = createElement('a', {\n        className: 'e-link e-numericitem e-spacing e-pager-default',\n        attrs: {\n          role: 'link',\n          tabindex: '-1',\n          'aria-label': pagerObj.getLocalizedLabel('Page') + i + pagerObj.getLocalizedLabel('Of') + pagerObj.totalPages + pagerObj.getLocalizedLabel('Pages'),\n          href: 'javascript:void(0);',\n          name: 'Goto page' + i\n        }\n      });\n\n      if (pagerObj.currentPage === i) {\n        classList(link, ['e-currentitem', 'e-active'], ['e-pager-default']);\n        link.setAttribute('aria-selected', 'true');\n      }\n\n      frag.appendChild(link);\n    }\n\n    div.appendChild(frag);\n    this.links = [].slice.call(div.childNodes);\n  };\n  /**\n   * Binding events to the element while component creation\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NumericContainer.prototype.wireEvents = function () {\n    EventHandler.add(this.pagerElement, 'click', this.clickHandler, this);\n  };\n  /**\n   * Unbinding events from the element while component destroy\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NumericContainer.prototype.unwireEvents = function () {\n    EventHandler.remove(this.pagerModule.element, 'click', this.clickHandler);\n  };\n  /**\n   * To destroy the PagerMessage\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NumericContainer.prototype.destroy = function () {\n    this.unwireEvents();\n  };\n\n  NumericContainer.prototype.refreshAriaAttrLabel = function () {\n    var pagerObj = this.pagerModule;\n    var numericContainer = pagerObj.element.querySelector('.e-numericcontainer');\n    var links = numericContainer.querySelectorAll('a');\n\n    for (var i = 0; i < links.length; i++) {\n      if (links[i].hasAttribute('aria-label') && links[i].hasAttribute('index')) {\n        links[i].setAttribute('aria-label', pagerObj.getLocalizedLabel('Page') + links[i].getAttribute('index') + pagerObj.getLocalizedLabel('Of') + pagerObj.totalPages + pagerObj.getLocalizedLabel('Pages'));\n      }\n    }\n  };\n\n  NumericContainer.prototype.renderNumericContainer = function () {\n    this.element = createElement('div', {\n      className: 'e-pagercontainer',\n      attrs: {\n        'role': 'navigation'\n      }\n    });\n    this.renderFirstNPrev(this.element);\n    this.renderPrevPagerSet(this.element);\n    this.element.appendChild(createElement('div', {\n      className: 'e-numericcontainer'\n    }));\n    this.renderNextPagerSet(this.element);\n    this.renderNextNLast(this.element);\n    this.pagerModule.element.appendChild(this.element);\n  };\n\n  NumericContainer.prototype.renderFirstNPrev = function (pagerContainer) {\n    this.first = createElement('div', {\n      className: 'e-first e-icons e-icon-first',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('firstPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('firstPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    this.prev = createElement('div', {\n      className: 'e-prev e-icons e-icon-prev',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('previousPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('previousPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    append([this.first, this.prev], pagerContainer);\n  };\n\n  NumericContainer.prototype.renderPrevPagerSet = function (pagerContainer) {\n    var prevPager = createElement('div');\n    this.PP = createElement('a', {\n      className: 'e-link e-pp e-spacing',\n      innerHTML: '...',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('previousPagerTooltip'),\n        role: 'link',\n        'aria-label': this.pagerModule.getLocalizedLabel('previousPagerTooltip'),\n        tabindex: '-1',\n        name: this.pagerModule.getLocalizedLabel('previousPagerTooltip'),\n        href: 'javascript:void(0);'\n      }\n    });\n    prevPager.appendChild(this.PP);\n    pagerContainer.appendChild(prevPager);\n  };\n\n  NumericContainer.prototype.renderNextPagerSet = function (pagerContainer) {\n    var nextPager = createElement('div');\n    this.NP = createElement('a', {\n      className: 'e-link e-np e-spacing',\n      innerHTML: '...',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('nextPagerTooltip'),\n        role: 'link',\n        'aria-label': this.pagerModule.getLocalizedLabel('nextPagerTooltip'),\n        tabindex: '-1',\n        name: this.pagerModule.getLocalizedLabel('nextPagerTooltip'),\n        href: 'javascript:void(0);'\n      }\n    });\n    nextPager.appendChild(this.NP);\n    pagerContainer.appendChild(nextPager);\n  };\n\n  NumericContainer.prototype.renderNextNLast = function (pagerContainer) {\n    this.next = createElement('div', {\n      className: 'e-next e-icons e-icon-next',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('nextPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('nextPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    this.last = createElement('div', {\n      className: 'e-last e-icons e-icon-last',\n      attrs: {\n        title: this.pagerModule.getLocalizedLabel('lastPageTooltip'),\n        'aria-label': this.pagerModule.getLocalizedLabel('lastPageTooltip'),\n        tabindex: '-1'\n      }\n    });\n    append([this.next, this.last], pagerContainer);\n  };\n\n  NumericContainer.prototype.clickHandler = function (e) {\n    var pagerObj = this.pagerModule;\n    var target = e.target;\n    pagerObj.previousPageNo = pagerObj.currentPage;\n\n    if (!target.classList.contains('e-disable') && !isNullOrUndefined(target.getAttribute('index'))) {\n      pagerObj.currentPage = parseInt(target.getAttribute('index'), 10);\n      pagerObj.dataBind();\n    }\n\n    return false;\n  };\n\n  NumericContainer.prototype.updateLinksHtml = function () {\n    var pagerObj = this.pagerModule;\n    var currentPageSet;\n    var pageNo;\n    pagerObj.currentPage = pagerObj.totalPages === 1 ? 1 : pagerObj.currentPage;\n\n    if (pagerObj.currentPage > pagerObj.totalPages && pagerObj.totalPages) {\n      pagerObj.currentPage = pagerObj.totalPages;\n    }\n\n    currentPageSet = parseInt((pagerObj.currentPage / pagerObj.pageCount).toString(), 10);\n\n    if (pagerObj.currentPage % pagerObj.pageCount === 0 && currentPageSet > 0) {\n      currentPageSet = currentPageSet - 1;\n    }\n\n    for (var i = 0; i < pagerObj.pageCount; i++) {\n      pageNo = currentPageSet * pagerObj.pageCount + 1 + i;\n\n      if (pageNo <= pagerObj.totalPages) {\n        this.links[i].style.display = '';\n        this.links[i].setAttribute('index', pageNo.toString());\n        this.links[i].innerHTML = !pagerObj.customText ? pageNo.toString() : pagerObj.customText + pageNo;\n\n        if (pagerObj.currentPage !== pageNo) {\n          this.links[i].classList.add('e-pager-default');\n        } else {\n          this.links[i].classList.remove('e-pager-default');\n        }\n      } else {\n        this.links[i].innerHTML = !pagerObj.customText ? pageNo.toString() : pagerObj.customText + pageNo;\n        this.links[i].style.display = 'none';\n      }\n\n      classList(this.links[i], [], ['e-currentitem', 'e-active']);\n      this.links[i].removeAttribute('aria-selected');\n    }\n\n    this.first.setAttribute('index', '1');\n    this.last.setAttribute('index', pagerObj.totalPages.toString());\n    this.prev.setAttribute('index', (pagerObj.currentPage - 1).toString());\n    this.next.setAttribute('index', (pagerObj.currentPage + 1).toString());\n    this.pagerElement.querySelector('.e-mfirst').setAttribute('index', '1');\n    this.pagerElement.querySelector('.e-mlast').setAttribute('index', pagerObj.totalPages.toString());\n    this.pagerElement.querySelector('.e-mprev').setAttribute('index', (pagerObj.currentPage - 1).toString());\n    this.pagerElement.querySelector('.e-mnext').setAttribute('index', (pagerObj.currentPage + 1).toString());\n    this.PP.setAttribute('index', (parseInt(this.links[0].getAttribute('index'), 10) - pagerObj.pageCount).toString());\n    this.NP.setAttribute('index', (parseInt(this.links[this.links.length - 1].getAttribute('index'), 10) + 1).toString());\n  };\n\n  NumericContainer.prototype.updateStyles = function () {\n    this.updateFirstNPrevStyles();\n    this.updatePrevPagerSetStyles();\n    this.updateNextPagerSetStyles();\n    this.updateNextNLastStyles();\n\n    if (this.links.length) {\n      classList(this.links[(this.pagerModule.currentPage - 1) % this.pagerModule.pageCount], ['e-currentitem', 'e-active'], []);\n      this.links[(this.pagerModule.currentPage - 1) % this.pagerModule.pageCount].setAttribute('aria-selected', 'true');\n    }\n  };\n\n  NumericContainer.prototype.updateFirstNPrevStyles = function () {\n    var firstPage = ['e-firstpage', 'e-pager-default'];\n    var firstPageDisabled = ['e-firstpagedisabled', 'e-disable'];\n    var prevPage = ['e-prevpage', 'e-pager-default'];\n    var prevPageDisabled = ['e-prevpagedisabled', 'e-disable'];\n\n    if (this.pagerModule.totalPages > 0 && this.pagerModule.currentPage > 1) {\n      classList(this.prev, prevPage, prevPageDisabled);\n      classList(this.first, firstPage, firstPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mfirst'), firstPage, firstPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mprev'), prevPage, prevPageDisabled);\n    } else {\n      classList(this.prev, prevPageDisabled, prevPage);\n      classList(this.first, firstPageDisabled, firstPage);\n      classList(this.pagerElement.querySelector('.e-mprev'), prevPageDisabled, prevPage);\n      classList(this.pagerElement.querySelector('.e-mfirst'), firstPageDisabled, firstPage);\n    }\n  };\n\n  NumericContainer.prototype.updatePrevPagerSetStyles = function () {\n    if (this.pagerModule.currentPage > this.pagerModule.pageCount) {\n      classList(this.PP, ['e-numericitem', 'e-pager-default'], ['e-nextprevitemdisabled', 'e-disable']);\n    } else {\n      classList(this.PP, ['e-nextprevitemdisabled', 'e-disable'], ['e-numericitem', 'e-pager-default']);\n    }\n  };\n\n  NumericContainer.prototype.updateNextPagerSetStyles = function () {\n    var pagerObj = this.pagerModule;\n    var firstPage = this.links[0].innerHTML.replace(pagerObj.customText, '');\n\n    if (!firstPage.length || !this.links.length || parseInt(firstPage, 10) + pagerObj.pageCount > pagerObj.totalPages) {\n      classList(this.NP, ['e-nextprevitemdisabled', 'e-disable'], ['e-numericitem', 'e-pager-default']);\n    } else {\n      classList(this.NP, ['e-numericitem', 'e-pager-default'], ['e-nextprevitemdisabled', 'e-disable']);\n    }\n  };\n\n  NumericContainer.prototype.updateNextNLastStyles = function () {\n    var lastPage = ['e-lastpage', 'e-pager-default'];\n    var lastPageDisabled = ['e-lastpagedisabled', 'e-disable'];\n    var nextPage = ['e-nextpage', 'e-pager-default'];\n    var nextPageDisabled = ['e-nextpagedisabled', 'e-disable'];\n    var pagerObj = this.pagerModule;\n\n    if (pagerObj.currentPage === pagerObj.totalPages || pagerObj.totalRecordsCount === 0) {\n      classList(this.last, lastPageDisabled, lastPage);\n      classList(this.next, nextPageDisabled, nextPage);\n      classList(this.pagerElement.querySelector('.e-mlast'), lastPageDisabled, lastPage);\n      classList(this.pagerElement.querySelector('.e-mnext'), nextPageDisabled, nextPage);\n    } else {\n      classList(this.last, lastPage, lastPageDisabled);\n      classList(this.next, nextPage, nextPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mlast'), lastPage, lastPageDisabled);\n      classList(this.pagerElement.querySelector('.e-mnext'), nextPage, nextPageDisabled);\n    }\n  };\n\n  return NumericContainer;\n}();\n/**\n * `PagerMessage` module is used to display pager information.\n */\n\n\nvar PagerMessage =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for externalMessage module\n   *\n   * @param {Pager} pagerModule - specifies the pager Module\n   * @hidden\n   */\n  function PagerMessage(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * The function is used to render pager message\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  PagerMessage.prototype.render = function () {\n    var div = createElement('div', {\n      className: 'e-parentmsgbar',\n      attrs: {\n        'aria-label': this.pagerModule.getLocalizedLabel('Information')\n      }\n    });\n    this.pageNoMsgElem = createElement('span', {\n      className: 'e-pagenomsg',\n      styles: 'textalign:right'\n    });\n    this.pageCountMsgElem = createElement('span', {\n      className: 'e-pagecountmsg',\n      styles: 'textalign:right'\n    });\n    append([this.pageNoMsgElem, this.pageCountMsgElem], div);\n    this.pagerModule.element.appendChild(div);\n    this.refresh();\n  };\n  /**\n   * Refreshes the pager information.\n   *\n   * @returns {void}\n   */\n\n\n  PagerMessage.prototype.refresh = function () {\n    var pagerObj = this.pagerModule;\n    this.pageNoMsgElem.textContent = this.format(pagerObj.getLocalizedLabel('currentPageInfo'), [pagerObj.totalRecordsCount === 0 ? 0 : pagerObj.currentPage, pagerObj.totalPages || 0, pagerObj.totalRecordsCount || 0]) + ' ';\n    this.pageCountMsgElem.textContent = this.format(pagerObj.getLocalizedLabel(pagerObj.totalRecordsCount <= 1 ? 'totalItemInfo' : 'totalItemsInfo'), [pagerObj.totalRecordsCount || 0, pagerObj.totalRecordsCount ? pagerObj.pageSize * (pagerObj.currentPage - 1) + 1 : 0, pagerObj.pageSize * pagerObj.currentPage > pagerObj.totalRecordsCount ? pagerObj.totalRecordsCount : pagerObj.pageSize * pagerObj.currentPage]);\n    this.pageNoMsgElem.parentElement.setAttribute('aria-label', this.pageNoMsgElem.textContent + this.pageCountMsgElem.textContent);\n  };\n  /**\n   * Hides the Pager information.\n   *\n   * @returns {void}\n   */\n\n\n  PagerMessage.prototype.hideMessage = function () {\n    if (this.pageNoMsgElem) {\n      this.pageNoMsgElem.style.display = 'none';\n    }\n\n    if (this.pageCountMsgElem) {\n      this.pageCountMsgElem.style.display = 'none';\n    }\n  };\n  /**\n   * Shows the Pager information.\n   *\n   * @returns {void}\n   */\n\n\n  PagerMessage.prototype.showMessage = function () {\n    if (!this.pageNoMsgElem) {\n      this.render();\n    }\n\n    this.pageNoMsgElem.style.display = '';\n    this.pageCountMsgElem.style.display = '';\n  };\n  /**\n   * To destroy the PagerMessage\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  PagerMessage.prototype.destroy = function () {//destroy\n  };\n\n  PagerMessage.prototype.format = function (str, args) {\n    var regx;\n\n    for (var i = 0; i < args.length; i++) {\n      regx = new RegExp('\\\\{' + i + '\\\\}', 'gm');\n      str = str.replace(regx, args[i].toString());\n    }\n\n    return str;\n  };\n\n  return PagerMessage;\n}();\n\nvar __extends$19 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Represents the `Pager` component.\n * ```html\n * <div id=\"pager\"/>\n * ```\n * ```typescript\n * <script>\n *   var pagerObj = new Pager({ totalRecordsCount: 50, pageSize:10 });\n *   pagerObj.appendTo(\"#pager\");\n * </script>\n * ```\n */\n\n\nvar Pager =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$19(Pager, _super);\n  /**\n   * Constructor for creating the component.\n   *\n   * @param {PagerModel} options - specifies the options\n   * @param {string} element - specifies the element\n   * @param {string} parent - specifies the pager parent\n   * @hidden\n   */\n\n\n  function Pager(options, element, parent) {\n    var _this = _super.call(this, options, element) || this;\n    /** @hidden */\n\n\n    _this.hasParent = false;\n    _this.pageRefresh = 'pager-refresh';\n    _this.firstPagerFocus = false;\n    _this.parent = parent;\n    return _this;\n  }\n  /**\n   * To provide the array of modules needed for component rendering\n   *\n   * @returns {ModuleDeclaration[]} returns the modules declaration\n   * @hidden\n   */\n\n\n  Pager.prototype.requiredModules = function () {\n    var modules = [];\n\n    if (this.enableExternalMessage) {\n      modules.push({\n        member: 'externalMessage',\n        args: [this]\n      });\n    }\n\n    if (this.checkpagesizes()) {\n      modules.push({\n        member: 'pagerdropdown',\n        args: [this]\n      });\n    }\n\n    return modules;\n  };\n  /**\n   * Initialize the event handler\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Pager.prototype.preRender = function () {\n    //preRender\n    this.defaultConstants = {\n      currentPageInfo: '{0} of {1} pages',\n      totalItemsInfo: '({0} items)',\n      totalItemInfo: '({0} item)',\n      firstPageTooltip: 'Go to first page',\n      lastPageTooltip: 'Go to last page',\n      nextPageTooltip: 'Go to next page',\n      previousPageTooltip: 'Go to previous page',\n      nextPagerTooltip: 'Go to next pager items',\n      previousPagerTooltip: 'Go to previous pager items',\n      pagerDropDown: 'Items per page',\n      pagerAllDropDown: 'Items',\n      CurrentPageInfo: '{0} of {1} pages',\n      TotalItemsInfo: '({0} items)',\n      FirstPageTooltip: 'Go to first page',\n      LastPageTooltip: 'Go to last page',\n      NextPageTooltip: 'Go to next page',\n      PreviousPageTooltip: 'Go to previous page',\n      NextPagerTooltip: 'Go to next pager items',\n      PreviousPagerTooltip: 'Go to previous pager items',\n      PagerDropDown: 'Items per page',\n      PagerAllDropDown: 'Items',\n      All: 'All',\n      Container: 'Pager Container',\n      Information: 'Pager Information',\n      ExternalMsg: 'Pager external message',\n      Page: 'Page ',\n      Of: ' of ',\n      Pages: ' Pages'\n    };\n    this.containerModule = new NumericContainer(this);\n    this.pagerMessageModule = new PagerMessage(this);\n  };\n  /**\n   * To Initialize the component rendering\n   *\n   * @returns {void}\n   */\n\n\n  Pager.prototype.render = function () {\n    this.element.setAttribute('data-role', 'pager');\n    this.element.setAttribute('tabindex', '-1');\n    this.initLocalization();\n    this.element.setAttribute('aria-label', this.getLocalizedLabel('Container'));\n\n    if (this.cssClass) {\n      addClass([this.element], [this.cssClass]);\n    }\n\n    if (!this.hasParent) {\n      this.element.setAttribute('tabindex', '0');\n    }\n\n    if (this.template) {\n      if (this.isReactTemplate()) {\n        this.on(this.pageRefresh, this.pagerTemplate, this);\n        this.notify(this.pageRefresh, {});\n      } else {\n        this.pagerTemplate();\n      }\n    } else {\n      this.updateRTL();\n      this.totalRecordsCount = this.totalRecordsCount || 0;\n      this.renderFirstPrevDivForDevice();\n      this.containerModule.render();\n\n      if (this.enablePagerMessage) {\n        this.pagerMessageModule.render();\n      }\n\n      this.renderNextLastDivForDevice();\n\n      if (this.checkpagesizes() && this.pagerdropdownModule) {\n        this.pagerdropdownModule.render();\n      }\n\n      this.addAriaLabel();\n\n      if (this.enableExternalMessage && this.externalMessageModule) {\n        this.externalMessageModule.render();\n      }\n\n      this.refresh();\n      this.trigger('created', {\n        'currentPage': this.currentPage,\n        'totalRecordsCount': this.totalRecordsCount\n      });\n    }\n\n    this.wireEvents();\n    this.addListener();\n  };\n  /**\n   * Get the properties to be maintained in the persisted state.\n   *\n   * @returns {string} returns the persist data\n   * @hidden\n   */\n\n\n  Pager.prototype.getPersistData = function () {\n    var keyEntity = ['currentPage', 'pageSize'];\n    return this.addOnPersist(keyEntity);\n  };\n  /**\n   * To destroy the Pager component.\n   *\n   * @method destroy\n   * @returns {void}\n   */\n\n\n  Pager.prototype.destroy = function () {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (this.isReactTemplate()) {\n      this.off(this.pageRefresh, this.pagerTemplate);\n\n      if (!this.hasParent) {\n        this.destroyTemplate(['template']);\n      }\n    }\n\n    this.removeListener();\n    this.unwireEvents();\n\n    _super.prototype.destroy.call(this);\n\n    this.containerModule.destroy();\n    this.pagerMessageModule.destroy();\n\n    if (!this.isReactTemplate()) {\n      this.element.innerHTML = '';\n    }\n  };\n  /**\n   * Destroys the given template reference.\n   *\n   * @param {string[]} propertyNames - Defines the collection of template name.\n   * @param {any} index - Defines the index\n   */\n  // eslint-disable-next-line\n\n\n  Pager.prototype.destroyTemplate = function (propertyNames, index) {\n    this.clearTemplate(propertyNames, index);\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Pager.prototype.getModuleName = function () {\n    return 'pager';\n  };\n  /**\n   * Called internally if any of the property value changed.\n   *\n   * @param {PagerModel} newProp - specifies the new property\n   * @param {PagerModel} oldProp - specifies the old propety\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Pager.prototype.onPropertyChanged = function (newProp, oldProp) {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (newProp.pageCount !== oldProp.pageCount) {\n      this.containerModule.refreshNumericLinks();\n      this.containerModule.refresh();\n    }\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'currentPage':\n          if (this.checkGoToPage(newProp.currentPage, oldProp.currentPage)) {\n            this.currentPageChanged(newProp, oldProp);\n          }\n\n          break;\n\n        case 'pageSize':\n        case 'totalRecordsCount':\n        case 'customText':\n          if (this.checkpagesizes() && this.pagerdropdownModule) {\n            if (oldProp.pageSize !== newProp.pageSize) {\n              this.currentPage = 1;\n            }\n\n            this.pagerdropdownModule.setDropDownValue('value', this.pageSize);\n          }\n\n          if (newProp.pageSize !== oldProp.pageSize) {\n            this.pageSize = newProp.pageSize;\n            this.currentPageChanged(newProp, oldProp);\n          } else {\n            this.refresh();\n          }\n\n          break;\n\n        case 'pageSizes':\n          if (this.checkpagesizes() && this.pagerdropdownModule) {\n            this.pagerdropdownModule.destroy();\n            this.pagerdropdownModule.render();\n          }\n\n          this.refresh();\n          break;\n\n        case 'template':\n          this.templateFn = this.compile(this.template);\n          this.refresh();\n          break;\n\n        case 'locale':\n          this.initLocalization();\n          this.refresh();\n          break;\n\n        case 'enableExternalMessage':\n          if (this.enableExternalMessage && this.externalMessageModule) {\n            this.externalMessageModule.render();\n          }\n\n          break;\n\n        case 'externalMessage':\n          if (this.externalMessageModule) {\n            this.externalMessageModule.refresh();\n          }\n\n          break;\n\n        case 'enableRtl':\n          this.updateRTL();\n          break;\n\n        case 'enablePagerMessage':\n          if (this.enablePagerMessage) {\n            this.pagerMessageModule.showMessage();\n          } else {\n            this.pagerMessageModule.hideMessage();\n          }\n\n          break;\n      }\n    }\n  };\n\n  Pager.prototype.wireEvents = function () {\n    if (!this.hasParent) {\n      EventHandler.add(this.element, 'keydown', this.keyPressHandler, this);\n      EventHandler.add(document.body, 'keydown', this.keyDownHandler, this);\n    }\n\n    EventHandler.add(this.element, 'focusin', this.onFocusIn, this);\n    EventHandler.add(this.element, 'focusout', this.onFocusOut, this);\n  };\n\n  Pager.prototype.unwireEvents = function () {\n    if (!this.hasParent) {\n      EventHandler.remove(this.element, 'keydown', this.keyPressHandler);\n      EventHandler.remove(document.body, 'keydown', this.keyDownHandler);\n    }\n\n    EventHandler.remove(this.element, 'focusin', this.onFocusIn);\n    EventHandler.remove(this.element, 'focusout', this.onFocusOut);\n  };\n\n  Pager.prototype.onFocusIn = function (e) {\n    var focusedTabIndexElement = this.getFocusedTabindexElement();\n\n    if (isNullOrUndefined(focusedTabIndexElement)) {\n      var target = e.target;\n      var dropDownPage = this.getDropDownPage();\n\n      if (!this.hasParent) {\n        this.element.tabIndex = -1;\n      }\n\n      if (target === this.element && !this.hasParent) {\n        var focusablePagerElements = this.getFocusablePagerElements(this.element, []);\n        this.addFocus(focusablePagerElements[0], true);\n        return;\n      }\n\n      if (target === this.element) {\n        this.element.tabIndex = 0;\n        return;\n      }\n\n      if (target !== dropDownPage && !target.classList.contains('e-disable')) {\n        this.addFocus(target, true);\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Pager.prototype.onFocusOut = function (e) {\n    var focusedElement = this.getFocusedElement();\n    var dropDownPage = this.getDropDownPage();\n\n    if (!isNullOrUndefined(focusedElement)) {\n      this.removeFocus(focusedElement, true);\n    }\n\n    if (this.pageSizes && dropDownPage && dropDownPage.classList.contains('e-input-focus')) {\n      this.removeFocus(dropDownPage, true);\n    }\n\n    this.setTabIndexForFocusLastElement();\n\n    if (!this.hasParent) {\n      this.element.tabIndex = 0;\n    }\n\n    if (this.hasParent) {\n      this.element.tabIndex = -1;\n    }\n  };\n\n  Pager.prototype.keyDownHandler = function (e) {\n    if (e.altKey) {\n      if (e.keyCode === 74) {\n        var focusablePagerElements = this.getFocusablePagerElements(this.element, []);\n\n        if (focusablePagerElements.length > 0) {\n          focusablePagerElements[0].focus();\n        }\n      }\n    }\n  };\n\n  Pager.prototype.keyPressHandler = function (e) {\n    var presskey = extend(e, {\n      cancel: false\n    });\n    this.notify(keyPressed, presskey);\n\n    if (presskey.cancel === true) {\n      e.stopImmediatePropagation();\n    }\n  };\n\n  Pager.prototype.addListener = function () {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (!this.hasParent) {\n      this.on(keyPressed, this.onKeyPress, this);\n    }\n  };\n\n  Pager.prototype.removeListener = function () {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (!this.hasParent) {\n      this.off(keyPressed, this.onKeyPress);\n    }\n  };\n\n  Pager.prototype.onKeyPress = function (e) {\n    if (!this.hasParent) {\n      if (this.checkPagerHasFocus()) {\n        this.changePagerFocus(e);\n      } else {\n        e.preventDefault();\n        this.setPagerFocus();\n      }\n    }\n  };\n  /**\n   * @returns {boolean} - Return the true value if pager has focus\n   * @hidden */\n\n\n  Pager.prototype.checkPagerHasFocus = function () {\n    return this.getFocusedTabindexElement() ? true : false;\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  Pager.prototype.setPagerContainerFocus = function () {\n    this.element.focus();\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  Pager.prototype.setPagerFocus = function () {\n    var focusablePagerElements = this.getFocusablePagerElements(this.element, []);\n\n    if (focusablePagerElements.length > 0) {\n      focusablePagerElements[0].focus();\n    }\n  };\n\n  Pager.prototype.setPagerFocusForActiveElement = function () {\n    var currentActivePage = this.getActiveElement();\n\n    if (currentActivePage) {\n      currentActivePage.focus();\n    }\n  };\n\n  Pager.prototype.setTabIndexForFocusLastElement = function () {\n    var focusablePagerElements = this.getFocusablePagerElements(this.element, []);\n    var dropDownPage = this.getDropDownPage();\n\n    if (this.pageSizes && dropDownPage && !isNullOrUndefined(dropDownPage.offsetParent)) {\n      dropDownPage.tabIndex = 0;\n    } else if (focusablePagerElements.length > 0) {\n      focusablePagerElements[focusablePagerElements.length - 1].tabIndex = 0;\n    }\n  };\n  /**\n   * @param {KeyboardEventArgs} e - Keyboard Event Args\n   * @returns {void}\n   * @hidden */\n\n\n  Pager.prototype.changePagerFocus = function (e) {\n    if (e.shiftKey && e.keyCode === 9) {\n      this.changeFocusByShiftTab(e);\n    } else if (e.keyCode === 9) {\n      this.changeFocusByTab(e);\n    } else if (e.keyCode === 13 || e.keyCode === 32) {\n      this.navigateToPageByEnterOrSpace(e);\n    } else if (e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 35 || e.keyCode === 36) {\n      this.navigateToPageByKey(e);\n    }\n  };\n\n  Pager.prototype.getFocusedTabindexElement = function () {\n    var focusedTabIndexElement;\n    var tabindexElements = this.element.querySelectorAll('[tabindex]:not([tabindex=\"-1\"])');\n\n    for (var i = 0; i < tabindexElements.length; i++) {\n      var element = tabindexElements[i];\n\n      if (element && (element.classList.contains('e-focused') || element.classList.contains('e-input-focus'))) {\n        focusedTabIndexElement = element;\n        break;\n      }\n    }\n\n    return focusedTabIndexElement;\n  };\n\n  Pager.prototype.changeFocusByTab = function (e) {\n    var currentItemPagerFocus = this.getFocusedTabindexElement();\n    var focusablePagerElements = this.getFocusablePagerElements(this.element, []);\n    var dropDownPage = this.getDropDownPage();\n\n    if (focusablePagerElements.length > 0) {\n      if (this.pageSizes && dropDownPage && currentItemPagerFocus === focusablePagerElements[focusablePagerElements.length - 1]) {\n        dropDownPage.tabIndex = 0;\n      } else {\n        for (var i = 0; i < focusablePagerElements.length; i++) {\n          if (currentItemPagerFocus === focusablePagerElements[i]) {\n            var incrementNumber = i + 1;\n\n            if (incrementNumber < focusablePagerElements.length) {\n              e.preventDefault();\n              focusablePagerElements[incrementNumber].focus();\n            }\n\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  Pager.prototype.changeFocusByShiftTab = function (e) {\n    var currentItemPagerFocus = this.getFocusedTabindexElement();\n    var focusablePagerElements = this.getFocusablePagerElements(this.element, []);\n    var dropDownPage = this.getDropDownPage();\n\n    if (this.pageSizes && dropDownPage && dropDownPage.classList.contains('e-input-focus')) {\n      dropDownPage.tabIndex = -1;\n      this.addFocus(focusablePagerElements[focusablePagerElements.length - 1], true);\n    } else if (focusablePagerElements.length > 0) {\n      for (var i = 0; i < focusablePagerElements.length; i++) {\n        if (currentItemPagerFocus === focusablePagerElements[i]) {\n          var decrementNumber = i - 1;\n\n          if (decrementNumber >= 0) {\n            e.preventDefault();\n            focusablePagerElements[decrementNumber].focus();\n          } else if (this.hasParent) {\n            var rows = this.parent.getRows();\n            var lastRow = rows[rows.length - 1];\n            var lastCell = lastRow.lastChild;\n            e.preventDefault();\n            lastCell.focus();\n            this.firstPagerFocus = true;\n          }\n\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  Pager.prototype.checkFirstPagerFocus = function () {\n    if (this.firstPagerFocus) {\n      this.firstPagerFocus = false;\n      return true;\n    }\n\n    return false;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Pager.prototype.navigateToPageByEnterOrSpace = function (e) {\n    var currentItemPagerFocus = this.getFocusedElement();\n\n    if (currentItemPagerFocus) {\n      this.goToPage(parseInt(currentItemPagerFocus.getAttribute('index'), 10));\n      var currentActivePage = this.getActiveElement();\n      var selectedClass = this.getClass(currentItemPagerFocus);\n      var classElement = this.getElementByClass(selectedClass);\n\n      if ((selectedClass === 'e-first' || selectedClass === 'e-prev' || selectedClass === 'e-next' || selectedClass === 'e-last' || selectedClass === 'e-pp' || selectedClass === 'e-np') && classElement && !classElement.classList.contains('e-disable')) {\n        classElement.focus();\n      } else if (this.checkFocusInAdaptiveMode(currentItemPagerFocus)) {\n        this.changeFocusInAdaptiveMode(currentItemPagerFocus);\n      } else {\n        if (currentActivePage) {\n          currentActivePage.focus();\n        }\n      }\n    }\n  };\n\n  Pager.prototype.navigateToPageByKey = function (e) {\n    var actionClass = e.keyCode === 37 ? '.e-prev' : e.keyCode === 39 ? '.e-next' : e.keyCode === 35 ? '.e-last' : e.keyCode === 36 ? '.e-first' : '';\n    var pagingItem = this.element.querySelector(actionClass);\n    var currentItemPagerFocus = this.getFocusedElement();\n\n    if (!isNullOrUndefined(pagingItem) && pagingItem.hasAttribute('index') && !isNaN(parseInt(pagingItem.getAttribute('index'), 10))) {\n      this.goToPage(parseInt(pagingItem.getAttribute('index'), 10));\n      var currentActivePage = this.getActiveElement();\n\n      if (this.checkFocusInAdaptiveMode(currentItemPagerFocus)) {\n        this.changeFocusInAdaptiveMode(currentItemPagerFocus);\n      } else {\n        if (currentActivePage) {\n          currentActivePage.focus();\n        }\n      }\n    }\n  };\n\n  Pager.prototype.checkFocusInAdaptiveMode = function (element) {\n    var selectedClass = this.getClass(element);\n    return selectedClass === 'e-mfirst' || selectedClass === 'e-mprev' || selectedClass === 'e-mnext' || selectedClass === 'e-mlast' ? true : false;\n  };\n\n  Pager.prototype.changeFocusInAdaptiveMode = function (element) {\n    var selectedClass = this.getClass(element);\n    var classElement = this.getElementByClass(selectedClass);\n\n    if (classElement && classElement.classList.contains('e-disable')) {\n      if (selectedClass === 'e-mnext' || selectedClass === 'e-mlast') {\n        var mPrev = this.element.querySelector('.e-mprev');\n        mPrev.focus();\n      } else {\n        this.setPagerFocus();\n      }\n    }\n  };\n\n  Pager.prototype.removeTabindexLastElements = function () {\n    var tabIndexElements = this.element.querySelectorAll('[tabindex]:not([tabindex=\"-1\"])');\n\n    if (tabIndexElements.length > 1) {\n      for (var i = 1; i < tabIndexElements.length; i++) {\n        var element = tabIndexElements[i];\n\n        if (element) {\n          element.tabIndex = -1;\n        }\n      }\n    }\n  };\n\n  Pager.prototype.getActiveElement = function () {\n    return this.element.querySelector('.e-active');\n  };\n  /**\n   * @returns {Element} - Returns DropDown Page\n   * @hidden */\n\n\n  Pager.prototype.getDropDownPage = function () {\n    var dropDownPageHolder = this.element.querySelector('.e-pagerdropdown');\n    var dropDownPage;\n\n    if (dropDownPageHolder) {\n      dropDownPage = dropDownPageHolder.children[0];\n    }\n\n    return dropDownPage;\n  };\n\n  Pager.prototype.getFocusedElement = function () {\n    return this.element.querySelector('.e-focused');\n  };\n\n  Pager.prototype.getClass = function (element) {\n    var currentClass;\n    var classList$$1 = ['e-mfirst', 'e-mprev', 'e-first', 'e-prev', 'e-pp', 'e-np', 'e-next', 'e-last', 'e-mnext', 'e-mlast'];\n\n    for (var i = 0; i < classList$$1.length; i++) {\n      if (element && element.classList.contains(classList$$1[i])) {\n        currentClass = classList$$1[i];\n        return currentClass;\n      }\n    }\n\n    return currentClass;\n  };\n\n  Pager.prototype.getElementByClass = function (className) {\n    return this.element.querySelector('.' + className);\n  };\n  /**\n   * @param {Element} element - Pager element\n   * @param {Element[]} previousElements - Iterating pager element\n   * @returns {Element[]} - Returns focusable pager element\n   * @hidden */\n\n\n  Pager.prototype.getFocusablePagerElements = function (element, previousElements) {\n    var target = element;\n    var targetChildrens = target.children;\n    var pagerElements = previousElements;\n\n    for (var i = 0; i < targetChildrens.length; i++) {\n      var element_1 = targetChildrens[i];\n\n      if (element_1.children.length > 0 && !element_1.classList.contains('e-pagesizes')) {\n        pagerElements = this.getFocusablePagerElements(element_1, pagerElements);\n      } else {\n        var tabindexElement = targetChildrens[i];\n\n        if (tabindexElement.hasAttribute('tabindex') && !element_1.classList.contains('e-disable') && element_1.style.display !== 'none' && !isNullOrUndefined(element_1.offsetParent)) {\n          pagerElements.push(tabindexElement);\n        }\n      }\n    }\n\n    return pagerElements;\n  };\n\n  Pager.prototype.addFocus = function (element, addFocusClass) {\n    if (addFocusClass) {\n      addClass([element], ['e-focused', 'e-focus']);\n    }\n\n    element.tabIndex = 0;\n  };\n\n  Pager.prototype.removeFocus = function (element, removeFocusClass) {\n    if (removeFocusClass) {\n      removeClass([element], ['e-focused', 'e-focus']);\n    }\n\n    element.tabIndex = -1;\n  };\n  /**\n   * Gets the localized label by locale keyword.\n   *\n   * @param  {string} key - specifies the key\n   * @returns {string} returns the localized label\n   */\n\n\n  Pager.prototype.getLocalizedLabel = function (key) {\n    return this.localeObj.getConstant(key);\n  };\n  /**\n   * Navigate to target page by given number.\n   *\n   * @param  {number} pageNo - Defines page number.\n   * @returns {void}\n   */\n\n\n  Pager.prototype.goToPage = function (pageNo) {\n    if (this.checkGoToPage(pageNo)) {\n      this.currentPage = pageNo;\n      this.dataBind();\n    }\n  };\n  /**\n   * @param {number} pageSize - specifies the pagesize\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Pager.prototype.setPageSize = function (pageSize) {\n    this.pageSize = pageSize;\n    this.dataBind();\n  };\n\n  Pager.prototype.checkpagesizes = function () {\n    if (this.pageSizes === true || this.pageSizes.length) {\n      return true;\n    }\n\n    return false;\n  };\n\n  Pager.prototype.checkGoToPage = function (newPageNo, oldPageNo) {\n    if (newPageNo !== this.currentPage) {\n      this.previousPageNo = this.currentPage;\n    }\n\n    if (!isNullOrUndefined(oldPageNo)) {\n      this.previousPageNo = oldPageNo;\n    }\n\n    if (this.previousPageNo !== newPageNo && newPageNo >= 1 && newPageNo <= this.totalPages) {\n      return true;\n    }\n\n    return false;\n  };\n\n  Pager.prototype.currentPageChanged = function (newProp, oldProp) {\n    if (this.enableQueryString) {\n      this.updateQueryString(this.currentPage);\n    }\n\n    if (newProp.currentPage !== oldProp.currentPage || newProp.pageSize !== oldProp.pageSize) {\n      var args = {\n        currentPage: this.currentPage,\n        newProp: newProp,\n        oldProp: oldProp,\n        cancel: false\n      };\n      this.trigger('click', args);\n\n      if (!args.cancel) {\n        this.refresh();\n      }\n    }\n  };\n\n  Pager.prototype.pagerTemplate = function () {\n    if (this.isReactTemplate() && this.hasParent) {\n      return;\n    }\n\n    var result;\n    this.element.classList.add('e-pagertemplate');\n    this.compile(this.template);\n    var data = {\n      currentPage: this.currentPage,\n      pageSize: this.pageSize,\n      pageCount: this.pageCount,\n      totalRecordsCount: this.totalRecordsCount,\n      totalPages: this.totalPages\n    };\n    var tempId = this.element.parentElement.id + '_template';\n\n    if (this.isReactTemplate() && !this.isVue) {\n      this.getPagerTemplate()(data, this, 'template', tempId, null, null, this.element);\n      this.renderReactTemplates();\n    } else {\n      result = this.isVue ? this.getPagerTemplate()(data, this, 'template') : this.getPagerTemplate()(data);\n      appendChildren(this.element, result);\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Pager.prototype.updateTotalPages = function () {\n    this.totalPages = this.isAllPage ? 1 : this.totalRecordsCount % this.pageSize === 0 ? this.totalRecordsCount / this.pageSize : parseInt((this.totalRecordsCount / this.pageSize).toString(), 10) + 1;\n  };\n  /**\n   * @returns {Function} returns the function\n   * @hidden\n   */\n\n\n  Pager.prototype.getPagerTemplate = function () {\n    return this.templateFn;\n  };\n  /**\n   * @param {string} template - specifies the template\n   * @returns {Function} returns the function\n   * @hidden\n   */\n\n\n  Pager.prototype.compile = function (template) {\n    if (template) {\n      try {\n        if (document.querySelectorAll(template).length) {\n          this.templateFn = compile(document.querySelector(template).innerHTML.trim());\n        }\n      } catch (e) {\n        this.templateFn = compile(template);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Refreshes page count, pager information and external message.\n   *\n   * @returns {void}\n   */\n\n\n  Pager.prototype.refresh = function () {\n    if (this.template) {\n      if (this.isReactTemplate()) {\n        this.updateTotalPages();\n        this.notify(this.pageRefresh, {});\n      } else {\n        this.element.innerHTML = '';\n        this.updateTotalPages();\n        this.pagerTemplate();\n      }\n    } else {\n      this.updateRTL();\n      var focusedTabIndexElement = this.getFocusedTabindexElement();\n      this.containerModule.refresh();\n      this.removeTabindexLastElements();\n\n      if (focusedTabIndexElement && focusedTabIndexElement.classList.contains('e-disable')) {\n        if (this.checkFocusInAdaptiveMode(focusedTabIndexElement)) {\n          this.changeFocusInAdaptiveMode(focusedTabIndexElement);\n        } else {\n          this.setPagerFocusForActiveElement();\n        }\n      }\n\n      if (this.enablePagerMessage) {\n        this.pagerMessageModule.refresh();\n      }\n\n      if (this.pagerdropdownModule) {\n        this.pagerdropdownModule.refresh();\n      }\n\n      if (this.enableExternalMessage && this.externalMessageModule) {\n        this.externalMessageModule.refresh();\n      }\n\n      this.setTabIndexForFocusLastElement();\n    }\n  };\n\n  Pager.prototype.updateRTL = function () {\n    if (this.enableRtl) {\n      this.element.classList.add('e-rtl');\n    } else {\n      this.element.classList.remove('e-rtl');\n    }\n  };\n\n  Pager.prototype.initLocalization = function () {\n    this.localeObj = new L10n(this.getModuleName(), this.defaultConstants, this.locale);\n  };\n\n  Pager.prototype.updateQueryString = function (value) {\n    var updatedUrl = this.getUpdatedURL(window.location.href, 'page', value.toString());\n    window.history.pushState({\n      path: updatedUrl\n    }, '', updatedUrl);\n  };\n\n  Pager.prototype.getUpdatedURL = function (uri, key, value) {\n    var regx = new RegExp('([?|&])' + key + '=.*?(&|#|$)', 'i');\n\n    if (uri.match(regx)) {\n      return uri.replace(regx, '$1' + key + '=' + value + '$2');\n    } else {\n      var hash = '';\n\n      if (uri.indexOf('#') !== -1) {\n        hash = uri.replace(/.*#/, '#');\n        uri = uri.replace(/#.*/, '');\n      }\n\n      return uri + (uri.indexOf('?') !== -1 ? '&' : '?') + key + '=' + value + hash;\n    }\n  };\n\n  Pager.prototype.renderFirstPrevDivForDevice = function () {\n    this.element.appendChild(createElement('div', {\n      className: 'e-mfirst e-icons e-icon-first',\n      attrs: {\n        title: this.getLocalizedLabel('firstPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n    this.element.appendChild(createElement('div', {\n      className: 'e-mprev e-icons e-icon-prev',\n      attrs: {\n        title: this.getLocalizedLabel('previousPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n  };\n\n  Pager.prototype.renderNextLastDivForDevice = function () {\n    this.element.appendChild(createElement('div', {\n      className: 'e-mnext e-icons e-icon-next',\n      attrs: {\n        title: this.getLocalizedLabel('nextPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n    this.element.appendChild(createElement('div', {\n      className: 'e-mlast e-icons e-icon-last',\n      attrs: {\n        title: this.getLocalizedLabel('lastPageTooltip'),\n        tabindex: '-1'\n      }\n    }));\n  };\n\n  Pager.prototype.addAriaLabel = function () {\n    var classList$$1 = ['.e-mfirst', '.e-mprev', '.e-mnext', '.e-mlast'];\n\n    if (!Browser.isDevice) {\n      for (var i = 0; i < classList$$1.length; i++) {\n        var element = this.element.querySelector(classList$$1[i]);\n        element.setAttribute('aria-label', element.getAttribute('title'));\n      }\n    }\n  };\n\n  Pager.prototype.isReactTemplate = function () {\n    return (this.isReact || this.isVue) && this.template && typeof this.template !== 'string';\n  };\n\n  __decorate$5([Property(false)], Pager.prototype, \"enableQueryString\", void 0);\n\n  __decorate$5([Property(false)], Pager.prototype, \"enableExternalMessage\", void 0);\n\n  __decorate$5([Property(true)], Pager.prototype, \"enablePagerMessage\", void 0);\n\n  __decorate$5([Property(12)], Pager.prototype, \"pageSize\", void 0);\n\n  __decorate$5([Property(10)], Pager.prototype, \"pageCount\", void 0);\n\n  __decorate$5([Property(1)], Pager.prototype, \"currentPage\", void 0);\n\n  __decorate$5([Property()], Pager.prototype, \"totalRecordsCount\", void 0);\n\n  __decorate$5([Property()], Pager.prototype, \"externalMessage\", void 0);\n\n  __decorate$5([Property(false)], Pager.prototype, \"pageSizes\", void 0);\n\n  __decorate$5([Property()], Pager.prototype, \"template\", void 0);\n\n  __decorate$5([Property('')], Pager.prototype, \"customText\", void 0);\n\n  __decorate$5([Event()], Pager.prototype, \"click\", void 0);\n\n  __decorate$5([Property('')], Pager.prototype, \"cssClass\", void 0);\n\n  __decorate$5([Event()], Pager.prototype, \"dropDownChanged\", void 0);\n\n  __decorate$5([Event()], Pager.prototype, \"created\", void 0);\n\n  Pager = __decorate$5([NotifyPropertyChanges], Pager);\n  return Pager;\n}(Component);\n/**\n * `PagerDropDown` module handles selected pageSize from DropDownList.\n */\n\n\nvar PagerDropDown =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for pager module\n   *\n   * @param {Pager} pagerModule - specifies the pagermodule\n   * @hidden\n   */\n  function PagerDropDown(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   * @hidden\n   */\n\n\n  PagerDropDown.prototype.getModuleName = function () {\n    return 'pagerdropdown';\n  };\n  /**\n   * The function is used to render pager dropdown\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  PagerDropDown.prototype.render = function () {\n    var pagerObj = this.pagerModule;\n    this.pagerDropDownDiv = createElement('div', {\n      className: 'e-pagesizes'\n    });\n    var dropDownDiv = createElement('div', {\n      className: 'e-pagerdropdown'\n    });\n    var defaultTextDiv = createElement('div', {\n      className: 'e-pagerconstant'\n    });\n    var input = createElement('input', {\n      attrs: {\n        type: 'text',\n        tabindex: '-1'\n      }\n    });\n    this.pagerCons = createElement('span', {\n      className: 'e-constant',\n      innerHTML: this.pagerModule.getLocalizedLabel('pagerDropDown')\n    });\n    dropDownDiv.appendChild(input);\n    defaultTextDiv.appendChild(this.pagerCons);\n    this.pagerDropDownDiv.appendChild(dropDownDiv);\n    this.pagerDropDownDiv.appendChild(defaultTextDiv);\n    this.pagerModule.element.appendChild(this.pagerDropDownDiv);\n    var pageSizesModule = this.pagerModule.pageSizes;\n    var pageSizesArray = pageSizesModule.length ? this.convertValue(pageSizesModule) : [this.pagerModule.getLocalizedLabel('All'), '5', '10', '12', '20'];\n    var defaultValue = this.pagerModule.pageSize;\n    this.dropDownListObject = new DropDownList({\n      dataSource: pageSizesArray,\n      value: defaultValue.toString(),\n      change: this.onChange.bind(this),\n      placeholder: this.pagerModule.getLocalizedLabel('pagerDropDown'),\n      cssClass: this.pagerModule.cssClass ? 'e-alldrop' + ' ' + this.pagerModule.cssClass : 'e-alldrop'\n    });\n    this.dropDownListObject.appendTo(input);\n\n    if (pageSizesModule.length) {\n      this.dropDownListObject.element.value = this.pagerModule.pageSize.toString();\n    }\n\n    pagerObj.pageSize = defaultValue;\n    pagerObj.dataBind();\n    pagerObj.trigger('dropDownChanged', {\n      pageSize: defaultValue\n    });\n    this.addEventListener();\n  };\n  /**\n   * For internal use only - Get the pagesize.\n   *\n   * @param {ChangeEventArgs} e - specifies the changeeventargs\n   * @returns {void}\n   * @private\n   * @hidden\n   */\n\n\n  PagerDropDown.prototype.onChange = function (e) {\n    if (this.dropDownListObject.value === this.pagerModule.getLocalizedLabel('All')) {\n      this.pagerModule.pageSize = this.pagerModule.totalRecordsCount;\n      this.pagerModule.isAllPage = true;\n      this.refresh();\n      e.value = this.pagerModule.pageSize;\n\n      if (document.getElementsByClassName('e-popup-open e-alldrop').length) {\n        document.getElementsByClassName('e-popup-open e-alldrop')[0].style.display = 'none';\n      }\n    } else {\n      this.pagerModule.pageSize = parseInt(this.dropDownListObject.value, 10);\n      this.pagerModule.isAllPage = false;\n\n      if (this.pagerCons.innerHTML !== this.pagerModule.getLocalizedLabel('pagerDropDown')) {\n        this.refresh();\n      }\n    }\n\n    this.pagerModule.dataBind();\n    this.pagerModule.trigger('dropDownChanged', {\n      pageSize: this.pagerModule.isAllPage ? this.pagerModule.totalRecordsCount : parseInt(this.dropDownListObject.value, 10)\n    });\n  };\n\n  PagerDropDown.prototype.refresh = function () {\n    if (this.pagerCons) {\n      if (this.pagerModule.pageSize === this.pagerModule.totalRecordsCount) {\n        this.pagerCons.innerHTML = this.pagerModule.getLocalizedLabel('pagerAllDropDown');\n      } else {\n        this.pagerCons.innerHTML = this.pagerModule.getLocalizedLabel('pagerDropDown');\n      }\n    }\n  };\n\n  PagerDropDown.prototype.beforeValueChange = function (prop) {\n    if (typeof prop.newProp.value === 'number') {\n      var val = prop.newProp.value.toString();\n      prop.newProp.value = val;\n    }\n  };\n\n  PagerDropDown.prototype.convertValue = function (pageSizeValue) {\n    var item = pageSizeValue;\n\n    for (var i = 0; i < item.length; i++) {\n      item[i] = parseInt(item[i], 10) ? item[i].toString() : this.pagerModule.getLocalizedLabel(item[i]) !== '' ? this.pagerModule.getLocalizedLabel(item[i]) : item[i];\n    }\n\n    return item;\n  };\n\n  PagerDropDown.prototype.setDropDownValue = function (prop, value) {\n    if (this.dropDownListObject) {\n      this.dropDownListObject[prop] = this.pagerModule.isAllPage ? this.pagerModule.getLocalizedLabel('All') : value;\n    }\n  };\n\n  PagerDropDown.prototype.addEventListener = function () {\n    this.dropDownListObject.on('beforeValueChange', this.beforeValueChange, this);\n  };\n\n  PagerDropDown.prototype.removeEventListener = function () {\n    this.dropDownListObject.off('beforeValueChange', this.beforeValueChange);\n  };\n  /**\n   * To destroy the Pagerdropdown\n   *\n   * @param {string} args - specifies the arguments\n   * @param {string} args.requestType - specfies the request type\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  PagerDropDown.prototype.destroy = function (args) {\n    if (this.dropDownListObject && !this.dropDownListObject.isDestroyed) {\n      this.removeEventListener();\n      this.dropDownListObject.destroy();\n      remove(this.pagerDropDownDiv);\n    }\n  };\n\n  return PagerDropDown;\n}();\n/**\n * `ExternalMessage` module is used to display user provided message.\n */\n\n\nvar ExternalMessage =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for externalMessage module\n   *\n   * @param {Pager} pagerModule - specifies the pagermodule\n   * @hidden\n   */\n  function ExternalMessage(pagerModule) {\n    this.pagerModule = pagerModule;\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  ExternalMessage.prototype.getModuleName = function () {\n    return 'externalMessage';\n  };\n  /**\n   * The function is used to render pager externalMessage\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ExternalMessage.prototype.render = function () {\n    this.element = createElement('div', {\n      className: 'e-pagerexternalmsg',\n      attrs: {\n        'aria-label': this.pagerModule.getLocalizedLabel('ExternalMsg')\n      }\n    });\n    this.pagerModule.element.appendChild(this.element);\n    this.refresh();\n  };\n  /**\n   * Refreshes the external message of Pager.\n   *\n   * @returns {void}\n   */\n\n\n  ExternalMessage.prototype.refresh = function () {\n    if (this.pagerModule.externalMessage && this.pagerModule.externalMessage.toString().length) {\n      this.showMessage();\n      this.element.innerHTML = this.pagerModule.externalMessage;\n    } else {\n      this.hideMessage();\n    }\n  };\n  /**\n   * Hides the external message of Pager.\n   *\n   * @returns {void}\n   */\n\n\n  ExternalMessage.prototype.hideMessage = function () {\n    if (!isNullOrUndefined(this.element)) {\n      this.element.style.display = 'none';\n    }\n  };\n  /**\n   * Shows the external message of the Pager.\n   *\n   * @returns {void}s\n   */\n\n\n  ExternalMessage.prototype.showMessage = function () {\n    this.element.style.display = '';\n  };\n  /**\n   * To destroy the PagerMessage\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ExternalMessage.prototype.destroy = function () {\n    remove(this.element);\n  };\n\n  return ExternalMessage;\n}();\n/**\n * The `Page` module is used to render pager and handle paging action.\n */\n\n\nvar Page =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid paging module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {PageSettingsModel} pageSettings - specifies the PageSettingsModel\n   * @hidden\n   */\n  function Page(parent, pageSettings) {\n    this.isInitialRender = true;\n    this.isCancel = false;\n    Pager.Inject(ExternalMessage, PagerDropDown);\n    this.parent = parent;\n    this.pageSettings = pageSettings;\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Page.prototype.getModuleName = function () {\n    return 'pager';\n  };\n  /**\n   * The function used to render pager from grid pageSettings\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.render = function () {\n    var gObj = this.parent;\n    this.pagerDestroy();\n\n    if (!isNullOrUndefined(this.parent.pagerTemplate)) {\n      this.pageSettings.template = this.parent.pagerTemplate;\n      this.parent.pageTemplateChange = true;\n    }\n\n    this.element = this.parent.createElement('div', {\n      className: 'e-gridpager'\n    });\n    var pagerObj = extend$1({}, extend({}, getActualProperties(this.pageSettings)), {\n      click: this.clickHandler.bind(this),\n      dropDownChanged: this.onSelect.bind(this),\n      enableRtl: gObj.enableRtl,\n      locale: gObj.locale,\n      created: this.addAriaAttr.bind(this)\n    }, ['parentObj', 'propName']);\n    pagerObj.cssClass = this.parent.cssClass ? this.parent.cssClass : '';\n    this.pagerObj = new Pager(pagerObj, undefined, this.parent);\n    this.pagerObj.hasParent = true;\n    this.pagerObj.on(pagerRefresh, this.renderReactPagerTemplate, this);\n    this.pagerObj.allowServerDataBinding = false;\n  };\n\n  Page.prototype.onSelect = function (e) {\n    this.pageSettings.pageSize = e.pageSize;\n\n    if (!this.isInitialLoad) {\n      this.pageSettings.currentPage = 1;\n    }\n  };\n\n  Page.prototype.addAriaAttr = function () {\n    if (!this.pageSettings.template) {\n      var numericContainerNew = this.parent.createElement('div', {\n        className: 'e-numericcontainer'\n      });\n      var pagerContainer = this.element.querySelector('.e-pagercontainer');\n      var frag = document.createDocumentFragment();\n      var numericContainer = this.element.querySelector('.e-numericcontainer');\n      var links = numericContainer.querySelectorAll('a');\n\n      for (var i = 0; i < links.length; i++) {\n        if (this.parent.getContentTable()) {\n          links[i].setAttribute('aria-owns', this.parent.getContentTable().id);\n        } else {\n          links[i].setAttribute('aria-owns', this.parent.element.getAttribute('id') + '_content_table');\n        }\n\n        var numericContainerDiv = this.parent.createElement('div');\n        numericContainerDiv.appendChild(links[i]);\n        frag.appendChild(numericContainerDiv);\n      }\n\n      numericContainerNew.appendChild(frag);\n      pagerContainer.replaceChild(numericContainerNew, numericContainer);\n      var classList$$1 = ['.e-mfirst', '.e-mprev', '.e-first', '.e-prev', '.e-next', '.e-last', '.e-mnext', '.e-mlast'];\n\n      for (var j = 0; j < classList$$1.length; j++) {\n        var element = this.element.querySelector(classList$$1[j]);\n\n        if (this.parent.getContentTable()) {\n          element.setAttribute('aria-owns', this.parent.getContentTable().id);\n        }\n      }\n    }\n  };\n\n  Page.prototype.dataReady = function (e) {\n    this.updateModel(e);\n  };\n  /**\n   * Refreshes the page count, pager information, and external message.\n   *\n   * @returns {void}\n   */\n\n\n  Page.prototype.refresh = function () {\n    this.pagerObj.refresh();\n  };\n  /**\n   * Navigates to the target page according to the given number.\n   *\n   * @param  {number} pageNo - Defines the page number to navigate.\n   * @returns {void}\n   */\n\n\n  Page.prototype.goToPage = function (pageNo) {\n    this.pagerObj.goToPage(pageNo);\n  };\n  /**\n   * @param {number} pageSize - specifies the page size\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.setPageSize = function (pageSize) {\n    this.pagerObj.setPageSize(pageSize);\n  };\n  /**\n   * The function used to update pageSettings model\n   *\n   * @param {NotifyArgs} e - specfies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.updateModel = function (e) {\n    this.parent.pageSettings.totalRecordsCount = e.count;\n    this.parent.dataBind();\n  };\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.onActionComplete = function (e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      currentPage: this.parent.pageSettings.currentPage,\n      requestType: 'paging',\n      type: actionComplete\n    }));\n  };\n  /**\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    var newProp = e.properties;\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n      this.pagerObj[prop] = newProp[prop];\n    }\n\n    this.pagerObj.dataBind();\n  };\n\n  Page.prototype.clickHandler = function (e) {\n    var gObj = this.parent;\n\n    if (this.isForceCancel || isActionPrevent(gObj) && !gObj.prevPageMoving && !this.isCancel) {\n      if (!this.isForceCancel) {\n        if (!isNullOrUndefined(e.newProp) && !isNullOrUndefined(e.newProp.pageSize)) {\n          gObj.notify(preventBatch, {\n            instance: this,\n            handler: this.setPageSize,\n            arg1: e.newProp.pageSize\n          });\n          this.pagerObj.pageSize = e.oldProp.pageSize;\n          gObj.pageSettings.pageSize = e.newProp.pageSize;\n        } else if (e.currentPage) {\n          gObj.notify(preventBatch, {\n            instance: this,\n            handler: this.goToPage,\n            arg1: e.currentPage\n          });\n          this.pagerObj.currentPage = gObj.pageSettings.currentPage === this.pagerObj.currentPage ? this.pagerObj.previousPageNo : gObj.pageSettings.currentPage;\n        }\n\n        this.isForceCancel = true;\n        this.pagerObj.dataBind();\n      } else {\n        this.isForceCancel = false;\n      }\n\n      e.cancel = true;\n      return;\n    }\n\n    gObj.pageSettings.pageSize = this.pagerObj.pageSize;\n    gObj.prevPageMoving = false;\n    var prevPage = this.pageSettings.currentPage;\n    var args = {\n      cancel: false,\n      requestType: 'paging',\n      previousPage: prevPage,\n      currentPage: e.currentPage,\n      type: actionBegin\n    };\n\n    if (!this.isCancel) {\n      this.pageSettings.currentPage = e.currentPage;\n      this.parent.notify(modelChanged, args);\n    }\n\n    if (args.cancel) {\n      e.cancel = true;\n      this.pageSettings.currentPage = prevPage;\n      this.pagerObj.currentPage = prevPage;\n      this.isCancel = true;\n      return;\n    }\n\n    this.isCancel = false;\n    this.parent.requestTypeAction = 'paging';\n  };\n\n  Page.prototype.keyPressHandler = function (e) {\n    if (e.action in keyActions) {\n      e.preventDefault();\n      this.element.querySelector(keyActions[e.action]).click();\n    }\n  };\n  /**\n   * Defines the text of the external message.\n   *\n   * @param  {string} message - Defines the message to update.\n   * @returns {void}\n   */\n\n\n  Page.prototype.updateExternalMessage = function (message) {\n    if (!this.pagerObj.enableExternalMessage) {\n      this.pagerObj.enableExternalMessage = true;\n      this.pagerObj.dataBind();\n    }\n\n    this.pagerObj.externalMessage = message;\n    this.pagerObj.dataBind();\n  };\n\n  Page.prototype.appendToElement = function () {\n    this.isInitialLoad = true;\n    this.parent.element.appendChild(this.element);\n    this.parent.setGridPager(this.element);\n    this.pagerObj.isReact = this.parent.isReact;\n    this.pagerObj.isVue = this.parent.isVue;\n    this.pagerObj.appendTo(this.element);\n    this.isInitialLoad = false;\n  };\n\n  Page.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n      this.appendToElement();\n\n      if (this.isReactTemplate()) {\n        this.pagerObj.updateTotalPages();\n        this.created();\n      }\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.addEventListener = function () {\n    this.handlers = {\n      load: this.render,\n      end: this.appendToElement,\n      ready: this.dataReady,\n      complete: this.onActionComplete,\n      updateLayout: this.enableAfterRender,\n      inboundChange: this.onPropertyChanged,\n      keyPress: this.keyPressHandler,\n      created: this.created\n    };\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (this.parent.isReact || this.parent.isVue) {\n      this.parent.addEventListener(create, this.handlers.created.bind(this));\n    }\n\n    this.evtHandlers = [{\n      event: initialLoad,\n      handler: this.handlers.load\n    }, {\n      event: initialEnd,\n      handler: this.handlers.end\n    }, {\n      event: dataReady,\n      handler: this.handlers.ready\n    }, {\n      event: pageComplete,\n      handler: this.handlers.complete\n    }, {\n      event: uiUpdate,\n      handler: this.handlers.updateLayout\n    }, {\n      event: inBoundModelChanged,\n      handler: this.handlers.inboundChange\n    }, {\n      event: keyPressed,\n      handler: this.handlers.keyPress\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  };\n\n  Page.prototype.created = function () {\n    if (this.isInitialRender && this.isReactTemplate()) {\n      this.isInitialRender = false;\n      this.renderReactPagerTemplate();\n    }\n  };\n\n  Page.prototype.isReactTemplate = function () {\n    return (this.parent.isReact || this.parent.isVue) && this.pagerObj.template && typeof this.pagerObj.template !== 'string';\n  };\n\n  Page.prototype.renderReactPagerTemplate = function () {\n    if (!this.isInitialRender && this.isReactTemplate()) {\n      var result = void 0;\n      this.parent.destroyTemplate(['pagerTemplate']);\n      this.element.classList.add('e-pagertemplate');\n      this.pagerObj.compile(this.pagerObj.template);\n      var page = this.parent.pageSettings;\n      var data = {\n        currentPage: page.currentPage,\n        pageSize: page.pageSize,\n        pageCount: page.pageCount,\n        totalRecordsCount: page.totalRecordsCount,\n        totalPages: this.pagerObj.totalPages\n      };\n      var tempId = this.parent.id + '_pagertemplate';\n\n      if (this.parent.isReact) {\n        this.pagerObj.templateFn(data, this.parent, 'pagerTemplate', tempId, null, null, this.pagerObj.element);\n        this.parent.renderTemplates();\n      } else {\n        result = this.pagerObj.templateFn(data, this.parent, 'pagerTemplate');\n        appendChildren(this.pagerObj.element, result);\n      }\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (this.parent.isReact || this.parent.isVue) {\n      this.parent.removeEventListener(create, this.handlers.created);\n    }\n\n    this.parent.off(pagerRefresh, this.renderReactPagerTemplate);\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  };\n  /**\n   * To destroy the pager\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Page.prototype.destroy = function () {\n    this.removeEventListener();\n\n    if (this.isReactTemplate()) {\n      this.parent.destroyTemplate(['pagerTemplate']);\n    }\n\n    this.pagerObj.destroy();\n  };\n\n  Page.prototype.pagerDestroy = function () {\n    if (this.pagerObj && !this.pagerObj.isDestroyed) {\n      this.pagerObj.destroy();\n      remove(this.element);\n    }\n  };\n\n  return Page;\n}();\n/**\n * @hidden\n */\n\n\nvar keyActions = {\n  pageUp: '.e-prev',\n  pageDown: '.e-next',\n  ctrlAltPageDown: '.e-last',\n  ctrlAltPageUp: '.e-first',\n  altPageUp: '.e-pp',\n  altPageDown: '.e-np'\n};\n\nvar __extends$20 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * FilterCellRenderer class which responsible for building filter cell.\n *\n * @hidden\n */\n\n\nvar FilterCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$20(FilterCellRenderer, _super);\n\n  function FilterCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TH', {\n      className: 'e-filterbarcell'\n    });\n    return _this;\n  }\n  /**\n   * Function to return the wrapper for the TH content.\n   *\n   * @returns {string} returns the gui\n   */\n\n\n  FilterCellRenderer.prototype.getGui = function () {\n    return this.parent.createElement('div');\n  };\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param  {Cell} cell\n   * @param  {Object} data\n   */\n\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  FilterCellRenderer.prototype.render = function (cell, data) {\n    var tr = this.parent.element.querySelector('.e-filterbar');\n    var node = this.element.cloneNode();\n    var innerDIV = this.getGui();\n    var input;\n    var column = cell.column;\n    tr.appendChild(node);\n    node.setAttribute('e-mappinguid', column.uid);\n\n    if (column.filterTemplate) {\n      var fltrData = {};\n\n      if (data) {\n        fltrData[column.field] = data[column.field];\n      }\n\n      var col = 'column';\n      fltrData[col] = column;\n\n      if (column.visible) {\n        var isReactCompiler = this.parent.isReact && typeof column.filterTemplate !== 'string';\n        var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n        var tempID = this.parent.element.id + column.uid + 'filterTemplate';\n\n        if (isReactCompiler || isReactChild) {\n          column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID, null, null, node);\n          this.parent.renderTemplates();\n        } else {\n          var element = column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID);\n          appendChildren(node, element);\n        }\n      } else {\n        node.classList.add('e-hide');\n      }\n    } else {\n      if (column.type !== 'checkbox') {\n        if ((isNullOrUndefined(column.allowFiltering) || column.allowFiltering) && !isNullOrUndefined(column.filterBarTemplate)) {\n          node.classList.add('e-fltrtemp');\n          attributes(innerDIV, {\n            'class': 'e-fltrtempdiv'\n          });\n\n          if (isNullOrUndefined(column.filterBarTemplate.create)) {\n            input = this.parent.createElement('input', {\n              id: column.field + '_filterBarcell',\n              className: 'e-filterUi_input e-filtertext e-fltrTemp',\n              attrs: {\n                type: 'search',\n                title: column.headerText\n              }\n            });\n            innerDIV.appendChild(input);\n          } else {\n            var args = {\n              column: column,\n              node: Element\n            };\n            var temp = column.filterBarTemplate.create;\n\n            if (typeof temp === 'string') {\n              temp = getValue(temp, window);\n            }\n\n            input = temp(args);\n\n            if (typeof input === 'string') {\n              var div = this.parent.createElement('div');\n              div.innerHTML = input;\n              input = div.firstChild;\n            }\n\n            attributes(innerDIV, {\n              class: 'e-filterUi_input e-filtertext e-fltrTemp',\n              title: column.headerText,\n              id: column.field + '_filterBarcell'\n            });\n            innerDIV.appendChild(input);\n          }\n        } else {\n          attributes(innerDIV, {\n            'class': 'e-filterdiv e-fltrinputdiv'\n          });\n          input = this.parent.createElement('input', {\n            id: column.field + '_filterBarcell',\n            className: 'e-filtertext',\n            attrs: {\n              type: 'search',\n              title: column.headerText + cell.attributes.title,\n              value: data[cell.column.field] ? data[cell.column.field] : '',\n              role: 'search'\n            }\n          });\n          innerDIV.appendChild(input);\n          var args = {\n            element: input,\n            floatLabelType: 'Never',\n            properties: {\n              enableRtl: this.parent.enableRtl,\n              showClearButton: true,\n              cssClass: this.parent.cssClass\n            }\n          };\n          Input.createInput(args, this.parent.createElement);\n        } //TODO: apply intial filtering\n\n\n        if (column.allowFiltering === false || column.field === '' || isNullOrUndefined(column.field)) {\n          input.setAttribute('disabled', 'true');\n          input.classList.add('e-disable');\n        }\n\n        if (!column.visible) {\n          node.classList.add('e-hide');\n        }\n\n        this.appendHtml(node, innerDIV); // render's the dropdownlist component if showFilterBarOperator sets to true\n\n        if (this.parent.filterSettings.showFilterBarOperator && this.parent.filterSettings.type === 'FilterBar' && !this.parent.isPrinting && isNullOrUndefined(column.filterTemplate) && isNullOrUndefined(column.filterBarTemplate)) {\n          this.operatorIconRender(innerDIV, column, cell);\n        }\n\n        if ((isNullOrUndefined(column.allowFiltering) || column.allowFiltering) && !isNullOrUndefined(column.filterBarTemplate)) {\n          var templateWrite = column.filterBarTemplate.write;\n          var args = {\n            element: input,\n            column: column\n          };\n\n          if (typeof templateWrite === 'string') {\n            templateWrite = getValue(templateWrite, window);\n          }\n\n          templateWrite.call(this, args);\n        }\n      }\n    }\n\n    return node;\n  };\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   *\n   * @param {Element} node - specifies the node\n   * @param {string|Element} innerHtml - specifies the innerHTML\n   * @returns {Element} retruns the element\n   */\n\n\n  FilterCellRenderer.prototype.appendHtml = function (node, innerHtml) {\n    node.appendChild(innerHtml);\n    return node;\n  };\n\n  FilterCellRenderer.prototype.operatorIconRender = function (innerDIV, column, cell) {\n    var gObj = this.parent;\n    var operators;\n    var fbicon = this.parent.createElement('input', {\n      className: ' e-filterbaroperator e-icons e-icon-filter',\n      id: cell.column.uid\n    });\n    innerDIV.querySelector('span').appendChild(fbicon);\n\n    if (column.filter && column.filter.operator) {\n      operators = column.filter.operator;\n    } else if (gObj.filterSettings.columns.length) {\n      for (var i = 0, a = gObj.filterSettings.columns; i < a.length; i++) {\n        var col = a[i];\n\n        if (col.field === column.field) {\n          operators = col.operator;\n        } else {\n          operators = 'equal';\n        }\n      }\n    } else {\n      operators = 'equal';\n    }\n\n    if (!isNullOrUndefined(gObj.filterModule.operators[column.field])) {\n      operators = gObj.filterModule.operators[column.field];\n    }\n\n    this.dropOptr = new DropDownList({\n      fields: {\n        text: 'text',\n        value: 'value'\n      },\n      popupHeight: 'auto',\n      value: operators,\n      width: '0px',\n      enabled: column.allowFiltering,\n      popupWidth: 'auto',\n      enableRtl: this.parent.enableRtl,\n      change: this.internalEvent.bind(this),\n      beforeOpen: function () {\n        var operator = gObj.filterModule.customOperators;\n        this.dataSource = operator[gObj.getColumnByUid(this.element.id).type + 'Operator'];\n\n        for (var i = 0; i < this.dataSource.length; i++) {\n          if (column.filter && column.filter.operator && isNullOrUndefined(gObj.filterModule.operators[column.field]) && this.dataSource[i].value === column.filter.operator) {\n            this.value = column.filter.operator;\n          }\n        }\n      },\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    });\n    this.dropOptr.appendTo(fbicon);\n    var spanElmt = closest(this.dropOptr.element, 'span');\n    spanElmt.classList.add('e-filterbardropdown');\n    spanElmt.removeAttribute('tabindex');\n  };\n\n  FilterCellRenderer.prototype.internalEvent = function (e) {\n    var gObj = this.parent;\n    var col = gObj.getColumnByUid(e.element.getAttribute('id'));\n    e.column = col;\n    gObj.filterModule.operators[col.field] = e.value;\n    gObj.notify(getFilterBarOperator, e);\n  };\n\n  return FilterCellRenderer;\n}(CellRenderer);\n/**\n * `filter operators` render boolean column.\n *\n * @hidden\n */\n\n\nvar FlMenuOptrUI =\n/** @__PURE__ @class */\nfunction () {\n  function FlMenuOptrUI(parent, customFltrOperators, serviceLocator, filterSettings) {\n    this.ddOpen = this.dropDownOpen.bind(this);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.filterSettings = filterSettings;\n    this.customFilterOperators = customFltrOperators;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroyDropDownList, this);\n      this.parent.on(destroy, this.destroyDropDownList, this);\n    }\n  }\n  /**\n   * @param {Element} dlgConetntEle - specifies the content element\n   * @param {Element} target - specifies the target\n   * @param {Column} column - specifies the column\n   * @param {Dialog} dlgObj - specifies the dialog\n   * @param {Object[]} operator - specifies the operator list\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line max-len\n\n\n  FlMenuOptrUI.prototype.renderOperatorUI = function (dlgConetntEle, target, column, dlgObj, operator) {\n    this.dialogObj = dlgObj;\n    var optr = column.type + 'Operator';\n    this.optrData = this.customOptr = !isNullOrUndefined(operator) ? operator : !isNullOrUndefined(this.parent.filterSettings.operators) && !isNullOrUndefined(this.parent.filterSettings.operators[optr]) ? this.parent.filterSettings.operators[optr] : this.customFilterOperators[optr];\n    var dropDatasource = this.customOptr;\n    var selectedValue = this.dropSelectedVal(column, optr);\n    var optrDiv = this.parent.createElement('div', {\n      className: 'e-flm_optrdiv'\n    });\n    dlgConetntEle.appendChild(optrDiv);\n    var optrInput = this.parent.createElement('input', {\n      id: column.uid + '-floptr'\n    });\n    optrDiv.appendChild(optrInput);\n    this.dropOptr = new DropDownList({\n      dataSource: dropDatasource,\n      fields: {\n        text: 'text',\n        value: 'value'\n      },\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      enableRtl: this.parent.enableRtl,\n      text: selectedValue\n    });\n    this.dropOptr.addEventListener(open, this.ddOpen);\n    this.dropOptr.appendTo('#' + column.uid + '-floptr');\n  };\n\n  FlMenuOptrUI.prototype.renderResponsiveDropDownList = function (args) {\n    args.popup.element.style.width = '100%';\n  };\n\n  FlMenuOptrUI.prototype.dropDownOpen = function (args) {\n    args.popup.element.style.zIndex = (this.dialogObj.zIndex + 1).toString();\n\n    if (this.parent.enableAdaptiveUI) {\n      this.renderResponsiveDropDownList(args);\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  FlMenuOptrUI.prototype.dropSelectedVal = function (col, optr) {\n    var selValue = '';\n    var columns = this.parent.filterSettings.columns;\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var column = columns_1[_i];\n\n      if (col.field === column.field || col.isForeignColumn() && col.foreignKeyValue === column.field) {\n        var selectedField = new DataManager(this.optrData).executeLocal(new Query().where('value', 'equal', column.operator));\n        selValue = !isNullOrUndefined(selectedField[0]) ? selectedField[0].text : '';\n      }\n    }\n\n    if (selValue === '') {\n      // rewuired or not\n      if (col.filter.operator) {\n        var optrLen = Object.keys(this.optrData).length;\n\n        for (var i = 0; i < optrLen; i++) {\n          if (this.optrData[i].value === col.filter.operator) {\n            selValue = this.optrData[i].text;\n          }\n        }\n      } else {\n        selValue = this.optrData[0].text;\n      }\n    }\n\n    return selValue;\n  };\n  /**\n   * @returns {string} returns the operator\n   * @hidden\n   */\n\n\n  FlMenuOptrUI.prototype.getFlOperator = function () {\n    return this.dropOptr.value;\n  };\n\n  FlMenuOptrUI.prototype.destroyDropDownList = function () {\n    if (this.dropOptr.isDestroyed) {\n      return;\n    }\n\n    this.dropOptr.removeEventListener(open, this.ddOpen);\n    this.dropOptr.destroy();\n    this.parent.off(filterMenuClose, this.destroyDropDownList);\n    this.parent.off(destroy, this.destroyDropDownList);\n  };\n\n  return FlMenuOptrUI;\n}();\n/**\n * `string filterui` render string column.\n *\n * @hidden\n */\n\n\nvar StringFilterUI =\n/** @__PURE__ @class */\nfunction () {\n  function StringFilterUI(parent, serviceLocator, filterSettings) {\n    this.parent = parent;\n    this.serLocator = serviceLocator;\n    this.filterSettings = filterSettings;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  StringFilterUI.prototype.create = function (args) {\n    this.instance = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'strui-' + args.column.uid\n    });\n    args.target.appendChild(this.instance);\n    this.dialogObj = args.dialogObj;\n    this.processDataOperation(args);\n  };\n\n  StringFilterUI.prototype.processDataOperation = function (args) {\n    var _this = this;\n\n    if (args.column.isForeignColumn()) {\n      this.parent.getDataModule().dataManager.executeQuery(this.parent.getDataModule().generateQuery(true)).then(function (result) {\n        _this.getAutoCompleteOptions(args, result);\n      });\n      return;\n    }\n\n    this.getAutoCompleteOptions(args);\n  };\n\n  StringFilterUI.prototype.getAutoCompleteOptions = function (args, result) {\n    var isForeignColumn = args.column.isForeignColumn();\n    var foreignColumnQuery;\n\n    if (isForeignColumn) {\n      var filteredData = CheckBoxFilterBase.getDistinct(result.result, args.column.field).records || [];\n      var filterQuery = void 0;\n\n      for (var i = 0; i < filteredData.length; i++) {\n        if (filterQuery) {\n          filterQuery = filterQuery.or(args.column.field, 'contains', filteredData[i][args.column.field], this.parent.filterSettings.enableCaseSensitivity, this.parent.filterSettings.ignoreAccent);\n        } else {\n          filterQuery = new Predicate(args.column.field, 'contains', filteredData[i][args.column.field], this.parent.filterSettings.enableCaseSensitivity, this.parent.filterSettings.ignoreAccent);\n        }\n      }\n\n      foreignColumnQuery = new Query().where(filterQuery);\n      foreignColumnQuery.params = this.parent.query.params;\n    }\n\n    var dataSource = isForeignColumn ? args.column.dataSource : this.parent.dataSource;\n    var fields = {\n      value: isForeignColumn ? args.column.foreignKeyValue : args.column.field\n    };\n    var autoComplete = new AutoComplete(extend({\n      dataSource: dataSource instanceof DataManager ? dataSource : new DataManager(dataSource),\n      fields: fields,\n      locale: this.parent.locale,\n      enableRtl: this.parent.enableRtl,\n      query: isForeignColumn ? foreignColumnQuery : this.parent.getDataModule().generateQuery(true),\n      sortOrder: 'Ascending',\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      autofill: true,\n      placeholder: args.localizeText.getConstant('EnterValue')\n    }, args.column.filter.params));\n    this.acFocus = this.focus(autoComplete, args);\n    this.acComplete = this.actionComplete(autoComplete);\n    this.acOpen = this.openPopup.bind(this);\n    autoComplete.addEventListener(focus, this.acFocus);\n    autoComplete.addEventListener(open, this.acOpen);\n    autoComplete.addEventListener(actionComplete, this.acComplete);\n\n    if (dataSource && 'result' in dataSource) {\n      var query = this.parent.getQuery ? this.parent.getQuery().clone() : new Query();\n      var defObj = eventPromise({\n        requestType: 'stringfilterrequest'\n      }, query);\n      this.parent.trigger(dataStateChange, defObj.state);\n      var def = defObj.deffered;\n      def.promise.then(function (e) {\n        autoComplete.dataSource = new DataManager(e);\n      });\n    }\n\n    this.actObj = autoComplete;\n    this.actObj.appendTo(this.instance);\n\n    if (isForeignColumn) {\n      this.parent.filterModule.filterModule.afterRenderFilterUI();\n    }\n  };\n\n  StringFilterUI.prototype.write = function (args) {\n    if (args.filteredValue !== '' && !isNullOrUndefined(args.filteredValue)) {\n      var struiObj = document.querySelector('#strui-' + args.column.uid).ej2_instances[0];\n      struiObj.value = args.filteredValue;\n    }\n  };\n\n  StringFilterUI.prototype.read = function (element, column, filterOptr, filterObj) {\n    var actuiObj = document.querySelector('#strui-' + column.uid).ej2_instances[0];\n\n    if (Browser.isDevice) {\n      actuiObj.hidePopup();\n      actuiObj.focusOut();\n    }\n\n    var filterValue = actuiObj.value;\n\n    if (isNullOrUndefined(filterValue) || filterValue === '') {\n      filterValue = null;\n    }\n\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', this.parent.filterSettings.enableCaseSensitivity);\n  };\n\n  StringFilterUI.prototype.openPopup = function (args) {\n    getZIndexCalcualtion(args, this.dialogObj);\n  };\n\n  StringFilterUI.prototype.focus = function (actObj, args) {\n    return function () {\n      actObj.filterType = args.getOptrInstance.getFlOperator();\n    };\n  };\n\n  StringFilterUI.prototype.actionComplete = function (actObj) {\n    return function (e) {\n      e.result = e.result.filter(function (obj, index, arr) {\n        return arr.map(function (mapObj) {\n          return getValue(actObj.fields.value, mapObj);\n        }).indexOf(getValue(actObj.fields.value, obj)) === index;\n      });\n    };\n  };\n\n  StringFilterUI.prototype.destroy = function () {\n    if (!this.actObj || this.actObj.isDestroyed) {\n      return;\n    }\n\n    this.actObj.removeEventListener(focus, this.acFocus);\n    this.actObj.removeEventListener(open, this.acOpen);\n    this.actObj.removeEventListener(actionComplete, this.acComplete);\n    this.actObj.destroy();\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  return StringFilterUI;\n}();\n/**\n * `numberfilterui` render number column.\n *\n * @hidden\n */\n\n\nvar NumberFilterUI =\n/** @__PURE__ @class */\nfunction () {\n  function NumberFilterUI(parent, serviceLocator, filterSettings) {\n    this.filterSettings = filterSettings;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  NumberFilterUI.prototype.keyEventHandler = function (args) {\n    if (args.keyCode === 13 || args.keyCode === 9) {\n      var evt = document.createEvent('HTMLEvents');\n      evt.initEvent('change', false, true); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.dispatchEvent(evt);\n    }\n  };\n\n  NumberFilterUI.prototype.create = function (args) {\n    this.instance = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'numberui-' + args.column.uid\n    });\n    args.target.appendChild(this.instance);\n    this.numericTxtObj = new NumericTextBox(extend({\n      format: typeof args.column.format === 'string' || isUndefined(args.column.format) ? args.column.format : args.column.format.format,\n      locale: this.parent.locale,\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      placeholder: args.localizeText.getConstant('EnterValue'),\n      enableRtl: this.parent.enableRtl\n    }, args.column.filter.params));\n    this.numericTxtObj.appendTo(this.instance);\n  };\n\n  NumberFilterUI.prototype.write = function (args) {\n    var numberuiObj = document.querySelector('#numberui-' + args.column.uid).ej2_instances[0];\n    numberuiObj.element.addEventListener('keydown', this.keyEventHandler);\n    numberuiObj.value = args.filteredValue;\n  };\n\n  NumberFilterUI.prototype.read = function (element, column, filterOptr, filterObj) {\n    var numberuiObj = document.querySelector('#numberui-' + column.uid).ej2_instances[0];\n    var filterValue = numberuiObj.value;\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', true);\n  };\n\n  NumberFilterUI.prototype.destroy = function () {\n    if (!this.numericTxtObj || this.numericTxtObj.isDestroyed) {\n      return;\n    }\n\n    this.numericTxtObj.destroy();\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  return NumberFilterUI;\n}();\n/**\n * `boolfilterui` render boolean column.\n *\n * @hidden\n */\n\n\nvar BooleanFilterUI =\n/** @__PURE__ @class */\nfunction () {\n  function BooleanFilterUI(parent, serviceLocator, filterSettings) {\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.filterSettings = filterSettings;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  BooleanFilterUI.prototype.create = function (args) {\n    var isForeignColumn = args.column.isForeignColumn();\n    var dataSource = isForeignColumn ? args.column.dataSource : this.parent.dataSource;\n    var fields = isForeignColumn ? args.column.foreignKeyValue : args.column.field;\n    this.elem = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'bool-ui-' + args.column.uid\n    });\n    args.target.appendChild(this.elem);\n    this.dialogObj = args.dialogObj;\n    this.dropInstance = new DropDownList(extend({\n      dataSource: dataSource instanceof DataManager ? dataSource : new DataManager(dataSource),\n      query: new Query().select(fields),\n      fields: {\n        text: fields,\n        value: fields\n      },\n      placeholder: args.localizeText.getConstant('SelectValue'),\n      cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n      locale: this.parent.locale,\n      enableRtl: this.parent.enableRtl\n    }, args.column.filter.params));\n    this.ddOpen = this.openPopup.bind(this);\n    this.ddComplete = this.actionComplete(fields);\n    this.dropInstance.addEventListener(open, this.ddOpen);\n    this.dropInstance.addEventListener(actionComplete, this.ddComplete);\n    this.dropInstance.appendTo(this.elem);\n  };\n\n  BooleanFilterUI.prototype.write = function (args) {\n    var drpuiObj = document.querySelector('#bool-ui-' + args.column.uid).ej2_instances[0];\n\n    if (!isNullOrUndefined(args.filteredValue)) {\n      drpuiObj.value = args.filteredValue;\n    }\n  };\n\n  BooleanFilterUI.prototype.read = function (element, column, filterOptr, filterObj) {\n    var drpuiObj = document.querySelector('#bool-ui-' + column.uid).ej2_instances[0];\n    var filterValue = drpuiObj.value;\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', false);\n  };\n\n  BooleanFilterUI.prototype.openPopup = function (args) {\n    getZIndexCalcualtion(args, this.dialogObj);\n  };\n\n  BooleanFilterUI.prototype.actionComplete = function (fields) {\n    return function (e) {\n      e.result = DataUtil.distinct(e.result, fields, true);\n    };\n  };\n\n  BooleanFilterUI.prototype.destroy = function () {\n    if (!this.dropInstance || this.dropInstance.isDestroyed) {\n      return;\n    }\n\n    this.dropInstance.removeEventListener(open, this.ddOpen);\n    this.dropInstance.removeEventListener(actionComplete, this.ddComplete);\n    this.dropInstance.destroy();\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  return BooleanFilterUI;\n}();\n/**\n * `datefilterui` render date column.\n *\n * @hidden\n */\n\n\nvar DateFilterUI =\n/** @__PURE__ @class */\nfunction () {\n  function DateFilterUI(parent, serviceLocator, filterSettings) {\n    this.dpOpen = this.openPopup.bind(this);\n    this.parent = parent;\n    this.locator = serviceLocator;\n    this.fltrSettings = filterSettings;\n\n    if (this.parent) {\n      this.parent.on(filterMenuClose, this.destroy, this);\n      this.parent.on(destroy, this.destroy, this);\n    }\n  }\n\n  DateFilterUI.prototype.create = function (args) {\n    var format = getCustomDateFormat(args.column.format, args.column.type);\n    this.dialogObj = args.dialogObj;\n    this.inputElem = this.parent.createElement('input', {\n      className: 'e-flmenu-input',\n      id: 'dateui-' + args.column.uid\n    });\n    args.target.appendChild(this.inputElem);\n\n    if (args.column.type === 'date') {\n      this.datePickerObj = new DatePicker(extend({\n        format: format,\n        cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n        placeholder: args.localizeText.getConstant('ChooseDate'),\n        width: '100%',\n        locale: this.parent.locale,\n        enableRtl: this.parent.enableRtl\n      }, args.column.filter.params));\n    } else if (args.column.type === 'datetime') {\n      this.datePickerObj = new DateTimePicker(extend({\n        format: format,\n        cssClass: this.parent.cssClass ? 'e-popup-flmenu' + ' ' + this.parent.cssClass : 'e-popup-flmenu',\n        placeholder: args.localizeText.getConstant('ChooseDate'),\n        width: '100%',\n        locale: this.parent.locale,\n        enableRtl: this.parent.enableRtl\n      }, args.column.filter.params));\n    }\n\n    this.datePickerObj.addEventListener(open, this.dpOpen);\n    this.datePickerObj.appendTo(this.inputElem);\n  };\n\n  DateFilterUI.prototype.write = function (args) {\n    var dateuiObj = document.querySelector('#dateui-' + args.column.uid).ej2_instances[0];\n    dateuiObj.value = !isNullOrUndefined(args.filteredValue) ? new Date(args.filteredValue) : null;\n  };\n\n  DateFilterUI.prototype.read = function (element, column, filterOptr, filterObj) {\n    var dateuiObj = document.querySelector('#dateui-' + column.uid).ej2_instances[0];\n    var filterValue = dateuiObj.value;\n    filterValue = isNullOrUndefined(filterValue) ? null : filterValue;\n    filterObj.filterByColumn(column.field, filterOptr, filterValue, 'and', true);\n  };\n\n  DateFilterUI.prototype.openPopup = function (args) {\n    args.popup.element.style.zIndex = (this.dialogObj.zIndex + 1).toString();\n  };\n\n  DateFilterUI.prototype.destroy = function () {\n    this.parent.off(filterMenuClose, this.destroy);\n    this.parent.off(destroy, this.destroy);\n\n    if (isNullOrUndefined(this.datePickerObj) || this.datePickerObj.isDestroyed) {\n      return;\n    }\n\n    this.datePickerObj.removeEventListener(open, this.dpOpen);\n    this.datePickerObj.destroy();\n  };\n\n  return DateFilterUI;\n}();\n/**\n * `filter menu` render boolean column.\n *\n * @hidden\n */\n\n\nvar FilterMenuRenderer =\n/** @__PURE__ @class */\nfunction () {\n  function FilterMenuRenderer(parent, filterSettings, serviceLocator, customFltrOperators, fltrObj) {\n    this.isDialogOpen = false;\n    this.maxHeight = '350px';\n    this.isMenuCheck = false;\n    this.colTypes = {\n      'string': StringFilterUI,\n      'number': NumberFilterUI,\n      'date': DateFilterUI,\n      'boolean': BooleanFilterUI,\n      'datetime': DateFilterUI\n    };\n    this.parent = parent;\n    this.filterSettings = filterSettings;\n    this.serviceLocator = serviceLocator;\n    this.customFilterOperators = customFltrOperators;\n    this.filterObj = fltrObj;\n    this.flMuiObj = new FlMenuOptrUI(this.parent, this.customFilterOperators, this.serviceLocator);\n    this.l10n = this.serviceLocator.getService('localization');\n    this.menuFilterBase = new CheckBoxFilterBase(parent);\n  }\n\n  FilterMenuRenderer.prototype.clearCustomFilter = function (col) {\n    this.clearBtnClick(col);\n  };\n\n  FilterMenuRenderer.prototype.applyCustomFilter = function (args) {\n    this.filterBtnClick(args.col);\n  };\n\n  FilterMenuRenderer.prototype.openDialog = function (args) {\n    this.options = args;\n    this.col = this.parent.getColumnByField(args.field);\n\n    if (isNullOrUndefined(this.col.filter) || isNullOrUndefined(this.col.filter.type) || this.col.filter.type === 'Menu') {\n      ///\n      this.renderDlgContent(args.target, this.col);\n    }\n  };\n\n  FilterMenuRenderer.prototype.closeDialog = function (target) {\n    if (!this.dlgObj) {\n      return;\n    }\n\n    if (this.parent.isReact || this.parent.isVue) {\n      clearReactVueTemplates(this.parent, ['filterTemplate']);\n    }\n\n    var elem = document.getElementById(this.dlgObj.element.id);\n\n    if (this.dlgObj && !this.dlgObj.isDestroyed && elem) {\n      var argument = {\n        cancel: false,\n        column: this.col,\n        target: target,\n        element: elem\n      };\n      this.parent.notify(filterMenuClose, argument);\n\n      if (argument.cancel) {\n        return;\n      }\n\n      this.isDialogOpen = false;\n\n      if (this.isMenuCheck) {\n        this.menuFilterBase.unWireEvents();\n        this.parent.off(cBoxFltrComplete, this.actionComplete);\n        this.isMenuCheck = false;\n      }\n\n      this.dlgObj.destroy();\n      remove(elem);\n    }\n\n    this.parent.notify(filterDialogClose, {});\n  };\n\n  FilterMenuRenderer.prototype.renderDlgContent = function (target, column) {\n    var args = {\n      requestType: filterBeforeOpen,\n      columnName: column.field,\n      columnType: column.type\n    };\n    var filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.parent.trigger(actionBegin, args);\n    var mainDiv = this.parent.createElement('div', {\n      className: 'e-flmenu-maindiv',\n      id: column.uid + '-flmenu'\n    });\n    this.dlgDiv = this.parent.createElement('div', {\n      className: 'e-flmenu',\n      id: column.uid + '-flmdlg'\n    });\n    this.dlgDiv.setAttribute('aria-label', this.l10n.getConstant('FilterMenuDialogARIA'));\n\n    if (this.parent.enableAdaptiveUI) {\n      var responsiveCnt = document.querySelector('.e-resfilter > .e-dlg-content > .e-mainfilterdiv');\n      responsiveCnt.appendChild(this.dlgDiv);\n    } else {\n      this.parent.element.appendChild(this.dlgDiv);\n    }\n\n    this.dlgObj = new Dialog({\n      showCloseIcon: false,\n      closeOnEscape: false,\n      locale: this.parent.locale,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      created: this.dialogCreated.bind(this, target, column),\n      position: this.parent.element.classList.contains('e-device') ? {\n        X: 'center',\n        Y: 'center'\n      } : {\n        X: '',\n        Y: ''\n      },\n      target: this.parent.element.classList.contains('e-device') ? document.body : this.parent.element,\n      buttons: [{\n        click: this.filterBtnClick.bind(this, column),\n        buttonModel: {\n          content: this.l10n.getConstant('FilterButton'),\n          isPrimary: true,\n          cssClass: this.parent.cssClass ? 'e-flmenu-okbtn' + ' ' + this.parent.cssClass : 'e-flmenu-okbtn'\n        }\n      }, {\n        click: this.clearBtnClick.bind(this, column),\n        buttonModel: {\n          content: this.l10n.getConstant('ClearButton'),\n          cssClass: this.parent.cssClass ? 'e-flmenu-cancelbtn' + ' ' + this.parent.cssClass : 'e-flmenu-cancelbtn'\n        }\n      }],\n      content: mainDiv,\n      width: !isNullOrUndefined(parentsUntil(target, 'e-bigger')) || this.parent.element.classList.contains('e-device') ? 260 : 250,\n      animationSettings: {\n        effect: 'None'\n      },\n      cssClass: this.parent.cssClass ? 'e-filter-popup' + ' ' + this.parent.cssClass : 'e-filter-popup'\n    });\n    var isStringTemplate = 'isStringTemplate';\n    this.dlgObj[isStringTemplate] = true;\n    this.renderResponsiveDialog();\n    this.dlgObj.appendTo(this.dlgDiv);\n  };\n\n  FilterMenuRenderer.prototype.renderResponsiveDialog = function () {\n    var gObj = this.parent;\n\n    if (gObj.enableAdaptiveUI) {\n      this.dlgObj.position = {\n        X: '',\n        Y: ''\n      };\n      this.dlgObj.target = document.querySelector('.e-resfilter > .e-dlg-content > .e-mainfilterdiv');\n      this.dlgObj.width = '100%';\n      this.dlgObj.isModal = false;\n      this.dlgObj.buttons = [{}];\n    }\n  };\n\n  FilterMenuRenderer.prototype.dialogCreated = function (target, column) {\n    if (!Browser.isDevice && target) {\n      getFilterMenuPostion(target, this.dlgObj);\n    }\n\n    this.currentDialogCreatedColumn = column;\n    this.renderFilterUI(target, column);\n\n    if (!column.isForeignColumn()) {\n      this.afterRenderFilterUI();\n    }\n  };\n  /**\n   * Function to notify filterDialogCreated and trigger actionComplete\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  FilterMenuRenderer.prototype.afterRenderFilterUI = function () {\n    var column = this.currentDialogCreatedColumn;\n\n    if (column.showColumnMenu) {\n      this.parent.notify(filterDialogCreated, {});\n    }\n\n    if (this.parent.enableAdaptiveUI) {\n      this.dlgObj.element.style.left = '0px';\n      this.dlgObj.element.style.maxHeight = 'none';\n    } else {\n      this.dlgObj.element.style.maxHeight = this.maxHeight;\n    }\n\n    this.dlgObj.show();\n\n    if (!column.filterTemplate) {\n      this.writeMethod(column, this.dlgObj.element.querySelector('#' + column.uid + '-flmenu'));\n    }\n\n    var args = {\n      requestType: filterAfterOpen,\n      columnName: column.field,\n      columnType: column.type\n    };\n    var filterModel = 'filterModel';\n    args[filterModel] = this;\n    this.isDialogOpen = true;\n\n    if (!this.isMenuCheck) {\n      this.parent.trigger(actionComplete, args);\n    }\n  };\n\n  FilterMenuRenderer.prototype.renderFilterUI = function (target, col) {\n    var dlgConetntEle = this.dlgObj.element.querySelector('.e-flmenu-maindiv');\n    this.parent.log('column_type_missing', {\n      column: col\n    });\n    this.renderOperatorUI(dlgConetntEle, target, col);\n    this.renderFlValueUI(dlgConetntEle, target, col);\n  };\n\n  FilterMenuRenderer.prototype.renderOperatorUI = function (dlgConetntEle, target, column) {\n    this.flMuiObj.renderOperatorUI(dlgConetntEle, target, column, this.dlgObj, this.filterObj.menuOperator);\n  };\n\n  FilterMenuRenderer.prototype.renderFlValueUI = function (dlgConetntEle, target, column) {\n    var valueDiv = this.parent.createElement('div', {\n      className: 'e-flmenu-valuediv'\n    });\n    var fObj = this.filterObj;\n    dlgConetntEle.appendChild(valueDiv);\n    var instanceofFilterUI = new this.colTypes[column.type](this.parent, this.serviceLocator, this.parent.filterSettings);\n\n    if (column.filterTemplate) {\n      var fltrData = {};\n      var valueInString = 'value';\n      fltrData[column.field] = fltrData[valueInString] = fObj.values[column.field];\n\n      if (column.foreignKeyValue) {\n        fltrData[column.foreignKeyValue] = fObj.values[column.field];\n        fltrData[column.field] = undefined;\n      }\n\n      var col = 'column';\n      fltrData[col] = column;\n      var isReactCompiler = this.parent.isReact && typeof column.filterTemplate !== 'string';\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n      var tempID = this.parent.element.id + column.uid + 'filterTemplate';\n\n      if (isReactCompiler || isReactChild) {\n        column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID, null, null, valueDiv);\n        this.parent.renderTemplates();\n      } else {\n        var compElement = column.getFilterTemplate()(fltrData, this.parent, 'filterTemplate', tempID);\n        appendChildren(valueDiv, compElement);\n      }\n\n      if (this.isMenuCheck) {\n        this.menuFilterBase.cBox = this.dlgObj.element.querySelector('.e-checkboxlist.e-fields');\n        this.menuFilterBase.wireEvents();\n        this.parent.on(cBoxFltrComplete, this.actionComplete, this);\n        this.menuFilterBase.getAllData();\n      }\n    } else {\n      if (!isNullOrUndefined(column.filter) && !isNullOrUndefined(column.filter.ui) && !isNullOrUndefined(column.filter.ui.create)) {\n        var temp = column.filter.ui.create;\n\n        if (typeof temp === 'string') {\n          temp = getValue(temp, window);\n        }\n\n        temp({\n          column: column,\n          target: valueDiv,\n          getOptrInstance: this.flMuiObj,\n          dialogObj: this.dlgObj\n        });\n      } else {\n        instanceofFilterUI.create({\n          column: column,\n          target: valueDiv,\n          getOptrInstance: this.flMuiObj,\n          localizeText: this.l10n,\n          dialogObj: this.dlgObj\n        });\n      }\n    }\n  };\n\n  FilterMenuRenderer.prototype.writeMethod = function (col, dlgContentEle) {\n    var flValue;\n    var target = dlgContentEle.querySelector('.e-flmenu-valinput');\n    var instanceofFilterUI = new this.colTypes[col.type](this.parent, this.serviceLocator, this.parent.filterSettings);\n    var columns = this.filterSettings.columns;\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var column = columns_1[_i];\n\n      if (col.uid === column.uid) {\n        flValue = column.value;\n      }\n    }\n\n    if (!isNullOrUndefined(col.filter) && !isNullOrUndefined(col.filter.ui) && !isNullOrUndefined(col.filter.ui.write)) {\n      var temp = col.filter.ui.write;\n\n      if (typeof temp === 'string') {\n        temp = getValue(temp, window);\n      }\n\n      temp({\n        column: col,\n        target: target,\n        parent: this.parent,\n        filteredValue: flValue\n      });\n    } else {\n      instanceofFilterUI.write({\n        column: col,\n        target: target,\n        parent: this.parent,\n        filteredValue: flValue\n      });\n    }\n  };\n\n  FilterMenuRenderer.prototype.filterBtnClick = function (col) {\n    var flValue;\n    var targ = this.dlgObj.element.querySelector('.e-flmenu-valuediv input');\n    var flOptrValue = this.flMuiObj.getFlOperator();\n    var instanceofFilterUI = new this.colTypes[col.type](this.parent, this.serviceLocator, this.parent.filterSettings);\n\n    if (col.filterTemplate) {\n      var element = this.dlgDiv.querySelector('.e-flmenu-valuediv');\n      var fltrValue = void 0;\n\n      if (element.children[0].value) {\n        fltrValue = element.children[0].value;\n      } else {\n        if (!isNullOrUndefined(element.children[0].ej2_instances)) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fltrValue = (this.parent.isAngular ? element.children[0] : element.querySelector('input')).ej2_instances[0].value;\n        } else {\n          var eControl = element.querySelector('.e-control');\n          fltrValue = col.type === 'boolean' ? eControl.checked : !isNullOrUndefined(eControl.ej2_instances) ? eControl.ej2_instances[0].value : eControl.value;\n        }\n      }\n\n      this.filterObj.filterByColumn(col.field, flOptrValue, fltrValue);\n    } else {\n      if (!isNullOrUndefined(col.filter) && !isNullOrUndefined(col.filter.ui) && !isNullOrUndefined(col.filter.ui.read)) {\n        var temp = col.filter.ui.read;\n\n        if (typeof temp === 'string') {\n          temp = getValue(temp, window);\n        } // eslint-disable-next-line\n\n\n        flValue = temp({\n          element: targ,\n          column: col,\n          operator: flOptrValue,\n          fltrObj: this.filterObj\n        });\n      } else {\n        instanceofFilterUI.read(targ, col, flOptrValue, this.filterObj);\n      }\n    }\n\n    this.closeDialog();\n\n    if (this.parent.showColumnMenu) {\n      this.parent.notify(afterFilterColumnMenuClose, {});\n    }\n  };\n\n  FilterMenuRenderer.prototype.closeResponsiveDialog = function () {\n    this.closeDialog();\n  };\n\n  FilterMenuRenderer.prototype.clearBtnClick = function (column) {\n    this.filterObj.removeFilteredColsByField(column.field);\n    this.closeDialog();\n    var iconClass = this.parent.showColumnMenu && column.showColumnMenu ? '.e-columnmenu' : '.e-icon-filter';\n    var col = this.parent.element.querySelector('[e-mappinguid=\"' + column.uid + '\"]').parentElement;\n    var flIcon = col.querySelector(iconClass);\n\n    if (flIcon) {\n      flIcon.classList.remove('e-filtered');\n    }\n  };\n\n  FilterMenuRenderer.prototype.destroy = function () {\n    this.closeDialog();\n  };\n  /**\n   * @returns {FilterUI} returns the filterUI\n   * @hidden\n   */\n\n\n  FilterMenuRenderer.prototype.getFilterUIInfo = function () {\n    return {\n      field: this.col.field,\n      operator: this.flMuiObj.getFlOperator()\n    };\n  };\n\n  FilterMenuRenderer.prototype.renderCheckBoxMenu = function () {\n    this.isMenuCheck = true;\n    this.menuFilterBase.updateModel(this.options);\n    this.menuFilterBase.getAndSetChkElem(this.options);\n    this.dlgObj.buttons = [{\n      click: this.menuFilterBase.btnClick.bind(this.menuFilterBase),\n      buttonModel: {\n        content: this.menuFilterBase.getLocalizedLabel('FilterButton'),\n        cssClass: 'e-primary',\n        isPrimary: true\n      }\n    }, {\n      click: this.menuFilterBase.btnClick.bind(this.menuFilterBase),\n      buttonModel: {\n        cssClass: 'e-flat',\n        content: this.menuFilterBase.getLocalizedLabel('ClearButton')\n      }\n    }];\n    this.menuFilterBase.dialogObj = this.dlgObj;\n    this.menuFilterBase.dlg = this.dlgObj.element;\n    this.menuFilterBase.dlg.classList.add('e-menucheckbox');\n    this.menuFilterBase.dlg.classList.remove('e-checkboxfilter');\n    this.maxHeight = '800px';\n    return this.menuFilterBase.sBox.innerHTML;\n  };\n\n  FilterMenuRenderer.prototype.actionComplete = function (args) {\n    if (this.isMenuCheck) {\n      this.parent.trigger(actionComplete, args);\n    }\n  };\n\n  return FilterMenuRenderer;\n}();\n/**\n * @hidden\n * `CheckBoxFilter` module is used to handle filtering action.\n */\n\n\nvar CheckBoxFilter =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for checkbox filtering module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {FilterSettings} filterSettings - specifies the filtersettings\n   * @param {ServiceLocator} serviceLocator - specifies the ServiceLocator\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function CheckBoxFilter(parent, filterSettings, serviceLocator) {\n    this.parent = parent;\n    this.isresetFocus = true;\n    this.checkBoxBase = new CheckBoxFilterBase(parent);\n    this.addEventListener();\n  }\n  /**\n   * To destroy the check box filter.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  CheckBoxFilter.prototype.destroy = function () {\n    this.removeEventListener();\n    this.checkBoxBase.closeDialog();\n  };\n\n  CheckBoxFilter.prototype.openDialog = function (options) {\n    this.checkBoxBase.openDialog(options);\n    this.parent.log('column_type_missing', {\n      column: options.column\n    });\n  };\n\n  CheckBoxFilter.prototype.closeDialog = function () {\n    this.destroy();\n\n    if (this.isresetFocus) {\n      this.parent.notify(restoreFocus, {});\n    }\n  };\n\n  CheckBoxFilter.prototype.closeResponsiveDialog = function () {\n    this.checkBoxBase.closeDialog();\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} - returns the module name\n   * @private\n   */\n\n\n  CheckBoxFilter.prototype.getModuleName = function () {\n    return 'checkboxFilter';\n  };\n\n  CheckBoxFilter.prototype.actionBegin = function (args) {\n    this.parent.trigger(actionBegin, args);\n  };\n\n  CheckBoxFilter.prototype.actionComplete = function (args) {\n    this.parent.trigger(actionComplete, args);\n  };\n\n  CheckBoxFilter.prototype.actionPrevent = function (args) {\n    if (isActionPrevent(this.parent)) {\n      this.parent.notify(preventBatch, args);\n      args.cancel = true;\n    }\n  };\n\n  CheckBoxFilter.prototype.clearCustomFilter = function (col) {\n    this.checkBoxBase.clearFilter(col);\n  };\n\n  CheckBoxFilter.prototype.applyCustomFilter = function () {\n    this.checkBoxBase.fltrBtnHandler();\n    this.checkBoxBase.closeDialog();\n  };\n\n  CheckBoxFilter.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(cBoxFltrBegin, this.actionBegin, this);\n    this.parent.on(cBoxFltrComplete, this.actionComplete, this);\n    this.parent.on(fltrPrevent, this.actionPrevent, this);\n  };\n\n  CheckBoxFilter.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(cBoxFltrBegin, this.actionBegin);\n    this.parent.off(cBoxFltrComplete, this.actionComplete);\n    this.parent.off(fltrPrevent, this.actionPrevent);\n  };\n\n  return CheckBoxFilter;\n}();\n\nvar __extends$21 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @hidden\n * `ExcelFilter` module is used to handle filtering action.\n */\n\n\nvar ExcelFilter =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$21(ExcelFilter, _super);\n  /**\n   * Constructor for excelbox filtering module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {FilterSettings} filterSettings - specifies the Filtersettings\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @param {object} customFltrOperators - specifies the customFltrOperators\n   * @hidden\n   */\n\n\n  function ExcelFilter(parent, filterSettings, serviceLocator, customFltrOperators) {\n    var _this = _super.call(this, parent, filterSettings, serviceLocator) || this;\n\n    _this.parent = parent;\n    _this.isresetFocus = true;\n    _this.excelFilterBase = new ExcelFilterBase(parent, customFltrOperators);\n    return _this;\n  }\n  /**\n   * To destroy the excel filter.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ExcelFilter.prototype.destroy = function () {\n    this.excelFilterBase.closeDialog();\n  };\n\n  ExcelFilter.prototype.openDialog = function (options) {\n    this.excelFilterBase.openDialog(options);\n  };\n\n  ExcelFilter.prototype.closeDialog = function () {\n    this.excelFilterBase.closeDialog();\n\n    if (this.isresetFocus) {\n      this.parent.notify(restoreFocus, {});\n    }\n  };\n\n  ExcelFilter.prototype.clearCustomFilter = function (col) {\n    this.excelFilterBase.clearFilter(col);\n  };\n\n  ExcelFilter.prototype.closeResponsiveDialog = function (isCustomFilter) {\n    if (isCustomFilter) {\n      this.excelFilterBase.removeDialog();\n    } else {\n      this.closeDialog();\n    }\n  };\n\n  ExcelFilter.prototype.applyCustomFilter = function (args) {\n    if (!args.isCustomFilter) {\n      this.excelFilterBase.fltrBtnHandler();\n      this.excelFilterBase.closeDialog();\n    } else {\n      this.excelFilterBase.filterBtnClick(args.col.field);\n    }\n  };\n\n  ExcelFilter.prototype.filterByColumn = function (fieldName, firstOperator, firstValue, predicate, matchCase, ignoreAccent, secondOperator, secondValue) {\n    this.excelFilterBase.filterByColumn(fieldName, firstOperator, firstValue, predicate, matchCase, ignoreAccent, secondOperator, secondValue);\n  };\n  /**\n   * @returns {FilterUI} returns the filterUI\n   * @hidden\n   */\n\n\n  ExcelFilter.prototype.getFilterUIInfo = function () {\n    return this.excelFilterBase.getFilterUIInfo();\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  ExcelFilter.prototype.getModuleName = function () {\n    return 'excelFilter';\n  };\n\n  return ExcelFilter;\n}(CheckBoxFilter);\n/**\n *\n * The `Filter` module is used to handle filtering action.\n */\n\n\nvar Filter =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for Grid filtering module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {FilterSettings} filterSettings - specifies the filterSettings\n   * @param {ServiceLocator} serviceLocator - specifes the serviceLocator\n   * @hidden\n   */\n  function Filter(parent, filterSettings, serviceLocator) {\n    this.predicate = 'and';\n    this.contentRefresh = true;\n    this.filterByMethod = true;\n    this.refresh = true;\n    this.values = {};\n    this.operators = {};\n    this.cellText = {};\n    this.nextFlMenuOpen = '';\n    this.type = {\n      'Menu': FilterMenuRenderer,\n      'CheckBox': CheckBoxFilter,\n      'Excel': ExcelFilter\n    };\n    /** @hidden */\n\n    this.filterOperators = {\n      contains: 'contains',\n      endsWith: 'endswith',\n      equal: 'equal',\n      greaterThan: 'greaterthan',\n      greaterThanOrEqual: 'greaterthanorequal',\n      lessThan: 'lessthan',\n      lessThanOrEqual: 'lessthanorequal',\n      notEqual: 'notequal',\n      startsWith: 'startswith'\n    };\n    this.fltrDlgDetails = {\n      field: '',\n      isOpen: false\n    };\n    /** @hidden */\n\n    this.skipNumberInput = ['=', ' ', '!'];\n    this.skipStringInput = ['>', '<', '='];\n    this.actualPredicate = {};\n    this.parent = parent;\n    this.filterSettings = filterSettings;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n    this.setFullScreenDialog();\n  }\n  /**\n   * To render filter bar when filtering enabled.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.render = function (e) {\n    if (DataUtil.getObject('args.isFrozen', e) || this.parent.getFrozenMode() === leftRight && DataUtil.getObject('args.renderFrozenRightContent', e)) {\n      return;\n    }\n\n    var gObj = this.parent;\n    this.l10n = this.serviceLocator.getService('localization');\n    this.getLocalizedCustomOperators();\n\n    if (this.parent.filterSettings.type === 'FilterBar') {\n      if (gObj.columns.length) {\n        var fltrElem = this.parent.element.querySelector('.e-filterbar');\n\n        if (fltrElem) {\n          remove(fltrElem);\n        }\n\n        var rowRenderer = new RowRenderer(this.serviceLocator, CellType.Filter, gObj);\n        var cellrender = this.serviceLocator.getService('cellRendererFactory');\n        cellrender.addCellRenderer(CellType.Filter, new FilterCellRenderer(this.parent, this.serviceLocator));\n        this.valueFormatter = this.serviceLocator.getService('valueFormatter');\n        rowRenderer.element = this.parent.createElement('tr', {\n          className: 'e-filterbar',\n          attrs: {\n            role: 'row'\n          }\n        });\n        var row$$1 = this.generateRow();\n        row$$1.data = this.values;\n\n        if (gObj.getFrozenMode() === 'Right') {\n          var thead = gObj.getFrozenRightHeader().querySelector('thead');\n          thead.appendChild(rowRenderer.element);\n        } else {\n          this.parent.getHeaderContent().querySelector('thead:not(.e-masked-thead)').appendChild(rowRenderer.element);\n        }\n\n        var rowdrag = this.parent.element.querySelector('.e-rowdragheader');\n        this.element = rowRenderer.render(row$$1, gObj.getColumns(), null, null, rowRenderer.element);\n        var detail = this.element.querySelector('.e-detailheadercell');\n\n        if (detail) {\n          detail.className = 'e-filterbarcell e-mastercell';\n        }\n\n        if (rowdrag) {\n          rowdrag.className = 'e-dragheadercell e-mastercell';\n        }\n\n        var gCells = [].slice.call(this.element.getElementsByClassName('e-grouptopleftcell'));\n\n        if (gCells.length) {\n          gCells[gCells.length - 1].classList.add('e-lastgrouptopleftcell');\n        }\n\n        this.wireEvents();\n        this.parent.notify(freezeRender, {\n          case: 'filter'\n        });\n      }\n    }\n  };\n  /**\n   * To show the responsive custom filter dialog\n   *\n   * @param {boolean} enable - specifes dialog open\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.showCustomFilter = function (enable) {\n    this.responsiveDialogRenderer.isCustomDialog = enable;\n    this.responsiveDialogRenderer.showResponsiveDialog(this.column);\n  };\n  /**\n   * To create the filter module.\n   *\n   * @param {Column} col - specifies the filtering column name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.setFilterModel = function (col) {\n    var type = col.filter.type || this.parent.filterSettings.type;\n    this.filterModule = new this.type[type](this.parent, this.parent.filterSettings, this.serviceLocator, this.customOperators, this);\n  };\n  /**\n   * To destroy the filter bar.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    if (this.filterModule) {\n      this.filterModule.destroy();\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if (!this.parent.refreshing && (this.parent.isDestroyed || !this.parent.allowFiltering)) {\n      this.filterSettings.columns = [];\n    }\n\n    this.updateFilterMsg();\n    this.removeEventListener();\n    this.unWireEvents();\n\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator) {\n      var dropdownlist = [].slice.call(this.element.getElementsByClassName('e-filterbaroperator'));\n\n      for (var i = 0; i < dropdownlist.length; i++) {\n        if (dropdownlist[i].ej2_instances[0]) {\n          dropdownlist[i].ej2_instances[0].destroy();\n        }\n      }\n    }\n\n    if (this.element) {\n      if (this.element.parentElement) {\n        remove(this.element);\n      }\n\n      var filterBarElement = this.parent.getHeaderContent().querySelector('.e-filterbar');\n\n      if (this.parent.isFrozenGrid() && filterBarElement) {\n        remove(filterBarElement);\n      }\n    }\n  };\n\n  Filter.prototype.setFullScreenDialog = function () {\n    if (this.serviceLocator) {\n      this.serviceLocator.registerAdaptiveService(this, this.parent.enableAdaptiveUI, ResponsiveDialogAction.isFilter);\n    }\n  };\n\n  Filter.prototype.generateRow = function () {\n    var options = {};\n    var row$$1 = new Row(options);\n    row$$1.cells = this.generateCells();\n    return row$$1;\n  };\n\n  Filter.prototype.generateCells = function () {\n    //TODO: generate dummy column for group, detail, stacked row here for filtering;\n    var cells = [];\n\n    if (this.parent.allowGrouping) {\n      for (var c = 0, len = this.parent.groupSettings.columns.length; c < len; c++) {\n        cells.push(this.generateCell({}, CellType.HeaderIndent));\n      }\n    }\n\n    if (this.parent.detailTemplate || this.parent.childGrid) {\n      cells.push(this.generateCell({}, CellType.DetailHeader));\n    }\n\n    if (this.parent.isRowDragable() && this.parent.getFrozenMode() !== 'Right') {\n      cells.push(this.generateCell({}, CellType.RowDragHIcon));\n    }\n\n    for (var _i = 0, _a = this.parent.getColumns(); _i < _a.length; _i++) {\n      var dummy = _a[_i];\n      cells.push(this.generateCell(dummy));\n    }\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      cells.push(this.generateCell({}, CellType.RowDragHIcon));\n    }\n\n    return cells;\n  };\n\n  Filter.prototype.generateCell = function (column, cellType) {\n    var opt = {\n      'visible': column.visible,\n      'isDataCell': false,\n      'rowId': '',\n      'column': column,\n      'cellType': cellType ? cellType : CellType.Filter,\n      'attributes': {\n        title: this.l10n.getConstant('FilterbarTitle')\n      }\n    };\n    return new Cell(opt);\n  };\n  /**\n   * To update filterSettings when applying filter.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.updateModel = function () {\n    var col = this.parent.getColumnByField(this.fieldName);\n    this.filterObjIndex = this.getFilteredColsIndexByField(col);\n    this.prevFilterObject = this.filterSettings.columns[this.filterObjIndex];\n    var arrayVal = Array.isArray(this.value) ? this.value : [this.value];\n    var moduleName = this.parent.dataSource.adaptor && this.parent.dataSource.adaptor.getModuleName ? this.parent.dataSource.adaptor.getModuleName() : undefined;\n\n    for (var i = 0, len = arrayVal.length; i < len; i++) {\n      var field = col.isForeignColumn() ? col.foreignKeyValue : this.fieldName;\n      var isMenuNotEqual = this.operator === 'notequal';\n      this.currentFilterObject = {\n        field: field,\n        uid: col.uid,\n        isForeignKey: col.isForeignColumn(),\n        operator: this.operator,\n        value: arrayVal[i],\n        predicate: this.predicate,\n        matchCase: this.matchCase,\n        ignoreAccent: this.ignoreAccent,\n        actualFilterValue: {},\n        actualOperator: {}\n      };\n      var index = this.getFilteredColsIndexByField(col);\n\n      if (index > -1 && !Array.isArray(this.value)) {\n        this.filterSettings.columns[index] = this.currentFilterObject;\n      } else {\n        this.filterSettings.columns.push(this.currentFilterObject);\n      }\n\n      if (!this.column.isForeignColumn() && isNullOrUndefined(this.value) && (this.operator === 'equal' || this.operator === 'notequal') && moduleName !== 'ODataAdaptor' && moduleName !== 'ODataV4Adaptor') {\n        this.filterSettings.columns = [];\n\n        if (col.type === 'string') {\n          this.filterSettings.columns.push({\n            field: field,\n            ignoreAccent: this.ignoreAccent,\n            matchCase: this.matchCase,\n            operator: this.operator,\n            predicate: isMenuNotEqual ? 'and' : 'or',\n            value: ''\n          });\n        }\n\n        this.filterSettings.columns.push({\n          field: field,\n          ignoreAccent: this.ignoreAccent,\n          matchCase: this.matchCase,\n          operator: this.operator,\n          predicate: isMenuNotEqual ? 'and' : 'or',\n          value: undefined\n        });\n        this.filterSettings.columns.push({\n          field: field,\n          ignoreAccent: this.ignoreAccent,\n          matchCase: this.matchCase,\n          operator: this.operator,\n          predicate: isMenuNotEqual ? 'and' : 'or',\n          value: null\n        });\n      }\n    } // eslint-disable-next-line no-self-assign\n\n\n    this.filterSettings.columns = this.filterSettings.columns;\n    this.parent.dataBind();\n  };\n\n  Filter.prototype.getFilteredColsIndexByField = function (col) {\n    var cols = this.filterSettings.columns;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (cols[i].uid === col.uid || col.isForeignColumn() && this.parent.getColumnByUid(col.uid).field === col.foreignKeyValue) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * To trigger action complete event.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.onActionComplete = function (e) {\n    var args = !this.isRemove ? {\n      currentFilterObject: this.currentFilterObject,\n\n      /* tslint:disable:no-string-literal */\n      currentFilteringColumn: !isNullOrUndefined(this.column) ? this.column.field : undefined,\n\n      /* tslint:enable:no-string-literal */\n      columns: this.filterSettings.columns,\n      requestType: 'filtering',\n      type: actionComplete\n    } : {\n      requestType: 'filtering',\n      type: actionComplete\n    };\n    this.parent.trigger(actionComplete, extend(e, args));\n    this.isRemove = false;\n  };\n\n  Filter.prototype.wireEvents = function () {\n    EventHandler.add(this.parent.getHeaderContent(), 'keyup', this.keyUpHandlerImmediate, this);\n  };\n\n  Filter.prototype.unWireEvents = function () {\n    EventHandler.remove(this.parent.getHeaderContent(), 'keyup', this.keyUpHandlerImmediate);\n  };\n\n  Filter.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.parent.getHeaderTable().classList.add('e-sortfilter');\n      this.render();\n    }\n  };\n\n  Filter.prototype.refreshFilterValue = function () {\n    this.parent.removeEventListener(beforeDataBound, this.refreshFilterValueFn);\n\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.columns.length && !this.parent.getCurrentViewRecords().length) {\n      this.initialEnd();\n    }\n  };\n\n  Filter.prototype.initialEnd = function () {\n    this.parent.off(contentReady, this.initialEnd);\n\n    if (this.parent.getColumns().length && this.filterSettings.columns.length) {\n      var gObj = this.parent;\n      this.contentRefresh = false;\n      this.initialLoad = true;\n\n      for (var _i = 0, _a = gObj.filterSettings.columns; _i < _a.length; _i++) {\n        var col = _a[_i];\n        this.filterByColumn(col.field, col.operator, col.value, col.predicate, col.matchCase, col.ignoreAccent, col.actualFilterValue, col.actualOperator);\n      }\n\n      this.initialLoad = false;\n      this.updateFilterMsg();\n      this.contentRefresh = true;\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(setFullScreenDialog, this.setFullScreenDialog, this);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(filterComplete, this.onActionComplete, this);\n    this.parent.on(inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(keyPressed, this.keyUpHandler, this);\n    this.parent.on(columnPositionChanged, this.columnPositionChanged, this);\n    this.parent.on(headerRefreshed, this.render, this);\n    this.parent.on(contentReady, this.initialEnd, this);\n    this.parent.on(filterMenuClose, this.filterMenuClose, this);\n    this.docClickHandler = this.clickHandler.bind(this);\n    EventHandler.add(document, 'click', this.docClickHandler, this);\n    EventHandler.add(this.parent.element, 'mousedown', this.refreshClearIcon, this);\n    this.parent.on(filterOpen, this.columnMenuFilter, this);\n    this.parent.on(click, this.filterIconClickHandler, this);\n    this.parent.on('persist-data-changed', this.initialEnd, this);\n    this.parent.on(closeFilterDialog, this.clickHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.refreshFilterValueFn = this.refreshFilterValue.bind(this);\n    this.parent.addEventListener(beforeDataBound, this.refreshFilterValueFn);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.removeEventListener = function () {\n    EventHandler.remove(document, 'click', this.docClickHandler);\n    EventHandler.remove(this.parent.element, 'mousedown', this.refreshClearIcon);\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(setFullScreenDialog, this.setFullScreenDialog);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(filterComplete, this.onActionComplete);\n    this.parent.off(inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(keyPressed, this.keyUpHandler);\n    this.parent.off(columnPositionChanged, this.columnPositionChanged);\n    this.parent.off(headerRefreshed, this.render);\n    this.parent.off(filterOpen, this.columnMenuFilter);\n    this.parent.off(filterMenuClose, this.filterMenuClose);\n    this.parent.off(click, this.filterIconClickHandler);\n    this.parent.off(closeFilterDialog, this.clickHandler);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  Filter.prototype.refreshClearIcon = function (e) {\n    if (this.parent.allowFiltering && this.parent.filterSettings.type === 'FilterBar' && e.target.closest('th') && e.target.closest('th').classList.contains('e-filterbarcell') && e.target.classList.contains('e-clear-icon')) {\n      var targetText = e.target.previousElementSibling;\n      Input.setValue(null, targetText, 'Never', true);\n\n      if (this.filterSettings.mode === 'Immediate') {\n        this.removeFilteredColsByField(targetText.id.slice(0, -14)); //Length of _filterBarcell = 14\n      }\n    }\n  };\n\n  Filter.prototype.filterMenuClose = function () {\n    this.fltrDlgDetails.isOpen = false;\n  };\n  /**\n   * Filters the Grid row by fieldName, filterOperator, and filterValue.\n   *\n   * @param  {string} fieldName - Defines the field name of the filter column.\n   * @param  {string} filterOperator - Defines the operator to filter records.\n   * @param  {string | number | Date | boolean} filterValue - Defines the value which is used to filter records.\n   * @param  {string} predicate - Defines the relationship of one filter query with another by using AND or OR predicate.\n   * @param  {boolean} matchCase - If match case is set to true, then the filter records\n   * the exact match or <br> filters records that are case insensitive (uppercase and lowercase letters treated the same).\n   * @param {boolean} ignoreAccent - If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.\n   * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.\n   * @param  {string} actualOperator - Defines the actual filter operator for the filter column.\n   * @returns {void}\n   */\n\n\n  Filter.prototype.filterByColumn = function (fieldName, filterOperator, filterValue, predicate, matchCase, ignoreAccent, actualFilterValue, actualOperator) {\n    var _this = this;\n\n    var gObj = this.parent;\n    var filterCell;\n    this.column = gObj.grabColumnByFieldFromAllCols(fieldName);\n\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator && isNullOrUndefined(this.column.filterBarTemplate) && isNullOrUndefined(this.column.filterTemplate)) {\n      filterOperator = this.getOperatorName(fieldName);\n    }\n\n    if (!this.column) {\n      return;\n    }\n\n    if (this.filterSettings.type === 'FilterBar') {\n      filterCell = gObj.getHeaderContent().querySelector('[id=\\'' + this.column.field + '_filterBarcell\\']');\n    }\n\n    if (!isNullOrUndefined(this.column.allowFiltering) && !this.column.allowFiltering) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        columnName: this.column.headerText\n      });\n      return;\n    }\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.filterByColumn,\n        arg1: fieldName,\n        arg2: filterOperator,\n        arg3: filterValue,\n        arg4: predicate,\n        arg5: matchCase,\n        arg6: ignoreAccent,\n        arg7: actualFilterValue,\n        arg8: actualOperator\n      });\n      return;\n    }\n\n    this.predicate = predicate ? predicate : Array.isArray(filterValue) ? 'or' : 'and';\n    this.value = filterValue;\n    this.matchCase = matchCase || false;\n    this.ignoreAccent = this.ignoreAccent = !isNullOrUndefined(ignoreAccent) ? ignoreAccent : this.parent.filterSettings.ignoreAccent;\n    this.fieldName = fieldName;\n    this.operator = filterOperator;\n    filterValue = !isNullOrUndefined(filterValue) ? filterValue.toString() : filterValue;\n\n    if (filterValue === '') {\n      filterValue = null;\n    }\n\n    if (this.column.type === 'number' || this.column.type === 'date') {\n      this.matchCase = true;\n    }\n\n    gObj.getColumnHeaderByField(fieldName).setAttribute('aria-filtered', 'true');\n\n    if (filterCell && this.filterSettings.type === 'FilterBar') {\n      if (filterValue && filterValue.length < 1 || !this.filterByMethod && this.checkForSkipInput(this.column, filterValue)) {\n        this.filterStatusMsg = filterValue && filterValue.length < 1 ? '' : this.l10n.getConstant('InvalidFilterMessage');\n        this.updateFilterMsg();\n        return;\n      }\n\n      if (filterCell.value !== filterValue) {\n        filterCell.value = filterValue;\n      }\n    }\n\n    if (!isNullOrUndefined(this.column.format)) {\n      this.applyColumnFormat(filterValue);\n\n      if (this.initialLoad && this.filterSettings.type === 'FilterBar') {\n        filterCell.value = this.values[this.column.field];\n      }\n    } else {\n      this.values[this.column.field] = filterValue; //this line should be above updateModel\n    }\n\n    var predObj = {\n      field: this.fieldName,\n      predicate: predicate,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      operator: this.operator,\n      value: this.value,\n      type: this.column.type\n    };\n    var filterColumn = this.parent.filterSettings.columns.filter(function (fColumn) {\n      return fColumn.field === _this.fieldName;\n    });\n\n    if (filterColumn.length > 1 && !isNullOrUndefined(this.actualPredicate[this.fieldName])) {\n      this.actualPredicate[this.fieldName].push(predObj);\n    } else {\n      this.actualPredicate[this.fieldName] = [predObj];\n    }\n\n    if (this.checkAlreadyColFiltered(this.column.field)) {\n      return;\n    }\n\n    this.updateModel();\n  };\n\n  Filter.prototype.applyColumnFormat = function (filterValue) {\n    var _this = this;\n\n    var getFlvalue = this.column.type === 'date' || this.column.type === 'datetime' ? new Date(filterValue) : parseFloat(filterValue);\n\n    if ((this.column.type === 'date' || this.column.type === 'datetime') && filterValue && Array.isArray(this.value) && filterValue.split(',').length > 1) {\n      this.values[this.column.field] = filterValue.split(',').map(function (val) {\n        if (val === '') {\n          val = null;\n        }\n\n        return _this.setFormatForFlColumn(new Date(val), _this.column);\n      });\n    } else {\n      this.values[this.column.field] = this.setFormatForFlColumn(getFlvalue, this.column);\n    }\n  }; // To skip the second time request to server while applying initial filtering - EJ2-44361\n\n\n  Filter.prototype.skipUid = function (col) {\n    var flag = true;\n    var colLen = Object.keys(col);\n\n    for (var i = 0; i < colLen.length; i++) {\n      var key = Object.keys(col[colLen[i]]);\n\n      if (key.length === 1 && key[0] === 'uid') {\n        flag = false;\n      }\n    }\n\n    return flag;\n  };\n\n  Filter.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    for (var _i = 0, _a = Object.keys(e.properties); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'columns':\n          // eslint-disable-next-line no-case-declarations\n          var col = 'columns'; // eslint-disable-next-line no-case-declarations\n\n          var args = {\n            currentFilterObject: this.currentFilterObject,\n            currentFilteringColumn: this.column ? this.column.field : undefined,\n            action: 'filter',\n            columns: this.filterSettings.columns,\n            requestType: 'filtering',\n            type: actionBegin,\n            cancel: false\n          };\n\n          if (this.contentRefresh && this.skipUid(e.properties[col])) {\n            this.parent.notify(modelChanged, args);\n\n            if (args.cancel) {\n              if (isNullOrUndefined(this.prevFilterObject)) {\n                this.filterSettings.columns.splice(this.filterSettings.columns.length - 1, 1);\n              } else {\n                this.filterSettings.columns[this.filterObjIndex] = this.prevFilterObject;\n              }\n\n              return;\n            }\n\n            this.updateFilterIcon();\n            this.refreshFilterSettings();\n            this.updateFilterMsg();\n            this.updateFilter();\n          }\n\n          break;\n\n        case 'showFilterBarStatus':\n          if (e.properties[prop]) {\n            this.updateFilterMsg();\n          } else if (this.parent.allowPaging) {\n            this.parent.updateExternalMessage('');\n          }\n\n          break;\n\n        case 'showFilterBarOperator':\n        case 'type':\n          this.parent.refreshHeader();\n          this.refreshFilterSettings();\n          break;\n      }\n    }\n  };\n\n  Filter.prototype.refreshFilterSettings = function () {\n    if (this.filterSettings.type === 'FilterBar') {\n      for (var i = 0; i < this.filterSettings.columns.length; i++) {\n        this.column = this.parent.grabColumnByUidFromAllCols(this.filterSettings.columns[i].uid);\n        var filterValue = this.filterSettings.columns[i].value;\n        filterValue = !isNullOrUndefined(filterValue) && filterValue.toString();\n\n        if (!isNullOrUndefined(this.column.format)) {\n          this.applyColumnFormat(filterValue);\n        } else {\n          var key = this.filterSettings.columns[i].field;\n          this.values[key] = this.filterSettings.columns[i].value;\n        }\n\n        var filterElement = this.getFilterBarElement(this.column.field);\n\n        if (filterElement) {\n          if (this.cellText[this.filterSettings.columns[i].field] !== '' && !isNullOrUndefined(this.cellText[this.filterSettings.columns[i].field])) {\n            filterElement.value = this.cellText[this.column.field];\n          } else {\n            filterElement.value = this.filterSettings.columns[i].value;\n          }\n        }\n      }\n\n      if (this.filterSettings.columns.length === 0) {\n        var col = this.parent.getColumns();\n\n        for (var i = 0; i < col.length; i++) {\n          var filterElement = this.getFilterBarElement(col[i].field);\n\n          if (filterElement && filterElement.value !== '') {\n            filterElement.value = '';\n            delete this.values[col[i].field];\n          }\n        }\n      }\n    }\n  };\n\n  Filter.prototype.updateFilterIcon = function () {\n    if (this.filterSettings.columns.length === 0 && this.parent.element.querySelector('.e-filtered')) {\n      var fltrIconElement = [].slice.call(this.parent.element.getElementsByClassName('e-filtered'));\n\n      for (var i = 0, len = fltrIconElement.length; i < len; i++) {\n        fltrIconElement[i].removeAttribute('aria-filtered');\n        fltrIconElement[i].classList.remove('e-filtered');\n      }\n    }\n  };\n\n  Filter.prototype.getFilterBarElement = function (col) {\n    var selector = '[id=\\'' + col + '_filterBarcell\\']';\n    var filterElement;\n\n    if (selector && !isNullOrUndefined(this.element)) {\n      filterElement = this.element.querySelector(selector);\n    }\n\n    return filterElement;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  Filter.prototype.refreshFilter = function () {\n    this.refreshFilterSettings();\n    this.updateFilterMsg();\n  };\n  /**\n   * Clears all the filtered rows of the Grid.\n   *\n   * @param {string[]} fields - returns the fields\n   * @returns {void}\n   */\n\n\n  Filter.prototype.clearFiltering = function (fields) {\n    var _this = this;\n\n    var cols = getActualPropFromColl(this.filterSettings.columns);\n\n    if (!isNullOrUndefined(fields)) {\n      this.refresh = false;\n      fields.forEach(function (field) {\n        _this.removeFilteredColsByField(field, false);\n      });\n      this.parent.setProperties({\n        filterSettings: {\n          columns: this.filterSettings.columns\n        }\n      }, true);\n      this.parent.renderModule.refresh();\n      this.refresh = true;\n      return;\n    }\n\n    if (isActionPrevent(this.parent)) {\n      this.parent.notify(preventBatch, {\n        instance: this,\n        handler: this.clearFiltering\n      });\n      return;\n    }\n\n    for (var i = 0; i < cols.length; i++) {\n      cols[i].uid = cols[i].uid || this.parent.getColumnByField(cols[i].field).uid;\n    }\n\n    var colUid = cols.map(function (f) {\n      return f.uid;\n    });\n    var filteredcols = colUid.filter(function (item, pos) {\n      return colUid.indexOf(item) === pos;\n    });\n    this.refresh = false;\n\n    for (var i = 0, len = filteredcols.length; i < len; i++) {\n      this.removeFilteredColsByField(this.parent.getColumnByUid(filteredcols[i]).field, false);\n    }\n\n    this.refresh = true;\n\n    if (filteredcols.length) {\n      this.parent.renderModule.refresh();\n    }\n\n    if (this.parent.filterSettings.columns.length === 0 && this.parent.element.querySelector('.e-filtered')) {\n      var fltrElement = [].slice.call(this.parent.element.getElementsByClassName('e-filtered'));\n\n      for (var i = 0, len = fltrElement.length; i < len; i++) {\n        fltrElement[0].removeAttribute('aria-filtered');\n        fltrElement[0].classList.remove('e-filtered');\n      }\n    }\n\n    this.isRemove = true;\n    this.filterStatusMsg = '';\n    this.updateFilterMsg();\n  };\n\n  Filter.prototype.checkAlreadyColFiltered = function (field) {\n    var columns = this.filterSettings.columns;\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var col = columns_1[_i];\n\n      if (col.field === field && col.value === this.value && col.operator === this.operator && col.predicate === this.predicate) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Filter.prototype.columnMenuFilter = function (args) {\n    this.column = args.col;\n    var ele = closest(args.target, '#' + args.id);\n\n    if (args.isClose && !ele) {\n      this.filterModule.closeDialog();\n    } else if (ele) {\n      this.filterDialogOpen(this.column, args.target);\n    }\n  };\n\n  Filter.prototype.filterDialogOpen = function (col, target, left, top) {\n    if (this.filterModule) {\n      this.filterModule.closeDialog();\n    }\n\n    this.setFilterModel(col);\n    this.filterModule.openDialog(this.createOptions(col, target, left, top));\n  };\n  /**\n   * Create filter dialog options\n   *\n   * @param  {Column} col - Filtering column detail.\n   * @param  {Element} target -  Filter dialog target.\n   * @param  {number} left -  Filter dialog left position.\n   * @param  {number} top -  Filter dialog top position.\n   * @returns {Object} returns the created dialog options\n   * @hidden\n   */\n\n\n  Filter.prototype.createOptions = function (col, target, left, top) {\n    var gObj = this.parent;\n    var dataSource = col.filter.dataSource || gObj.dataSource && 'result' in gObj.dataSource ? gObj.dataSource : gObj.getDataModule().dataManager;\n    var type = col.filter.type || this.parent.filterSettings.type;\n    var options = {\n      type: col.type,\n      field: col.field,\n      displayName: col.headerText,\n      dataSource: dataSource,\n      format: col.format,\n      height: 800,\n      columns: gObj.getColumns(),\n      filteredColumns: gObj.filterSettings.columns,\n      target: target,\n      dataManager: gObj.getDataModule().dataManager,\n      formatFn: col.getFormatter(),\n      ignoreAccent: gObj.filterSettings.ignoreAccent,\n      parserFn: col.getParser(),\n      query: gObj.query,\n      template: col.getFilterItemTemplate(),\n      hideSearchbox: isNullOrUndefined(col.filter.hideSearchbox) ? false : col.filter.hideSearchbox,\n      handler: this.filterHandler.bind(this),\n      localizedStrings: gObj.getLocaleConstants(),\n      position: {\n        X: left,\n        Y: top\n      },\n      column: col,\n      foreignKeyValue: col.foreignKeyValue,\n      actualPredicate: this.actualPredicate,\n      localeObj: gObj.localeObj,\n      isRemote: gObj.getDataModule().isRemote(),\n      allowCaseSensitive: this.filterSettings.enableCaseSensitivity,\n      isResponsiveFilter: this.parent.enableAdaptiveUI,\n      operator: this.actualPredicate[col.field] && type === 'Menu' ? this.actualPredicate[col.field][0].operator : 'equal'\n    };\n    return options;\n  };\n  /**\n   * Removes filtered column by field name.\n   *\n   * @param  {string} field - Defines column field name to remove filter.\n   * @param  {boolean} isClearFilterBar - Specifies whether the filter bar value needs to be cleared.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.removeFilteredColsByField = function (field, isClearFilterBar) {\n    var fCell;\n    var cols = this.filterSettings.columns;\n\n    if (isActionPrevent(this.parent)) {\n      var args = {\n        instance: this,\n        handler: this.removeFilteredColsByField,\n        arg1: field,\n        arg2: isClearFilterBar\n      };\n      this.parent.notify(preventBatch, args);\n      return;\n    }\n\n    var colUid = cols.map(function (f) {\n      return f.uid;\n    });\n    var filteredColsUid = colUid.filter(function (item, pos) {\n      return colUid.indexOf(item) === pos;\n    });\n\n    var _loop_1 = function (i, len) {\n      cols[i].uid = cols[i].uid || this_1.parent.getColumnByField(cols[i].field).uid;\n      var len_1 = cols.length;\n      var column = this_1.parent.grabColumnByUidFromAllCols(filteredColsUid[i]);\n\n      if (column.field === field || column.field === column.foreignKeyValue && column.isForeignColumn()) {\n        var currentPred = this_1.filterSettings.columns.filter(function (e) {\n          return e.uid === column.uid;\n        })[0];\n\n        if (this_1.filterSettings.type === 'FilterBar' && !isClearFilterBar) {\n          var selector = '[id=\\'' + column.field + '_filterBarcell\\']';\n          fCell = this_1.parent.getHeaderContent().querySelector(selector);\n\n          if (fCell) {\n            fCell.value = '';\n            delete this_1.values[field];\n          }\n        }\n\n        while (len_1--) {\n          if (cols[len_1].uid === column.uid) {\n            cols.splice(len_1, 1);\n          }\n        }\n\n        var fltrElement = this_1.parent.getColumnHeaderByField(column.field);\n        fltrElement.removeAttribute('aria-filtered');\n\n        if (this_1.filterSettings.type !== 'FilterBar' || this_1.parent.showColumnMenu) {\n          var iconClass = this_1.parent.showColumnMenu && column.showColumnMenu ? '.e-columnmenu' : '.e-icon-filter';\n          fltrElement.querySelector(iconClass).classList.remove('e-filtered');\n        }\n\n        this_1.isRemove = true;\n\n        if (this_1.actualPredicate[field]) {\n          delete this_1.actualPredicate[field];\n        }\n\n        if (this_1.values[field]) {\n          delete this_1.values[field];\n        }\n\n        if (this_1.refresh) {\n          this_1.parent.notify(modelChanged, {\n            requestType: 'filtering',\n            type: actionBegin,\n            currentFilterObject: currentPred,\n            currentFilterColumn: column,\n            action: 'clearFilter'\n          });\n        }\n\n        return \"break\";\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = 0, len = filteredColsUid.length; i < len; i++) {\n      var state_1 = _loop_1(i, len);\n\n      if (state_1 === \"break\") break;\n    }\n\n    this.updateFilterMsg();\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Filter.prototype.getModuleName = function () {\n    return 'filter';\n  };\n\n  Filter.prototype.keyUpHandlerImmediate = function (e) {\n    if (e.keyCode !== 13) {\n      this.keyUpHandler(e);\n    }\n  };\n\n  Filter.prototype.keyUpHandler = function (e) {\n    var gObj = this.parent;\n    var target = e.target;\n\n    if (target && matches(target, '.e-filterbar input')) {\n      var closeHeaderEle = closest(target, 'th.e-filterbarcell');\n      this.column = gObj.getColumnByUid(closeHeaderEle.getAttribute('e-mappinguid'));\n\n      if (!this.column) {\n        return;\n      }\n\n      if (e.action === 'altDownArrow' && this.parent.filterSettings.showFilterBarOperator) {\n        var dropDownListInput = closest(target, 'span').querySelector('.e-filterbaroperator');\n        dropDownListInput.ej2_instances[0].showPopup();\n        dropDownListInput.focus();\n      }\n\n      if ((this.filterSettings.mode === 'Immediate' || e.keyCode === 13 && !e.target.classList.contains('e-filterbaroperator')) && e.keyCode !== 9 && !this.column.filterTemplate) {\n        this.value = target.value.trim();\n        this.processFilter(e);\n      }\n    }\n\n    if (e.action === 'altDownArrow' && this.filterSettings.type !== 'FilterBar') {\n      var element = gObj.focusModule.currentInfo.element;\n\n      if (element && element.classList.contains('e-headercell')) {\n        var column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n        this.openMenuByField(column.field);\n        this.parent.focusModule.clearIndicator();\n      }\n    }\n\n    if (e.action === 'escape' && this.filterSettings.type === 'Menu' && this.filterModule) {\n      this.filterModule.closeDialog();\n      gObj.notify(restoreFocus, {});\n    }\n  };\n\n  Filter.prototype.updateCrossIcon = function (element) {\n    if (element.value.length) {\n      element.nextElementSibling.classList.remove('e-hide');\n    }\n  };\n\n  Filter.prototype.updateFilterMsg = function () {\n    if (this.filterSettings.type === 'FilterBar') {\n      var gObj = this.parent;\n      var getFormatFlValue = void 0;\n      var columns = this.filterSettings.columns;\n      var column = void 0;\n\n      if (!this.filterSettings.showFilterBarStatus) {\n        return;\n      }\n\n      if (columns.length > 0 && this.filterStatusMsg !== this.l10n.getConstant('InvalidFilterMessage')) {\n        this.filterStatusMsg = '';\n\n        for (var index = 0; index < columns.length; index++) {\n          column = gObj.grabColumnByUidFromAllCols(columns[index].uid) || gObj.grabColumnByFieldFromAllCols(columns[index].field);\n\n          if (index) {\n            this.filterStatusMsg += ' && ';\n          }\n\n          if (!isNullOrUndefined(column.format)) {\n            var flValue = column.type === 'date' || column.type === 'datetime' ? this.valueFormatter.fromView(this.values[column.field], column.getParser(), column.type) : this.values[column.field];\n\n            if (!(column.type === 'date' || column.type === 'datetime')) {\n              var formater = this.serviceLocator.getService('valueFormatter');\n              getFormatFlValue = formater.toView(flValue, column.getParser()).toString();\n            } else {\n              getFormatFlValue = this.setFormatForFlColumn(flValue, column);\n            }\n\n            this.filterStatusMsg += column.headerText + ': ' + getFormatFlValue;\n          } else {\n            this.filterStatusMsg += column.headerText + ': ' + this.values[column.field];\n          }\n        }\n      }\n\n      if (gObj.allowPaging) {\n        gObj.updateExternalMessage(this.filterStatusMsg);\n      } //TODO: virtual paging\n\n\n      this.filterStatusMsg = '';\n    }\n  };\n\n  Filter.prototype.setFormatForFlColumn = function (value, column) {\n    var formater = this.serviceLocator.getService('valueFormatter');\n    return formater.toView(value, column.getFormatter()).toString();\n  };\n\n  Filter.prototype.checkForSkipInput = function (column, value) {\n    var isSkip;\n\n    if (column.type === 'number') {\n      if (DataUtil.operatorSymbols[value] || this.skipNumberInput.indexOf(value) > -1) {\n        isSkip = true;\n      }\n    } else if (column.type === 'string') {\n      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n        var val = value_1[_i];\n\n        if (this.skipStringInput.indexOf(val) > -1) {\n          isSkip = true;\n        }\n      }\n    }\n\n    return isSkip;\n  };\n\n  Filter.prototype.processFilter = function (e) {\n    this.stopTimer();\n    this.startTimer(e);\n  };\n\n  Filter.prototype.startTimer = function (e) {\n    var _this = this;\n\n    this.timer = window.setInterval(function () {\n      _this.onTimerTick();\n    }, e.keyCode === 13 ? 0 : this.filterSettings.immediateModeDelay);\n  };\n\n  Filter.prototype.stopTimer = function () {\n    window.clearInterval(this.timer);\n  };\n\n  Filter.prototype.onTimerTick = function () {\n    var selector = '[id=\\'' + this.column.field + '_filterBarcell\\']';\n    var filterElement = this.element.querySelector(selector);\n\n    if (!filterElement && this.parent.isFrozenGrid()) {\n      filterElement = this.parent.getHeaderContent().querySelector(selector);\n    }\n\n    var filterValue;\n    this.cellText[this.column.field] = filterElement.value;\n    this.stopTimer();\n\n    if (!isNullOrUndefined(this.column.filterBarTemplate)) {\n      var templateRead = this.column.filterBarTemplate.read;\n\n      if (typeof templateRead === 'string') {\n        templateRead = getValue(templateRead, window);\n      }\n\n      if (!isNullOrUndefined(templateRead)) {\n        this.value = templateRead.call(this, filterElement);\n      }\n    } else {\n      filterValue = JSON.parse(JSON.stringify(filterElement.value));\n    }\n\n    if (isNullOrUndefined(this.value) || this.value === '') {\n      this.removeFilteredColsByField(this.column.field);\n      return;\n    }\n\n    this.validateFilterValue(this.value);\n    this.filterByMethod = false;\n    this.filterByColumn(this.column.field, this.operator, this.value, this.predicate, this.filterSettings.enableCaseSensitivity, this.ignoreAccent);\n    this.filterByMethod = true;\n    filterElement.value = filterValue;\n    this.updateFilterMsg();\n  };\n\n  Filter.prototype.validateFilterValue = function (value) {\n    var skipInput;\n    var index;\n    this.matchCase = this.filterSettings.enableCaseSensitivity;\n\n    switch (this.column.type) {\n      case 'number':\n        if (this.column.filter.operator) {\n          this.operator = this.column.filter.operator;\n        } else {\n          this.operator = this.filterOperators.equal;\n        }\n\n        skipInput = ['>', '<', '=', '!'];\n\n        for (var i = 0; i < value.length; i++) {\n          if (skipInput.indexOf(value[i]) > -1) {\n            index = i;\n            break;\n          }\n        }\n\n        this.getOperator(value.substring(index));\n\n        if (index !== 0) {\n          this.value = value.substring(0, index);\n        }\n\n        if (this.value !== '' && value.length >= 1) {\n          this.value = this.valueFormatter.fromView(this.value, this.column.getParser(), this.column.type);\n        }\n\n        if (isNaN(this.value)) {\n          this.filterStatusMsg = this.l10n.getConstant('InvalidFilterMessage');\n        }\n\n        break;\n\n      case 'date':\n      case 'datetime':\n        this.operator = this.filterOperators.equal;\n\n        if (this.value !== '' && !(this.value instanceof Date)) {\n          this.getOperator(value);\n          this.value = this.valueFormatter.fromView(this.value, this.column.getParser(), this.column.type);\n\n          if (isNullOrUndefined(this.value)) {\n            this.filterStatusMsg = this.l10n.getConstant('InvalidFilterMessage');\n          }\n        }\n\n        break;\n\n      case 'string':\n        this.matchCase = false;\n\n        if (value.charAt(0) === '*') {\n          this.value = this.value.slice(1);\n          this.operator = this.filterOperators.startsWith;\n        } else if (value.charAt(value.length - 1) === '%') {\n          this.value = this.value.slice(0, -1);\n          this.operator = this.filterOperators.startsWith;\n        } else if (value.charAt(0) === '%') {\n          this.value = this.value.slice(1);\n          this.operator = this.filterOperators.endsWith;\n        } else {\n          if (this.column.filter.operator) {\n            this.operator = this.column.filter.operator;\n          } else {\n            this.operator = this.filterOperators.startsWith;\n          }\n        }\n\n        break;\n\n      case 'boolean':\n        if (value.toLowerCase() === 'true' || value === '1') {\n          this.value = true;\n        } else if (value.toLowerCase() === 'false' || value === '0') {\n          this.value = false;\n        } else if (value.length) {\n          this.filterStatusMsg = this.l10n.getConstant('InvalidFilterMessage');\n        }\n\n        this.operator = this.filterOperators.equal;\n        break;\n\n      default:\n        if (this.column.filter.operator) {\n          this.operator = this.column.filter.operator;\n        } else {\n          this.operator = this.filterOperators.equal;\n        }\n\n    }\n  };\n\n  Filter.prototype.getOperator = function (value) {\n    var singleOp = value.charAt(0);\n    var multipleOp = value.slice(0, 2);\n    var operators = extend({\n      '=': this.filterOperators.equal,\n      '!': this.filterOperators.notEqual\n    }, DataUtil.operatorSymbols); // eslint-disable-next-line no-prototype-builtins\n\n    if (operators.hasOwnProperty(singleOp) || operators.hasOwnProperty(multipleOp)) {\n      this.operator = operators[singleOp];\n      this.value = value.substring(1);\n\n      if (!this.operator) {\n        this.operator = operators[multipleOp];\n        this.value = value.substring(2);\n      }\n    }\n\n    if (this.operator === this.filterOperators.lessThan || this.operator === this.filterOperators.greaterThan) {\n      if (this.value.charAt(0) === '=') {\n        this.operator = this.operator + 'orequal';\n        this.value = this.value.substring(1);\n      }\n    }\n  };\n\n  Filter.prototype.columnPositionChanged = function () {\n    if (this.parent.filterSettings.type !== 'FilterBar') {\n      return;\n    }\n  };\n\n  Filter.prototype.getLocalizedCustomOperators = function () {\n    var numOptr = [{\n      value: 'equal',\n      text: this.l10n.getConstant('Equal')\n    }, {\n      value: 'greaterthan',\n      text: this.l10n.getConstant('GreaterThan')\n    }, {\n      value: 'greaterthanorequal',\n      text: this.l10n.getConstant('GreaterThanOrEqual')\n    }, {\n      value: 'lessthan',\n      text: this.l10n.getConstant('LessThan')\n    }, {\n      value: 'lessthanorequal',\n      text: this.l10n.getConstant('LessThanOrEqual')\n    }, {\n      value: 'notequal',\n      text: this.l10n.getConstant('NotEqual')\n    }];\n    this.customOperators = {\n      stringOperator: [{\n        value: 'startswith',\n        text: this.l10n.getConstant('StartsWith')\n      }, {\n        value: 'endswith',\n        text: this.l10n.getConstant('EndsWith')\n      }, {\n        value: 'contains',\n        text: this.l10n.getConstant('Contains')\n      }, {\n        value: 'equal',\n        text: this.l10n.getConstant('Equal')\n      }, {\n        value: 'notequal',\n        text: this.l10n.getConstant('NotEqual')\n      }],\n      numberOperator: numOptr,\n      dateOperator: numOptr,\n      datetimeOperator: numOptr,\n      booleanOperator: [{\n        value: 'equal',\n        text: this.l10n.getConstant('Equal')\n      }, {\n        value: 'notequal',\n        text: this.l10n.getConstant('NotEqual')\n      }]\n    };\n  };\n  /**\n   * @param {string} field - specifies the field name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Filter.prototype.openMenuByField = function (field) {\n    var gObj = this.parent;\n\n    if (gObj.enableAdaptiveUI) {\n      this.showCustomFilter(false);\n      return;\n    }\n\n    var column = gObj.getColumnByField(field);\n    var header = gObj.getColumnHeaderByField(field);\n    var target = header.querySelector('.e-filtermenudiv');\n\n    if (!target) {\n      return;\n    }\n\n    var gClient = gObj.element.getBoundingClientRect();\n    var fClient = target.getBoundingClientRect();\n    this.filterDialogOpen(column, target, fClient.right - gClient.left, fClient.bottom - gClient.top);\n  };\n\n  Filter.prototype.filterIconClickHandler = function (e) {\n    var target = e.target;\n\n    if (target.classList.contains('e-filtermenudiv') && (this.parent.filterSettings.type === 'Menu' || this.parent.filterSettings.type === 'CheckBox' || this.parent.filterSettings.type === 'Excel')) {\n      var gObj = this.parent;\n      var col = gObj.getColumnByUid(parentsUntil(target, 'e-headercell').firstElementChild.getAttribute('e-mappinguid'));\n      this.column = col;\n\n      if (this.fltrDlgDetails.field === col.field && this.fltrDlgDetails.isOpen) {\n        return;\n      }\n\n      if (this.filterModule) {\n        this.filterModule.closeDialog();\n      }\n\n      this.fltrDlgDetails = {\n        field: col.field,\n        isOpen: true\n      };\n      this.openMenuByField(col.field);\n    }\n  };\n\n  Filter.prototype.clickHandler = function (e) {\n    if (this.filterSettings.type === 'FilterBar' && this.filterSettings.showFilterBarOperator) {\n      if (parentsUntil(e.target, 'e-filterbarcell') && e.target.classList.contains('e-input-group-icon')) {\n        var filterOperatorElement = closest(e.target, 'div').querySelector('.e-filterbaroperator');\n\n        if (filterOperatorElement) {\n          filterOperatorElement.focus();\n        } else {\n          e.target.focus();\n        }\n      }\n\n      if (e.target.classList.contains('e-list-item')) {\n        var inputId = document.querySelector('.e-popup-open').getAttribute('id').replace('_popup', '');\n\n        if (inputId.indexOf('grid-column') !== -1) {\n          closest(document.getElementById(inputId), 'div').querySelector('.e-filtertext').focus();\n        }\n      }\n    }\n\n    if (this.filterSettings.mode === 'Immediate' || this.parent.filterSettings.type === 'Menu' || this.parent.filterSettings.type === 'CheckBox' || this.parent.filterSettings.type === 'Excel') {\n      var target = e.target;\n      var datepickerEle = target.classList.contains('e-day'); // due to datepicker popup cause\n\n      var dialog = parentsUntil(this.parent.element, 'e-dialog');\n      var hasDialog = false;\n      var popupEle = parentsUntil(target, 'e-popup');\n      var hasDialogClosed = this.parent.element.querySelector('.e-filter-popup');\n\n      if (dialog && popupEle) {\n        hasDialog = dialog.id === popupEle.id;\n      }\n\n      if (hasDialogClosed && (parentsUntil(target, 'e-excel-ascending') || parentsUntil(target, 'e-excel-descending'))) {\n        this.filterModule.closeDialog(target);\n      }\n\n      if (parentsUntil(target, 'e-filter-popup') || target.classList.contains('e-filtermenudiv')) {\n        return;\n      } else if (this.filterModule && !parentsUntil(target, 'e-popup-wrapper') && !closest(target, '.e-filter-item.e-menu-item') && !datepickerEle) {\n        if (hasDialog && !parentsUntil(target, 'e-filter-popup') && !parentsUntil(target, 'e-popup-flmenu') || !popupEle && hasDialogClosed) {\n          this.filterModule.isresetFocus = parentsUntil(target, 'e-grid') && parentsUntil(target, 'e-grid').id === this.parent.element.id;\n          this.filterModule.closeDialog(target);\n        }\n      }\n    }\n  };\n\n  Filter.prototype.filterHandler = function (args) {\n    this.actualPredicate[args.field] = args.actualPredicate;\n    var dataManager = new DataManager(this.filterSettings.columns);\n    var query = new Query().where('field', this.filterOperators.equal, args.field);\n    var result = dataManager.executeLocal(query);\n\n    for (var i = 0; i < result.length; i++) {\n      var index = -1;\n\n      for (var j = 0; j < this.filterSettings.columns.length; j++) {\n        if (result[i].field === this.filterSettings.columns[j].field) {\n          index = j;\n          break;\n        }\n      }\n\n      if (index !== -1) {\n        this.filterSettings.columns.splice(index, 1);\n      }\n    }\n\n    if (this.values[args.field]) {\n      delete this.values[args.field];\n    }\n\n    var col = this.parent.getColumnByField(args.field);\n    var iconClass = this.parent.showColumnMenu && col.showColumnMenu ? '.e-columnmenu' : '.e-icon-filter';\n    var filterIconElement = this.parent.getColumnHeaderByField(args.field).querySelector(iconClass);\n\n    if (args.action === 'filtering') {\n      this.filterSettings.columns = this.filterSettings.columns.concat(args.filterCollection);\n\n      if (this.filterSettings.columns.length && filterIconElement) {\n        filterIconElement.classList.add('e-filtered');\n      }\n    } else {\n      if (filterIconElement) {\n        filterIconElement.classList.remove('e-filtered');\n      }\n\n      args.requestType = 'filtering';\n      this.parent.renderModule.refresh(args); //hot-fix onpropertychanged not working for object { array }\n    }\n\n    this.parent.dataBind();\n  };\n\n  Filter.prototype.updateFilter = function () {\n    var cols = this.filterSettings.columns;\n    this.actualPredicate = {};\n\n    for (var i = 0; i < cols.length; i++) {\n      this.column = this.parent.getColumnByField(cols[i].field) || getColumnByForeignKeyValue(cols[i].field, this.parent.getForeignKeyColumns());\n      var fieldName = cols[i].field;\n\n      if (!this.parent.getColumnByField(cols[i].field)) {\n        fieldName = getColumnByForeignKeyValue(cols[i].field, this.parent.getForeignKeyColumns()).field;\n      }\n\n      this.refreshFilterIcon(fieldName, cols[i].operator, cols[i].value, cols[i].type, cols[i].predicate, cols[i].matchCase, cols[i].ignoreAccent, cols[i].uid);\n    }\n  };\n\n  Filter.prototype.refreshFilterIcon = function (fieldName, operator, value, type, predicate, matchCase, ignoreAccent, uid) {\n    var obj = {\n      field: fieldName,\n      predicate: predicate,\n      matchCase: matchCase,\n      ignoreAccent: ignoreAccent,\n      operator: operator,\n      value: value,\n      type: type\n    };\n\n    if (this.actualPredicate[fieldName]) {\n      this.actualPredicate[fieldName].push(obj);\n    } else {\n      this.actualPredicate[fieldName] = [obj];\n    }\n\n    var field = uid ? this.parent.grabColumnByUidFromAllCols(uid).field : fieldName;\n    this.addFilteredClass(field);\n  };\n\n  Filter.prototype.addFilteredClass = function (fieldName) {\n    var filterIconElement;\n    var col = this.parent.getColumnByField(fieldName);\n\n    if (this.parent.showColumnMenu && col.showColumnMenu) {\n      filterIconElement = this.parent.getColumnHeaderByField(fieldName).querySelector('.e-columnmenu');\n    } else if (col) {\n      filterIconElement = this.parent.getColumnHeaderByField(fieldName).querySelector('.e-icon-filter');\n    }\n\n    if (filterIconElement) {\n      filterIconElement.classList.add('e-filtered');\n    }\n  };\n  /**\n   * @hidden\n   * @returns {FilterUI} returns the FilterUI\n   */\n\n\n  Filter.prototype.getFilterUIInfo = function () {\n    return this.filterModule ? this.filterModule.getFilterUIInfo() : {};\n  };\n  /**\n   * @param {string} field - specifies the field name\n   * @returns {string} returns the operator name\n   * @hidden\n   */\n\n\n  Filter.prototype.getOperatorName = function (field) {\n    return document.getElementById(this.parent.getColumnByField(field).uid).ej2_instances[0].value;\n  };\n  /**\n   * Renders checkbox items in Menu filter dialog.\n   *\n   * @returns {void}\n   */\n\n\n  Filter.prototype.renderCheckboxOnFilterMenu = function () {\n    return this.filterModule.renderCheckBoxMenu();\n  };\n\n  return Filter;\n}();\n\nvar resizeClassList = {\n  root: 'e-rhandler',\n  suppress: 'e-rsuppress',\n  icon: 'e-ricon',\n  helper: 'e-rhelper',\n  header: 'th.e-headercell',\n  cursor: 'e-rcursor'\n};\n/**\n * `Resize` module is used to handle Resize to fit for columns.\n *\n * @hidden\n * @private\n */\n\nvar Resize =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid resize module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function Resize(parent) {\n    this.tapped = false;\n    this.isDblClk = true;\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.widthService = new ColumnWidthService(parent);\n    this.addEventListener();\n  }\n  /**\n   * Resize by field names.\n   *\n   * @param  {string|string[]} fName - Defines the field name.\n   * @returns {void}\n   */\n\n\n  Resize.prototype.autoFitColumns = function (fName) {\n    var columnName = fName === undefined || fName === null || fName.length <= 0 ? this.parent.getColumns().map(function (x) {\n      return x.field;\n    }) : typeof fName === 'string' ? [fName] : fName;\n    this.parent.isAutoFitColumns = true;\n    this.findColumn(columnName);\n  };\n\n  Resize.prototype.autoFit = function () {\n    var newarray = this.parent.getColumns().filter(function (c) {\n      return c.autoFit === true;\n    }).map(function (c) {\n      return c.field || c.headerText;\n    });\n\n    if (newarray.length > 0) {\n      this.autoFitColumns(newarray);\n    }\n\n    if (this.parent.resizeSettings.mode === 'Auto') {\n      this.widthService.setWidthToTable();\n    }\n  };\n\n  Resize.prototype.resizeColumn = function (fName, index, id) {\n    var gObj = this.parent;\n    var tWidth = 0;\n    var headerTable;\n    var contentTable;\n    var footerTable;\n    var headerDivTag = 'e-gridheader';\n    var contentDivTag = gridContent;\n    var footerDivTag = gridFooter;\n    var indentWidth = 0;\n    var uid = id ? id : this.parent.getUidByColumnField(fName);\n    var columnIndex = this.parent.getNormalizedColumnIndex(uid);\n    var headerTextClone;\n    var contentTextClone;\n    var footerTextClone;\n    var columnIndexByField = this.parent.getColumnIndexByField(fName);\n    var left = gObj.getFrozenColumns() || gObj.getFrozenLeftColumnsCount();\n    var movable = gObj.getMovableColumnsCount();\n\n    if (!isNullOrUndefined(gObj.getFooterContent())) {\n      footerTable = gObj.getFooterContentTable();\n    }\n\n    if (gObj.isFrozenGrid()) {\n      var col = gObj.getColumnByField(fName);\n\n      if (col.getFreezeTableName() === frozenLeft) {\n        headerTable = gObj.getHeaderTable();\n        contentTable = gObj.getContentTable();\n        headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n        contentTextClone = contentTable.querySelectorAll(\"td:nth-child(\" + (columnIndex + 1) + \")\");\n\n        if (footerTable) {\n          footerTextClone = footerTable.querySelectorAll(\"td:nth-child(\" + (columnIndex + 1) + \")\");\n        }\n      } else if (col.getFreezeTableName() === 'movable') {\n        headerTable = gObj.getHeaderContent().querySelector('.' + movableHeader).children[0];\n        contentTable = gObj.getContent().querySelector('.' + movableContent).children[0];\n        headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n        contentTextClone = contentTable.querySelectorAll(\"td:nth-child(\" + (columnIndex - left + 1) + \")\");\n\n        if (footerTable) {\n          footerTable = gObj.getFooterContent().querySelector('.e-movablefootercontent').children[0];\n          footerTextClone = footerTable.querySelectorAll(\"td:nth-child(\" + (columnIndex - left + 1) + \")\");\n        }\n      } else if (col.getFreezeTableName() === frozenRight) {\n        headerTable = gObj.getHeaderContent().querySelector('.e-frozen-right-header').children[0];\n        contentTable = gObj.getContent().querySelector('.e-frozen-right-content').children[0];\n        headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n        contentTextClone = contentTable.querySelectorAll(\"td:nth-child(\" + (columnIndex - (left + movable) + 1) + \")\");\n\n        if (footerTable) {\n          footerTable = gObj.getFooterContent().querySelector('.e-movablefootercontent').children[0];\n          footerTextClone = footerTable.querySelectorAll(\"td:nth-child(\" + (columnIndex - (left + movable) + 1) + \")\");\n        }\n      }\n    } else {\n      headerTable = gObj.getHeaderTable();\n      contentTable = gObj.getContentTable();\n      headerTextClone = headerTable.querySelector('[e-mappinguid=\"' + uid + '\"]').parentElement.cloneNode(true);\n      contentTextClone = contentTable.querySelectorAll(\"td.e-rowcell:nth-child(\" + (columnIndex + 1) + \"):not(.e-groupcaption):not(.e-detailcell)\");\n\n      if (footerTable) {\n        footerTextClone = footerTable.querySelectorAll(\"td:nth-child(\" + (columnIndex + 1) + \"):not(.e-groupcaption)\");\n      }\n    }\n\n    var indentWidthClone = [].slice.call(headerTable.querySelector('tr').getElementsByClassName('e-grouptopleftcell'));\n\n    if (indentWidthClone.length > 0) {\n      for (var i = 0; i < indentWidthClone.length; i++) {\n        indentWidth += indentWidthClone[i].offsetWidth;\n      }\n    }\n\n    var detailsElement = contentTable.querySelector('.e-detailrowcollapse') || contentTable.querySelector('.e-detailrowexpand');\n\n    if ((this.parent.detailTemplate || this.parent.childGrid) && detailsElement) {\n      indentWidth += detailsElement.offsetWidth;\n    }\n\n    var headerText = [headerTextClone];\n    var contentText = [];\n    var footerText = [];\n\n    if (footerTable) {\n      for (var i = 0; i < footerTextClone.length; i++) {\n        footerText[i] = footerTextClone[i].cloneNode(true);\n      }\n    }\n\n    for (var i = 0; i < contentTextClone.length; i++) {\n      contentText[i] = contentTextClone[i].cloneNode(true);\n    }\n\n    var wHeader = this.createTable(headerTable, headerText, headerDivTag);\n    var wFooter = null;\n    var wContent = null;\n\n    if (gObj.getCurrentViewRecords().length) {\n      wContent = this.createTable(contentTable, contentText, contentDivTag);\n    }\n\n    if (footerText.length) {\n      wFooter = this.createTable(footerTable, footerText, footerDivTag);\n    }\n\n    var columnbyindex = gObj.getColumns()[columnIndexByField];\n    var width = columnbyindex.width = formatUnit(Math.max(wHeader, wContent, wFooter));\n    var colMaxWidth = columnbyindex.maxWidth && parseFloat(columnbyindex.maxWidth.toString());\n\n    if (parseInt(width, 10) > colMaxWidth) {\n      columnbyindex.width = colMaxWidth;\n    }\n\n    this.widthService.setColumnWidth(gObj.getColumns()[columnIndexByField]);\n    var result = gObj.getColumns().some(function (x) {\n      return x.width === null || x.width === undefined || x.width.length <= 0;\n    });\n\n    if (result === false) {\n      var element = gObj.getColumns();\n\n      for (var i = 0; i < element.length; i++) {\n        if (element[i].visible) {\n          tWidth = tWidth + parseFloat(element[i].width);\n        }\n      }\n    }\n\n    var calcTableWidth = tWidth + indentWidth;\n\n    if (tWidth > 0 && !gObj.isFrozenGrid()) {\n      if (this.parent.detailTemplate || this.parent.childGrid) {\n        this.widthService.setColumnWidth(new Column({\n          width: '30px'\n        }));\n      }\n\n      if (this.parent.resizeSettings.mode === 'Auto') {\n        calcTableWidth = '100%';\n      }\n\n      headerTable.style.width = formatUnit(calcTableWidth);\n      contentTable.style.width = formatUnit(calcTableWidth);\n\n      if (!isNullOrUndefined(footerTable)) {\n        footerTable.style.width = formatUnit(calcTableWidth);\n      }\n    }\n\n    if (gObj.isFrozenGrid()) {\n      this.widthService.refreshFrozenScrollbar();\n    }\n\n    var tableWidth = headerTable.offsetWidth;\n    var contentwidth = gObj.getContent().scrollWidth;\n\n    if (contentwidth > tableWidth) {\n      headerTable.classList.add('e-tableborder');\n      contentTable.classList.add('e-tableborder');\n    } else {\n      headerTable.classList.remove('e-tableborder');\n      contentTable.classList.remove('e-tableborder');\n    }\n\n    if (!isNullOrUndefined(footerTable)) {\n      footerTable.classList.add('e-tableborder');\n    }\n  };\n  /**\n   * To destroy the resize\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Resize.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.widthService = null;\n    this.unwireEvents();\n    this.removeEventListener();\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Resize.prototype.getModuleName = function () {\n    return 'resize';\n  };\n\n  Resize.prototype.findColumn = function (fName) {\n    for (var i = 0; i < fName.length; i++) {\n      var fieldName = fName[i];\n      var columnIndex = this.parent.getColumnIndexByField(fieldName);\n      var column = this.parent.getColumns()[columnIndex];\n\n      if (columnIndex > -1 && !isNullOrUndefined(column) && column.visible === true) {\n        this.resizeColumn(fieldName, columnIndex);\n      }\n    }\n  };\n  /**\n   * To create table for autofit\n   *\n   * @param {Element} table - specifies the table\n   * @param {Element[]} text - specifies the text\n   * @param {string} tag - specifies the tag name\n   * @returns {number} returns the number\n   * @hidden\n   */\n\n\n  Resize.prototype.createTable = function (table$$1, text, tag) {\n    var myTableDiv = this.parent.createElement('div');\n    myTableDiv.className = this.parent.element.className;\n    myTableDiv.style.cssText = 'display: inline-block;visibility:hidden;position:absolute';\n    var mySubDiv = this.parent.createElement('div');\n    mySubDiv.className = tag;\n    var myTable = this.parent.createElement('table', {\n      attrs: {\n        role: 'grid'\n      }\n    });\n    myTable.className = table$$1.className;\n    myTable.classList.add('e-resizetable');\n    myTable.style.cssText = 'table-layout: auto;width: auto';\n    var myTr = this.parent.createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n\n    for (var i = 0; i < text.length; i++) {\n      var tr = myTr.cloneNode();\n      tr.className = table$$1.querySelector('tr').className;\n      tr.appendChild(text[i]);\n      myTable.appendChild(tr);\n    }\n\n    mySubDiv.appendChild(myTable);\n    myTableDiv.appendChild(mySubDiv);\n    document.body.appendChild(myTableDiv);\n    var offsetWidthValue = myTable.getBoundingClientRect().width;\n    document.body.removeChild(myTableDiv);\n    return Math.ceil(offsetWidthValue);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Resize.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(headerRefreshed, this.refreshHeight, this);\n    this.parent.on(initialEnd, this.wireEvents, this);\n    this.parent.on(contentReady, this.autoFit, this);\n    this.parent.on(refreshHandlers, this.refreshHeight, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Resize.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(headerRefreshed, this.refreshHeight);\n    this.parent.off(initialEnd, this.wireEvents);\n    this.parent.off(refreshHandlers, this.refreshHeight);\n    this.parent.off(destroy, this.destroy);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Resize.prototype.render = function () {\n    this.unwireEvents();\n    this.wireEvents();\n    this.setHandlerHeight();\n  };\n\n  Resize.prototype.refreshHeight = function () {\n    if (this.parent.getHeaderTable()) {\n      var element = this.getResizeHandlers();\n\n      for (var i = 0; i < element.length; i++) {\n        if (element[i].parentElement.offsetHeight > 0) {\n          element[i].style.height = element[i].parentElement.offsetHeight + 'px';\n        }\n      }\n\n      this.setHandlerHeight();\n    }\n  };\n\n  Resize.prototype.wireEvents = function () {\n    EventHandler.add(this.parent.getHeaderContent(), Browser.touchStartEvent, this.touchResizeStart, this);\n    EventHandler.add(this.parent.getHeaderContent(), dblclick, this.callAutoFit, this);\n  };\n\n  Resize.prototype.unwireEvents = function () {\n    EventHandler.remove(this.parent.getHeaderContent(), Browser.touchStartEvent, this.touchResizeStart);\n    EventHandler.remove(this.parent.getHeaderContent(), dblclick, this.callAutoFit);\n  };\n\n  Resize.prototype.getResizeHandlers = function () {\n    return this.parent.isFrozenGrid() ? [].slice.call(this.parent.getHeaderContent().getElementsByClassName(resizeClassList.root)) : [].slice.call(this.parent.getHeaderTable().getElementsByClassName(resizeClassList.root));\n  };\n\n  Resize.prototype.setHandlerHeight = function () {\n    var element = [].slice.call(this.parent.getHeaderTable().getElementsByClassName(resizeClassList.suppress));\n\n    for (var i = 0; i < element.length; i++) {\n      element[i].style.height = element[i].parentElement.offsetHeight + 'px';\n    }\n  };\n\n  Resize.prototype.callAutoFit = function (e) {\n    if (e.target.classList.contains('e-rhandler')) {\n      var col = this.getTargetColumn(e);\n\n      if (col.columns) {\n        return;\n      }\n\n      this.resizeColumn(col.field, this.parent.getNormalizedColumnIndex(col.uid), col.uid);\n      var header = closest(e.target, resizeClassList.header);\n      header.classList.add('e-resized');\n    }\n  };\n\n  Resize.prototype.touchResizeStart = function (e) {\n    if (!Global.timer) {\n      Global.timer = setTimeout(function () {\n        Global.timer = null;\n      }, 300);\n      return this.resizeStart(e);\n    } else {\n      clearTimeout(Global.timer);\n      Global.timer = null;\n      this.callAutoFit(e);\n    }\n  };\n\n  Resize.prototype.resizeStart = function (e) {\n    var _this = this;\n\n    if (e.target.classList.contains('e-rhandler')) {\n      if (!this.helper) {\n        if (this.getScrollBarWidth() === 0) {\n          if (this.parent.allowGrouping) {\n            for (var i = 0; i < this.parent.groupSettings.columns.length; i++) {\n              this.widthService.setColumnWidth(new Column({\n                width: '30px'\n              }), i);\n            }\n          }\n\n          for (var _i = 0, _a = this.refreshColumnWidth(); _i < _a.length; _i++) {\n            var col = _a[_i];\n            this.widthService.setColumnWidth(col);\n          }\n\n          this.widthService.setWidthToTable();\n        }\n\n        this.refreshStackedColumnWidth();\n        this.element = e.target;\n\n        if (this.parent.getVisibleFrozenColumns()) {\n          var mtbody = this.parent.getMovableContentTbody();\n          var ftbody = this.parent.getFrozenLeftContentTbody();\n          var frtbody = this.parent.getFrozenRightContentTbody();\n          var mtr = [].slice.call(mtbody.querySelectorAll('tr'));\n          var ftr = [].slice.call(ftbody.querySelectorAll('tr'));\n          var frTr = [];\n\n          if (this.parent.getFrozenMode() === leftRight && frtbody) {\n            frTr = [].slice.call(frtbody.querySelectorAll('tr'));\n          }\n\n          var _loop_1 = function (i) {\n            gridActionHandler(this_1.parent, function (tableName, row$$1) {\n              if (_this.parent.rowHeight) {\n                row$$1[i].style.height = _this.parent.rowHeight + 'px';\n              } else {\n                row$$1[i].style.removeProperty('height');\n              }\n            }, [ftr, mtr, frTr]);\n          };\n\n          var this_1 = this;\n\n          for (var i = 0; i < mtr.length; i++) {\n            _loop_1(i);\n          }\n        }\n\n        this.parentElementWidth = this.parent.element.getBoundingClientRect().width;\n        this.appendHelper();\n        this.column = this.getTargetColumn(e);\n        this.pageX = this.getPointX(e);\n\n        if (this.column.getFreezeTableName() === frozenRight) {\n          if (this.parent.enableRtl) {\n            this.minMove = (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0) - parseFloat(isNullOrUndefined(this.column.width) ? '' : this.column.width.toString());\n          } else {\n            this.minMove = parseFloat(isNullOrUndefined(this.column.width) ? '' : this.column.width.toString()) - (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0);\n          }\n        } else if (this.parent.enableRtl) {\n          this.minMove = parseFloat(this.column.width.toString()) - (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0);\n        } else {\n          this.minMove = (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0) - parseFloat(isNullOrUndefined(this.column.width) ? '' : this.column.width.toString());\n        }\n\n        this.minMove += this.pageX;\n      }\n\n      if (Browser.isDevice && !this.helper.classList.contains(resizeClassList.icon)) {\n        this.helper.classList.add(resizeClassList.icon);\n        EventHandler.add(document, Browser.touchStartEvent, this.removeHelper, this);\n        EventHandler.add(this.helper, Browser.touchStartEvent, this.resizeStart, this);\n      } else {\n        var args = {\n          e: e,\n          column: this.column\n        };\n        this.parent.trigger(resizeStart, args, function (args) {\n          if (args.cancel || _this.parent.isEdit) {\n            _this.cancelResizeAction();\n\n            return;\n          }\n\n          EventHandler.add(document, Browser.touchEndEvent, _this.resizeEnd, _this);\n          EventHandler.add(_this.parent.element, Browser.touchMoveEvent, _this.resizing, _this);\n\n          _this.updateCursor('add');\n        });\n      }\n    }\n  };\n\n  Resize.prototype.cancelResizeAction = function (removeEvents) {\n    if (removeEvents) {\n      EventHandler.remove(this.parent.element, Browser.touchMoveEvent, this.resizing);\n      EventHandler.remove(document, Browser.touchEndEvent, this.resizeEnd);\n      this.updateCursor('remove');\n    }\n\n    if (Browser.isDevice) {\n      EventHandler.remove(document, Browser.touchStartEvent, this.removeHelper);\n      EventHandler.remove(this.helper, Browser.touchStartEvent, this.resizeStart);\n    }\n\n    detach(this.helper);\n    this.refresh();\n  };\n\n  Resize.prototype.getWidth = function (width, minWidth, maxWidth) {\n    if (minWidth && width < minWidth) {\n      return minWidth;\n    } else if (maxWidth && width > maxWidth) {\n      return maxWidth;\n    } else {\n      return width;\n    }\n  };\n\n  Resize.prototype.updateResizeEleHeight = function () {\n    var elements = [].slice.call(this.parent.getHeaderContent().getElementsByClassName('e-rhandler'));\n\n    for (var i = 0; i < elements.length; i++) {\n      elements[i].style.height = this.element.parentElement.offsetHeight + 'px';\n    }\n  };\n\n  Resize.prototype.getColData = function (column, mousemove) {\n    return {\n      width: parseFloat(isNullOrUndefined(this.widthService.getWidth(column)) || this.widthService.getWidth(column) === 'auto' ? '0' : this.widthService.getWidth(column).toString()) + mousemove,\n      minWidth: column.minWidth ? parseFloat(column.minWidth.toString()) : null,\n      maxWidth: column.maxWidth ? parseFloat(column.maxWidth.toString()) : null\n    };\n  };\n\n  Resize.prototype.resizing = function (e) {\n    if (isNullOrUndefined(this.column)) {\n      return;\n    }\n\n    var offsetWidth = 0;\n\n    if (isNullOrUndefined(this.column)) {\n      offsetWidth = parentsUntil(this.element, 'th').offsetWidth;\n    }\n\n    if (this.parent.allowTextWrap) {\n      this.updateResizeEleHeight();\n      this.setHelperHeight();\n    }\n\n    var pageX = this.getPointX(e);\n    var mousemove = this.parent.enableRtl ? -(pageX - this.pageX) : pageX - this.pageX;\n\n    if (this.column.getFreezeTableName() === frozenRight) {\n      mousemove = this.parent.enableRtl ? pageX - this.pageX : this.pageX - pageX;\n    }\n\n    var colData = this.getColData(this.column, mousemove);\n\n    if (!colData.width) {\n      colData.width = closest(this.element, 'th').offsetWidth;\n    }\n\n    var width = this.getWidth(colData.width, colData.minWidth, colData.maxWidth);\n    this.parent.log('resize_min_max', {\n      column: this.column,\n      width: width\n    });\n\n    if (this.column.getFreezeTableName() === frozenRight) {\n      if (this.parent.enableRtl && this.minMove >= pageX || !this.parent.enableRtl && this.minMove <= pageX) {\n        width = this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 10;\n        this.pageX = pageX = this.minMove;\n      }\n    }\n\n    if (this.column.getFreezeTableName() !== frozenRight && (!this.parent.enableRtl && this.minMove >= pageX || this.parent.enableRtl && this.minMove <= pageX) || this.column.getFreezeTableName() === frozenRight && (this.parent.enableRtl && this.minMove >= pageX || !this.parent.enableRtl && this.minMove <= pageX)) {\n      width = this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 10;\n      this.pageX = pageX = this.minMove;\n    }\n\n    if (width !== parseFloat(isNullOrUndefined(this.column.width) || this.column.width === 'auto' ? offsetWidth.toString() : this.column.width.toString())) {\n      this.pageX = pageX;\n      this.column.width = formatUnit(width);\n      var args = {\n        e: e,\n        column: this.column\n      };\n      this.parent.trigger(onResize, args);\n\n      if (args.cancel) {\n        this.cancelResizeAction(true);\n        return;\n      }\n\n      var columns = [this.column];\n      var finalColumns = [this.column];\n\n      if (this.column.columns) {\n        columns = this.getSubColumns(this.column, []);\n        columns = this.calulateColumnsWidth(columns, false, mousemove);\n        finalColumns = this.calulateColumnsWidth(columns, true, mousemove);\n      }\n\n      for (var _i = 0, finalColumns_1 = finalColumns; _i < finalColumns_1.length; _i++) {\n        var col = finalColumns_1[_i];\n        this.widthService.setColumnWidth(col, null, 'resize');\n      }\n\n      this.updateHelper();\n    }\n\n    this.isDblClk = false;\n  };\n\n  Resize.prototype.calulateColumnsWidth = function (columns, isUpdate, mousemove) {\n    var finalColumns = [];\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var col = columns_1[_i];\n      var totalWidth = 0;\n\n      for (var i = 0; i < columns.length; i++) {\n        totalWidth += parseFloat(columns[i].width.toString());\n      }\n\n      var colData = this.getColData(col, parseFloat(col.width) * mousemove / totalWidth);\n      var colWidth = this.getWidth(colData.width, colData.minWidth, colData.maxWidth);\n\n      if (colWidth !== parseFloat(col.width.toString())) {\n        if (isUpdate) {\n          col.width = formatUnit(colWidth < 1 ? 1 : colWidth);\n        }\n\n        finalColumns.push(col);\n      }\n    }\n\n    return finalColumns;\n  };\n\n  Resize.prototype.getSubColumns = function (column, subColumns) {\n    for (var _i = 0, _a = column.columns; _i < _a.length; _i++) {\n      var col = _a[_i];\n\n      if (col.visible !== false && col.allowResizing) {\n        if (col.columns) {\n          this.getSubColumns(col, subColumns);\n        } else {\n          subColumns.push(col);\n        }\n      }\n    }\n\n    return subColumns;\n  };\n\n  Resize.prototype.resizeEnd = function (e) {\n    if (!this.helper || this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(this.parent.element, Browser.touchMoveEvent, this.resizing);\n    EventHandler.remove(document, Browser.touchEndEvent, this.resizeEnd);\n    this.updateCursor('remove');\n    detach(this.helper);\n    var args = {\n      e: e,\n      column: this.column\n    };\n    var content$$1 = this.parent.getContent().querySelector('.' + content);\n    var cTable = content$$1.querySelector('.' + movableContent) ? content$$1.querySelector('.' + movableContent) : content$$1;\n\n    if (cTable.scrollHeight > cTable.clientHeight) {\n      this.parent.scrollModule.setPadding();\n      cTable.style.overflowY = 'scroll';\n    }\n\n    this.parent.trigger(resizeStop, args);\n    closest(this.element, '.e-headercell').classList.add('e-resized');\n\n    if (parentsUntil(this.element, 'e-frozenheader')) {\n      this.isFrozenColResized = true;\n    } else {\n      this.isFrozenColResized = false;\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      this.parent.notify(freezeRender, {\n        case: 'textwrap'\n      });\n    }\n\n    if (this.parent.allowTextWrap) {\n      this.updateResizeEleHeight();\n      this.parent.notify(textWrapRefresh, {\n        case: 'textwrap'\n      });\n    }\n\n    this.refresh();\n    this.doubleTapEvent(e);\n    this.isDblClk = true;\n  };\n\n  Resize.prototype.getPointX = function (e) {\n    if (e.touches && e.touches.length) {\n      return e.touches[0].pageX;\n    } else {\n      return e.pageX;\n    }\n  };\n\n  Resize.prototype.refreshColumnWidth = function () {\n    var columns = this.parent.getColumns();\n\n    for (var _i = 0, _a = [].slice.apply(this.parent.getHeaderContent().querySelectorAll('th.e-headercell')); _i < _a.length; _i++) {\n      var ele = _a[_i];\n\n      for (var _b = 0, columns_2 = columns; _b < columns_2.length; _b++) {\n        var column = columns_2[_b];\n\n        if (ele.querySelector('[e-mappinguid]') && ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === column.uid && column.visible) {\n          column.width = ele.getBoundingClientRect().width;\n          break;\n        }\n      }\n    }\n\n    return columns;\n  };\n\n  Resize.prototype.refreshStackedColumnWidth = function () {\n    for (var _i = 0, _a = this.parent.getStackedColumns(this.parent.columns); _i < _a.length; _i++) {\n      var stackedColumn = _a[_i];\n      stackedColumn.width = this.getStackedWidth(stackedColumn, 0);\n    }\n  };\n\n  Resize.prototype.getStackedWidth = function (column, width) {\n    for (var _i = 0, _a = column.columns; _i < _a.length; _i++) {\n      var col = _a[_i];\n\n      if (col.visible !== false) {\n        if (col.columns) {\n          this.getStackedWidth(col, width);\n        } else {\n          width += col.width;\n        }\n      }\n    }\n\n    return width;\n  };\n\n  Resize.prototype.getTargetColumn = function (e) {\n    var cell = closest(e.target, resizeClassList.header);\n    cell = cell.querySelector('.e-headercelldiv') || cell.querySelector('.e-stackedheadercelldiv');\n    var uid = cell.getAttribute('e-mappinguid');\n    return this.parent.getColumnByUid(uid);\n  };\n\n  Resize.prototype.updateCursor = function (action) {\n    var headerRows = [].slice.call(this.parent.getHeaderContent().querySelectorAll('th'));\n    headerRows.push(this.parent.element);\n\n    for (var _i = 0, headerRows_1 = headerRows; _i < headerRows_1.length; _i++) {\n      var row$$1 = headerRows_1[_i];\n      row$$1.classList[action](resizeClassList.cursor);\n    }\n  };\n\n  Resize.prototype.refresh = function () {\n    this.column = null;\n    this.pageX = null;\n    this.element = null;\n    this.helper = null;\n  };\n\n  Resize.prototype.appendHelper = function () {\n    this.helper = this.parent.createElement('div', {\n      className: resizeClassList.helper\n    });\n    this.parent.element.appendChild(this.helper);\n    this.setHelperHeight();\n  };\n\n  Resize.prototype.setHelperHeight = function () {\n    var isFrozen = this.parent.isFrozenGrid();\n    var height = isFrozen ? this.parent.getContent().querySelector('.' + content).offsetHeight : this.parent.getContent().offsetHeight - this.getScrollBarWidth();\n    var rect = closest(this.element, resizeClassList.header);\n    var tr = [].slice.call(this.parent.getHeaderContent().querySelectorAll('tr'));\n    var right = this.parent.getFrozenRightColumnsCount();\n\n    if (isFrozen) {\n      if (parentsUntil(rect, movableHeader)) {\n        tr = [].slice.call(this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelectorAll('tr'));\n      } else if (right && parentsUntil(rect, 'e-frozen-right-header')) {\n        tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelectorAll('tr'));\n      } else {\n        tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-left-header').querySelectorAll('tr'));\n      }\n    }\n\n    for (var i = tr.indexOf(rect.parentElement); i < tr.length && i > -1; i++) {\n      height += tr[i].offsetHeight;\n    }\n\n    var pos = this.calcPos(rect);\n\n    if (parentsUntil(rect, 'e-frozen-right-header')) {\n      pos.left += this.parent.enableRtl ? rect.offsetWidth - 2 : 0 - 1;\n    } else {\n      pos.left += this.parent.enableRtl ? 0 - 1 : rect.offsetWidth - 2;\n    }\n\n    this.helper.style.cssText = 'height: ' + height + 'px; top: ' + pos.top + 'px; left:' + Math.floor(pos.left) + 'px;';\n\n    if (this.parent.enableVirtualization) {\n      this.helper.classList.add('e-virtual-rhandler');\n    }\n  };\n\n  Resize.prototype.getScrollBarWidth = function (height) {\n    var ele = this.parent.getContent().firstChild;\n    return ele.scrollHeight > ele.clientHeight && height || ele.scrollWidth > ele.clientWidth ? getScrollBarWidth() : 0;\n  };\n\n  Resize.prototype.removeHelper = function (e) {\n    var cls = e.target.classList;\n\n    if (!(cls.contains(resizeClassList.root) || cls.contains(resizeClassList.icon)) && this.helper) {\n      EventHandler.remove(document, Browser.touchStartEvent, this.removeHelper);\n      EventHandler.remove(this.helper, Browser.touchStartEvent, this.resizeStart);\n      detach(this.helper);\n      this.refresh();\n    }\n  };\n\n  Resize.prototype.updateHelper = function () {\n    var rect = closest(this.element, resizeClassList.header);\n    var left;\n\n    if (parentsUntil(rect, 'e-frozen-right-header')) {\n      left = Math.floor(this.calcPos(rect).left + (this.parent.enableRtl ? rect.offsetWidth - 2 : 0 - 1));\n    } else {\n      left = Math.floor(this.calcPos(rect).left + (this.parent.enableRtl ? 0 - 1 : rect.offsetWidth - 2));\n    }\n\n    var borderWidth = 2; // to maintain the helper inside of grid element.\n\n    if (left > this.parentElementWidth) {\n      left = this.parentElementWidth - borderWidth;\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      var table$$1 = closest(rect, '.' + table);\n      var fLeft = table$$1.offsetLeft;\n\n      if (left < fLeft) {\n        left = fLeft;\n      }\n    }\n\n    this.helper.style.left = left + 'px';\n  };\n\n  Resize.prototype.calcPos = function (elem) {\n    var parentOffset = {\n      top: 0,\n      left: 0\n    };\n    var offset = elem.getBoundingClientRect();\n    var doc = elem.ownerDocument;\n    var offsetParent = parentsUntil(elem, 'e-grid') || doc.documentElement;\n\n    while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && offsetParent.style.position === 'static') {\n      offsetParent = offsetParent.parentNode;\n    }\n\n    if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n      parentOffset = offsetParent.getBoundingClientRect();\n    }\n\n    return {\n      top: offset.top - parentOffset.top,\n      left: offset.left - parentOffset.left\n    };\n  };\n\n  Resize.prototype.doubleTapEvent = function (e) {\n    var _this = this;\n\n    if (this.getUserAgent() && this.isDblClk) {\n      if (!this.tapped) {\n        this.tapped = setTimeout(function () {\n          _this.tapped = null;\n        }, 300);\n      } else {\n        clearTimeout(this.tapped);\n        this.callAutoFit(e);\n        this.tapped = null;\n      }\n    }\n  };\n\n  Resize.prototype.getUserAgent = function () {\n    var userAgent = Browser.userAgent.toLowerCase();\n    return /iphone|ipod|ipad/.test(userAgent);\n  };\n\n  Resize.prototype.timeoutHandler = function () {\n    this.tapped = null;\n  };\n\n  return Resize;\n}();\n/**\n *\n * The `Reorder` module is used for reordering columns.\n */\n\n\nvar Reorder =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid reorder module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function Reorder(parent) {\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(headerDrop, this.headerDrop, this);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(reorderComplete, this.onActionComplete, this);\n    this.parent.on(columnDrag, this.drag, this);\n    this.parent.on(columnDragStart, this.dragStart, this);\n    this.parent.on(columnDragStop, this.dragStop, this);\n    this.parent.on(headerDrop, this.headerDrop, this);\n    this.parent.on(headerRefreshed, this.createReorderElement, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  Reorder.prototype.chkDropPosition = function (srcElem, destElem) {\n    var col = this.parent.getColumnByUid(destElem.firstElementChild.getAttribute('e-mappinguid'));\n    var bool = col ? !col.lockColumn : true;\n    return (srcElem.parentElement.isEqualNode(destElem.parentElement) || this.parent.enableColumnVirtualization || this.parent.isFrozenGrid() && Array.prototype.indexOf.call(closest(srcElem, 'thead').children, srcElem.parentElement) === Array.prototype.indexOf.call(closest(destElem, 'thead').children, destElem.parentElement)) && this.targetParentContainerIndex(srcElem, destElem) > -1 && bool;\n  };\n\n  Reorder.prototype.chkDropAllCols = function (srcElem, destElem) {\n    var isFound;\n    var headers = this.getHeaderCells();\n    var header;\n\n    while (!isFound && headers.length > 0) {\n      header = headers.pop();\n      isFound = srcElem !== header && this.targetParentContainerIndex(srcElem, destElem) > -1;\n    }\n\n    return isFound;\n  };\n\n  Reorder.prototype.findColParent = function (col, cols, parent) {\n    // eslint-disable-next-line no-self-assign\n    parent = parent;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (col === cols[i]) {\n        return true;\n      } else if (cols[i].columns) {\n        var cnt = parent.length;\n        parent.push(cols[i]);\n\n        if (!this.findColParent(col, cols[i].columns, parent)) {\n          parent.splice(cnt, parent.length - cnt);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Reorder.prototype.getColumnsModel = function (cols) {\n    var columnModel = [];\n    var subCols = [];\n\n    if (!this.parent.getFrozenColumns() && this.parent.isFrozenGrid()) {\n      return this.parent.getColumns();\n    } else {\n      for (var i = 0, len = cols.length; i < len; i++) {\n        columnModel.push(cols[i]);\n\n        if (cols[i].columns) {\n          subCols = subCols.concat(cols[i].columns);\n        }\n      }\n\n      if (subCols.length) {\n        columnModel = columnModel.concat(this.getColumnsModel(subCols));\n      }\n    }\n\n    return columnModel;\n  };\n\n  Reorder.prototype.headerDrop = function (e) {\n    var gObj = this.parent;\n    var dropElement = this.element.querySelector('.e-headercelldiv') || this.element.querySelector('.e-stackedheadercelldiv');\n    var uId = dropElement.getAttribute('e-mappinguid');\n    var column = gObj.getColumnByUid(uId);\n\n    if (!closest(e.target, 'th') || !isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        column: column\n      });\n      return;\n    }\n\n    var destElem = closest(e.target, '.e-headercell');\n    var destElemDiv = destElem.querySelector('.e-headercelldiv') || destElem.querySelector('.e-stackedheadercelldiv');\n    var destElemUid = destElemDiv.getAttribute('e-mappinguid');\n\n    if (!isNullOrUndefined(destElemUid)) {\n      var destColumn = gObj.getColumnByUid(destElemUid);\n\n      if (isNullOrUndefined(destColumn) || !destColumn.allowReordering || destColumn.lockColumn) {\n        this.parent.log('action_disabled_column', {\n          moduleName: this.getModuleName(),\n          column: column,\n          destColumn: destColumn\n        });\n        return;\n      }\n    }\n\n    if (destElem && !(!this.chkDropPosition(this.element, destElem) || !this.chkDropAllCols(this.element, destElem))) {\n      if (this.parent.enableColumnVirtualization) {\n        var columns = this.parent.columns;\n        var sourceUid_1 = this.element.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n        var col = this.parent.columns.filter(function (col) {\n          return col.uid === sourceUid_1;\n        });\n        var colMatchIndex_1 = null;\n        var column_1 = col[0];\n        var destUid_1 = destElem.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n        columns.some(function (col, index) {\n          if (col.uid === destUid_1) {\n            colMatchIndex_1 = index;\n            return col.uid === destUid_1;\n          }\n\n          return false;\n        });\n\n        if (!isNullOrUndefined(colMatchIndex_1)) {\n          this.moveColumns(colMatchIndex_1, column_1);\n        }\n      } else {\n        var newIndex = this.targetParentContainerIndex(this.element, destElem);\n        var uid = this.element.firstElementChild.getAttribute('e-mappinguid');\n        this.destElement = destElem;\n        this.parent.notify(setReorderDestinationElement, {\n          ele: destElem\n        });\n\n        if (uid) {\n          this.moveColumns(newIndex, this.parent.getColumnByUid(uid));\n        } else {\n          var headers = this.getHeaderCells();\n          var oldIdx = getElementIndex(this.element, headers);\n          var columns = this.getColumnsModel(this.parent.columns);\n          this.moveColumns(newIndex, columns[oldIdx]);\n        }\n      }\n    }\n  };\n\n  Reorder.prototype.isActionPrevent = function (gObj) {\n    return isActionPrevent(gObj);\n  };\n\n  Reorder.prototype.moveColumns = function (destIndex, column, reorderByColumn, preventRefresh) {\n    var gObj = this.parent;\n\n    if (this.isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.moveColumns,\n        arg1: destIndex,\n        arg2: column\n      });\n      return;\n    }\n\n    var isFrozen = !gObj.getFrozenColumns() && gObj.isFrozenGrid();\n    var parent = this.getColParent(column, this.parent.columns);\n    var cols = parent ? parent.columns : isFrozen ? this.parent.getColumns() : this.parent.columns;\n    var srcIdx = inArray(column, cols);\n\n    if ((this.parent.isFrozenGrid() && parent || this.parent.lockcolPositionCount) && !reorderByColumn && !this.parent.enableColumnVirtualization) {\n      for (var i = 0; i < cols.length; i++) {\n        if (cols[i].field === column.field) {\n          srcIdx = i;\n          break;\n        }\n      }\n\n      var col = this.parent.getColumnByUid(this.destElement.firstElementChild.getAttribute('e-mappinguid'));\n\n      if (col) {\n        for (var i = 0; i < cols.length; i++) {\n          if (cols[i].field === col.field) {\n            destIndex = i;\n            break;\n          }\n        }\n      } else {\n        for (var i = 0; i < cols.length; i++) {\n          if (cols[i].headerText === this.destElement.innerText.trim()) {\n            destIndex = i;\n          }\n        }\n      }\n    }\n\n    if (!gObj.allowReordering || srcIdx === destIndex || srcIdx === -1 || destIndex === -1) {\n      return;\n    }\n\n    cols.splice(destIndex, 0, cols.splice(srcIdx, 1)[0]);\n    var args = {\n      column: column,\n      destIndex: destIndex,\n      columns: cols,\n      parent: parent,\n      cancel: false\n    };\n    gObj.notify(refreshFrozenColumns, args);\n\n    if (args.cancel) {\n      return;\n    }\n\n    gObj.getColumns(true);\n    gObj.notify(columnPositionChanged, {\n      fromIndex: destIndex,\n      toIndex: srcIdx\n    });\n\n    if (preventRefresh !== false) {\n      gObj.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'reorder',\n        fromIndex: destIndex,\n        toIndex: srcIdx,\n        toColumnUid: column.uid\n      });\n    }\n  };\n\n  Reorder.prototype.targetParentContainerIndex = function (srcElem, destElem) {\n    var cols = !this.parent.getFrozenColumns() && this.parent.isFrozenGrid() ? this.parent.getColumns() : this.parent.columns;\n    var headers = this.getHeaderCells();\n    var flatColumns = this.getColumnsModel(cols);\n    var parent = this.getColParent(flatColumns[getElementIndex(srcElem, headers)], cols);\n    cols = parent ? parent.columns : cols;\n    return inArray(flatColumns[getElementIndex(destElem, headers)], cols);\n  };\n\n  Reorder.prototype.getHeaderCells = function () {\n    var frozenColumns = this.parent.getFrozenColumns();\n\n    if (frozenColumns || this.parent.isFrozenGrid() || this.parent.lockcolPositionCount) {\n      var fTh = void 0;\n      var mTh = void 0;\n      var fHeaders = [];\n      var fRows = [].slice.call(this.parent.getHeaderTable().getElementsByClassName('e-columnheader'));\n\n      if (frozenColumns || this.parent.isFrozenGrid()) {\n        var mRows = [].slice.call(this.parent.getHeaderContent().querySelector('.' + movableHeader).getElementsByClassName('e-columnheader'));\n\n        for (var i = 0; i < fRows.length; i++) {\n          fTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));\n          mTh = [].slice.call(mRows[i].getElementsByClassName('e-headercell'));\n          var isAvail = void 0;\n\n          for (var k = 0; k < fTh.length; k++) {\n            for (var j = 0; j < mTh.length; j++) {\n              if (mTh[j].innerText === fTh[k].innerText && parseInt(mTh[j].getAttribute('data-colindex'), 10) === parseInt(fTh[k].getAttribute('data-colindex'), 10)) {\n                isAvail = true;\n                break;\n              }\n            }\n\n            if (!isAvail) {\n              fHeaders = fHeaders.concat([fTh[k]]);\n            }\n          }\n\n          for (var j = 0; j < mTh.length; j++) {\n            fHeaders.push(mTh[j]);\n          }\n        }\n\n        if (this.parent.getFrozenRightColumnsCount()) {\n          var frRows = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-right-header').getElementsByClassName('e-columnheader'));\n          var frTh = [].slice.call(frRows[0].getElementsByClassName('e-headercell'));\n\n          for (var i = 0; i < frTh.length; i++) {\n            fHeaders.push(frTh[i]);\n          }\n        }\n      } else {\n        for (var i = 0; i < fRows.length; i++) {\n          mTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));\n\n          for (var k = 0; k < mTh.length; k++) {\n            var isAvail = void 0;\n\n            for (var j = k + 1; j < mTh.length; j++) {\n              if (mTh[j].innerText === mTh[k].innerText && parseInt(mTh[j].getAttribute('data-colindex'), 10) === parseInt(mTh[k].getAttribute('data-colindex'), 10)) {\n                isAvail = true;\n                break;\n              }\n            }\n\n            if (!isAvail) {\n              fHeaders = fHeaders.concat([mTh[k]]);\n            }\n          }\n        }\n      }\n\n      return fHeaders;\n    } else {\n      return [].slice.call(this.parent.element.getElementsByClassName('e-headercell'));\n    }\n  };\n\n  Reorder.prototype.getColParent = function (column, columns) {\n    var parents$$1 = [];\n    this.findColParent(column, columns, parents$$1);\n    return parents$$1[parents$$1.length - 1];\n  };\n\n  Reorder.prototype.reorderSingleColumn = function (fromFName, toFName) {\n    var fColumn = this.parent.enableColumnVirtualization ? this.parent.columns.filter(function (col) {\n      return col.field === fromFName;\n    })[0] : this.parent.getColumnByField(fromFName);\n    var toColumn = this.parent.enableColumnVirtualization ? this.parent.columns.filter(function (col) {\n      return col.field === toFName;\n    })[0] : this.parent.getColumnByField(toFName);\n\n    if (!isNullOrUndefined(fColumn) && (!fColumn.allowReordering || fColumn.lockColumn) || !isNullOrUndefined(toColumn) && (!toColumn.allowReordering || fColumn.lockColumn)) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        column: fColumn,\n        destColumn: toColumn\n      });\n      return;\n    }\n\n    var column = toColumn;\n    var parent = this.getColParent(column, this.parent.columns);\n    var columns = parent ? parent.columns : this.parent.columns;\n    var destIndex = inArray(column, columns);\n\n    if (destIndex > -1) {\n      this.moveColumns(destIndex, fColumn, true);\n    }\n  };\n\n  Reorder.prototype.reorderMultipleColumns = function (fromFNames, toFName) {\n    var toIndex = this.parent.getColumnIndexByField(toFName);\n    var toColumn = this.parent.getColumnByField(toFName);\n\n    if (toIndex < 0 || !isNullOrUndefined(toColumn) && (!toColumn.allowReordering || toColumn.lockColumn)) {\n      return;\n    }\n\n    for (var i = 0; i < fromFNames.length; i++) {\n      var column = this.parent.getColumnByField(fromFNames[i]);\n\n      if (!isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < fromFNames.length; i++) {\n      var column = this.parent.getColumnByIndex(toIndex);\n      var parent_1 = this.getColParent(column, this.parent.columns);\n      var columns = parent_1 ? parent_1.columns : this.parent.columns;\n      var destIndex = inArray(column, columns);\n\n      if (destIndex > -1) {\n        this.moveColumns(destIndex, this.parent.getColumnByField(fromFNames[i]), true, true);\n      }\n\n      if (this.parent.getColumnIndexByField(fromFNames[i + 1]) >= destIndex) {\n        toIndex++; //R to L\n      }\n    }\n  };\n\n  Reorder.prototype.moveTargetColumn = function (column, toIndex) {\n    if (toIndex > -1) {\n      this.moveColumns(toIndex, column, true);\n    }\n  };\n\n  Reorder.prototype.reorderSingleColumnByTarget = function (fieldName, toIndex) {\n    this.moveTargetColumn(this.parent.getColumnByField(fieldName), toIndex);\n  };\n\n  Reorder.prototype.reorderMultipleColumnByTarget = function (fieldName, toIndex) {\n    for (var i = 0; i < fieldName.length; i++) {\n      this.reorderSingleColumnByTarget(fieldName[i], toIndex);\n    }\n  };\n  /**\n   * Changes the position of the Grid columns by field names.\n   *\n   * @param  {string | string[]} fromFName - Defines the origin field names.\n   * @param  {string} toFName - Defines the destination field name.\n   * @returns {void}\n   */\n\n\n  Reorder.prototype.reorderColumns = function (fromFName, toFName) {\n    if (typeof fromFName === 'string') {\n      this.reorderSingleColumn(fromFName, toFName);\n      this.fromCol = fromFName;\n    } else {\n      this.reorderMultipleColumns(fromFName, toFName);\n      this.fromCol = fromFName[0];\n    }\n  };\n  /**\n   * Changes the position of the Grid columns by field index.\n   *\n   * @param  {number} fromIndex - Defines the origin field index.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  Reorder.prototype.reorderColumnByIndex = function (fromIndex, toIndex) {\n    this.moveTargetColumn(this.parent.getColumnByIndex(fromIndex), toIndex);\n  };\n  /**\n   * Changes the position of the Grid columns by field index.\n   *\n   * @param  {string | string[]} fieldName - Defines the field name.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @returns {void}\n   */\n\n\n  Reorder.prototype.reorderColumnByTargetIndex = function (fieldName, toIndex) {\n    if (typeof fieldName === 'string') {\n      this.reorderSingleColumnByTarget(fieldName, toIndex);\n    } else {\n      this.reorderMultipleColumnByTarget(fieldName, toIndex);\n    }\n  };\n\n  Reorder.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.createReorderElement();\n    }\n  };\n\n  Reorder.prototype.createReorderElement = function (e) {\n    if (e && e.args.isXaxis) {\n      this.setDisplay('none');\n    }\n\n    var header = this.parent.element.querySelector('.' + headerContent);\n    this.upArrow = header.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-icon-reorderuparrow e-reorderuparrow',\n      attrs: {\n        style: 'display:none'\n      }\n    }));\n    this.downArrow = header.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-icon-reorderdownarrow e-reorderdownarrow',\n      attrs: {\n        style: 'display:none'\n      }\n    }));\n  };\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specified the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Reorder.prototype.onActionComplete = function (e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      type: actionComplete\n    }));\n    var target = this.fromCol && this.parent.getColumnHeaderByField(this.fromCol);\n\n    if (target) {\n      this.parent.focusModule.onClick({\n        target: target\n      }, true);\n    }\n  };\n  /**\n   * To destroy the reorder\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Reorder.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    if (this.upArrow.parentNode) {\n      remove(this.upArrow);\n    }\n\n    if (this.downArrow.parentNode) {\n      remove(this.downArrow);\n    }\n\n    this.parent.off(headerDrop, this.headerDrop);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(reorderComplete, this.onActionComplete);\n    this.parent.off(columnDrag, this.drag);\n    this.parent.off(columnDragStart, this.dragStart);\n    this.parent.off(columnDragStop, this.dragStop);\n    this.parent.off(headerRefreshed, this.createReorderElement);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(destroy, this.destroy); //call ejdrag and drop destroy\n  };\n\n  Reorder.prototype.keyPressHandler = function (e) {\n    var gObj = this.parent;\n\n    switch (e.action) {\n      case 'ctrlLeftArrow':\n      case 'ctrlRightArrow':\n        // eslint-disable-next-line no-case-declarations\n        var element = gObj.focusModule.currentInfo.element;\n\n        if (element && element.classList.contains('e-headercell')) {\n          var column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n          var visibleCols = gObj.getVisibleColumns();\n          var index = visibleCols.indexOf(column);\n          var toCol = e.action === 'ctrlLeftArrow' ? visibleCols[index - 1] : visibleCols[index + 1];\n\n          if (toCol && toCol.field && column.field) {\n            this.reorderColumns(column.field, toCol.field);\n          }\n        }\n\n        break;\n    }\n  };\n\n  Reorder.prototype.drag = function (e) {\n    var gObj = this.parent;\n    var target = e.target;\n\n    if (!e.column.allowReordering || e.column.lockColumn) {\n      return;\n    }\n\n    var closest$$1 = closest(target, '.e-headercell:not(.e-stackedHeaderCell)');\n    var cloneElement = gObj.element.querySelector('.e-cloneproperties');\n    var content$$1 = gObj.isFrozenGrid() ? gObj.getMovableVirtualContent() : gObj.getContent().firstElementChild;\n    var isLeft = this.x > getPosition(e.event).x + content$$1.scrollLeft;\n    removeClass([].slice.call(gObj.getHeaderTable().getElementsByClassName('e-reorderindicate')), ['e-reorderindicate']);\n    this.setDisplay('none');\n    this.stopTimer();\n    classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n    this.updateScrollPostion(e.event);\n\n    if (closest$$1 && !closest$$1.isEqualNode(this.element)) {\n      target = closest$$1; //consider stacked, detail header cell\n\n      if (!(!this.chkDropPosition(this.element, target) || !this.chkDropAllCols(this.element, target))) {\n        this.updateArrowPosition(target, isLeft);\n        classList(target, ['e-allowDrop', 'e-reorderindicate'], []);\n      } else if (!(gObj.allowGrouping && parentsUntil(e.target, 'e-groupdroparea'))) {\n        classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n      }\n    }\n\n    gObj.trigger(columnDrag, {\n      target: target,\n      draggableType: 'headercell',\n      column: e.column\n    });\n  };\n\n  Reorder.prototype.updateScrollPostion = function (e) {\n    var _this = this;\n\n    var x = getPosition(e).x;\n    var cliRect = this.parent.element.getBoundingClientRect();\n    var cliRectBaseRight = cliRect.right;\n\n    if (this.parent.isFrozenGrid()) {\n      this.updateFrozenScrollPosition(x, cliRect);\n    } else {\n      var cliRectBaseLeft = cliRect.left;\n      var scrollElem_1 = this.parent.getContent().firstElementChild;\n\n      if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {\n        this.timer = window.setInterval(function () {\n          _this.setScrollLeft(scrollElem_1, true);\n        }, 50);\n      } else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {\n        this.timer = window.setInterval(function () {\n          _this.setScrollLeft(scrollElem_1, false);\n        }, 50);\n      }\n    }\n  };\n\n  Reorder.prototype.updateFrozenScrollPosition = function (x, cliRect) {\n    var _this = this;\n\n    var scrollElem = this.parent.getContent().querySelector('.' + movableContent);\n    var mhdrCliRect = this.parent.element.querySelector('.' + movableHeader).getBoundingClientRect();\n    var left = this.parent.getFrozenLeftCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n    var cliRectBaseRight = right ? mhdrCliRect.right : cliRect.right;\n    var cliRectBaseLeft = left ? mhdrCliRect.left : cliRect.left;\n\n    if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {\n      this.timer = window.setInterval(function () {\n        _this.setScrollLeft(scrollElem, true);\n      }, 50);\n    } else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {\n      this.timer = window.setInterval(function () {\n        _this.setScrollLeft(scrollElem, false);\n      }, 50);\n    }\n  };\n\n  Reorder.prototype.setScrollLeft = function (scrollElem, isLeft) {\n    var scrollLeft = scrollElem.scrollLeft;\n    scrollElem.scrollLeft = scrollElem.scrollLeft + (isLeft ? -5 : 5);\n\n    if (scrollLeft !== scrollElem.scrollLeft) {\n      this.setDisplay('none');\n    }\n  };\n\n  Reorder.prototype.stopTimer = function () {\n    window.clearInterval(this.timer);\n  };\n\n  Reorder.prototype.updateArrowPosition = function (target, isLeft) {\n    var cliRect = target.getBoundingClientRect();\n    var cliRectBase = this.parent.element.getBoundingClientRect();\n\n    if (isLeft && cliRect.left < cliRectBase.left || !isLeft && cliRect.right > cliRectBase.right) {\n      return;\n    }\n\n    if (this.parent.isFrozenGrid() && target.classList.contains('e-headercell')) {\n      var left = this.parent.getFrozenLeftCount();\n      var right = this.parent.getFrozenRightColumnsCount();\n      var dropEle = this.element.querySelector('.e-headercelldiv');\n      var dropCol = dropEle ? this.parent.getColumnByUid(dropEle.getAttribute('data-uid')) : null;\n      var col = this.parent.getColumnByUid(target.firstElementChild.getAttribute('e-mappinguid'));\n      var fhdrWidth = Math.round(this.parent.getFrozenVirtualHeader().getBoundingClientRect().right);\n      var mhdrRight = Math.round(this.parent.getMovableVirtualHeader().getBoundingClientRect().right);\n\n      if (col) {\n        if (left && !right && this.parent.getNormalizedColumnIndex(col.uid) >= left && (isLeft && Math.round(cliRect.left) < fhdrWidth || !isLeft && mhdrRight < cliRect.right)) {\n          return;\n        }\n\n        if (!left && right && dropCol && dropCol.getFreezeTableName() !== col.getFreezeTableName() && !isLeft && Math.round(cliRect.right) < fhdrWidth) {\n          return;\n        }\n      }\n    }\n\n    var isSticky = this.parent.getHeaderContent().classList.contains('e-sticky');\n    this.upArrow.style.top = isSticky ? cliRect.top + cliRect.height + 'px' : cliRect.top + cliRect.height - cliRectBase.top + 'px';\n    this.downArrow.style.top = isSticky ? cliRect.top - 7 + 'px' : cliRect.top - cliRectBase.top - 7 + 'px';\n    this.upArrow.style.left = this.downArrow.style.left = isSticky ? (isLeft ? cliRect.left : cliRect.right) - 4 + 'px' : (isLeft ? cliRect.left : cliRect.right) - cliRectBase.left - 4 + 'px';\n    this.setDisplay('');\n  };\n\n  Reorder.prototype.dragStart = function (e) {\n    var gObj = this.parent;\n    var target = e.target;\n    this.element = target.classList.contains('e-headercell') ? target : parentsUntil(target, 'e-headercell');\n\n    if (!e.column.allowReordering || e.column.lockColumn) {\n      return;\n    }\n\n    var content$$1 = gObj.isFrozenGrid() ? gObj.getMovableVirtualContent() : gObj.getContent().firstElementChild;\n    this.x = getPosition(e.event).x + content$$1.scrollLeft;\n    gObj.trigger(columnDragStart, {\n      target: target,\n      draggableType: 'headercell',\n      column: e.column\n    });\n  };\n\n  Reorder.prototype.dragStop = function (e) {\n    var gObj = this.parent;\n    this.setDisplay('none');\n    this.stopTimer();\n\n    if (!e.cancel) {\n      gObj.trigger(columnDrop, {\n        target: e.target,\n        draggableType: 'headercell',\n        column: e.column\n      });\n    }\n\n    removeClass([].slice.call(gObj.getHeaderTable().getElementsByClassName('e-reorderindicate')), ['e-reorderindicate']);\n  };\n\n  Reorder.prototype.setDisplay = function (display) {\n    this.upArrow.style.display = display;\n    this.downArrow.style.display = display;\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} return the module name\n   * @private\n   */\n\n\n  Reorder.prototype.getModuleName = function () {\n    return 'reorder';\n  };\n\n  return Reorder;\n}(); // eslint-disable-next-line valid-jsdoc\n\n/**\n *\n * Reorder module is used to handle row reordering.\n *\n * @hidden\n */\n\n\nvar RowDD =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid print module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function RowDD(parent) {\n    var _this = this;\n\n    this.selectedRows = [];\n    this.isOverflowBorder = true;\n    this.selectedRowColls = [];\n    this.isRefresh = true;\n    this.isReplaceDragEle = true;\n    this.istargetGrid = false; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this.helper = function (e) {\n      var gObj = _this.parent;\n      var target = _this.draggable.currentStateTarget;\n\n      var visualElement = _this.parent.createElement('div', {\n        className: 'e-cloneproperties e-draganddrop e-grid e-dragclone',\n        styles: 'height:\"auto\", z-index:2, width:' + gObj.element.offsetWidth\n      });\n\n      var table$$1 = _this.parent.createElement('table', {\n        styles: 'width:' + gObj.element.offsetWidth,\n        attrs: {\n          role: 'grid'\n        }\n      });\n\n      var tbody$$1 = _this.parent.createElement(tbody, {\n        attrs: {\n          role: 'rowgroup'\n        }\n      });\n\n      if (document.getElementsByClassName('e-griddragarea').length || gObj.rowDropSettings.targetID && (!target.classList.contains('e-selectionbackground') && gObj.selectionSettings.type !== 'Single' || !parentsUntil(target, 'e-rowcell')) || !gObj.rowDropSettings.targetID && !parentsUntil(target, 'e-rowdragdrop')) {\n        return false;\n      }\n\n      if (gObj.rowDropSettings.targetID && gObj.selectionSettings.mode === 'Row' && gObj.selectionSettings.type === 'Single') {\n        gObj.selectRow(parseInt(_this.draggable.currentStateTarget.parentElement.getAttribute(dataRowIndex), 10));\n      }\n\n      _this.startedRow = closest(target, 'tr').cloneNode(true);\n\n      var frzCols = _this.parent.isFrozenGrid();\n\n      if (frzCols) {\n        var rowIndex = parseInt(closest(target, 'tr').getAttribute(dataRowIndex), 10);\n        _this.startedRow.innerHTML = '';\n        _this.startedRow.innerHTML += gObj.getRowByIndex(rowIndex).innerHTML;\n        _this.startedRow.innerHTML += gObj.getMovableRowByIndex(rowIndex).innerHTML;\n\n        if (gObj.getFrozenMode() === leftRight) {\n          _this.startedRow.innerHTML += gObj.getFrozenRightRowByIndex(rowIndex).innerHTML;\n        }\n      }\n\n      _this.processArgs(target);\n\n      var args = {\n        selectedRow: _this.rows,\n        dragelement: target,\n        cloneElement: visualElement,\n        cancel: false,\n        data: _this.rowData\n      };\n      var selectedRows = gObj.getSelectedRows();\n      gObj.trigger(rowDragStartHelper, args);\n      var cancel = 'cancel';\n\n      if (args[cancel]) {\n        return false;\n      }\n\n      removeElement(_this.startedRow, '.e-indentcell');\n      removeElement(_this.startedRow, '.e-detailrowcollapse');\n      removeElement(_this.startedRow, '.e-detailrowexpand');\n\n      _this.removeCell(_this.startedRow, gridChkBox);\n\n      var exp = new RegExp('e-active', 'g'); //high contrast issue\n\n      _this.startedRow.innerHTML = _this.startedRow.innerHTML.replace(exp, '');\n      tbody$$1.appendChild(_this.startedRow);\n\n      if (gObj.getSelectedRowIndexes().length > 1 && _this.startedRow.hasAttribute('aria-selected')) {\n        var index = gObj.getFrozenMode() === leftRight ? 3 : 2;\n\n        var dropCountEle = _this.parent.createElement('span', {\n          className: 'e-dropitemscount',\n          innerHTML: frzCols ? '' + selectedRows.length / index : '' + selectedRows.length\n        });\n\n        visualElement.appendChild(dropCountEle);\n      }\n\n      var ele = closest(target, 'tr').querySelector('.e-icon-rowdragicon');\n\n      if (ele) {\n        ele.classList.add('e-dragstartrow');\n      }\n\n      table$$1.appendChild(tbody$$1);\n      visualElement.appendChild(table$$1);\n      gObj.element.appendChild(visualElement);\n      return visualElement;\n    };\n\n    this.dragStart = function (e) {\n      var gObj = _this.parent;\n      document.body.classList.add('e-prevent-select');\n\n      if (document.getElementsByClassName('e-griddragarea').length) {\n        return;\n      }\n\n      var target = e.target;\n\n      var spanCssEle = _this.parent.element.querySelector('.e-dropitemscount');\n\n      if (_this.parent.getSelectedRecords().length > 1 && spanCssEle) {\n        spanCssEle.style.left = _this.parent.element.querySelector('.e-cloneproperties table').offsetWidth - 5 + 'px';\n      }\n\n      _this.processArgs(target);\n\n      gObj.trigger(rowDragStart, {\n        rows: _this.rows,\n        target: e.target,\n        draggableType: 'rows',\n        fromIndex: parseInt(_this.rows[0].getAttribute(dataRowIndex), 10),\n        data: Object.keys(_this.rowData[0]).length > 0 ? _this.rowData : _this.currentViewData()\n      });\n      _this.dragStartData = _this.rowData;\n      var dropElem = document.getElementById(gObj.rowDropSettings.targetID);\n\n      if (gObj.rowDropSettings.targetID && dropElem && dropElem.ej2_instances && dropElem.ej2_instances[0].getModuleName() === 'grid') {\n        dropElem.ej2_instances[0].getContent().classList.add('e-allowRowDrop');\n      }\n    };\n\n    this.drag = function (e) {\n      var gObj = _this.parent;\n      _this.isDropGrid = _this.parent;\n      _this.istargetGrid = false;\n\n      if (_this.parent.rowDropSettings.targetID) {\n        var dropElement = document.getElementById(gObj.rowDropSettings.targetID);\n        _this.isDropGrid = dropElement.ej2_instances[0];\n\n        if (parentsUntil(e.target, 'e-grid')) {\n          _this.istargetGrid = _this.parent.rowDropSettings.targetID === parentsUntil(e.target, 'e-grid').id;\n        }\n      }\n\n      var cloneElement = _this.parent.element.querySelector('.e-cloneproperties');\n\n      var target = _this.getElementFromPosition(cloneElement, e.event);\n\n      classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur', 'e-movecur', 'e-grabcur']);\n      _this.isOverflowBorder = true;\n      _this.hoverState = gObj.enableHover;\n      var trElement = parentsUntil(target, 'e-grid') ? closest(e.target, 'tr') : null;\n\n      if (!e.target) {\n        return;\n      }\n\n      _this.processArgs(target);\n\n      var args = {\n        rows: _this.rows,\n        target: target,\n        draggableType: 'rows',\n        data: _this.rowData,\n        originalEvent: e,\n        cancel: false\n      };\n      gObj.trigger(rowDrag, args);\n\n      _this.stopTimer();\n\n      if (args.cancel) {\n        return;\n      }\n\n      gObj.element.classList.add('e-rowdrag');\n      _this.dragTarget = trElement && (parentsUntil(target, 'e-grid').id === cloneElement.parentElement.id || parentsUntil(target, 'e-grid').id) ? _this.isDropGrid.element.querySelector('.e-emptyrow') ? 0 : parseInt(trElement.getAttribute('data-rowindex'), 10) : parseInt(_this.startedRow.getAttribute('data-rowindex'), 10);\n\n      if (gObj.rowDropSettings.targetID) {\n        if (!parentsUntil(target, 'e-grid') || parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(target, 'e-grid').id) {\n          classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n        } else {\n          classList(cloneElement, ['e-grabcur'], ['e-notallowedcur']);\n        }\n      } else {\n        var elem = parentsUntil(target, 'e-grid');\n\n        if (elem && elem.id === cloneElement.parentElement.id) {\n          classList(cloneElement, ['e-movecur'], ['e-defaultcur']);\n        } else {\n          classList(cloneElement, ['e-notallowedcur'], ['e-movecur']);\n        }\n      }\n\n      if (parentsUntil(_this.isDropGrid.element, 'e-grid')) {\n        if ((!_this.isDropGrid.groupSettings.columns.length || e.target.classList.contains('e-selectionbackground')) && !_this.isDropGrid.element.querySelector('.e-emptyrow')) {\n          if (parentsUntil(target, 'e-grid') && parentsUntil(target, 'e-grid').id === _this.isDropGrid.element.id) {\n            _this.updateScrollPostion(e.event);\n          }\n\n          if ((_this.isOverflowBorder || _this.parent.frozenRows > _this.dragTarget) && (parseInt(_this.startedRow.getAttribute(dataRowIndex), 10) !== _this.dragTarget || _this.istargetGrid) || _this.istargetGrid && trElement && _this.isDropGrid.getRowByIndex(_this.isDropGrid.getCurrentViewRecords().length - 1).getAttribute('data-uid') === trElement.getAttribute('data-uid')) {\n            _this.moveDragRows(e, _this.startedRow, trElement);\n          } else {\n            var islastRowIndex = void 0;\n\n            if (_this.parent.enableVirtualization) {\n              islastRowIndex = trElement && parseInt(trElement.getAttribute(dataRowIndex), 10) === _this.parent.renderModule.data.dataManager.dataSource.json.length - 1;\n            } else {\n              var lastRowUid = _this.parent.getRowByIndex(_this.parent.getCurrentViewRecords().length - 1).getAttribute('data-uid');\n\n              islastRowIndex = trElement && lastRowUid === trElement.getAttribute('data-uid') && lastRowUid !== _this.startedRow.getAttribute('data-uid');\n            }\n\n            if (islastRowIndex && !_this.parent.rowDropSettings.targetID) {\n              var bottomborder = _this.parent.createElement('div', {\n                className: 'e-lastrow-dragborder'\n              });\n\n              var gridcontentEle = _this.parent.getContent();\n\n              bottomborder.style.width = _this.parent.element.offsetWidth - _this.getScrollWidth() + 'px';\n\n              if (_this.parent.enableVirtualization) {\n                bottomborder.style.zIndex = '1';\n              }\n\n              if (!gridcontentEle.getElementsByClassName('e-lastrow-dragborder').length) {\n                gridcontentEle.classList.add('e-grid-relative');\n                gridcontentEle.appendChild(bottomborder);\n                bottomborder.style.bottom = _this.getScrollWidth() + 'px';\n              }\n            }\n\n            _this.removeBorder(trElement);\n          }\n        }\n\n        if (target && target.classList.contains(content) && !_this.isDropGrid.element.querySelector('.e-emptyrow') && _this.istargetGrid) {\n          _this.removeBorder(trElement);\n\n          var rowIndex = _this.isDropGrid.getCurrentViewRecords().length - 1;\n          var selector = '.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse';\n          var rowElement = [];\n          rowElement = [].slice.call(_this.isDropGrid.getRowByIndex(rowIndex).querySelectorAll(selector));\n\n          if (_this.isDropGrid.isFrozenGrid()) {\n            rowElement = _this.borderRowElement(rowIndex, selector);\n          }\n\n          if (rowElement.length > 0) {\n            addRemoveActiveClasses(rowElement, true, 'e-dragborder');\n          }\n        }\n      }\n    };\n\n    this.dragStop = function (e) {\n      document.body.classList.remove('e-prevent-select');\n\n      if (isActionPrevent(_this.parent)) {\n        _this.parent.notify(preventBatch, {\n          instance: _this,\n          handler: _this.processDragStop,\n          arg1: e\n        });\n      } else {\n        _this.processDragStop(e);\n      }\n    };\n\n    this.processDragStop = function (e) {\n      var gObj = _this.parent;\n\n      if (_this.parent.isDestroyed) {\n        return;\n      }\n\n      var targetEle = _this.getElementFromPosition(e.helper, e.event);\n\n      var target = targetEle && !targetEle.classList.contains('e-dlg-overlay') ? targetEle : e.target;\n      gObj.element.classList.remove('e-rowdrag');\n      var dropElement = document.getElementById(gObj.rowDropSettings.targetID);\n\n      if (gObj.rowDropSettings.targetID && dropElement && dropElement.ej2_instances && dropElement.ej2_instances[0].getModuleName() === 'grid') {\n        dropElement.ej2_instances[0].getContent().classList.remove('e-allowRowDrop');\n      }\n\n      if (parentsUntil(_this.isDropGrid.element, 'e-grid')) {\n        _this.stopTimer();\n\n        _this.isDropGrid.enableHover = _this.hoverState;\n\n        _this.isDropGrid.getContent().classList.remove('e-grid-relative');\n\n        _this.removeBorder(targetEle);\n\n        var stRow = _this.isDropGrid.element.querySelector('.e-dragstartrow');\n\n        if (stRow) {\n          stRow.classList.remove('e-dragstartrow');\n        }\n      }\n\n      _this.processArgs(target);\n\n      var args = {\n        target: target,\n        draggableType: 'rows',\n        cancel: false,\n        fromIndex: parseInt(_this.rows[0].getAttribute(dataRowIndex), 10),\n        dropIndex: _this.dragTarget,\n        rows: _this.rows,\n        data: Object.keys(_this.dragStartData[0]).length > 0 ? _this.dragStartData : _this.currentViewData()\n      };\n      gObj.trigger(rowDrop, args, function () {\n        if (!(parentsUntil(target, row) || parentsUntil(target, 'e-emptyrow') || parentsUntil(target, gridContent)) || args.cancel) {\n          _this.dragTarget = null;\n          remove(e.helper);\n          return;\n        }\n\n        _this.isRefresh = false;\n\n        var selectedIndexes = _this.parent.getSelectedRowIndexes();\n\n        if (gObj.isRowDragable()) {\n          if (!_this.parent.rowDropSettings.targetID && _this.startedRow.querySelector('td.e-selectionbackground') && selectedIndexes.length > 1 && selectedIndexes.length !== _this.parent.getCurrentViewRecords().length) {\n            _this.reorderRows(selectedIndexes, args.dropIndex);\n          } else {\n            _this.reorderRows([parseInt(_this.startedRow.getAttribute(dataRowIndex), 10)], _this.dragTarget);\n          }\n\n          _this.dragTarget = null;\n\n          if (!gObj.rowDropSettings.targetID) {\n            if (e.helper.classList.contains('e-cloneproperties') && document.querySelector('.' + e.helper.classList[0])) {\n              remove(e.helper);\n            }\n\n            if (gObj.enableVirtualization) {\n              gObj.refresh();\n            } else {\n              _this.rowOrder(args);\n            }\n          }\n        }\n\n        _this.isRefresh = true;\n      });\n    };\n\n    this.removeCell = function (targetRow, className) {\n      return [].slice.call(targetRow.querySelectorAll('td')).filter(function (cell) {\n        if (cell.classList.contains(className)) {\n          targetRow.deleteCell(cell.cellIndex);\n        }\n      });\n    };\n\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialEnd, this.initializeDrag, this);\n    this.parent.on(columnDrop, this.columnDrop, this);\n    this.parent.on(rowDragAndDropComplete, this.onActionComplete, this);\n    this.onDataBoundFn = this.onDataBound.bind(this);\n    this.parent.addEventListener(dataBound, this.onDataBoundFn);\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  RowDD.prototype.refreshRow = function (args, tbody$$1, mtbody, frTbody, target, mTarget, frTarget) {\n    var gObj = this.parent;\n    var frzCols = gObj.isFrozenGrid();\n    var isLeftRight = gObj.getFrozenMode() === leftRight;\n    var tbodyMovableHeader;\n    var tbodyMovableContent;\n    var frHdr;\n    var frCnt;\n    var tbodyContent = gObj.getContentTable().querySelector(tbody);\n    var tbodyHeader = gObj.getHeaderTable().querySelector(tbody);\n\n    if (frzCols) {\n      tbodyMovableHeader = gObj.getMovableHeaderTbody();\n      tbodyMovableContent = gObj.getMovableContentTbody();\n\n      if (isLeftRight) {\n        frHdr = gObj.getFrozenRightHeaderTbody();\n        frCnt = gObj.getFrozenRightContentTbody();\n      }\n    }\n\n    var index = gObj.getFrozenMode() === leftRight ? 3 : 2;\n\n    for (var i = 0, len = args.rows.length; i < len; i++) {\n      if (frzCols) {\n        if (i % index === 0) {\n          tbody$$1.insertBefore(args.rows[i], target);\n        } else if (i % index === 1) {\n          mtbody.insertBefore(args.rows[i], mTarget);\n        } else {\n          frTbody.insertBefore(args.rows[i], frTarget);\n        }\n      } else {\n        tbody$$1.insertBefore(args.rows[i], target);\n      }\n    }\n\n    var tr = [].slice.call(tbody$$1.getElementsByClassName(row));\n    var mtr;\n    var frTr;\n\n    if (frzCols) {\n      mtr = [].slice.call(mtbody.getElementsByClassName(row));\n\n      if (isLeftRight) {\n        frTr = [].slice.call(frTbody.getElementsByClassName(row));\n      }\n    }\n\n    this.refreshData(tr, mtr, frTr);\n\n    if (this.parent.frozenRows) {\n      var _loop_1 = function (i, len) {\n        if (i < this_1.parent.frozenRows) {\n          setRowsInTbody(tbodyHeader, tbodyMovableHeader, frHdr, tr, mtr, frTr, function (tbody$$1, rows) {\n            tbody$$1.appendChild(rows[i]);\n          });\n        } else {\n          setRowsInTbody(tbodyContent, tbodyMovableContent, frCnt, tr, mtr, frTr, function (tbody$$1, rows) {\n            tbody$$1.appendChild(rows[i]);\n          });\n        }\n      };\n\n      var this_1 = this;\n\n      for (var i = 0, len = tr.length; i < len; i++) {\n        _loop_1(i, len);\n      }\n    }\n  };\n\n  RowDD.prototype.updateFrozenRowreOrder = function (args) {\n    var gObj = this.parent;\n    var tbodyMovH;\n    var tbodyMovC;\n    var tbodyFrH;\n    var tbodyFrC;\n    var frzCols = this.parent.isFrozenGrid();\n    var isLeftRight = gObj.getFrozenMode() === leftRight;\n    var tbodyC = gObj.getContentTable().querySelector(tbody);\n    var tbodyH = gObj.getHeaderTable().querySelector(tbody);\n\n    if (frzCols) {\n      tbodyMovH = gObj.getMovableHeaderTbody();\n      tbodyMovC = gObj.getMovableContentTbody();\n\n      if (isLeftRight) {\n        tbodyFrH = gObj.getFrozenRightHeaderTbody();\n        tbodyFrC = gObj.getFrozenRightContentTbody();\n      }\n    }\n\n    var tr = [].slice.call(tbodyH.getElementsByClassName(row)).concat([].slice.call(tbodyC.getElementsByClassName(row)));\n    var mtr;\n    var frTr;\n\n    if (frzCols) {\n      mtr = [].slice.call(tbodyMovH.getElementsByClassName(row)).concat([].slice.call(tbodyMovC.getElementsByClassName(row)));\n\n      if (isLeftRight) {\n        frTr = [].slice.call(tbodyFrH.getElementsByClassName(row)).concat([].slice.call(tbodyFrC.getElementsByClassName(row)));\n      }\n    }\n\n    var tbody$$1 = gObj.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    var mtbody = gObj.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    var frTbody = gObj.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    this.parent.clearSelection();\n    var targetRows = this.refreshRowTarget(args);\n\n    for (var i = 0, len = tr.length; i < len; i++) {\n      tbody$$1.appendChild(tr[i]);\n\n      if (frzCols) {\n        mtbody.appendChild(mtr[i]);\n\n        if (isLeftRight) {\n          frTbody.appendChild(frTr[i]);\n        }\n      }\n    }\n\n    this.refreshRow(args, tbody$$1, mtbody, frTbody, targetRows.target, targetRows.mTarget, targetRows.frTarget);\n  };\n\n  RowDD.prototype.refreshRowTarget = function (args) {\n    var gObj = this.parent;\n    var mTr;\n    var frTr;\n    var targetIdx = parseInt(args.target.parentElement.getAttribute(dataRowIndex), 10);\n\n    if (args.fromIndex < args.dropIndex || args.fromIndex === args.dropIndex) {\n      targetIdx = targetIdx + 1;\n    }\n\n    var tr = gObj.getRowByIndex(targetIdx);\n\n    if (gObj.isFrozenGrid()) {\n      mTr = gObj.getMovableRowByIndex(targetIdx);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frTr = gObj.getFrozenRightRowByIndex(targetIdx);\n      }\n    }\n\n    var rows = {\n      target: tr,\n      mTarget: mTr,\n      frTarget: frTr\n    };\n    return rows;\n  };\n\n  RowDD.prototype.updateFrozenColumnreOrder = function (args) {\n    var gObj = this.parent;\n    var mtbody;\n    var frTbody;\n    var frzCols = this.parent.isFrozenGrid();\n    var tbody$$1 = gObj.getContentTable().querySelector(tbody);\n\n    if (frzCols) {\n      mtbody = gObj.getMovableContentTbody();\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frTbody = gObj.getFrozenRightContentTbody();\n      }\n    }\n\n    this.parent.clearSelection();\n    var targetRows = this.refreshRowTarget(args);\n    this.refreshRow(args, tbody$$1, mtbody, frTbody, targetRows.target, targetRows.mTarget, targetRows.frTarget);\n  };\n\n  RowDD.prototype.refreshData = function (tr, mtr, frTr) {\n    var rowObj = {};\n    var movobj = {};\n    var frObj = {};\n    var recordobj = {};\n    var rowObjects = this.parent.getRowsObject();\n    var movbObject = this.parent.getMovableRowsObject();\n    var frRightObject = this.parent.getFrozenRightRowsObject();\n    var currentViewData = this.parent.getCurrentViewRecords();\n\n    for (var i = 0, len = tr.length; i < len; i++) {\n      var index = parseInt(tr[i].getAttribute(dataRowIndex), 10);\n      rowObj[i] = rowObjects[index];\n      recordobj[i] = currentViewData[index];\n\n      if (this.parent.isFrozenGrid()) {\n        movobj[i] = movbObject[index];\n\n        if (frTr) {\n          frObj[i] = frRightObject[index];\n        }\n      }\n    }\n\n    var rows = this.parent.getRows();\n    var movbRows;\n    var frRightRows;\n\n    if (this.parent.isFrozenGrid()) {\n      movbRows = this.parent.getMovableRows();\n\n      if (frTr) {\n        frRightRows = this.parent.getFrozenRightRows();\n      }\n    }\n\n    for (var i = 0, len = tr.length; i < len; i++) {\n      rows[i] = tr[i];\n      rowObjects[i] = rowObj[i];\n      currentViewData[i] = recordobj[i];\n\n      if (this.parent.isFrozenGrid()) {\n        movbRows[i] = mtr[i];\n        movbObject[i] = movobj[i];\n\n        if (frTr) {\n          frRightRows[i] = frTr[i];\n          frRightObject[i] = frObj[i];\n        }\n      }\n    }\n\n    resetRowIndex(this.parent, rowObjects, tr);\n\n    if (this.parent.isFrozenGrid()) {\n      resetRowIndex(this.parent, movbObject, mtr);\n\n      if (frTr) {\n        resetRowIndex(this.parent, frRightObject, frTr);\n      }\n    }\n  };\n\n  RowDD.prototype.rowOrder = function (args) {\n    if (args.dropIndex === args.fromIndex || isNaN(args.dropIndex)) {\n      return;\n    }\n\n    if (this.parent.isDetail()) {\n      this.parent.detailCollapseAll();\n      var rows = [].slice.call(this.parent.getContentTable().querySelector(tbody).children);\n      var rowObjects = this.parent.getRowsObject();\n      rows.filter(function (row$$1) {\n        if (row$$1.classList.contains('e-detailrow')) {\n          row$$1.remove();\n        }\n      });\n\n      for (var i = 0, len = rowObjects.length; i < len; i++) {\n        if (!rowObjects[i]) {\n          break;\n        }\n\n        if (rowObjects[i].isDetailRow) {\n          this.parent.getRowsObject().splice(i, 1);\n          i--;\n        }\n      }\n    }\n\n    if (args.target.classList.contains('e-rowcelldrag') || args.target.classList.contains('e-dtdiagonalright') || args.target.classList.contains('e-dtdiagonaldown')) {\n      args.target = args.target.parentElement;\n    }\n\n    if (!args.target.classList.contains('e-rowcell') && parentsUntil(args.target, 'e-rowcell')) {\n      args.target = parentsUntil(args.target, 'e-rowcell');\n    }\n\n    if (this.parent.frozenRows) {\n      this.updateFrozenRowreOrder(args);\n    } else {\n      this.updateFrozenColumnreOrder(args);\n    }\n\n    if (this.selectedRowColls.length > 0) {\n      this.parent.selectRows(this.selectedRowColls);\n      var indexes = [];\n\n      if (this.parent.filterSettings.columns.length || this.parent.sortSettings.columns.length) {\n        for (var i = 0, len = args.rows.length; i < len; i++) {\n          indexes.push(parseInt(args.rows[i].getAttribute(dataRowIndex), 10));\n        }\n\n        this.selectedRowColls = indexes;\n      }\n\n      this.selectedRowColls = [];\n    }\n  };\n\n  RowDD.prototype.currentViewData = function () {\n    var selectedIndexes = this.parent.getSelectedRowIndexes();\n    var currentVdata = [];\n    var fromIdx = parseInt(this.startedRow.getAttribute(dataRowIndex), 10);\n\n    for (var i = 0, n = selectedIndexes.length; i < n; i++) {\n      var currentV = 'currentViewData';\n      currentVdata[i] = this.parent[currentV][selectedIndexes[i]];\n    }\n\n    if (!this.parent.rowDropSettings.targetID && selectedIndexes.length === 0) {\n      currentVdata[0] = this.parent.currentViewData[fromIdx];\n    }\n\n    return currentVdata;\n  };\n\n  RowDD.prototype.saveChange = function (changeRecords, query) {\n    var _this = this;\n\n    this.parent.getDataModule().saveChanges(changeRecords, this.parent.getPrimaryKeyFieldNames()[0], {}, query).then(function () {\n      _this.parent.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n    }).catch(function (e) {\n      var error = 'error';\n      var message = 'message';\n\n      if (!isNullOrUndefined(e[error]) && !isNullOrUndefined(e[error][message])) {\n        e[error] = e[error][message];\n      }\n\n      _this.parent.trigger(actionFailure, e);\n    });\n  };\n\n  RowDD.prototype.reorderRows = function (fromIndexes, toIndex) {\n    var selectedIndexes = this.parent.getSelectedRowIndexes();\n    var selectedRecords = [];\n    var draggedRecords = [];\n    var currentViewData = this.parent.renderModule.data.dataManager.dataSource.json;\n    var skip = this.parent.allowPaging ? this.parent.pageSettings.currentPage * this.parent.pageSettings.pageSize - this.parent.pageSettings.pageSize : 0;\n    var dropIdx = toIndex + skip;\n    var actualIdx = fromIndexes[0] + skip;\n\n    for (var i = 0, len = fromIndexes.length; i < len; i++) {\n      draggedRecords[i] = currentViewData[fromIndexes[i] + skip];\n    }\n\n    for (var i = 0, len = selectedIndexes.length; i < len; i++) {\n      selectedRecords[i] = currentViewData[selectedIndexes[i] + skip];\n    }\n\n    for (var i = 0, len = draggedRecords.length; i < len; i++) {\n      if (i !== 0) {\n        for (var j = 0, len1 = currentViewData.length; j < len1; j++) {\n          if (JSON.stringify(this.parent.renderModule.data.dataManager.dataSource.json[j]) === JSON.stringify(draggedRecords[i])) {\n            actualIdx = j;\n            break;\n          }\n        }\n\n        for (var j = 0, len1 = currentViewData.length; j < len1; j++) {\n          if (JSON.stringify(this.parent.renderModule.data.dataManager.dataSource.json[j]) === JSON.stringify(draggedRecords[i - 1])) {\n            if (actualIdx > j) {\n              dropIdx = j + 1;\n            }\n\n            break;\n          }\n        }\n      }\n\n      this.reorderRow(actualIdx - skip, dropIdx - skip);\n    }\n\n    if (this.isRefresh) {\n      this.parent.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n    }\n\n    for (var i = 0, len = selectedRecords.length; i < len; i++) {\n      for (var j = 0, len1 = currentViewData.length; j < len1; j++) {\n        if (JSON.stringify(this.parent.renderModule.data.dataManager.dataSource.json[j]) === JSON.stringify(selectedRecords[i])) {\n          selectedIndexes[i] = j - skip;\n          break;\n        }\n      }\n    }\n\n    this.selectedRowColls = selectedIndexes;\n  };\n\n  RowDD.prototype.stopTimer = function () {\n    window.clearInterval(this.timer);\n  };\n  /**\n   * To trigger action complete event.\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  RowDD.prototype.onActionComplete = function (e) {\n    this.parent.trigger(actionComplete, extend(e, {\n      type: actionComplete,\n      requestType: 'rowdraganddrop'\n    }));\n  };\n\n  RowDD.prototype.initializeDrag = function () {\n    var gObj = this.parent;\n    this.draggable = new Draggable(gObj.element, {\n      dragTarget: '.e-rowcelldrag, .e-rowdragdrop, .e-rowcell',\n      distance: 5,\n      helper: this.helper,\n      dragStart: this.dragStart,\n      drag: this.drag,\n      dragStop: this.dragStop,\n      isReplaceDragEle: this.isReplaceDragEle,\n      isPreventSelect: false\n    });\n  };\n\n  RowDD.prototype.updateScrollPostion = function (e) {\n    var _this = this;\n\n    var y = getPosition(e).y;\n    var cliRect = this.isDropGrid.getContent().getBoundingClientRect();\n    var rowHeight = this.isDropGrid.getRowHeight() - 15;\n    var scrollElem = this.isDropGrid.getContent().firstElementChild;\n    var virtualScrollbtm = this.parent.enableVirtualization ? 20 : 0;\n\n    if (cliRect.top >= y) {\n      var scrollPixel_1 = -this.isDropGrid.getRowHeight();\n      this.isOverflowBorder = false;\n      this.timer = window.setInterval(function () {\n        _this.setScrollDown(scrollElem, scrollPixel_1);\n      }, 200);\n    } else if (cliRect.top + this.isDropGrid.getContent().clientHeight - rowHeight - 33 - virtualScrollbtm <= y) {\n      var scrollPixel_2 = this.isDropGrid.getRowHeight();\n      this.isOverflowBorder = false;\n      this.timer = window.setInterval(function () {\n        _this.setScrollDown(scrollElem, scrollPixel_2);\n      }, 200);\n    }\n  };\n\n  RowDD.prototype.setScrollDown = function (scrollElem, scrollPixel) {\n    scrollElem.scrollTop = scrollElem.scrollTop + scrollPixel;\n  };\n\n  RowDD.prototype.moveDragRows = function (e, startedRow, targetRow) {\n    var cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n    var element = closest(e.target, 'tr');\n\n    if (parentsUntil(element, 'e-grid') && (parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(element, 'e-grid').id || this.istargetGrid)) {\n      var targetElement = element ? element : this.startedRow;\n      this.setBorder(targetElement, e.event, startedRow, targetRow);\n    }\n  };\n\n  RowDD.prototype.setBorder = function (element, event, startedRow, targetRow) {\n    var node = this.parent.element;\n\n    if (this.istargetGrid) {\n      node = this.isDropGrid.element;\n    }\n\n    var cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n    this.removeFirstRowBorder(element);\n    this.removeLastRowBorder(element);\n\n    if (parentsUntil(element, 'e-grid') && element.classList.contains(row) && (!this.parent.rowDropSettings.targetID && parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(element, 'e-grid').id || this.istargetGrid)) {\n      removeClass(node.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'), ['e-dragborder']);\n      var rowElement = [];\n      var targetRowIndex = parseInt(targetRow.getAttribute(dataRowIndex), 10);\n\n      if (targetRow && targetRowIndex === 0) {\n        var div = this.parent.createElement('div', {\n          className: 'e-firstrow-dragborder'\n        });\n        var gridheaderEle = this.isDropGrid.getHeaderContent();\n        gridheaderEle.classList.add('e-grid-relative');\n        div.style.width = node.offsetWidth - this.getScrollWidth() + 'px';\n\n        if (!gridheaderEle.getElementsByClassName('e-firstrow-dragborder').length) {\n          gridheaderEle.appendChild(div);\n        }\n      } else if (this.parent.rowDropSettings.targetID && targetRow) {\n        element = this.isDropGrid.getRowByIndex(targetRowIndex - 1);\n        rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));\n      } else if (targetRow && parseInt(startedRow.getAttribute(dataRowIndex), 10) > targetRowIndex) {\n        element = this.parent.getRowByIndex(targetRowIndex - 1);\n        rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));\n      } else {\n        rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));\n      }\n\n      var frzCols = this.parent.isFrozenGrid();\n\n      if (targetRow && targetRowIndex !== 0 && frzCols) {\n        var rowIndex = parseInt(element.getAttribute(dataRowIndex), 10);\n        var selector = '.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse';\n        rowElement = this.borderRowElement(rowIndex, selector);\n      }\n\n      if (rowElement.length > 0) {\n        addRemoveActiveClasses(rowElement, true, 'e-dragborder');\n      }\n    }\n  };\n\n  RowDD.prototype.borderRowElement = function (rowIndex, selector) {\n    var lastRow = [];\n    lastRow = [].slice.call(this.isDropGrid.getRowByIndex(rowIndex).querySelectorAll(selector)).concat([].slice.call(this.isDropGrid.getMovableRowByIndex(rowIndex).querySelectorAll(selector)));\n\n    if (this.isDropGrid.getFrozenMode() === leftRight) {\n      lastRow = lastRow.concat([].slice.call(this.isDropGrid.getFrozenRightRowByIndex(rowIndex).querySelectorAll(selector)));\n    }\n\n    return lastRow;\n  };\n\n  RowDD.prototype.getScrollWidth = function () {\n    var scrollElem = this.parent.getContent().firstElementChild;\n    return scrollElem.scrollWidth > scrollElem.offsetWidth ? Scroll.getScrollBarWidth() : 0;\n  };\n\n  RowDD.prototype.removeFirstRowBorder = function (element) {\n    if (this.isDropGrid.element.getElementsByClassName('e-firstrow-dragborder').length > 0 && element && element.rowIndex !== 0) {\n      remove(this.isDropGrid.element.getElementsByClassName('e-firstrow-dragborder')[0]);\n    }\n  };\n\n  RowDD.prototype.removeLastRowBorder = function (element) {\n    var islastRowIndex;\n\n    if (this.parent.enableVirtualization) {\n      islastRowIndex = element && parseInt(element.getAttribute(dataRowIndex), 10) !== this.parent.renderModule.data.dataManager.dataSource.json.length - 1;\n    } else {\n      islastRowIndex = element && this.parent.getRowByIndex(this.parent.getCurrentViewRecords().length - 1).getAttribute('data-uid') !== element.getAttribute('data-uid');\n    }\n\n    if (this.parent.element.getElementsByClassName('e-lastrow-dragborder').length > 0 && element && islastRowIndex) {\n      remove(this.parent.element.getElementsByClassName('e-lastrow-dragborder')[0]);\n    }\n  };\n\n  RowDD.prototype.removeBorder = function (element) {\n    this.removeFirstRowBorder(element);\n\n    if (!this.parent.rowDropSettings.targetID) {\n      this.removeLastRowBorder(element);\n    }\n\n    element = (this.isDropGrid.isFrozenGrid() ? this.isDropGrid.getMovableRows() : this.isDropGrid.getRows()).filter(function (row$$1) {\n      return row$$1.querySelector('td.e-dragborder');\n    })[0];\n\n    if (element) {\n      var rowElement = [].slice.call(element.getElementsByClassName('e-dragborder'));\n\n      if (this.parent.isFrozenGrid()) {\n        var rowIndex = parseInt(element.getAttribute(dataRowIndex), 10);\n        var selector = '.e-dragborder';\n        rowElement = this.borderRowElement(rowIndex, selector);\n      }\n\n      addRemoveActiveClasses(rowElement, false, 'e-dragborder');\n    }\n  };\n\n  RowDD.prototype.getElementFromPosition = function (element, event) {\n    var position = getPosition(event);\n    element.style.display = 'none';\n    var target = document.elementFromPoint(position.x, position.y);\n    element.style.display = '';\n    return target;\n  };\n\n  RowDD.prototype.onDataBound = function () {\n    if (this.selectedRowColls.length > 0 && (this.parent.enableVirtualization || this.parent.allowRowDragAndDrop)) {\n      this.parent.selectRows(this.selectedRowColls);\n      this.selectedRowColls = [];\n    }\n  };\n\n  RowDD.prototype.getTargetIdx = function (targetRow) {\n    return targetRow ? parseInt(targetRow.getAttribute(dataRowIndex), 10) : 0;\n  };\n\n  RowDD.prototype.singleRowDrop = function (e) {\n    var targetRow = closest(e.target, 'tr');\n    var srcControl = e.droppedElement.parentElement.ej2_instances[0];\n    var currentIndex = targetRow ? targetRow.rowIndex : srcControl.currentViewData.length - 1;\n    this.reorderRow(this.startedRowIndex, currentIndex);\n  };\n\n  RowDD.prototype.columnDrop = function (e) {\n    var gObj = this.parent;\n\n    if (e.droppedElement.getAttribute('action') !== 'grouping' && (parentsUntil(e.target, row) || parentsUntil(e.target, 'e-emptyrow') || parentsUntil(e.target, gridContent))) {\n      var targetRow = closest(e.target, 'tr');\n      var srcControl = void 0;\n      var currentIndex = void 0;\n\n      if (e.droppedElement.querySelector('tr').getAttribute('single-dragrow') !== 'true' && e.droppedElement.parentElement.id === gObj.element.id || e.droppedElement.querySelector('tr').getAttribute('single-dragrow') === 'true' && e.droppedElement.parentElement.id !== gObj.element.id) {\n        return;\n      }\n\n      if (e.droppedElement.parentElement.id !== gObj.element.id) {\n        srcControl = e.droppedElement.parentElement.ej2_instances[0];\n      } else if (this.isSingleRowDragDrop || e.droppedElement.querySelector('tr').getAttribute('single-dragrow') === 'true') {\n        this.singleRowDrop(e);\n        return;\n      }\n\n      if (srcControl.element.id !== gObj.element.id && srcControl.rowDropSettings.targetID !== gObj.element.id) {\n        return;\n      }\n\n      var records = srcControl.getSelectedRecords();\n      var targetIndex = currentIndex = this.getTargetIdx(targetRow);\n\n      if (isNaN(targetIndex)) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        targetIndex = currentIndex = 0;\n      }\n\n      if (gObj.allowPaging) {\n        targetIndex = targetIndex + gObj.pageSettings.currentPage * gObj.pageSettings.pageSize - gObj.pageSettings.pageSize;\n      } //Todo: drag and drop mapper & BatchChanges\n\n\n      gObj.notify(rowsAdded, {\n        toIndex: targetIndex,\n        records: records\n      });\n      gObj.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n      var selectedRows = srcControl.getSelectedRowIndexes();\n      var skip = srcControl.allowPaging ? srcControl.pageSettings.currentPage * srcControl.pageSettings.pageSize - srcControl.pageSettings.pageSize : 0;\n      this.selectedRows = [];\n\n      for (var i = 0, len = records.length; i < len; i++) {\n        this.selectedRows.push(skip + selectedRows[i]);\n      }\n\n      srcControl.notify(rowsRemoved, {\n        indexes: this.selectedRows,\n        records: records\n      });\n      srcControl.notify(modelChanged, {\n        type: actionBegin,\n        requestType: 'rowdraganddrop'\n      });\n    }\n  };\n\n  RowDD.prototype.reorderRow = function (fromIndexes, toIndex) {\n    var gObj = this.parent;\n\n    if (!gObj.sortSettings.columns.length && !gObj.groupSettings.columns.length && !gObj.filterSettings.columns.length) {\n      //Todo: drag and drop mapper & BatchChanges\n      var skip = gObj.allowPaging ? gObj.pageSettings.currentPage * gObj.pageSettings.pageSize - gObj.pageSettings.pageSize : 0; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n      toIndex = toIndex + skip;\n      this.selectedRows = gObj.getSelectedRowIndexes();\n      gObj.notify(rowPositionChanged, {\n        fromIndex: fromIndexes + skip,\n        toIndex: toIndex\n      });\n    }\n  };\n\n  RowDD.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.initializeDrag();\n    }\n  };\n  /**\n   * To destroy the print\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  RowDD.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.draggable.destroy();\n    this.parent.off(initialEnd, this.initializeDrag);\n    this.parent.off(columnDrop, this.columnDrop);\n    this.parent.off(rowDragAndDropComplete, this.onActionComplete);\n    this.parent.removeEventListener(dataBound, this.onDataBoundFn);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(destroy, this.destroy); //destory ejdrag and drop\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  RowDD.prototype.getModuleName = function () {\n    return 'rowDragAndDrop';\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  RowDD.prototype.processArgs = function (target) {\n    var gObj = this.parent;\n    var dragIdx = parseInt(this.startedRow.getAttribute(dataRowIndex), 10);\n\n    if (gObj.getSelectedRecords().length > 0 && this.startedRow.cells[0].classList.contains('e-selectionbackground') === false || gObj.getSelectedRecords().length === 0) {\n      if (this.parent.enableVirtualization) {\n        this.rows = [this.startedRow];\n      } else {\n        this.rows = [this.parent.getRowByIndex(dragIdx)];\n\n        if (gObj.isFrozenGrid()) {\n          this.rows = [gObj.getRowByIndex(dragIdx), gObj.getMovableRowByIndex(dragIdx)];\n\n          if (gObj.getFrozenMode() === leftRight) {\n            this.rows = [gObj.getRowByIndex(dragIdx), gObj.getMovableRowByIndex(dragIdx), gObj.getFrozenRightRowByIndex(dragIdx)];\n          }\n        }\n      }\n\n      this.rowData = [this.parent.getRowInfo(this.startedRow.querySelector('.' + rowCell)).rowData];\n    } else {\n      this.rows = gObj.getSelectedRows();\n      this.rowData = gObj.getSelectedRecords();\n    }\n  };\n\n  return RowDD;\n}(); // eslint-disable-next-line valid-jsdoc\n\n/**\n *\n * The `Group` module is used to handle group action.\n */\n\n\nvar Group =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for Grid group module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {GroupSettingsModel} groupSettings - specifies the GroupSettingsModel\n   * @param {string[]} sortedColumns - specifies the sortedColumns\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @hidden\n   */\n  function Group(parent, groupSettings, sortedColumns, serviceLocator) {\n    var _this = this; //Internal variables\n\n\n    this.sortRequired = true;\n    /** @hidden */\n\n    this.groupSortFocus = false;\n    /** @hidden */\n\n    this.groupCancelFocus = false;\n    this.isAppliedGroup = false;\n    this.isAppliedUnGroup = false;\n    this.reorderingColumns = [];\n    this.visualElement = createElement('div', {\n      className: 'e-cloneproperties e-dragclone e-gdclone',\n      styles: 'line-height:23px',\n      attrs: {\n        action: 'grouping'\n      }\n    });\n\n    this.helper = function (e) {\n      var gObj = _this.parent;\n      var target = e.sender.target;\n      var element = target.classList.contains('e-groupheadercell') ? target : parentsUntil(target, 'e-groupheadercell');\n\n      if (!element || !target.classList.contains('e-drag') && _this.groupSettings.allowReordering) {\n        return false;\n      }\n\n      _this.column = gObj.getColumnByField(element.firstElementChild.getAttribute('ej-mappingname'));\n      _this.visualElement.textContent = element.textContent;\n      _this.visualElement.style.width = element.offsetWidth + 2 + 'px';\n      _this.visualElement.style.height = element.offsetHeight + 2 + 'px';\n\n      _this.visualElement.setAttribute('e-mappinguid', _this.column.uid);\n\n      gObj.element.appendChild(_this.visualElement);\n      return _this.visualElement;\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this.dragStart = function (e) {\n      _this.parent.element.classList.add('e-ungroupdrag');\n    };\n\n    this.drag = function (e) {\n      if (_this.groupSettings.allowReordering) {\n        _this.animateDropper(e);\n      }\n\n      var target = e.target;\n\n      var cloneElement = _this.parent.element.querySelector('.e-cloneproperties');\n\n      _this.parent.trigger(columnDrag, {\n        target: target,\n        draggableType: 'headercell',\n        column: _this.column\n      });\n\n      if (!_this.groupSettings.allowReordering) {\n        classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n\n        if (!(parentsUntil(target, gridContent) || parentsUntil(target, 'e-headercell'))) {\n          classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n        }\n      }\n    };\n\n    this.dragStop = function (e) {\n      _this.parent.element.classList.remove('e-ungroupdrag');\n\n      var preventDrop = !(parentsUntil(e.target, gridContent) || parentsUntil(e.target, 'e-gridheader'));\n\n      if (_this.groupSettings.allowReordering && preventDrop) {\n        remove(e.helper);\n\n        if (parentsUntil(e.target, 'e-groupdroparea')) {\n          _this.rearrangeGroup();\n        } else if (!parentsUntil(e.target, 'e-grid')) {\n          var field = _this.parent.getColumnByUid(e.helper.getAttribute('e-mappinguid')).field;\n\n          if (_this.groupSettings.columns.indexOf(field) !== -1) {\n            _this.ungroupColumn(field);\n          }\n        }\n\n        return;\n      } else if (preventDrop) {\n        remove(e.helper);\n        return;\n      }\n    };\n\n    this.animateDropper = function (e) {\n      var uid = _this.parent.element.querySelector('.e-cloneproperties').getAttribute('e-mappinguid');\n\n      var dragField = _this.parent.getColumnByUid(uid).field;\n\n      var parent = parentsUntil(e.target, 'e-groupdroparea');\n      var dropTarget = parentsUntil(e.target, 'e-group-animator');\n      var grouped = [].slice.call(_this.element.getElementsByClassName('e-groupheadercell')).map(function (e) {\n        return e.querySelector('div').getAttribute('ej-mappingname');\n      });\n      var cols = JSON.parse(JSON.stringify(grouped));\n\n      if (dropTarget || parent) {\n        if (dropTarget) {\n          var dropField = dropTarget.querySelector('div[ej-mappingname]').getAttribute('ej-mappingname');\n          var dropIndex = +dropTarget.getAttribute('index');\n\n          if (dropField !== dragField) {\n            var dragIndex = cols.indexOf(dragField);\n\n            if (dragIndex !== -1) {\n              cols.splice(dragIndex, 1);\n            }\n\n            var flag = dropIndex !== -1 && dragIndex === dropIndex;\n            cols.splice(dropIndex + (flag ? 1 : 0), 0, dragField);\n          }\n        } else if (parent && cols.indexOf(dragField) === -1) {\n          cols.push(dragField);\n        }\n\n        _this.element.innerHTML = '';\n\n        if (cols.length && !_this.element.classList.contains('e-grouped')) {\n          _this.element.classList.add('e-grouped');\n        }\n\n        _this.reorderingColumns = cols;\n\n        for (var c = 0; c < cols.length; c++) {\n          _this.addColToGroupDrop(cols[c]);\n        }\n      } else {\n        _this.addLabel();\n\n        _this.removeColFromGroupDrop(dragField);\n      }\n    };\n\n    this.drop = function (e) {\n      var gObj = _this.parent;\n      var column = gObj.getColumnByUid(e.droppedElement.getAttribute('e-mappinguid'));\n\n      _this.element.classList.remove('e-hover');\n\n      remove(e.droppedElement);\n\n      _this.aria.setDropTarget(_this.parent.element.querySelector('.e-groupdroparea'), false);\n\n      _this.aria.setGrabbed(_this.parent.getHeaderTable().querySelector('[aria-grabbed=true]'), false);\n\n      if (isNullOrUndefined(column) || column.allowGrouping === false || parentsUntil(gObj.getColumnHeaderByUid(column.uid), 'e-grid').getAttribute('id') !== gObj.element.getAttribute('id')) {\n        _this.parent.log('action_disabled_column', {\n          moduleName: _this.getModuleName(),\n          columnName: column.headerText\n        });\n\n        return;\n      }\n\n      _this.groupColumn(column.field);\n    };\n\n    this.contentRefresh = true;\n    this.aria = new AriaService();\n    this.parent = parent;\n    this.groupSettings = groupSettings;\n    this.serviceLocator = serviceLocator;\n    this.sortedColumns = sortedColumns;\n    this.focus = serviceLocator.getService('focus');\n    this.addEventListener();\n    this.groupGenerator = new GroupModelGenerator(this.parent);\n  }\n\n  Group.prototype.addLabel = function () {\n    if (!this.element.getElementsByClassName('e-group-animator').length) {\n      var dragLabel = this.l10n.getConstant('GroupDropArea');\n      this.element.innerHTML = dragLabel;\n      this.element.classList.remove('e-grouped');\n    }\n  };\n\n  Group.prototype.rearrangeGroup = function () {\n    this.sortRequired = false;\n    this.updateModel();\n  };\n\n  Group.prototype.columnDrag = function (e) {\n    if (this.groupSettings.allowReordering && e.column.allowGrouping) {\n      this.animateDropper(e);\n    }\n\n    var cloneElement = this.parent.element.querySelector('.e-cloneproperties');\n    classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n\n    if (!parentsUntil(e.target, 'e-groupdroparea') && !(this.parent.allowReordering && parentsUntil(e.target, 'e-headercell'))) {\n      classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n    }\n\n    if (e.target.classList.contains('e-groupdroparea')) {\n      this.element.classList.add('e-hover');\n    } else {\n      this.element.classList.remove('e-hover');\n    }\n  };\n\n  Group.prototype.columnDragStart = function (e) {\n    if (e.target.classList.contains('e-stackedheadercell')) {\n      return;\n    }\n\n    var dropArea = this.parent.element.querySelector('.e-groupdroparea');\n    this.aria.setDropTarget(dropArea, e.column.allowGrouping);\n    var element = e.target.classList.contains('e-headercell') ? e.target : parentsUntil(e.target, 'e-headercell');\n    this.aria.setGrabbed(element, true, !e.column.allowGrouping);\n  };\n\n  Group.prototype.columnDrop = function (e) {\n    var gObj = this.parent;\n\n    if (e.droppedElement.getAttribute('action') === 'grouping') {\n      var column = gObj.getColumnByUid(e.droppedElement.getAttribute('e-mappinguid'));\n\n      if (isNullOrUndefined(column) || column.allowGrouping === false || parentsUntil(gObj.getColumnHeaderByUid(column.uid), 'e-grid').getAttribute('id') !== gObj.element.getAttribute('id')) {\n        return;\n      }\n\n      this.ungroupColumn(column.field);\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Group.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(uiUpdate, this.enableAfterRender, this);\n    this.parent.on(groupComplete, this.onActionComplete, this);\n    this.parent.on(ungroupComplete, this.onActionComplete, this);\n    this.parent.on(inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(click, this.clickHandler, this);\n    this.parent.on(columnDrag, this.columnDrag, this);\n    this.parent.on(columnDragStart, this.columnDragStart, this);\n    this.parent.on(headerDrop, this.columnDrop, this);\n    this.parent.on(columnDrop, this.columnDrop, this);\n    this.parent.on(headerRefreshed, this.refreshSortIcons, this);\n    this.parent.on(sortComplete, this.refreshSortIcons, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(contentReady, this.initialEnd, this);\n    this.parent.on(onEmpty, this.initialEnd, this);\n    this.parent.on(initialEnd, this.render, this);\n    this.parent.on(groupAggregates, this.onGroupAggregates, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on('group-expand-collapse', this.updateExpand, this);\n    this.parent.on('persist-data-changed', this.initialEnd, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Group.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialEnd, this.render);\n    this.parent.off(uiUpdate, this.enableAfterRender);\n    this.parent.off(groupComplete, this.onActionComplete);\n    this.parent.off(ungroupComplete, this.onActionComplete);\n    this.parent.off(inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(click, this.clickHandler);\n    this.parent.off(columnDrag, this.columnDrag);\n    this.parent.off(columnDragStart, this.columnDragStart);\n    this.parent.off(columnDrop, this.columnDrop);\n    this.parent.off(headerDrop, this.columnDrop);\n    this.parent.off(headerRefreshed, this.refreshSortIcons);\n    this.parent.off(sortComplete, this.refreshSortIcons);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(groupAggregates, this.onGroupAggregates);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off('group-expand-collapse', this.updateExpand);\n  };\n\n  Group.prototype.initialEnd = function () {\n    var gObj = this.parent;\n    this.parent.off(contentReady, this.initialEnd);\n    this.parent.off(onEmpty, this.initialEnd);\n\n    if (this.parent.getColumns().length && this.groupSettings.columns.length) {\n      this.contentRefresh = false;\n\n      for (var _i = 0, _a = gObj.groupSettings.columns; _i < _a.length; _i++) {\n        var col = _a[_i];\n        this.groupColumn(col);\n      }\n\n      this.contentRefresh = true;\n    }\n  };\n\n  Group.prototype.keyPressHandler = function (e) {\n    var gObj = this.parent;\n\n    if (e.target && parentsUntil(e.target, 'e-groupheadercell') && (e.action === 'tab' || e.action === 'shiftTab')) {\n      var focusableGroupedItems = this.getFocusableGroupedItems();\n\n      if (e.action === 'tab' && e.target === focusableGroupedItems[focusableGroupedItems.length - 1] || e.action === 'shiftTab' && e.target === focusableGroupedItems[0]) {\n        return;\n      }\n\n      for (var i = 0; i < focusableGroupedItems.length; i++) {\n        if (e.target === focusableGroupedItems[i]) {\n          e.preventDefault();\n          var index = e.action === 'tab' ? i + 1 : i - 1;\n          focusableGroupedItems[index].focus();\n          return;\n        }\n      }\n    }\n\n    if (e.action !== 'ctrlSpace' && (!this.groupSettings.columns.length || ['altDownArrow', 'altUpArrow', 'ctrlDownArrow', 'ctrlUpArrow', 'enter'].indexOf(e.action) === -1)) {\n      return;\n    }\n\n    e.preventDefault();\n\n    switch (e.action) {\n      case 'altDownArrow':\n      case 'altUpArrow':\n        // eslint-disable-next-line no-case-declarations\n        var selected = gObj.allowSelection ? gObj.getSelectedRowIndexes() : [];\n\n        if (selected.length) {\n          var rows = gObj.getContentTable().querySelector(tbody).children;\n          var dataRow = gObj.getDataRows()[selected[selected.length - 1]];\n          var grpRow = void 0;\n\n          for (var i = dataRow.rowIndex; i >= 0; i--) {\n            if (!rows[i].classList.contains(row) && !rows[i].classList.contains('e-detailrow')) {\n              grpRow = rows[i];\n              break;\n            }\n          }\n\n          this.expandCollapseRows(grpRow.querySelector(e.action === 'altUpArrow' ? '.e-recordplusexpand' : '.e-recordpluscollapse'));\n        }\n\n        break;\n\n      case 'ctrlDownArrow':\n        this.expandAll();\n        break;\n\n      case 'ctrlUpArrow':\n        this.collapseAll();\n        break;\n\n      case 'enter':\n        if (e.target.classList.contains('e-groupsort')) {\n          this.groupSortFocus = true;\n          this.applySortFromTarget(e.target);\n          break;\n        } else if (e.target.classList.contains('e-ungroupbutton')) {\n          this.groupCancelFocus = true;\n          this.unGroupFromTarget(e.target);\n          break;\n        }\n\n        if (this.parent.isEdit || closest(e.target, '#' + this.parent.element.id + '_searchbar') !== null || parentsUntil(e.target, 'e-pager')) {\n          return;\n        } // eslint-disable-next-line no-case-declarations\n\n\n        var element = this.focus.getFocusedElement();\n\n        if (element.classList.contains('e-icon-grightarrow') || element.classList.contains('e-icon-gdownarrow')) {\n          element = element.parentElement;\n        } // eslint-disable-next-line no-case-declarations\n\n\n        var row$$1 = element ? element.parentElement.querySelector('[class^=\"e-record\"]') : null;\n\n        if (!row$$1) {\n          break;\n        }\n\n        if (element.children.length && (element.children[0].classList.contains('e-icon-grightarrow') || element.children[0].classList.contains('e-icon-gdownarrow'))) {\n          this.expandCollapseRows(row$$1);\n        }\n\n        break;\n\n      case 'ctrlSpace':\n        // eslint-disable-next-line no-case-declarations\n        var elem = gObj.focusModule.currentInfo.element;\n\n        if (elem && elem.classList.contains('e-headercell')) {\n          var column = gObj.getColumnByUid(elem.firstElementChild.getAttribute('e-mappinguid'));\n\n          if (column.field && gObj.groupSettings.columns.indexOf(column.field) < 0) {\n            this.groupColumn(column.field);\n          } else {\n            this.ungroupColumn(column.field);\n          }\n        }\n\n        break;\n    }\n  };\n  /**\n   * @returns {Element[]} - Return the focusable grouping items\n   * @hidden */\n\n\n  Group.prototype.getFocusableGroupedItems = function () {\n    var focusableGroupedItems = [];\n\n    if (this.groupSettings.columns.length) {\n      var focusableGroupedHeaderItems = this.element.querySelectorAll('.e-groupheadercell');\n\n      for (var i = 0; i < focusableGroupedHeaderItems.length; i++) {\n        focusableGroupedItems.push(focusableGroupedHeaderItems[i].querySelector('.e-grouptext'));\n        focusableGroupedItems.push(focusableGroupedHeaderItems[i].querySelector('.e-groupsort'));\n        focusableGroupedItems.push(focusableGroupedHeaderItems[i].querySelector('.e-ungroupbutton'));\n      }\n    }\n\n    return focusableGroupedItems;\n  };\n\n  Group.prototype.wireEvent = function () {\n    EventHandler.add(this.element, 'focusin', this.onFocusIn, this);\n    EventHandler.add(this.element, 'focusout', this.onFocusOut, this);\n  };\n\n  Group.prototype.unWireEvent = function () {\n    EventHandler.remove(this.element, 'focusin', this.onFocusIn);\n    EventHandler.remove(this.element, 'focusout', this.onFocusOut);\n  };\n\n  Group.prototype.onFocusIn = function (e) {\n    if (this.parent.focusModule.currentInfo && this.parent.focusModule.currentInfo.element) {\n      removeClass([this.parent.focusModule.currentInfo.element, this.parent.focusModule.currentInfo.elementToFocus], ['e-focused', 'e-focus']);\n      this.parent.focusModule.currentInfo.element.tabIndex = -1;\n    }\n\n    this.addOrRemoveFocus(e);\n  };\n\n  Group.prototype.onFocusOut = function (e) {\n    this.addOrRemoveFocus(e);\n  };\n\n  Group.prototype.addOrRemoveFocus = function (e) {\n    if (e.target.classList.contains('e-groupdroparea') || e.target.classList.contains('e-grouptext') || e.target.classList.contains('e-groupsort') || e.target.classList.contains('e-ungroupbutton')) {\n      var target = e.target.classList.contains('e-grouptext') ? e.target.parentElement.parentElement : e.target;\n\n      if (e.type === 'focusin') {\n        addClass([target], ['e-focused', 'e-focus']);\n        target.tabIndex = 0;\n      } else {\n        removeClass([target], ['e-focused', 'e-focus']);\n        target.tabIndex = -1;\n      }\n    }\n  };\n\n  Group.prototype.clickHandler = function (e) {\n    if (e.target.classList.contains('e-groupsort')) {\n      this.groupSortFocus = true;\n    }\n\n    if (e.target.classList.contains('e-ungroupbutton')) {\n      this.groupCancelFocus = true;\n    }\n\n    var trgtEle = parentsUntil(e.target, 'e-recordplusexpand') || parentsUntil(e.target, 'e-recordpluscollapse');\n\n    if (trgtEle && (trgtEle.children[0].classList.contains('e-icon-gdownarrow') || trgtEle.children[0].classList.contains('e-icon-grightarrow'))) {\n      this.expandCollapseRows(e.target);\n    }\n\n    this.applySortFromTarget(e.target);\n    this.unGroupFromTarget(e.target);\n    this.toogleGroupFromHeader(e.target);\n  };\n\n  Group.prototype.unGroupFromTarget = function (target) {\n    if (target.classList.contains('e-ungroupbutton')) {\n      this.ungroupColumn(target.parentElement.getAttribute('ej-mappingname'));\n    }\n  };\n\n  Group.prototype.toogleGroupFromHeader = function (target) {\n    if (this.groupSettings.showToggleButton) {\n      if (target.classList.contains('e-grptogglebtn')) {\n        if (target.classList.contains('e-toggleungroup')) {\n          this.ungroupColumn(this.parent.getColumnByUid(target.parentElement.getAttribute('e-mappinguid')).field);\n        } else {\n          this.groupColumn(this.parent.getColumnByUid(target.parentElement.getAttribute('e-mappinguid')).field);\n        }\n      } else {\n        if (target.classList.contains('e-toggleungroup')) {\n          this.ungroupColumn(target.parentElement.getAttribute('ej-mappingname'));\n        }\n      }\n    }\n  };\n\n  Group.prototype.applySortFromTarget = function (target) {\n    var gObj = this.parent;\n    var gHeader = closest(target, '.e-groupheadercell');\n\n    if (gObj.allowSorting && gHeader && !target.classList.contains('e-ungroupbutton') && !target.classList.contains('e-toggleungroup')) {\n      var field = gHeader.firstElementChild.getAttribute('ej-mappingname');\n\n      if (gObj.getColumnHeaderByField(field).getElementsByClassName('e-ascending').length) {\n        gObj.sortColumn(field, 'Descending', true);\n      } else {\n        gObj.sortColumn(field, 'Ascending', true);\n      }\n    }\n  };\n  /**\n   * Expands or collapses grouped rows by target element.\n   *\n   * @param  {Element} target - Defines the target element of the grouped row.\n   * @returns {void}\n   */\n\n\n  Group.prototype.expandCollapseRows = function (target) {\n    var trgt = parentsUntil(target, 'e-recordplusexpand') || parentsUntil(target, 'e-recordpluscollapse');\n\n    if (trgt) {\n      var rowNodes = this.parent.getContentTable().querySelector(tbody).children;\n      var isHide = void 0;\n      var dataManager = void 0;\n      var query = void 0;\n      var gObj = this.parent;\n      var indent = trgt.parentElement.getElementsByClassName('e-indentcell').length;\n      var uid = trgt.parentElement.getAttribute('data-uid');\n      var captionRow = gObj.getRowObjectFromUID(uid);\n      var expand = false;\n\n      if (trgt.classList.contains('e-recordpluscollapse')) {\n        addClass([trgt], 'e-recordplusexpand');\n        removeClass([trgt], 'e-recordpluscollapse');\n        trgt.firstElementChild.className = 'e-icons e-gdiagonaldown e-icon-gdownarrow';\n        trgt.firstElementChild.setAttribute('title', 'expanded');\n        expand = true;\n        captionRow.isExpand = true;\n\n        if (isGroupAdaptive(gObj)) {\n          this.updateVirtualRows(gObj, target, expand, query, dataManager);\n        }\n\n        if (this.parent.groupSettings.enableLazyLoading) {\n          this.parent.contentModule.captionExpand(trgt.parentElement);\n        }\n      } else {\n        isHide = true;\n        captionRow.isExpand = false;\n        removeClass([trgt], 'e-recordplusexpand');\n        addClass([trgt], 'e-recordpluscollapse');\n        trgt.firstElementChild.className = 'e-icons e-gnextforward e-icon-grightarrow';\n        trgt.firstElementChild.setAttribute('title', 'collapsed');\n\n        if (isGroupAdaptive(gObj)) {\n          this.updateVirtualRows(gObj, target, !isHide, query, dataManager);\n        }\n\n        if (this.parent.groupSettings.enableLazyLoading) {\n          this.parent.contentModule.captionCollapse(trgt.parentElement);\n        }\n      }\n\n      this.aria.setExpand(trgt, expand);\n\n      if (!isGroupAdaptive(gObj) && !this.parent.groupSettings.enableLazyLoading) {\n        var rowObjs = gObj.getRowsObject();\n        var startIdx = rowObjs.indexOf(captionRow);\n        var rowsState = {};\n        var cacheStartIdx = gObj.enableInfiniteScrolling && gObj.infiniteScrollSettings && gObj.infiniteScrollSettings.enableCache && rowObjs.length !== rowNodes.length ? Array.from(rowNodes).indexOf(trgt.parentElement) : undefined;\n\n        for (var i = startIdx; i < rowObjs.length; i++) {\n          if (i > startIdx && rowObjs[i].indent === indent) {\n            break;\n          }\n\n          if (rowObjs[i].isDetailRow) {\n            var visible = rowObjs[i - 1].isExpand && rowObjs[i - 1].visible;\n\n            if (cacheStartIdx && cacheStartIdx > 0 && cacheStartIdx < rowNodes.length) {\n              rowNodes[cacheStartIdx].style.display = visible ? '' : 'none';\n            } else if (isNullOrUndefined(cacheStartIdx)) {\n              rowNodes[i].style.display = visible ? '' : 'none';\n            }\n          } else if (rowsState[rowObjs[i].parentUid] === false) {\n            rowObjs[i].visible = false;\n\n            if (cacheStartIdx && cacheStartIdx > 0 && cacheStartIdx < rowNodes.length) {\n              rowNodes[cacheStartIdx].style.display = 'none';\n            } else if (isNullOrUndefined(cacheStartIdx)) {\n              rowNodes[i].style.display = 'none';\n            }\n          } else {\n            if (!(rowObjs[i].isDataRow || rowObjs[i].isCaptionRow || rowObjs[i].isDetailRow || rowObjs[i].isAggregateRow)) {\n              var visible = rowObjs[i].cells.some(function (cell) {\n                return cell.isDataCell && cell.visible;\n              });\n\n              if (visible === rowObjs[i].visible) {\n                continue;\n              }\n            }\n\n            rowObjs[i].visible = true;\n\n            if (cacheStartIdx && cacheStartIdx > 0 && cacheStartIdx < rowNodes.length) {\n              rowNodes[cacheStartIdx].style.display = '';\n              rowNodes[cacheStartIdx].classList.remove('e-hide');\n            } else if (isNullOrUndefined(cacheStartIdx)) {\n              rowNodes[i].style.display = '';\n              rowNodes[i].classList.remove('e-hide');\n            }\n          }\n\n          if (rowObjs[i].isCaptionRow) {\n            rowsState[rowObjs[i].uid] = rowObjs[i].isExpand && rowObjs[i].visible;\n          }\n\n          if (!isNullOrUndefined(cacheStartIdx)) {\n            cacheStartIdx++;\n          }\n        }\n\n        this.parent.notify(refreshExpandandCollapse, {\n          rows: this.parent.getRowsObject()\n        });\n      }\n\n      if (!this.parent.enableInfiniteScrolling || !this.parent.groupSettings.enableLazyLoading) {\n        this.parent.notify(captionActionComplete, {\n          isCollapse: isHide,\n          parentUid: uid\n        });\n      }\n    }\n  };\n\n  Group.prototype.updateVirtualRows = function (gObj, target, isExpand, query, dataManager) {\n    var rObj = gObj.getRowObjectFromUID(target.closest('tr').getAttribute('data-uid'));\n    rObj.isExpand = isExpand;\n    updatecloneRow(gObj);\n    this.parent.notify(refreshVirtualMaxPage, {});\n    query = gObj.getDataModule().generateQuery(false);\n    query.queries = gObj.getDataModule().aggregateQuery(gObj.getQuery().clone()).queries;\n    var args = {\n      requestType: 'virtualscroll',\n      rowObject: rObj\n    };\n\n    if (gObj.contentModule) {\n      args.virtualInfo = gObj.contentModule.prevInfo;\n    }\n\n    dataManager = gObj.getDataModule().getData(args, query.requiresCount());\n    dataManager.then(function (e) {\n      return gObj.renderModule.dataManagerSuccess(e, args);\n    });\n  };\n\n  Group.prototype.expandCollapse = function (isExpand) {\n    if (!this.parent.groupSettings.columns.length) {\n      return;\n    }\n\n    if (!isExpand) {\n      this.parent.notify(initialCollapse, isExpand);\n    }\n\n    var rowNodes = this.parent.getContentTable().querySelector(tbody).children;\n    var rowObjs = this.parent.getRowsObject();\n    var row$$1;\n\n    for (var i = 0, len = rowNodes.length; i < len; i++) {\n      if (rowNodes[i].querySelectorAll('.e-recordplusexpand, .e-recordpluscollapse').length) {\n        row$$1 = rowNodes[i].querySelector(isExpand ? '.e-recordpluscollapse' : '.e-recordplusexpand');\n\n        if (row$$1) {\n          if (isExpand) {\n            row$$1.className = 'e-recordplusexpand';\n            row$$1.firstElementChild.className = 'e-icons e-gdiagonaldown e-icon-gdownarrow';\n            row$$1.setAttribute('aria-expanded', 'true');\n            row$$1.firstElementChild.setAttribute('title', 'expanded');\n          } else {\n            row$$1.className = 'e-recordpluscollapse';\n            row$$1.firstElementChild.className = 'e-icons e-gnextforward e-icon-grightarrow';\n            row$$1.setAttribute('aria-expanded', 'false');\n            row$$1.firstElementChild.setAttribute('title', 'collapsed');\n          }\n        }\n\n        if (!(rowNodes[i].firstElementChild.classList.contains('e-recordplusexpand') || rowNodes[i].firstElementChild.classList.contains('e-recordpluscollapse'))) {\n          rowNodes[i].style.display = isExpand ? '' : 'none';\n        }\n      } else {\n        rowNodes[i].style.display = isExpand ? '' : 'none';\n      }\n\n      if (rowObjs[i].isCaptionRow) {\n        rowObjs[i].isExpand = isExpand ? true : false;\n      }\n    }\n\n    this.parent.updateVisibleExpandCollapseRows();\n    this.parent.notify(refreshExpandandCollapse, {\n      rows: this.parent.getRowsObject()\n    });\n  };\n  /**\n   * Expands all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Group.prototype.expandAll = function () {\n    this.expandCollapse(true);\n  };\n  /**\n   * Collapses all the grouped rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Group.prototype.collapseAll = function () {\n    this.expandCollapse(false);\n  };\n  /**\n   * The function is used to render grouping\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Group.prototype.render = function () {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.renderGroupDropArea();\n    this.initDragAndDrop();\n    this.refreshToggleBtn();\n    this.wireEvent();\n  };\n\n  Group.prototype.renderGroupDropArea = function () {\n    var groupElem = this.parent.element.querySelector('.e-groupdroparea');\n\n    if (groupElem) {\n      remove(groupElem);\n    }\n\n    this.element = this.parent.createElement('div', {\n      className: 'e-groupdroparea',\n      attrs: {\n        'tabindex': '-1'\n      }\n    });\n\n    if (this.groupSettings.allowReordering) {\n      this.element.classList.add('e-group-animate');\n    }\n\n    this.updateGroupDropArea();\n    this.parent.element.insertBefore(this.element, this.parent.element.firstChild);\n\n    if (!this.groupSettings.showDropArea) {\n      this.element.style.display = 'none';\n    }\n  };\n\n  Group.prototype.updateGroupDropArea = function (clear) {\n    if (this.groupSettings.showDropArea && !this.groupSettings.columns.length) {\n      var dragLabel = this.l10n.getConstant('GroupDropArea');\n      this.element.innerHTML = dragLabel;\n      this.element.classList.remove('e-grouped');\n    } else {\n      if (this.element.innerHTML === this.l10n.getConstant('GroupDropArea') && (this.groupSettings.columns.length === 1 || !this.isAppliedGroup && !this.isAppliedUnGroup) || clear) {\n        this.element.innerHTML = '';\n      }\n\n      this.element.classList.add('e-grouped');\n    }\n  };\n\n  Group.prototype.initDragAndDrop = function () {\n    this.initializeGHeaderDrop();\n    this.initializeGHeaderDrag();\n  };\n\n  Group.prototype.initializeGHeaderDrag = function () {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var drag = new Draggable(this.element, {\n      dragTarget: this.groupSettings.allowReordering ? '.e-drag' : '.e-groupheadercell',\n      distance: this.groupSettings.allowReordering ? -10 : 5,\n      helper: this.helper,\n      dragStart: this.dragStart,\n      drag: this.drag,\n      dragStop: this.dragStop\n    });\n  };\n\n  Group.prototype.initializeGHeaderDrop = function () {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var drop = new Droppable(this.element, {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  };\n  /**\n   * Groups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to group.\n   * @returns {void}\n   */\n\n\n  Group.prototype.groupColumn = function (columnName) {\n    var gObj = this.parent;\n    var column = gObj.getColumnByField(columnName);\n\n    if (isNullOrUndefined(column) || column.allowGrouping === false || this.contentRefresh && this.groupSettings.columns.indexOf(columnName) > -1) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        columnName: column.headerText\n      });\n      return;\n    }\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.groupColumn,\n        arg1: columnName\n      });\n      return;\n    }\n\n    column.visible = gObj.groupSettings.showGroupedColumn;\n    this.colName = columnName;\n    this.isAppliedGroup = true;\n\n    if (this.contentRefresh) {\n      this.updateModel();\n    } else {\n      this.addColToGroupDrop(columnName);\n    }\n\n    this.updateGroupDropArea();\n    this.isAppliedGroup = false;\n  };\n  /**\n   * Ungroups a column by column name.\n   *\n   * @param  {string} columnName - Defines the column name to ungroup.\n   * @returns {void}\n   */\n\n\n  Group.prototype.ungroupColumn = function (columnName) {\n    var gObj = this.parent;\n    var column = this.parent.enableColumnVirtualization ? this.parent.columns.filter(function (c) {\n      return c.field === columnName;\n    })[0] : gObj.getColumnByField(columnName);\n\n    if (isNullOrUndefined(column) || column.allowGrouping === false || this.groupSettings.columns.indexOf(columnName) < 0) {\n      return;\n    }\n\n    if (isActionPrevent(gObj)) {\n      gObj.notify(preventBatch, {\n        instance: this,\n        handler: this.ungroupColumn,\n        arg1: columnName\n      });\n      return;\n    }\n\n    column.visible = true;\n    this.colName = column.field;\n    var columns = JSON.parse(JSON.stringify(this.groupSettings.columns));\n    columns.splice(columns.indexOf(this.colName), 1);\n\n    if (this.sortedColumns.indexOf(columnName) < 0) {\n      for (var i = 0, len = gObj.sortSettings.columns.length; i < len; i++) {\n        if (columnName === gObj.sortSettings.columns[i].field) {\n          gObj.sortSettings.columns.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (this.groupSettings.allowReordering) {\n      this.reorderingColumns = columns;\n    }\n\n    this.groupSettings.columns = columns;\n\n    if (gObj.allowGrouping) {\n      this.isAppliedUnGroup = true;\n      this.parent.dataBind();\n    }\n  };\n  /**\n   * The function used to update groupSettings\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Group.prototype.updateModel = function () {\n    var columns = JSON.parse(JSON.stringify(this.groupSettings.columns));\n    columns = this.reorderingColumns.length ? JSON.parse(JSON.stringify(this.reorderingColumns)) : columns;\n\n    if (this.sortRequired) {\n      if (columns.indexOf(this.colName) === -1) {\n        columns.push(this.colName);\n      }\n\n      this.groupAddSortingQuery(this.colName);\n    }\n\n    this.sortRequired = true;\n    this.parent.groupSettings.columns = columns;\n    this.parent.dataBind();\n  };\n  /**\n   * The function used to trigger onActionComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Group.prototype.onActionComplete = function (e) {\n    if (e.requestType === 'grouping') {\n      this.addColToGroupDrop(this.colName);\n    } else {\n      this.removeColFromGroupDrop(this.colName);\n    }\n\n    var args = this.groupSettings.columns.indexOf(this.colName) > -1 ? {\n      columnName: this.colName,\n      requestType: 'grouping',\n      type: actionComplete\n    } : {\n      requestType: 'ungrouping',\n      type: actionComplete\n    };\n    this.parent.trigger(actionComplete, extend(e, args));\n    this.colName = null;\n  };\n\n  Group.prototype.groupAddSortingQuery = function (colName) {\n    var i = 0;\n\n    while (i < this.parent.sortSettings.columns.length) {\n      if (this.parent.sortSettings.columns[i].field === colName) {\n        break;\n      }\n\n      i++;\n    }\n\n    if (this.parent.sortSettings.columns.length === i) {\n      this.parent.sortSettings.columns.push({\n        field: colName,\n        direction: 'Ascending',\n        isFromGroup: true\n      });\n    } else if (!this.parent.allowSorting) {\n      this.parent.sortSettings.columns[i].direction = 'Ascending';\n    }\n  };\n\n  Group.prototype.createElement = function (field) {\n    var gObj = this.parent;\n    var direction = 'Ascending';\n    var animator = this.parent.createElement('div', {\n      className: 'e-grid-icon e-group-animator'\n    });\n    var groupedColumn = this.parent.createElement('div', {\n      className: 'e-grid-icon e-groupheadercell'\n    });\n    var childDiv = this.parent.createElement('div', {\n      attrs: {\n        'ej-mappingname': field\n      }\n    });\n\n    if (isComplexField(field)) {\n      childDiv.setAttribute('ej-complexname', getComplexFieldID(field));\n    }\n\n    var column = this.parent.getColumnByField(field); //Todo headerTemplateID for grouped column, disableHtmlEncode\n\n    var headerCell = gObj.getColumnHeaderByUid(column.uid); // if (!isNullOrUndefined(column.headerTemplate)) {\n    //     if (column.headerTemplate.indexOf('#') !== -1) {\n    //         childDiv.innerHTML = document.querySelector(column.headerTemplate).innerHTML.trim();\n    //     } else {\n    //         childDiv.innerHTML = column.headerTemplate;\n    //     }\n    //     childDiv.firstElementChild.classList.add('e-grouptext');\n    // } else {\n\n    if (this.groupSettings.allowReordering) {\n      childDiv.appendChild(this.parent.createElement('span', {\n        className: 'e-drag e-icons e-icon-drag',\n        innerHTML: '&nbsp;',\n        attrs: {\n          title: 'Drag',\n          tabindex: '-1',\n          'aria-label': this.l10n.getConstant('GroupedDrag')\n        }\n      }));\n    }\n\n    childDiv.appendChild(this.parent.createElement('span', {\n      className: 'e-grouptext',\n      innerHTML: column.headerText,\n      attrs: {\n        tabindex: '-1',\n        'aria-label': this.l10n.getConstant('GroupedSortIcon') + column.headerText\n      }\n    })); // }\n\n    if (this.groupSettings.showToggleButton) {\n      childDiv.appendChild(this.parent.createElement('span', {\n        className: 'e-togglegroupbutton e-icons e-icon-ungroup e-toggleungroup',\n        innerHTML: '&nbsp;',\n        attrs: {\n          tabindex: '-1',\n          'aria-label': this.l10n.getConstant('UnGroupAria')\n        }\n      }));\n    }\n\n    if (headerCell.querySelectorAll('.e-ascending,.e-descending').length) {\n      direction = headerCell.querySelector('.e-ascending') ? 'Ascending' : 'Descending';\n    }\n\n    childDiv.appendChild(this.parent.createElement('span', {\n      className: 'e-groupsort e-icons ' + ('e-' + direction.toLowerCase() + ' e-icon-' + direction.toLowerCase()),\n      innerHTML: '&nbsp;',\n      attrs: {\n        tabindex: '-1',\n        'aria-label': this.l10n.getConstant('GroupedSortIcon') + column.headerText,\n        role: 'button'\n      }\n    }));\n    childDiv.appendChild(this.parent.createElement('span', {\n      className: 'e-ungroupbutton e-icons e-icon-hide',\n      innerHTML: '&nbsp;',\n      attrs: {\n        title: this.l10n.getConstant('UnGroup'),\n        tabindex: '-1',\n        'aria-label': this.l10n.getConstant('UnGroupIcon') + column.headerText,\n        role: 'button'\n      },\n      styles: this.groupSettings.showUngroupButton ? '' : 'display:none'\n    }));\n    groupedColumn.appendChild(childDiv);\n\n    if (this.groupSettings.allowReordering) {\n      animator.appendChild(groupedColumn);\n      animator.appendChild(this.createSeparator());\n      groupedColumn = animator;\n    }\n\n    return groupedColumn;\n  };\n\n  Group.prototype.addColToGroupDrop = function (field) {\n    var groupElem = isComplexField(field) ? this.parent.element.querySelector('.e-groupdroparea div[ej-complexname=' + getComplexFieldID(field) + ']') : this.parent.element.querySelector('.e-groupdroparea div[ej-mappingname=' + field + ']');\n\n    if (this.groupSettings.allowReordering && groupElem) {\n      return;\n    }\n\n    var column = this.parent.getColumnByField(field);\n\n    if (isNullOrUndefined(column)) {\n      return;\n    }\n\n    var groupedColumn = this.createElement(field);\n\n    if (this.groupSettings.allowReordering) {\n      var index = this.element.getElementsByClassName('e-group-animator').length;\n      groupedColumn.setAttribute('index', index.toString());\n    }\n\n    this.element.appendChild(groupedColumn);\n    var focusModule = this.parent.focusModule;\n    focusModule.setActive(true);\n    var firstContentCellIndex = [0, 0];\n\n    if (focusModule.active.matrix.matrix[firstContentCellIndex[0]][firstContentCellIndex[1]] === 0) {\n      firstContentCellIndex = findCellIndex(focusModule.active.matrix.matrix, firstContentCellIndex, true);\n    }\n\n    focusModule.active.matrix.current = firstContentCellIndex;\n    focusModule.active.getTable().rows[focusModule.active.matrix.current[0]].cells[focusModule.active.matrix.current[1]].focus(); //Todo:  rtl\n  };\n\n  Group.prototype.createSeparator = function () {\n    return this.parent.createElement('span', {\n      className: 'e-nextgroup e-icons e-icon-next',\n      innerHTML: '&nbsp;',\n      attrs: {\n        tabindex: '-1',\n        'aria-label': this.l10n.getConstant('GroupSeperator')\n      },\n      styles: this.groupSettings.showUngroupButton ? '' : 'display:none'\n    });\n  };\n\n  Group.prototype.refreshToggleBtn = function (isRemove) {\n    if (this.groupSettings.showToggleButton) {\n      var headers = [].slice.call(this.parent.getHeaderTable().getElementsByClassName('e-headercelldiv'));\n\n      for (var i = 0, len = headers.length; i < len; i++) {\n        if (!(headers[i].classList.contains('e-emptycell') || headers[i].classList.contains('e-headerchkcelldiv'))) {\n          var column = this.parent.getColumnByUid(headers[i].getAttribute('e-mappinguid'));\n\n          if (!this.parent.showColumnMenu || this.parent.showColumnMenu && !column.showColumnMenu) {\n            if (headers[i].getElementsByClassName('e-grptogglebtn').length) {\n              remove(headers[i].querySelectorAll('.e-grptogglebtn')[0]);\n            }\n\n            if (!isRemove) {\n              headers[i].appendChild(this.parent.createElement('span', {\n                className: 'e-grptogglebtn e-icons ' + (this.groupSettings.columns.indexOf(column.field) > -1 ? 'e-toggleungroup e-icon-ungroup' : 'e-togglegroup e-icon-group'),\n                attrs: {\n                  tabindex: '-1',\n                  'aria-label': isNullOrUndefined(this.l10n) ? this.parent.localeObj.getConstant('GroupButton') : this.l10n.getConstant('GroupButton')\n                }\n              }));\n            }\n          }\n        }\n      }\n    }\n  };\n\n  Group.prototype.removeColFromGroupDrop = function (field) {\n    if (!isNullOrUndefined(this.getGHeaderCell(field))) {\n      var elem = this.getGHeaderCell(field);\n\n      if (this.groupSettings.allowReordering) {\n        var parent_1 = parentsUntil(elem, 'e-group-animator');\n        remove(parent_1);\n      } else {\n        remove(elem);\n      }\n\n      this.updateGroupDropArea();\n    }\n\n    this.isAppliedUnGroup = false;\n  };\n\n  Group.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    for (var _i = 0, _a = Object.keys(e.properties); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'columns':\n          // eslint-disable-next-line no-case-declarations\n          var args = void 0;\n\n          if (this.contentRefresh) {\n            if (!this.isAppliedUnGroup) {\n              if (!this.isAppliedGroup) {\n                this.updateGroupDropArea(true);\n\n                for (var j = 0; j < this.parent.sortSettings.columns.length; j++) {\n                  if (this.parent.sortSettings.columns[j].isFromGroup) {\n                    this.parent.sortSettings.columns.splice(j, 1);\n                    j--;\n                  }\n                }\n\n                for (var i = 0; i < this.groupSettings.columns.length; i++) {\n                  this.colName = this.groupSettings.columns[i];\n                  var col = this.parent.getColumnByField(this.colName);\n                  col.visible = this.parent.groupSettings.showGroupedColumn;\n                  this.groupAddSortingQuery(this.colName);\n\n                  if (i < this.groupSettings.columns.length - 1) {\n                    this.addColToGroupDrop(this.groupSettings.columns[i]);\n                  }\n                }\n              }\n\n              args = {\n                columnName: this.colName,\n                requestType: e.properties[prop].length ? 'grouping' : 'ungrouping',\n                type: actionBegin\n              };\n            } else {\n              args = {\n                columnName: this.colName,\n                requestType: 'ungrouping',\n                type: actionBegin\n              };\n            }\n\n            if (!this.groupSettings.showGroupedColumn) {\n              var columns = e.oldProperties[prop];\n\n              for (var i = 0; i < columns.length; i++) {\n                if (e.properties[prop].indexOf(columns[i]) === -1) {\n                  this.parent.getColumnByField(columns[i]).visible = true;\n                }\n              }\n            }\n\n            this.parent.notify(modelChanged, args);\n          }\n\n          break;\n\n        case 'showDropArea':\n          this.updateGroupDropArea();\n\n          if (this.groupSettings.showDropArea) {\n            this.element.style.display = '';\n            this.parent.headerModule.refreshUI();\n          } else {\n            this.element.style.display = 'none';\n          }\n\n          break;\n\n        case 'showGroupedColumn':\n          this.updateGroupedColumn(this.groupSettings.showGroupedColumn);\n          this.parent.notify(modelChanged, {\n            requestType: 'refresh'\n          });\n          break;\n\n        case 'showUngroupButton':\n          this.updateButtonVisibility(this.groupSettings.showUngroupButton, 'e-ungroupbutton');\n          break;\n\n        case 'showToggleButton':\n          this.updateButtonVisibility(this.groupSettings.showToggleButton, 'e-togglegroupbutton ');\n          this.parent.refreshHeader();\n          break;\n\n        case 'enableLazyLoading':\n          this.parent.freezeRefresh();\n          break;\n      }\n    }\n  };\n\n  Group.prototype.updateGroupedColumn = function (isVisible) {\n    for (var i = 0; i < this.groupSettings.columns.length; i++) {\n      this.parent.getColumnByField(this.groupSettings.columns[i]).visible = isVisible;\n    }\n  };\n\n  Group.prototype.updateButtonVisibility = function (isVisible, className) {\n    var gHeader = [].slice.call(this.element.getElementsByClassName(className));\n\n    for (var i = 0; i < gHeader.length; i++) {\n      gHeader[i].style.display = isVisible ? '' : 'none';\n    }\n  };\n\n  Group.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n    }\n  };\n  /**\n   * To destroy the reorder\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Group.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    if ((this.parent.isDestroyed || !this.parent.allowGrouping) && !this.parent.refreshing) {\n      this.clearGrouping();\n    }\n\n    this.unWireEvent();\n    this.removeEventListener();\n    this.refreshToggleBtn(true);\n\n    if (this.element.parentNode) {\n      remove(this.element);\n    } //call ejdrag and drop destroy\n\n  };\n  /**\n   * Clears all the grouped columns of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  Group.prototype.clearGrouping = function () {\n    var cols = JSON.parse(JSON.stringify(this.groupSettings.columns));\n    this.contentRefresh = false;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (i === len - 1) {\n        this.contentRefresh = true;\n      }\n\n      this.ungroupColumn(cols[i]);\n    }\n\n    this.contentRefresh = true;\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Group.prototype.getModuleName = function () {\n    return 'group';\n  };\n\n  Group.prototype.refreshSortIcons = function () {\n    var gObj = this.parent;\n    var header;\n    var cols = gObj.sortSettings.columns;\n    var gCols = gObj.groupSettings.columns;\n    var fieldNames = this.parent.getColumns().map(function (c) {\n      return c.field;\n    });\n    this.refreshToggleBtn();\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (fieldNames.indexOf(cols[i].field) === -1) {\n        continue;\n      }\n\n      header = gObj.getColumnHeaderByField(cols[i].field);\n\n      if (!gObj.allowSorting && (this.sortedColumns.indexOf(cols[i].field) > -1 || this.groupSettings.columns.indexOf(cols[i].field) > -1)) {\n        classList(header.querySelector('.e-sortfilterdiv'), ['e-ascending', 'e-icon-ascending'], []);\n\n        if (cols.length > 1) {\n          header.querySelector('.e-headercelldiv').appendChild(this.parent.createElement('span', {\n            className: 'e-sortnumber',\n            innerHTML: (i + 1).toString()\n          }));\n        }\n      } else if (this.getGHeaderCell(cols[i].field) && this.getGHeaderCell(cols[i].field).getElementsByClassName('e-groupsort').length) {\n        if (cols[i].direction === 'Ascending') {\n          classList(this.getGHeaderCell(cols[i].field).querySelector('.e-groupsort'), ['e-ascending', 'e-icon-ascending'], ['e-descending', 'e-icon-descending']);\n        } else {\n          classList(this.getGHeaderCell(cols[i].field).querySelector('.e-groupsort'), ['e-descending', 'e-icon-descending'], ['e-ascending', 'e-icon-ascending']);\n        }\n      }\n    }\n\n    for (var i = 0, len = gCols.length; i < len; i++) {\n      if (fieldNames.indexOf(gCols[i]) === -1) {\n        continue;\n      }\n\n      gObj.getColumnHeaderByField(gCols[i]).setAttribute('aria-grouped', 'true');\n    }\n  };\n\n  Group.prototype.getGHeaderCell = function (field) {\n    if (this.element && this.element.querySelector('[ej-mappingname=\"' + field + '\"]')) {\n      return this.element.querySelector('[ej-mappingname=\"' + field + '\"]').parentElement;\n    }\n\n    return null;\n  };\n\n  Group.prototype.onGroupAggregates = function (editedData) {\n    var aggregates = this.iterateGroupAggregates(editedData);\n    var rowData = this.groupGenerator.generateRows(aggregates, {});\n    var summaryRows = this.parent.getRowsObject().filter(function (row$$1) {\n      return !row$$1.isDataRow;\n    });\n    var updateSummaryRows = rowData.filter(function (data) {\n      return !data.isDataRow;\n    });\n\n    if (this.parent.isReact || this.parent.isVue) {\n      this.parent.destroyTemplate(['groupFooterTemplate', 'groupCaptionTemplate', 'footerTemplate']);\n    }\n\n    for (var i = 0; i < updateSummaryRows.length; i++) {\n      var row$$1 = updateSummaryRows[i];\n      var cells = row$$1.cells.filter(function (cell) {\n        return cell.isDataCell;\n      });\n      var args = {\n        cells: cells,\n        data: row$$1.data,\n        dataUid: summaryRows[i] ? summaryRows[i].uid : ''\n      };\n      this.parent.notify(refreshAggregateCell, args);\n    }\n  };\n\n  Group.prototype.iterateGroupAggregates = function (editedData) {\n    var updatedData = editedData instanceof Array ? editedData : [];\n    var rows = this.parent.getRowsObject();\n    var initData = this.parent.getCurrentViewRecords();\n    var deletedCols = [];\n    var changeds = rows.map(function (row$$1) {\n      if (row$$1.edit === 'delete') {\n        deletedCols.push(row$$1.data);\n      }\n\n      return row$$1.changes instanceof Object ? row$$1.changes : row$$1.data;\n    });\n    var field = this.parent.getPrimaryKeyFieldNames()[0];\n    changeds = updatedData.length === 0 ? changeds : updatedData;\n    var mergeData = initData.map(function (item) {\n      var pKeyVal = DataUtil.getObject(field, item);\n      var value;\n      var hasVal = changeds.some(function (cItem) {\n        value = cItem;\n        return pKeyVal === DataUtil.getObject(field, cItem);\n      });\n      return hasVal ? value : item;\n    });\n    var eData = editedData;\n\n    if (!(eData.type && eData.type === 'cancel') && deletedCols.length > 0) {\n      for (var i = 0; i < deletedCols.length; i++) {\n        var index = mergeData.indexOf(deletedCols[i]);\n        mergeData.splice(index, 1);\n      }\n    }\n\n    var aggregates = [];\n    var aggregateRows = this.parent.aggregates;\n\n    for (var j = 0; j < aggregateRows.length; j++) {\n      var row$$1 = aggregateRows[j];\n\n      for (var k = 0; k < row$$1.columns.length; k++) {\n        var aggr = {};\n        var type = row$$1.columns[k].type.toString();\n        aggr = {\n          type: type.toLowerCase(),\n          field: row$$1.columns[k].field\n        };\n        aggregates.push(aggr);\n      }\n    }\n\n    var result;\n    var aggrds;\n    var groupedCols = this.parent.groupSettings.columns;\n\n    for (var l = 0; l < groupedCols.length; l++) {\n      aggrds = result ? result : mergeData;\n      result = DataUtil.group(aggrds, groupedCols[l], aggregates, null, null);\n    }\n\n    return result;\n  };\n\n  Group.prototype.updateExpand = function (args) {\n    var uid = args.uid;\n    var isExpand = args.isExpand;\n    var rows = this.parent.getRowsObject();\n\n    for (var i = 0; i < rows.length; i++) {\n      var row$$1 = rows[i];\n\n      if (row$$1.uid === uid || isNullOrUndefined(uid)) {\n        row$$1.isExpand = isExpand;\n\n        var _loop_1 = function (j) {\n          var childRow = rows[j];\n          var closestParent = void 0;\n\n          if (childRow.parentUid !== row$$1.uid) {\n            closestParent = rows.filter(function (x) {\n              return x.uid === childRow.parentUid;\n            })[0];\n          }\n\n          if (childRow.parentUid === row$$1.uid) {\n            childRow.visible = row$$1.isExpand;\n          } else if (!isNullOrUndefined(closestParent) && childRow.parentUid === closestParent.uid) {\n            if (closestParent.isExpand && closestParent.visible === true) {\n              childRow.visible = true;\n            } else if (closestParent.isExpand && closestParent.visible === false) {\n              childRow.visible = false;\n            }\n          }\n\n          if (isNullOrUndefined(uid)) {\n            return \"break\";\n          }\n        };\n\n        for (var j = i + 1; j < rows.length; j++) {\n          var state_1 = _loop_1(j);\n\n          if (state_1 === \"break\") break;\n        }\n      }\n    }\n\n    this.parent.notify(contentReady, {\n      rows: rows,\n      args: {\n        isFrozen: false,\n        rows: rows\n      }\n    });\n  };\n\n  return Group;\n}();\n/**\n * The `DetailRow` module is used to handle detail template and hierarchy Grid operations.\n */\n\n\nvar DetailRow =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid detail template module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} locator - specifes the serviceLocator\n   * @hidden\n   */\n  function DetailRow(parent, locator) {\n    //Internal variables\n    this.aria = new AriaService();\n    this.childRefs = [];\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.focus = locator.getService('focus');\n    this.parent.on(click, this.clickHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(expandChildGrid, this.expand, this);\n    this.parent.on(columnVisibilityChanged, this.refreshColSpan, this);\n    this.parent.on(destroy, this.destroyChildGrids, this);\n    this.parent.on(destroyChildGrid, this.destroyChildGrids, this);\n  }\n\n  DetailRow.prototype.clickHandler = function (e) {\n    this.toogleExpandcollapse(closest(e.target, 'td'));\n  };\n\n  DetailRow.prototype.toogleExpandcollapse = function (target) {\n    var gObj = this.parent;\n    var table$$1 = this.parent.getContentTable();\n    var lastrowIdx = this.parent.getCurrentViewRecords().length - 1;\n    var parent = 'parentDetails';\n    var childGrid;\n    var isExpanded = target && target.classList.contains('e-detailrowcollapse');\n\n    if (!(target && (target.classList.contains('e-detailrowcollapse') || target.classList.contains('e-detailrowexpand')))) {\n      return;\n    }\n\n    var tr = target.parentElement;\n    var uid = tr.getAttribute('data-uid');\n    var rowObj = gObj.getRowObjectFromUID(uid);\n    var nextRow = this.parent.getContentTable().querySelector(tbody).children[tr.rowIndex + 1];\n\n    if (target.classList.contains('e-detailrowcollapse')) {\n      var data = rowObj.data;\n\n      if (this.isDetailRow(nextRow)) {\n        nextRow.style.display = '';\n        gObj.notify(detailStateChange, {\n          data: data,\n          childGrid: gObj.childGrid,\n          detailElement: target,\n          isExpanded: isExpanded\n        });\n      } else if (gObj.getDetailTemplate() || gObj.childGrid) {\n        var rowId = getUid('grid-row');\n        var detailRow = this.parent.createElement('tr', {\n          className: 'e-detailrow',\n          attrs: {\n            'data-uid': rowId,\n            role: 'row'\n          }\n        });\n        var detailCell = this.parent.createElement('td', {\n          className: 'e-detailcell'\n        });\n        var colSpan = this.parent.getVisibleColumns().length;\n\n        if (this.parent.allowRowDragAndDrop) {\n          colSpan++;\n        }\n\n        detailCell.setAttribute('colspan', colSpan.toString());\n        var row$$1 = new Row({\n          isDataRow: true,\n          isExpand: true,\n          uid: rowId,\n          isDetailRow: true,\n          cells: [new Cell({\n            cellType: CellType.Indent\n          }), new Cell({\n            isDataCell: true,\n            visible: true\n          })]\n        });\n        row$$1.parentUid = rowObj.uid;\n\n        for (var i = 0, len = gObj.groupSettings.columns.length; i < len; i++) {\n          detailRow.appendChild(this.parent.createElement('td', {\n            className: 'e-indentcell'\n          }));\n          row$$1.cells.unshift(new Cell({\n            cellType: CellType.Indent\n          }));\n        }\n\n        detailRow.appendChild(this.parent.createElement('td', {\n          className: 'e-detailindentcell'\n        }));\n        detailRow.appendChild(detailCell);\n        tr.parentNode.insertBefore(detailRow, tr.nextSibling);\n\n        if (gObj.detailTemplate) {\n          var isReactCompiler = this.parent.isReact && typeof gObj.detailTemplate !== 'string';\n          var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n          var detailTemplateID = gObj.element.id + 'detailTemplate';\n\n          if (isReactCompiler || isReactChild) {\n            gObj.getDetailTemplate()(data, gObj, 'detailTemplate', detailTemplateID, null, null, detailCell);\n            this.parent.renderTemplates();\n          } else {\n            appendChildren(detailCell, gObj.getDetailTemplate()(data, gObj, 'detailTemplate', detailTemplateID, undefined, undefined, undefined, this.parent['root']));\n          }\n        } else {\n          childGrid = new Grid(this.getGridModel(gObj, rowObj, gObj.printMode));\n          this.childRefs.push(childGrid);\n\n          if (childGrid.query) {\n            childGrid.query = childGrid.query.clone();\n          }\n\n          childGrid[parent] = {\n            parentID: gObj.element.id,\n            parentPrimaryKeys: gObj.getPrimaryKeyFieldNames(),\n            parentKeyField: gObj.childGrid.queryString,\n            parentKeyFieldValue: isComplexField(gObj.childGrid.queryString) ? getObject(gObj.childGrid.queryString, data) : data[gObj.childGrid.queryString],\n            parentRowData: data\n          };\n\n          if (gObj.isReact) {\n            childGrid.parentDetails.parentInstObj = gObj;\n          } else if (gObj.parentDetails && gObj.parentDetails.parentInstObj && gObj.parentDetails.parentInstObj.isReact) {\n            childGrid.parentDetails.parentInstObj = gObj.parentDetails.parentInstObj;\n          }\n\n          childGrid.isLegacyTemplate = gObj.isReact || gObj.isLegacyTemplate;\n\n          if (gObj.isPrinting) {\n            childGrid.isPrinting = true;\n            childGrid.on(contentReady, this.promiseResolve(childGrid), this);\n            childGrid.on(onEmpty, this.promiseResolve(childGrid), this);\n          }\n\n          rowObj.childGrid = childGrid;\n          var modules = childGrid.getInjectedModules();\n          var injectedModues = gObj.getInjectedModules();\n\n          if (!modules || modules.length !== injectedModues.length) {\n            childGrid.setInjectedModules(injectedModues);\n          }\n\n          var gridElem = this.parent.createElement('div', {\n            id: 'child' + parents(tr, 'e-grid').length + '_grid' + tr.rowIndex + getUid(''),\n            className: 'e-childgrid'\n          });\n          detailCell.appendChild(gridElem);\n          childGrid.appendTo(gridElem);\n        }\n\n        detailRow.appendChild(detailCell);\n\n        if (tr.nextSibling) {\n          tr.parentNode.insertBefore(detailRow, tr.nextSibling);\n        } else {\n          tr.parentNode.appendChild(detailRow);\n        }\n\n        var rowElems = gObj.getRows();\n        var rowObjs = gObj.getRowsObject();\n        rowElems.splice(rowElems.indexOf(tr) + 1, 0, detailRow);\n        rowObjs.splice(rowObjs.indexOf(rowObj) + 1, 0, row$$1);\n        gObj.trigger(detailDataBound, {\n          detailElement: detailCell,\n          data: data,\n          childGrid: childGrid\n        });\n        gObj.notify(detailDataBound, {\n          rows: rowObjs\n        });\n      }\n\n      classList(target, ['e-detailrowexpand'], ['e-detailrowcollapse']);\n      classList(target.firstElementChild, ['e-dtdiagonaldown', 'e-icon-gdownarrow'], ['e-dtdiagonalright', 'e-icon-grightarrow']);\n      rowObj.isExpand = true;\n\n      if (target.classList.contains('e-lastrowcell') && this.parent.getContent().clientHeight > table$$1.scrollHeight) {\n        removeClass(target.parentElement.querySelectorAll('td'), 'e-lastrowcell');\n        var detailrowIdx = table$$1.querySelector(tbody).getElementsByClassName('e-detailrow').length - 1;\n        addClass(table$$1.querySelector(tbody).getElementsByClassName('e-detailrow')[detailrowIdx].childNodes, ['e-lastrowcell']);\n        this.lastrowcell = true;\n      }\n\n      this.aria.setExpand(target, true);\n      target.firstElementChild.setAttribute('title', 'expanded');\n    } else {\n      if (this.isDetailRow(nextRow)) {\n        nextRow.style.display = 'none';\n        gObj.notify(detailStateChange, {\n          data: rowObj.data,\n          childGrid: gObj.childGrid,\n          detailElement: target,\n          isExpanded: isExpanded\n        });\n      }\n\n      classList(target, ['e-detailrowcollapse'], ['e-detailrowexpand']);\n      classList(target.firstElementChild, ['e-dtdiagonalright', 'e-icon-grightarrow'], ['e-dtdiagonaldown', 'e-icon-gdownarrow']);\n\n      if (parseInt(tr.getAttribute(dataRowIndex), 10) === lastrowIdx && this.lastrowcell) {\n        addClass(target.parentElement.querySelectorAll('td'), 'e-lastrowcell');\n        this.lastrowcell = false;\n      }\n\n      rowObj.isExpand = false;\n      this.aria.setExpand(target, false);\n      target.firstElementChild.setAttribute('title', 'collapsed');\n    }\n\n    if (!isNullOrUndefined(gObj.detailTemplate)) {\n      gObj.updateVisibleExpandCollapseRows();\n      gObj.notify(refreshExpandandCollapse, {\n        rows: gObj.getRowsObject()\n      });\n    }\n  };\n  /**\n   * @hidden\n   * @param {IGrid} gObj - specifies the grid Object\n   * @param {Row<Column>}rowObj - specifies the row object\n   * @param {string} printMode - specifies the printmode\n   * @returns {Object} returns the object\n   */\n\n\n  DetailRow.prototype.getGridModel = function (gObj, rowObj, printMode) {\n    var gridModel;\n\n    if (gObj.isPrinting && rowObj.isExpand && gObj.expandedRows && gObj.expandedRows[rowObj.index] && gObj.expandedRows[rowObj.index].gridModel) {\n      gObj.expandedRows[rowObj.index].gridModel.hierarchyPrintMode = gObj.childGrid.hierarchyPrintMode;\n      gridModel = gObj.expandedRows[rowObj.index].gridModel;\n    } else {\n      if (gObj.isPrinting && gObj.childGrid.allowPaging) {\n        gObj.childGrid.allowPaging = printMode === 'CurrentPage';\n      }\n\n      gridModel = extend({}, {}, gObj.childGrid, true);\n    }\n\n    return gridModel;\n  };\n\n  DetailRow.prototype.promiseResolve = function (grid) {\n    var _this = this;\n\n    return function () {\n      grid.off(contentReady, _this.promiseResolve);\n      grid.off(onEmpty, _this.promiseResolve);\n      grid.notify(hierarchyPrint, {});\n    };\n  };\n\n  DetailRow.prototype.isDetailRow = function (row$$1) {\n    return row$$1 && row$$1.classList.contains('e-detailrow');\n  };\n\n  DetailRow.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.parent.off(click, this.clickHandler);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(expandChildGrid, this.expand);\n    this.parent.off(columnVisibilityChanged, this.refreshColSpan);\n    this.parent.off(destroy, this.destroyChildGrids);\n    this.parent.off(destroyChildGrid, this.destroyChildGrids);\n  };\n\n  DetailRow.prototype.getTDfromIndex = function (index, className) {\n    var tr = this.parent.getDataRows()[index];\n\n    if (tr && tr.querySelector(className)) {\n      return tr.querySelector(className);\n    }\n\n    return null;\n  };\n  /**\n   * Expands a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the collapsed element to expand.\n   * @returns {void}\n   */\n\n\n  DetailRow.prototype.expand = function (target) {\n    if (!isNaN(target)) {\n      target = this.getTDfromIndex(target, '.e-detailrowcollapse');\n    }\n\n    if (target && target.classList.contains('e-detailrowcollapse')) {\n      this.toogleExpandcollapse(target);\n    }\n  };\n  /**\n   * Collapses a detail row with the given target.\n   *\n   * @param  {Element} target - Defines the expanded element to collapse.\n   * @returns {void}\n   */\n\n\n  DetailRow.prototype.collapse = function (target) {\n    if (!isNaN(target)) {\n      target = this.getTDfromIndex(target, '.e-detailrowexpand');\n    }\n\n    if (target && target.classList.contains('e-detailrowexpand')) {\n      this.toogleExpandcollapse(target);\n    }\n  };\n  /**\n   * Expands all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  DetailRow.prototype.expandAll = function () {\n    this.expandCollapse(true);\n    this.parent.trigger(actionComplete, {\n      requestType: 'expandAllComplete',\n      type: actionComplete,\n      moduleObj: this\n    });\n  };\n  /**\n   * Collapses all the detail rows of the Grid.\n   *\n   * @returns {void}\n   */\n\n\n  DetailRow.prototype.collapseAll = function () {\n    this.expandCollapse(false);\n    this.parent.trigger(actionComplete, {\n      requestType: 'collapseAllComplete',\n      type: actionComplete,\n      moduleObj: this\n    });\n  };\n\n  DetailRow.prototype.expandCollapse = function (isExpand) {\n    var td;\n    var rows = this.parent.getDataRows();\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      td = rows[i].querySelector('.e-detailrowcollapse, .e-detailrowexpand');\n\n      if (isExpand) {\n        this.expand(td);\n      } else {\n        this.collapse(td);\n      }\n    }\n  };\n\n  DetailRow.prototype.keyPressHandler = function (e) {\n    var gObj = this.parent;\n\n    switch (e.action) {\n      case 'ctrlDownArrow':\n        this.expandAll();\n        break;\n\n      case 'ctrlUpArrow':\n        this.collapseAll();\n        break;\n\n      case 'altUpArrow':\n      case 'altDownArrow':\n        // eslint-disable-next-line no-case-declarations\n        var selected = gObj.allowSelection ? gObj.getSelectedRowIndexes() : [];\n\n        if (selected.length) {\n          var dataRow = gObj.getDataRows()[selected[selected.length - 1]];\n          var td = dataRow.querySelector('.e-detailrowcollapse, .e-detailrowexpand');\n\n          if (e.action === 'altDownArrow') {\n            this.expand(td);\n          } else {\n            this.collapse(td);\n          }\n        }\n\n        break;\n\n      case 'enter':\n        if (this.parent.isEdit) {\n          return;\n        } // eslint-disable-next-line no-case-declarations\n\n\n        var element = this.focus.getFocusedElement();\n\n        if (element && (element.classList.contains('e-icon-grightarrow') || element.classList.contains('e-icon-gdownarrow'))) {\n          element = element.parentElement;\n        }\n\n        if (element && !element.classList.contains('e-detailrowcollapse') && !element.classList.contains('e-detailrowexpand')) {\n          break;\n        }\n\n        this.toogleExpandcollapse(element);\n        break;\n    }\n  };\n\n  DetailRow.prototype.refreshColSpan = function () {\n    var detailrows = this.parent.contentModule.getTable().querySelectorAll('tr.e-detailrow');\n    var colSpan = this.parent.getVisibleColumns().length;\n\n    for (var i = 0; i < detailrows.length; i++) {\n      detailrows[i].querySelector('.e-detailcell').setAttribute('colspan', colSpan + '');\n    }\n  };\n\n  DetailRow.prototype.destroyChildGrids = function () {\n    var rows = this.parent.getRowsObject();\n\n    for (var i = 0; i < rows.length; i++) {\n      rows[i].childGrid = null;\n    }\n\n    for (var i = 0; i < this.childRefs.length; i++) {\n      if (!this.childRefs[i].isDestroyed) {\n        this.childRefs[i].destroy();\n      }\n    }\n\n    this.childRefs = [];\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  DetailRow.prototype.getModuleName = function () {\n    return 'detailRow';\n  };\n\n  return DetailRow;\n}();\n/**\n *\n * The `Toolbar` module is used to handle ToolBar actions.\n */\n\n\nvar Toolbar$1 =\n/** @__PURE__ @class */\nfunction () {\n  function Toolbar$$1(parent, serviceLocator) {\n    this.predefinedItems = {};\n    this.isSearched = false;\n    this.items = ['Add', 'Edit', 'Update', 'Delete', 'Cancel', 'Print', 'Search', 'ColumnChooser', 'PdfExport', 'ExcelExport', 'CsvExport', 'WordExport'];\n    this.parent = parent;\n    this.gridID = parent.element.id;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  Toolbar$$1.prototype.render = function () {\n    this.l10n = this.serviceLocator.getService('localization');\n    var preItems = ['Add', 'Edit', 'Update', 'Delete', 'Cancel', 'Print', 'PdfExport', 'ExcelExport', 'WordExport', 'CsvExport'];\n    var isAdaptive = this.parent.enableAdaptiveUI;\n    var excludingItems = ['Edit', 'Delete', 'Update', 'Cancel'];\n\n    for (var _i = 0, preItems_1 = preItems; _i < preItems_1.length; _i++) {\n      var item = preItems_1[_i];\n      var itemStr = item.toLowerCase();\n      var localeName = itemStr[0].toUpperCase() + itemStr.slice(1);\n      this.predefinedItems[item] = {\n        id: this.gridID + '_' + itemStr,\n        prefixIcon: 'e-' + itemStr,\n        text: this.l10n.getConstant(localeName),\n        tooltipText: this.l10n.getConstant(localeName)\n      };\n\n      if (isAdaptive) {\n        this.predefinedItems[item].text = '';\n        this.predefinedItems[item].visible = excludingItems.indexOf(item) === -1;\n      }\n    }\n\n    this.predefinedItems.Search = {\n      id: this.gridID + '_search',\n      tooltipText: this.l10n.getConstant('Search'),\n      align: 'Right',\n      cssClass: 'e-search-wrapper',\n      type: 'Input'\n    };\n    this.predefinedItems.ColumnChooser = {\n      id: this.gridID + '_' + 'columnchooser',\n      cssClass: 'e-cc e-ccdiv e-cc-toolbar',\n      suffixIcon: 'e-' + 'columnchooser-btn',\n      text: isAdaptive ? '' : this.l10n.getConstant('Columnchooser'),\n      tooltipText: this.l10n.getConstant('Columnchooser'),\n      align: 'Right'\n    };\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar') {\n        this.predefinedItems.responsiveFilter = {\n          id: this.gridID + '_' + 'responsivefilter',\n          cssClass: 'e-gridresponsiveicons e-icons',\n          suffixIcon: 'e-' + 'resfilter-icon',\n          tooltipText: this.l10n.getConstant('FilterButton')\n        };\n      }\n\n      if (this.parent.allowSorting) {\n        this.predefinedItems.responsiveSort = {\n          id: this.gridID + '_' + 'responsivesort',\n          cssClass: 'e-gridresponsiveicons e-icons',\n          suffixIcon: 'e-' + 'ressort-icon',\n          tooltipText: this.l10n.getConstant('Sort')\n        };\n      }\n    }\n\n    if (this.parent.enableAdaptiveUI && this.parent.toolbar && this.parent.toolbar.indexOf('Search') > -1) {\n      this.predefinedItems.responsiveBack = {\n        id: this.gridID + '_' + 'responsiveback',\n        cssClass: 'e-gridresponsiveicons e-icons',\n        suffixIcon: 'e-' + 'resback-icon',\n        visible: false\n      };\n    }\n\n    this.createToolbar();\n  };\n  /**\n   * Gets the toolbar of the Grid.\n   *\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  Toolbar$$1.prototype.getToolbar = function () {\n    return this.toolbar.element;\n  };\n  /**\n   * Destroys the ToolBar.\n   *\n   * @function destroy\n   * @returns {void}\n   */\n\n\n  Toolbar$$1.prototype.destroy = function () {\n    if (this.toolbar && !this.toolbar.isDestroyed) {\n      if (!this.toolbar.element) {\n        this.parent.destroyTemplate(['toolbarTemplate']);\n\n        if (this.parent.isReact) {\n          this.parent.renderTemplates();\n        }\n      } else {\n        this.toolbar.off('render-react-toolbar-template', this.addReactToolbarPortals);\n        this.toolbar.destroy();\n      }\n\n      this.unWireEvent();\n      this.removeEventListener();\n\n      if (this.element.parentNode) {\n        remove(this.element);\n      }\n    }\n  };\n\n  Toolbar$$1.prototype.bindSearchEvents = function () {\n    this.searchElement = select('#' + this.gridID + '_searchbar', this.element);\n    this.wireEvent();\n    this.refreshToolbarItems();\n\n    if (this.parent.searchSettings) {\n      this.updateSearchBox();\n    }\n  };\n\n  Toolbar$$1.prototype.toolbarCreated = function (isNormal) {\n    if (this.element.querySelector('.e-search-wrapper')) {\n      if (!this.parent.enableAdaptiveUI || isNormal) {\n        var classList$$1 = this.parent.cssClass ? 'e-input-group e-search ' + this.parent.cssClass : 'e-input-group e-search';\n        this.element.querySelector('.e-search-wrapper').innerHTML = '<div class=\"' + classList$$1 + '\" role=\"search\">\\\n                    <input id=\"' + this.gridID + '_searchbar\" class=\"e-input e-search\" name=\"input\" type=\"search\" \\\n                    placeholder= \"' + this.l10n.getConstant('Search') + '\"/>\\\n                    <span id=\"' + this.gridID + '_clearbutton\" class=\"e-input-group-icon e-icons e-sicon e-clear-icon e-clear-icon-hide\" \\\n                    tabindex=\"-1\" title=\"' + this.l10n.getConstant('Clear') + '\" aria-label= \"clear\" role= \"clear\"></span>\\\n                    <span id=\"' + this.gridID + '_searchbutton\" class=\"e-input-group-icon e-search-icon e-icons\" \\\n                    tabindex=\"-1\" title=\"' + this.l10n.getConstant('Search') + '\" aria-label= \"search\" role= \"search\"></span> \\\n                    </div>';\n      } else {\n        this.element.querySelector('.e-search-wrapper').innerHTML = '<span id=\"' + this.gridID + '_clearbutton\" class=\"e-input-group-icon e-icons e-sicon e-clear-icon e-clear-icon-hide\" \\\n                    tabindex=\"-1\" title=\"' + this.l10n.getConstant('Clear') + '\" aria-label= \"clear\"></span>\\\n                    <span id=\"' + this.gridID + '_searchbutton\" class=\"e-input-group-icon e-search-icon e-icons\" \\\n                    tabindex=\"-1\" title=\"' + this.l10n.getConstant('Search') + '\" aria-label= \"search\"></span> \\\n                    </div>';\n      }\n    }\n\n    this.bindSearchEvents();\n  };\n\n  Toolbar$$1.prototype.createToolbar = function () {\n    var items = this.getItems();\n    this.toolbar = new Toolbar({\n      items: items,\n      clicked: this.toolbarClickHandler.bind(this),\n      enablePersistence: this.parent.enablePersistence,\n      enableRtl: this.parent.enableRtl,\n      created: this.toolbarCreated.bind(this),\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    });\n    this.toolbar.isReact = this.parent.isReact;\n    this.toolbar.on('render-react-toolbar-template', this.addReactToolbarPortals, this);\n    var isStringTemplate = 'isStringTemplate';\n    this.toolbar[isStringTemplate] = true;\n    var viewStr = 'viewContainerRef';\n    var registerTemp = 'registeredTemplate';\n\n    if (this.parent[viewStr]) {\n      this.toolbar[registerTemp] = {};\n      this.toolbar[viewStr] = this.parent[viewStr];\n    }\n\n    this.element = this.parent.createElement('div', {\n      id: this.gridID + '_toolbarItems'\n    });\n\n    if (this.parent.enableAdaptiveUI) {\n      this.element.classList.add('e-res-toolbar');\n    }\n\n    if (this.parent.toolbarTemplate) {\n      if (typeof this.parent.toolbarTemplate === 'string') {\n        this.toolbar.appendTo(this.parent.toolbarTemplate);\n        this.element = this.toolbar.element;\n      } else {\n        var isReactCompiler = this.parent.isReact && typeof this.parent.toolbarTemplate !== 'string';\n        var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n        var ID = this.parent.element.id + 'toolbarTemplate';\n\n        if (isReactCompiler || isReactChild) {\n          templateCompiler(this.parent.toolbarTemplate)({}, this.parent, 'toolbarTemplate', ID, null, null, this.element);\n          this.parent.renderTemplates();\n        } else {\n          appendChildren(this.element, templateCompiler(this.parent.toolbarTemplate)({}, this.parent, 'toolbarTemplate'));\n        }\n      }\n    } else {\n      this.toolbar.appendTo(this.element);\n    }\n\n    this.parent.element.insertBefore(this.element, this.parent.getHeaderContent());\n    var tlbrLeftElement = this.element.querySelector(\".e-toolbar-left\");\n    var tlbrCenterElement = this.element.querySelector(\".e-toolbar-center\");\n    var tlbrRightElement = this.element.querySelector(\".e-toolbar-right\");\n    var tlbrElement = this.element;\n    var tlbrLeftWidth = tlbrLeftElement ? tlbrLeftElement.clientWidth : 0;\n    var tlbrCenterWidth = tlbrCenterElement ? tlbrCenterElement.clientWidth : 0;\n    var tlbrRightWidth = tlbrRightElement ? tlbrRightElement.clientWidth : 0;\n    var tlbrWidth = tlbrElement ? tlbrElement.clientWidth : 0;\n\n    if (tlbrLeftWidth > tlbrWidth || tlbrCenterWidth > tlbrWidth || tlbrRightWidth > tlbrWidth) {\n      this.toolbar.refreshOverflow();\n    }\n  };\n\n  Toolbar$$1.prototype.addReactToolbarPortals = function (args) {\n    if (this.parent.isReact && args) {\n      this.parent.portals = this.parent.portals.concat(args);\n      this.parent.renderTemplates();\n    }\n  };\n\n  Toolbar$$1.prototype.renderResponsiveSearch = function (isRender) {\n    if (isRender) {\n      this.toolbarCreated(true);\n      this.refreshResponsiveToolbarItems(ResponsiveToolbarAction.isSearch);\n      this.searchElement = select('#' + this.gridID + '_searchbar', this.element);\n      var right = parentsUntil(this.searchElement, 'e-toolbar-right');\n      right.classList.add('e-responsive-right');\n\n      if (this.parent.searchSettings) {\n        this.updateSearchBox();\n      }\n\n      this.searchBoxObj.searchFocus({\n        target: this.searchElement\n      });\n      this.searchElement.focus();\n    } else {\n      this.refreshResponsiveToolbarItems(ResponsiveToolbarAction.isInitial);\n    }\n  };\n\n  Toolbar$$1.prototype.refreshResponsiveToolbarItems = function (action) {\n    if (action === ResponsiveToolbarAction.isInitial) {\n      var id = this.parent.element.id;\n      var items = [id + '_edit', id + '_delete'];\n      var selectedRecords = this.parent.getSelectedRowIndexes();\n      var excludingItems = [id + '_responsiveback', id + '_update', id + '_cancel'];\n\n      for (var _i = 0, _a = this.toolbar.items; _i < _a.length; _i++) {\n        var item = _a[_i];\n        var toolbarEle = this.toolbar.element.querySelector('#' + item.id);\n\n        if (toolbarEle) {\n          if (items.indexOf(item.id) > -1) {\n            if (selectedRecords.length) {\n              toolbarEle.parentElement.classList.remove('e-hidden');\n            } else {\n              toolbarEle.parentElement.classList.add('e-hidden');\n            }\n          } else {\n            if (excludingItems.indexOf(item.id) === -1) {\n              toolbarEle.parentElement.classList.remove('e-hidden');\n            } else {\n              toolbarEle.parentElement.classList.add('e-hidden');\n            }\n          }\n        }\n      }\n\n      if (this.searchElement) {\n        var right = parentsUntil(this.searchElement, 'e-toolbar-right');\n        right.classList.remove('e-responsive-right');\n        this.toolbarCreated(false);\n        this.unWireEvent();\n        this.searchElement = undefined;\n      }\n    }\n\n    if (action === ResponsiveToolbarAction.isSearch) {\n      var items = [this.parent.element.id + '_responsiveback', this.parent.element.id + '_search'];\n\n      for (var _b = 0, _c = this.toolbar.items; _b < _c.length; _b++) {\n        var item = _c[_b];\n        var toolbarEle = this.toolbar.element.querySelector('#' + item.id);\n\n        if (toolbarEle) {\n          if (items.indexOf(item.id) > -1) {\n            toolbarEle.parentElement.classList.remove('e-hidden');\n          } else {\n            toolbarEle.parentElement.classList.add('e-hidden');\n          }\n        }\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  Toolbar$$1.prototype.refreshToolbarItems = function (args) {\n    var gObj = this.parent;\n    var enableItems = [];\n    var disableItems = [];\n    var edit = gObj.editSettings;\n    var hasData = gObj.currentViewData && gObj.currentViewData.length;\n\n    if (edit.allowAdding) {\n      enableItems.push(this.gridID + '_add');\n    } else {\n      disableItems.push(this.gridID + '_add');\n    }\n\n    if (edit.allowEditing && hasData) {\n      enableItems.push(this.gridID + '_edit');\n    } else {\n      disableItems.push(this.gridID + '_edit');\n    }\n\n    if (edit.allowDeleting && hasData) {\n      enableItems.push(this.gridID + '_delete');\n    } else {\n      disableItems.push(this.gridID + '_delete');\n    }\n\n    if (gObj.editSettings.mode === 'Batch') {\n      if (gObj.element.getElementsByClassName('e-updatedtd').length && (edit.allowAdding || edit.allowEditing)) {\n        enableItems.push(this.gridID + '_update');\n        enableItems.push(this.gridID + '_cancel');\n      } else {\n        disableItems.push(this.gridID + '_update');\n        disableItems.push(this.gridID + '_cancel');\n      }\n    } else {\n      if (gObj.isEdit && (edit.allowAdding || edit.allowEditing)) {\n        enableItems = [this.gridID + '_update', this.gridID + '_cancel'];\n        disableItems = [this.gridID + '_add', this.gridID + '_edit', this.gridID + '_delete'];\n      } else {\n        disableItems.push(this.gridID + '_update');\n        disableItems.push(this.gridID + '_cancel');\n      }\n    }\n\n    this.enableItems(enableItems, true);\n    this.enableItems(disableItems, false);\n  };\n\n  Toolbar$$1.prototype.getItems = function () {\n    var items = [];\n    var toolbarItems = this.parent.toolbar || [];\n\n    if (typeof this.parent.toolbar === 'string') {\n      return [];\n    }\n\n    if (this.parent.rowRenderingMode === 'Vertical') {\n      if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar') {\n        items.push(this.getItemObject('responsiveFilter'));\n      }\n\n      if (this.parent.allowSorting) {\n        items.push(this.getItemObject('responsiveSort'));\n      }\n    }\n\n    for (var _i = 0, toolbarItems_1 = toolbarItems; _i < toolbarItems_1.length; _i++) {\n      var item = toolbarItems_1[_i];\n\n      switch (typeof item) {\n        case 'number':\n          items.push(this.getItemObject(this.items[item]));\n          break;\n\n        case 'string':\n          items.push(this.getItemObject(item));\n          break;\n\n        default:\n          items.push(this.getItem(item));\n      }\n    }\n\n    if (this.parent.enableAdaptiveUI && this.parent.toolbar && this.parent.toolbar.indexOf('Search') > -1) {\n      items.push(this.getItemObject('responsiveBack'));\n    }\n\n    return items;\n  };\n\n  Toolbar$$1.prototype.getItem = function (itemObject) {\n    var item = this.predefinedItems[itemObject.text];\n    return item ? extend(item, item, itemObject) : itemObject;\n  };\n\n  Toolbar$$1.prototype.getItemObject = function (itemName) {\n    return this.predefinedItems[itemName] || {\n      text: itemName,\n      id: this.gridID + '_' + itemName\n    };\n  };\n  /**\n   * Enables or disables ToolBar items.\n   *\n   * @param {string[]} items - Defines the collection of itemID of ToolBar items.\n   * @param {boolean} isEnable - Defines the items to be enabled or disabled.\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Toolbar$$1.prototype.enableItems = function (items, isEnable) {\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n      var item = items_1[_i];\n      var element = select('#' + item, this.element);\n\n      if (element) {\n        this.toolbar.enableItems(element.parentElement, isEnable);\n      }\n    }\n  };\n\n  Toolbar$$1.prototype.toolbarClickHandler = function (args) {\n    var _this = this;\n\n    var gObj = this.parent;\n    var gID = this.gridID;\n    extend(args, {\n      cancel: false\n    });\n    var newArgs = args;\n    var originalEvent = args.originalEvent;\n    gObj.trigger(toolbarClick, newArgs, function (toolbarargs) {\n      toolbarargs.originalEvent = toolbarargs.originalEvent ? toolbarargs.originalEvent : originalEvent;\n\n      if (!toolbarargs.cancel) {\n        switch (!isNullOrUndefined(toolbarargs.item) && toolbarargs.item.id) {\n          case gID + '_print':\n            gObj.print();\n            break;\n\n          case gID + '_edit':\n            gObj.startEdit();\n            break;\n\n          case gID + '_update':\n            gObj.endEdit();\n            break;\n\n          case gID + '_cancel':\n            gObj.closeEdit();\n            break;\n\n          case gID + '_add':\n            gObj.addRecord();\n            break;\n\n          case gID + '_delete':\n            gObj.deleteRecord();\n            break;\n\n          case gID + '_search':\n            if (toolbarargs.originalEvent.target.id === gID + '_searchbutton' && _this.searchElement) {\n              _this.search();\n            } else if (gObj.enableAdaptiveUI && !_this.searchElement && (toolbarargs.originalEvent.target.classList.contains('e-search-wrapper') || toolbarargs.originalEvent.target.id === gID + '_searchbutton')) {\n              _this.renderResponsiveSearch(true);\n            } else if (toolbarargs.originalEvent.target.id === gID + '_clearbutton' && _this.searchElement) {\n              _this.searchElement.value = '';\n\n              _this.sIcon.classList.add('e-clear-icon-hide');\n\n              if (_this.isSearched) {\n                _this.parent.search(_this.searchElement.value);\n\n                _this.isSearched = false;\n              }\n            }\n\n            break;\n\n          case gID + '_columnchooser':\n            /* eslint-disable */\n            var tarElement = _this.parent.element.querySelector('.e-ccdiv');\n\n            var y = tarElement.getBoundingClientRect().top;\n            var x = tarElement.getBoundingClientRect().left;\n            var targetEle = toolbarargs.originalEvent.target;\n            /* eslint-enable */\n\n            y = tarElement.getBoundingClientRect().top + tarElement.offsetTop;\n            gObj.createColumnchooser(x, y, targetEle);\n            break;\n\n          case gID + '_responsivefilter':\n            gObj.showResponsiveCustomFilter();\n            break;\n\n          case gID + '_responsivesort':\n            gObj.showResponsiveCustomSort();\n            break;\n\n          case gID + '_responsiveback':\n            _this.renderResponsiveSearch(false);\n\n            break;\n        }\n      }\n    });\n  };\n\n  Toolbar$$1.prototype.modelChanged = function (e) {\n    if (e.module === 'edit') {\n      this.refreshToolbarItems();\n    }\n  };\n\n  Toolbar$$1.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName() || !this.parent.toolbar) {\n      return;\n    }\n\n    if (this.element) {\n      remove(this.element);\n    }\n\n    this.render();\n  };\n\n  Toolbar$$1.prototype.keyUpHandler = function (e) {\n    if (e.keyCode === 13) {\n      this.search();\n    }\n\n    if (this.searchElement) {\n      this.sIcon = this.searchElement.parentElement.querySelector('.e-clear-icon');\n\n      if (this.searchElement.value.length && !isNullOrUndefined(this.sIcon)) {\n        this.sIcon.classList.remove('e-clear-icon-hide');\n      } else {\n        this.sIcon.classList.add('e-clear-icon-hide');\n      }\n    }\n  };\n\n  Toolbar$$1.prototype.search = function () {\n    this.isSearched = true;\n    this.parent.search(this.searchElement.value);\n  };\n\n  Toolbar$$1.prototype.updateSearchBox = function () {\n    if (this.searchElement) {\n      this.searchElement.value = this.parent.searchSettings.key;\n    }\n  };\n\n  Toolbar$$1.prototype.wireEvent = function () {\n    if (this.searchElement) {\n      this.searchBoxObj = new SearchBox(this.searchElement);\n      EventHandler.add(this.searchElement, 'keyup', this.keyUpHandler, this);\n      this.searchBoxObj.wireEvent();\n    }\n\n    EventHandler.add(this.element, 'focusin', this.onFocusIn, this);\n    EventHandler.add(this.element, 'focusout', this.onFocusOut, this);\n  };\n\n  Toolbar$$1.prototype.unWireEvent = function () {\n    if (this.searchElement) {\n      EventHandler.remove(this.searchElement, 'keyup', this.keyUpHandler);\n      this.searchBoxObj.unWireEvent();\n    }\n\n    EventHandler.remove(this.element, 'focusin', this.onFocusIn);\n    EventHandler.remove(this.element, 'focusout', this.onFocusOut);\n  };\n\n  Toolbar$$1.prototype.onFocusIn = function (e) {\n    var currentInfo = this.parent.focusModule.currentInfo;\n\n    if (currentInfo && currentInfo.element) {\n      removeClass([currentInfo.element, currentInfo.elementToFocus], ['e-focused', 'e-focus']);\n      currentInfo.element.tabIndex = -1;\n    }\n\n    e.target.tabIndex = 0;\n  };\n\n  Toolbar$$1.prototype.onFocusOut = function (e) {\n    e.target.tabIndex = -1;\n  };\n\n  Toolbar$$1.prototype.setFocusToolbarItem = function (element) {\n    var elementToFocus = element.querySelector('.e-btn,.e-input');\n\n    if (!elementToFocus && this.parent.enableAdaptiveUI && !this.searchElement && element.classList.contains('e-search-wrapper')) {\n      elementToFocus = element.querySelector('#' + this.gridID + '_searchbutton');\n    }\n\n    elementToFocus.focus();\n  };\n\n  Toolbar$$1.prototype.getFocusableToolbarItems = function () {\n    return this.element.querySelectorAll('.e-toolbar-item:not(.e-overlay):not(.e-hidden)');\n  };\n\n  Toolbar$$1.prototype.keyPressedHandler = function (e) {\n    if (e.target && parentsUntil(e.target, 'e-toolbar-item')) {\n      var targetParent = parentsUntil(e.target, 'e-toolbar-item');\n      var focusableToolbarItems = this.getFocusableToolbarItems();\n\n      if (e.action === 'tab' || e.action === 'shiftTab') {\n        if (e.action === 'tab' && targetParent === focusableToolbarItems[focusableToolbarItems.length - 1] || e.action === 'shiftTab' && targetParent === focusableToolbarItems[0]) {\n          return;\n        }\n\n        for (var i = 0; i < focusableToolbarItems.length; i++) {\n          if (targetParent === focusableToolbarItems[i]) {\n            e.preventDefault();\n            var index = e.action === 'tab' ? i + 1 : i - 1;\n            this.setFocusToolbarItem(focusableToolbarItems[index]);\n            return;\n          }\n        }\n      }\n\n      if (e.action === 'enter') {\n        if (this.parent.enableAdaptiveUI && !this.searchElement && e.target.id === this.gridID + '_searchbutton') {\n          this.renderResponsiveSearch(true);\n        }\n      }\n    }\n  };\n\n  Toolbar$$1.prototype.reRenderToolbar = function () {\n    if (this.element) {\n      remove(this.element);\n    }\n\n    this.render();\n  };\n\n  Toolbar$$1.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: setFullScreenDialog,\n      handler: this.reRenderToolbar\n    }, {\n      event: initialEnd,\n      handler: this.render\n    }, {\n      event: uiUpdate,\n      handler: this.onPropertyChanged\n    }, {\n      event: inBoundModelChanged,\n      handler: this.updateSearchBox.bind(this)\n    }, {\n      event: modelChanged,\n      handler: this.refreshToolbarItems\n    }, {\n      event: toolbarRefresh,\n      handler: this.refreshToolbarItems\n    }, {\n      event: inBoundModelChanged,\n      handler: this.modelChanged\n    }, {\n      event: dataBound,\n      handler: this.refreshToolbarItems\n    }, {\n      event: click,\n      handler: this.removeResponsiveSearch\n    }, {\n      event: rowModeChange,\n      handler: this.reRenderToolbar\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }, {\n      event: keyPressed,\n      handler: this.keyPressedHandler\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.rowSelectedFunction = this.rowSelected.bind(this);\n    this.rowDeSelectedFunction = this.rowSelected.bind(this);\n    this.parent.addEventListener(rowSelected, this.rowSelectedFunction);\n    this.parent.addEventListener(rowDeselected, this.rowDeSelectedFunction);\n  };\n\n  Toolbar$$1.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n    this.parent.removeEventListener(rowSelected, this.rowSelectedFunction);\n    this.parent.removeEventListener(rowDeselected, this.rowDeSelectedFunction);\n  };\n\n  Toolbar$$1.prototype.removeResponsiveSearch = function (e) {\n    var target = e.target;\n    var isSearch = target.classList.contains('e-search-icon') || target.classList.contains('e-search-wrapper');\n\n    if (this.parent.enableAdaptiveUI && !isSearch && this.searchElement && !parentsUntil(e.target, 'e-res-toolbar')) {\n      this.renderResponsiveSearch(false);\n    }\n  };\n\n  Toolbar$$1.prototype.rowSelected = function () {\n    if (this.parent.enableAdaptiveUI) {\n      this.refreshResponsiveToolbarItems(ResponsiveToolbarAction.isInitial);\n    }\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  Toolbar$$1.prototype.getModuleName = function () {\n    return 'toolbar';\n  };\n\n  return Toolbar$$1;\n}();\n\nvar __extends$22 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Footer module is used to render grid content\n *\n * @hidden\n */\n\n\nvar FooterRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$22(FooterRenderer, _super);\n\n  function FooterRenderer(gridModule, serviceLocator) {\n    var _this = _super.call(this, gridModule, serviceLocator) || this;\n\n    _this.aggregates = {};\n    _this.parent = gridModule;\n    _this.locator = serviceLocator;\n    _this.modelGenerator = new SummaryModelGenerator(_this.parent);\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * The function is used to render grid footer div\n   *\n   * @returns {void}\n   */\n\n\n  FooterRenderer.prototype.renderPanel = function () {\n    var div = this.parent.createElement('div', {\n      className: gridFooter\n    });\n    var innerDiv = this.parent.createElement('div', {\n      className: 'e-summarycontent'\n    });\n    var movableContent$$1 = innerDiv;\n\n    if (this.parent.isFrozenGrid()) {\n      var fDiv = this.parent.createElement('div', {\n        className: 'e-frozenfootercontent e-frozen-left-footercontent'\n      });\n      var mDiv = this.parent.createElement('div', {\n        className: 'e-movablefootercontent'\n      });\n      var frDiv = this.parent.createElement('div', {\n        className: 'e-frozenfootercontent e-frozen-right-footercontent'\n      });\n\n      if (this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount()) {\n        innerDiv.appendChild(fDiv);\n        this.frozenContent = fDiv;\n      }\n\n      innerDiv.appendChild(mDiv);\n      this.movableContent = mDiv;\n      movableContent$$1 = mDiv;\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        innerDiv.appendChild(frDiv);\n        this.frozenRightContent = frDiv;\n      }\n    }\n\n    if (Browser.isDevice) {\n      movableContent$$1.style.overflowX = 'scroll';\n    }\n\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n\n    if (this.parent.getPager() != null) {\n      this.parent.element.insertBefore(div, this.parent.getPager());\n    } else {\n      this.parent.element.appendChild(div);\n    }\n  };\n  /**\n   * The function is used to render grid footer table\n   *\n   * @returns {void}\n   */\n\n\n  FooterRenderer.prototype.renderTable = function () {\n    var frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n    var innerDiv = this.createContentTable('_footer_table');\n    var table$$1 = innerDiv.querySelector('.' + table);\n    var tFoot = this.parent.createElement('tfoot');\n    table$$1.appendChild(tFoot);\n\n    if (this.parent.isFrozenGrid()) {\n      var freezeTable = table$$1.cloneNode(true);\n      var frTable = table$$1.cloneNode(true);\n\n      if (frzCols) {\n        this.frozenContent.appendChild(freezeTable);\n        this.freezeTable = freezeTable;\n      }\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        remove(frTable.querySelector(colGroup));\n        var hdr = this.parent.getHeaderContent().querySelector('.e-frozen-right-header');\n        var frCol = hdr.querySelector(colGroup).cloneNode(true);\n        frTable.insertBefore(frCol, frTable.querySelector(tbody));\n        this.frozenRightContent.appendChild(frTable);\n        this.frTable = frTable;\n      }\n\n      this.movableContent.appendChild(table$$1);\n      remove(table$$1.querySelector(colGroup));\n      var colGroup$$1 = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n      table$$1.insertBefore(colGroup$$1, table$$1.querySelector(tbody));\n      this.setColGroup(colGroup$$1);\n    }\n\n    this.setTable(table$$1);\n  };\n\n  FooterRenderer.prototype.renderSummaryContent = function (e, table$$1, cStart, cEnd) {\n    var input = this.parent.dataSource instanceof Array ? !this.parent.getDataModule().isRemote() && this.parent.parentDetails ? this.getData() : this.parent.dataSource : this.parent.currentViewData;\n    var summaries = this.modelGenerator.getData();\n    var dummies = isNullOrUndefined(cStart) ? this.modelGenerator.getColumns() : this.modelGenerator.getColumns(cStart, cEnd); // eslint-disable-next-line max-len\n\n    var rows = isNullOrUndefined(cStart) ? this.modelGenerator.generateRows(input, e || this.aggregates) : this.modelGenerator.generateRows(input, e || this.aggregates, cStart, cEnd);\n    var fragment = document.createDocumentFragment();\n    var rowrenderer = new RowRenderer(this.locator, null, this.parent);\n    rowrenderer.element = this.parent.createElement('TR', {\n      className: 'e-summaryrow',\n      attrs: {\n        role: 'row'\n      }\n    });\n\n    for (var srow = 0, len = summaries.length; srow < len; srow++) {\n      var row$$1 = rows[srow];\n\n      if (!row$$1) {\n        continue;\n      }\n\n      var tr = rowrenderer.render(row$$1, dummies);\n      fragment.appendChild(tr);\n    }\n\n    table$$1.tFoot.appendChild(fragment);\n    this.aggregates = !isNullOrUndefined(e) ? e : this.aggregates;\n  };\n\n  FooterRenderer.prototype.refresh = function (e) {\n    var frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n    var movable = this.parent.getMovableColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n\n    if (this.parent.isFrozenGrid()) {\n      remove(this.getPanel());\n      this.renderPanel();\n      this.renderTable();\n\n      if (frzCols) {\n        this.freezeTable.tFoot.innerHTML = '';\n        this.renderSummaryContent(e, this.freezeTable, 0, frzCols);\n      }\n    }\n\n    this.getTable().tFoot.innerHTML = '';\n    this.renderSummaryContent(e, this.getTable(), frzCols, right ? frzCols + movable : undefined);\n\n    if (this.parent.getFrozenRightColumnsCount()) {\n      this.frTable.tFoot.innerHTML = '';\n      this.renderSummaryContent(e, this.frTable, frzCols + movable, frzCols + movable + right);\n      var movableLastCell = [].slice.call(this.getTable().getElementsByClassName('e-lastsummarycell'));\n\n      if (movableLastCell.length) {\n        for (var i = 0; i < movableLastCell.length; i++) {\n          movableLastCell[i].style.borderRight = '0px';\n        }\n      }\n    } // check freeze content have no row case\n\n\n    if (this.parent.isFrozenGrid()) {\n      var movableCnt = [].slice.call(this.parent.element.querySelector('.e-movablefootercontent').getElementsByClassName('e-summaryrow'));\n      var frozenCnt = void 0;\n\n      if (frzCols) {\n        frozenCnt = [].slice.call(this.parent.element.querySelector('.e-frozen-left-footercontent').getElementsByClassName('e-summaryrow'));\n        this.refreshHeight(frozenCnt, movableCnt);\n        var frozenDiv = this.frozenContent;\n\n        if (!frozenDiv.offsetHeight) {\n          frozenDiv.style.height = this.getTable().offsetHeight + 'px';\n        }\n      }\n\n      if (right) {\n        var frCnt = [].slice.call(this.parent.element.querySelector('.e-frozen-right-footercontent').getElementsByClassName('e-summaryrow'));\n        this.refreshHeight(frCnt, movableCnt);\n\n        if (frozenCnt) {\n          this.refreshHeight(frCnt, frozenCnt);\n        }\n\n        var frDiv = this.frTable;\n\n        if (!frDiv.offsetHeight) {\n          frDiv.style.height = this.getTable().offsetHeight + 'px';\n        }\n      }\n\n      if (this.parent.allowResizing) {\n        this.updateFooterTableWidth(this.getTable());\n      }\n    }\n\n    if (isNullOrUndefined(e) && this.parent.isAutoFitColumns) {\n      this.parent.autoFitColumns();\n    }\n\n    this.onScroll();\n  };\n\n  FooterRenderer.prototype.refreshHeight = function (frozenCnt, movableCnt) {\n    for (var i = 0; i < frozenCnt.length; i++) {\n      var frozenHeight$$1 = frozenCnt[i].getBoundingClientRect().height;\n      var movableHeight = movableCnt[i].getBoundingClientRect().height;\n\n      if (frozenHeight$$1 < movableHeight) {\n        frozenCnt[i].classList.remove('e-hide');\n        frozenCnt[i].style.height = movableHeight + 'px';\n      } else if (frozenHeight$$1 > movableHeight) {\n        movableCnt[i].classList.remove('e-hide');\n        movableCnt[i].style.height = frozenHeight$$1 + 'px';\n      }\n    }\n  };\n\n  FooterRenderer.prototype.refreshCol = function () {\n    // frozen table\n    var mheaderCol;\n    var fheaderCol = mheaderCol = this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true);\n\n    if (this.parent.getFrozenColumns()) {\n      // eslint-disable-next-line max-len\n      var isXaxis = this.parent.enableColumnVirtualization && this.parent.contentModule.isXaxis();\n\n      if (isXaxis) {\n        mheaderCol = this.parent.getMovableVirtualHeader().querySelector(colGroup).cloneNode(true);\n      } else {\n        mheaderCol = renderMovable(fheaderCol, this.parent.getFrozenColumns(), this.parent);\n        this.freezeTable.replaceChild(fheaderCol, this.freezeTable.querySelector(colGroup));\n      }\n    }\n\n    this.getTable().replaceChild(mheaderCol, this.getColGroup());\n    this.setColGroup(mheaderCol);\n  };\n\n  FooterRenderer.prototype.onWidthChange = function (args) {\n    this.getColFromIndex(args.index).style.width = formatUnit(args.width);\n\n    if (this.parent.allowResizing && args.module === 'resize') {\n      this.updateFooterTableWidth(this.getTable());\n    }\n  };\n\n  FooterRenderer.prototype.onScroll = function (e) {\n    if (e === void 0) {\n      e = {\n        left: this.parent.isFrozenGrid() ? this.parent.getContent().querySelector('.' + movableContent).scrollLeft : this.parent.getContent().firstChild.scrollLeft\n      };\n    }\n\n    this.getTable().parentElement.scrollLeft = e.left;\n  };\n\n  FooterRenderer.prototype.getColFromIndex = function (index) {\n    var left = this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenColumns();\n    var movable = this.parent.getMovableColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n    var isDrag = this.parent.isRowDragable() && !(this.parent.getFrozenMode() === 'Right') ? 1 : 0;\n\n    if (left && index < left + isDrag) {\n      return this.freezeTable.querySelector(colGroup).children[index];\n    } else if (right && index >= left + movable + isDrag) {\n      return this.frTable.querySelector(colGroup).children[index - (left ? left + movable + isDrag : left + movable)];\n    }\n\n    return this.getColGroup().children[index - (left ? left + isDrag : left)];\n  };\n\n  FooterRenderer.prototype.columnVisibilityChanged = function () {\n    this.refresh();\n  };\n\n  FooterRenderer.prototype.addEventListener = function () {\n    this.evtHandlers = [{\n      event: colGroupRefresh,\n      handler: this.refreshCol\n    }, {\n      event: columnWidthChanged,\n      handler: this.onWidthChange\n    }, {\n      event: scroll,\n      handler: this.onScroll\n    }, {\n      event: columnVisibilityChanged,\n      handler: this.columnVisibilityChanged\n    }, {\n      event: refreshFooterRenderer,\n      handler: this.refreshFooterRenderer\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  };\n\n  FooterRenderer.prototype.removeEventListener = function () {\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  };\n\n  FooterRenderer.prototype.updateFooterTableWidth = function (tFoot) {\n    var tHead = this.parent.getHeaderTable();\n\n    if (tHead && tFoot) {\n      tFoot.style.width = tHead.style.width;\n    }\n  };\n\n  FooterRenderer.prototype.refreshFooterRenderer = function (editedData) {\n    var aggregates = this.onAggregates(editedData);\n    this.refresh(aggregates);\n  };\n\n  FooterRenderer.prototype.getIndexByKey = function (data, ds) {\n    var key = this.parent.getPrimaryKeyFieldNames()[0];\n\n    for (var i = 0; i < ds.length; i++) {\n      if (ds[i][key] === data[key]) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  FooterRenderer.prototype.getData = function () {\n    return this.parent.getDataModule().dataManager.executeLocal(this.parent.getDataModule().generateQuery(true));\n  };\n\n  FooterRenderer.prototype.onAggregates = function (editedData) {\n    editedData = editedData instanceof Array ? editedData : [];\n    var field = this.parent.getPrimaryKeyFieldNames()[0];\n    var dataSource = [];\n    var isModified = false;\n    var batchChanges = {};\n    var gridData = 'dataSource';\n    var isFiltered = false;\n\n    if (!this.parent.renderModule.data.isRemote() && this.parent.allowFiltering && this.parent.filterSettings.columns.length) {\n      isFiltered = true;\n    }\n\n    var currentViewData = this.parent.dataSource instanceof Array ? isFiltered ? this.parent.getFilteredRecords() : this.parent.dataSource : this.parent.dataSource[gridData].json.length ? this.parent.dataSource[gridData].json : this.parent.getCurrentViewRecords();\n\n    if (this.parent.parentDetails && !this.parent.getDataModule().isRemote()) {\n      currentViewData = this.getData();\n    }\n\n    if (this.parent.editModule) {\n      batchChanges = this.parent.editModule.getBatchChanges();\n    }\n\n    if (Object.keys(batchChanges).length) {\n      for (var i = 0; i < currentViewData.length; i++) {\n        isModified = false; // eslint-disable-next-line max-len\n\n        if (batchChanges[changedRecords].length && this.getIndexByKey(currentViewData[i], batchChanges[changedRecords]) > -1) {\n          isModified = true; // eslint-disable-next-line max-len\n\n          dataSource.push(batchChanges[changedRecords][this.getIndexByKey(currentViewData[i], batchChanges[changedRecords])]);\n        } // eslint-disable-next-line max-len\n\n\n        if (batchChanges[deletedRecords].length && this.getIndexByKey(currentViewData[i], batchChanges[deletedRecords]) > -1) {\n          isModified = true;\n        } else if (!isModified) {\n          dataSource.push(currentViewData[i]);\n        }\n      }\n\n      if (batchChanges[addedRecords].length) {\n        for (var i = 0; i < batchChanges[addedRecords].length; i++) {\n          dataSource.push(batchChanges[addedRecords][i]);\n        }\n      }\n    } else {\n      if (editedData.length) {\n        var data = iterateExtend(currentViewData);\n        dataSource = data.map(function (item) {\n          var idVal = DataUtil.getObject(field, item);\n          var value;\n          var hasVal = editedData.some(function (cItem) {\n            value = cItem;\n            return idVal === DataUtil.getObject(field, cItem);\n          });\n          return hasVal ? value : item;\n        });\n      } else {\n        dataSource = currentViewData;\n      }\n    }\n\n    var eData = editedData;\n\n    if (eData.type && eData.type === 'cancel') {\n      dataSource = currentViewData;\n    }\n\n    var aggregate = {};\n    var agrVal;\n    var aggregateRows = this.parent.aggregates;\n\n    for (var i = 0; i < aggregateRows.length; i++) {\n      for (var j = 0; j < aggregateRows[i].columns.length; j++) {\n        var data = [];\n        var type = aggregateRows[i].columns[j].type.toString();\n        data = dataSource;\n        agrVal = calculateAggregate(type, data, aggregateRows[i].columns[j], this.parent);\n        aggregate[aggregateRows[i].columns[j].field + ' - ' + type.toLowerCase()] = agrVal;\n      }\n    }\n\n    var result = {\n      result: dataSource,\n      count: dataSource.length,\n      aggregates: aggregate\n    };\n    return result;\n  };\n\n  return FooterRenderer;\n}(ContentRender);\n\nvar __extends$23 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * SummaryCellRenderer class which responsible for building summary cell content.\n *\n * @hidden\n */\n\n\nvar SummaryCellRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$23(SummaryCellRenderer, _super);\n\n  function SummaryCellRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-summarycell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    return _this;\n  }\n\n  SummaryCellRenderer.prototype.getValue = function (field, data, column) {\n    var key = !isNullOrUndefined(column.type) ? column.field + ' - ' + (typeof column.type === 'string' ? column.type.toLowerCase() : '') : column.columnName;\n    return data[column.columnName] ? data[column.columnName][key] : '';\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  SummaryCellRenderer.prototype.evaluate = function (node, cell, data, attributes$$1) {\n    var column = cell.column;\n    this.parent.on(refreshAggregateCell, this.refreshWithAggregate(node, cell), this);\n\n    if (!(column.footerTemplate || column.groupFooterTemplate || column.groupCaptionTemplate)) {\n      if (this.parent.rowRenderingMode === 'Vertical') {\n        node.style.display = 'none';\n      }\n\n      return true;\n    } else {\n      if (this.parent.rowRenderingMode === 'Vertical') {\n        node.classList.add('e-lastsummarycell');\n      }\n    }\n\n    var tempObj = column.getTemplate(cell.cellType);\n    var tempID = '';\n    var gColumn = this.parent.getColumnByField(data[column.columnName].field);\n\n    if (!isNullOrUndefined(gColumn)) {\n      data[column.columnName].headerText = gColumn.headerText;\n\n      if (gColumn.isForeignColumn()) {\n        var fData = gColumn.columnData.filter(function (e) {\n          return e[gColumn.foreignKeyField] === data[column.columnName].key;\n        })[0];\n\n        if (fData) {\n          data[column.columnName].foreignKey = fData[gColumn.foreignKeyValue];\n        }\n      }\n    }\n\n    var isReactCompiler = this.parent.isReact && (column.footerTemplate ? typeof column.footerTemplate !== 'string' : column.groupFooterTemplate ? typeof column.groupFooterTemplate !== 'string' : column.groupCaptionTemplate ? typeof column.groupCaptionTemplate !== 'string' : false);\n    var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n\n    if (isReactCompiler || isReactChild) {\n      var prop = data[column.columnName];\n\n      if (tempObj.property === 'groupCaptionTemplate' || tempObj.property === 'groupFooterTemplate') {\n        var groupKey = 'groupKey';\n        var key = 'key';\n        prop[groupKey] = prop[key];\n      }\n\n      tempObj.fn(prop, this.parent, tempObj.property, tempID, null, null, node);\n      this.parent.renderTemplates();\n    } else {\n      appendChildren(node, tempObj.fn(data[column.columnName], this.parent, tempObj.property, tempID));\n    }\n\n    return false;\n  };\n\n  SummaryCellRenderer.prototype.refreshWithAggregate = function (node, cell) {\n    var _this = this;\n\n    var cellNode = cell;\n    return function (args) {\n      var cell = cellNode;\n      var field = cell.column.columnName ? cell.column.columnName : null;\n      var curCell = !isNullOrUndefined(field) ? args.cells.filter(function (cell) {\n        return cell.column.columnName === field;\n      })[0] : null;\n\n      if (node.parentElement && node.parentElement.getAttribute('data-uid') === args.dataUid && field && field === curCell.column.columnName) {\n        _this.refreshTD(node, curCell, args.data);\n      }\n    };\n  };\n\n  return SummaryCellRenderer;\n}(CellRenderer);\n/**\n * Summary Action controller.\n */\n\n\nvar Aggregate =\n/** @__PURE__ @class */\nfunction () {\n  function Aggregate(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.addEventListener();\n  }\n\n  Aggregate.prototype.getModuleName = function () {\n    return 'aggregate';\n  };\n\n  Aggregate.prototype.initiateRender = function () {\n    var _this = this;\n\n    var cellFac = this.locator.getService('cellRendererFactory');\n    var instance = new SummaryCellRenderer(this.parent, this.locator);\n    var type = [CellType.Summary, CellType.CaptionSummary, CellType.GroupSummary];\n\n    for (var i = 0; i < type.length; i++) {\n      cellFac.addCellRenderer(type[i], instance);\n    }\n\n    this.footerRenderer = new FooterRenderer(this.parent, this.locator);\n    this.footerRenderer.renderPanel();\n    this.footerRenderer.renderTable();\n    var footerContent = this.footerRenderer.getPanel();\n\n    if (this.parent.element.scrollHeight >= this.parent.getHeight(this.parent.height) && footerContent) {\n      addClass([footerContent], ['e-footerpadding']);\n    }\n\n    this.locator.register('footerRenderer', this.footerRenderer);\n\n    var fn = function () {\n      _this.prepareSummaryInfo();\n\n      _this.parent.off(dataReady, fn);\n    };\n\n    this.parent.on(dataReady, fn, this);\n    this.parent.on(dataReady, this.footerRenderer.refresh, this.footerRenderer);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Aggregate.prototype.prepareSummaryInfo = function () {\n    var _this = this;\n\n    summaryIterator(this.parent.aggregates, function (column) {\n      var cFormat = getValue('customFormat', column);\n\n      if (!isNullOrUndefined(cFormat)) {\n        column.setPropertiesSilent({\n          format: cFormat\n        });\n      }\n\n      if (typeof column.format === 'object') {\n        var valueFormatter = new ValueFormatter();\n        column.setFormatter(valueFormatter.getFormatFunction(extend({}, column.format)));\n      } else if (typeof column.format === 'string') {\n        var fmtr = _this.locator.getService('valueFormatter');\n\n        column.setFormatter(fmtr.getFormatFunction({\n          format: column.format\n        }));\n      }\n\n      column.setPropertiesSilent({\n        columnName: column.columnName || column.field\n      });\n    });\n  };\n\n  Aggregate.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    if (isNullOrUndefined(this.footerRenderer)) {\n      this.initiateRender();\n    }\n\n    this.prepareSummaryInfo();\n    this.footerRenderer.refresh();\n    var cModel = new CaptionSummaryModelGenerator(this.parent);\n    var gModel = new GroupSummaryModelGenerator(this.parent);\n\n    if (gModel.getData().length !== 0 || !cModel.isEmpty()) {\n      this.parent.notify(modelChanged, {});\n    }\n  };\n\n  Aggregate.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialEnd, this.initiateRender, this);\n    this.parent.on(uiUpdate, this.onPropertyChanged, this);\n    this.parent.on(refreshAggregates, this.refresh, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n\n  Aggregate.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.footerRenderer.removeEventListener();\n    this.parent.off(initialEnd, this.initiateRender);\n    this.parent.off(dataReady, this.footerRenderer.refresh);\n    this.parent.off(uiUpdate, this.onPropertyChanged);\n    this.parent.off(refreshAggregates, this.refresh);\n    this.parent.off(destroy, this.destroy);\n\n    if (this.parent.element.querySelector('.' + gridFooter)) {\n      remove(this.parent.element.querySelector('.' + gridFooter));\n    }\n  };\n\n  Aggregate.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  Aggregate.prototype.refresh = function (data) {\n    var editedData = data instanceof Array ? data : [data];\n    this.parent.notify(refreshFooterRenderer, editedData);\n\n    if (this.parent.groupSettings.columns.length > 0) {\n      this.parent.notify(groupAggregates, editedData);\n    }\n  };\n\n  return Aggregate;\n}();\n/**\n * @param {AggregateRowModel[]} aggregates - specifies the AggregateRowModel\n * @param {Function} callback - specifies the Function\n * @returns {void}\n * @private\n */\n\n\nfunction summaryIterator(aggregates, callback) {\n  for (var i = 0; i < aggregates.length; i++) {\n    for (var j = 0; j < aggregates[i].columns.length; j++) {\n      callback(aggregates[i].columns[j], aggregates[i]);\n    }\n  }\n}\n/**\n * InterSectionObserver - class watch whether it enters the viewport.\n *\n * @hidden\n */\n\n\nvar InterSectionObserver =\n/** @__PURE__ @class */\nfunction () {\n  function InterSectionObserver(element, options, movableEle) {\n    var _this = this;\n\n    this.fromWheel = false;\n    this.touchMove = false;\n    this.options = {};\n    this.sentinelInfo = {\n      'up': {\n        check: function (rect, info) {\n          var top = rect.top - _this.containerRect.top;\n          info.entered = top >= 0;\n          return top + _this.options.pageHeight / 2 >= 0;\n        },\n        axis: 'Y'\n      },\n      'down': {\n        check: function (rect, info) {\n          var bottom = rect.bottom;\n          info.entered = rect.bottom <= _this.containerRect.bottom;\n          return bottom - _this.containerRect.top - _this.options.pageHeight / 2 <= _this.options.pageHeight / 2;\n        },\n        axis: 'Y'\n      },\n      'right': {\n        check: function (rect, info) {\n          var right = rect.right;\n\n          if (_this.movableEle) {\n            info.entered = right < _this.movableContainerRect.right;\n            return right - _this.movableContainerRect.width <= _this.movableContainerRect.right;\n          }\n\n          info.entered = right < _this.containerRect.right;\n          return right - _this.containerRect.width <= _this.containerRect.right;\n        },\n        axis: 'X'\n      },\n      'left': {\n        check: function (rect, info) {\n          var left = rect.left;\n          info.entered = left > 0;\n\n          if (_this.movableEle) {\n            return left + _this.movableContainerRect.width >= _this.movableContainerRect.left;\n          }\n\n          return left + _this.containerRect.width >= _this.containerRect.left;\n        },\n        axis: 'X'\n      }\n    };\n    this.element = element;\n    this.options = options;\n    this.movableEle = movableEle;\n  }\n\n  InterSectionObserver.prototype.observe = function (callback, onEnterCallback) {\n    var _this = this;\n\n    this.containerRect = this.options.container.getBoundingClientRect();\n    EventHandler.add(this.options.container, 'wheel', function () {\n      return _this.fromWheel = true;\n    }, this);\n    EventHandler.add(this.options.container, 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);\n\n    if (this.options.movableContainer) {\n      this.movableContainerRect = this.options.movableContainer.getBoundingClientRect();\n      EventHandler.add(this.options.scrollbar, 'wheel', function () {\n        return _this.fromWheel = true;\n      }, this);\n      EventHandler.add(this.options.scrollbar, 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);\n    }\n  };\n\n  InterSectionObserver.prototype.check = function (direction) {\n    var info = this.sentinelInfo[direction];\n\n    if (this.movableContainerRect && (direction === 'left' || direction === 'right')) {\n      return info.check(this.movableEle.getBoundingClientRect(), info);\n    }\n\n    return info.check(this.element.getBoundingClientRect(), info);\n  };\n\n  InterSectionObserver.prototype.virtualScrollHandler = function (callback, onEnterCallback) {\n    var _this = this;\n\n    var delay = Browser.info.name === 'chrome' ? 200 : 100;\n    var debounced100 = debounce(callback, delay);\n    var debounced50 = debounce(callback, 50);\n    this.options.prevTop = this.options.prevLeft = 0;\n    return function (e) {\n      var top = _this.options.movableContainer ? _this.options.container.scrollTop : e.target.scrollTop;\n      var left = _this.options.movableContainer ? _this.options.scrollbar.scrollLeft : e.target.scrollLeft;\n      var direction = _this.options.prevTop < top ? 'down' : 'up';\n      direction = _this.options.prevLeft === left ? direction : _this.options.prevLeft < left ? 'right' : 'left';\n      _this.options.prevTop = top;\n      _this.options.prevLeft = left;\n      var current = _this.sentinelInfo[direction];\n\n      if (_this.options.axes.indexOf(current.axis) === -1) {\n        return;\n      }\n\n      var check = _this.check(direction);\n\n      if (current.entered) {\n        if (_this.movableEle && (direction === 'right' || direction === 'left')) {\n          onEnterCallback(_this.movableEle, current, direction, {\n            top: top,\n            left: left\n          }, _this.fromWheel, check);\n        } else {\n          onEnterCallback(_this.element, current, direction, {\n            top: top,\n            left: left\n          }, _this.fromWheel, check);\n        }\n      }\n\n      if (check) {\n        var fn = debounced100; //this.fromWheel ? this.options.debounceEvent ? debounced100 : callback : debounced100;\n\n        if (current.axis === 'X') {\n          fn = debounced50;\n        }\n\n        fn({\n          direction: direction,\n          sentinel: current,\n          offset: {\n            top: top,\n            left: left\n          },\n          focusElement: document.activeElement\n        });\n      }\n\n      _this.fromWheel = false;\n    };\n  };\n\n  InterSectionObserver.prototype.setPageHeight = function (value) {\n    this.options.pageHeight = value;\n  };\n\n  return InterSectionObserver;\n}();\n/**\n * Content module is used to render grid content\n */\n\n\nvar VirtualRowModelGenerator =\n/** @__PURE__ @class */\nfunction () {\n  function VirtualRowModelGenerator(parent) {\n    this.cOffsets = {};\n    this.cache = {};\n    this.movableCache = {};\n    this.frozenRightCache = {};\n    this.rowCache = {};\n    this.data = {};\n    this.groups = {};\n    this.currentInfo = {};\n    this.parent = parent;\n    this.model = this.parent.pageSettings;\n    this.rowModelGenerator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  VirtualRowModelGenerator.prototype.generateRows = function (data, e) {\n    var isFrozen = this.parent.isFrozenGrid();\n    var isManualRefresh = false;\n    var info = e.virtualInfo = e.virtualInfo || this.getData();\n    var xAxis = info.sentinelInfo && info.sentinelInfo.axis === 'X';\n    var page = !xAxis && info.loadNext && !info.loadSelf ? info.nextInfo.page : info.page;\n    var result = [];\n    var indexes = this.getBlockIndexes(page);\n    var loadedBlocks = [];\n\n    if (this.currentInfo.blockIndexes) {\n      indexes = info.blockIndexes = e.virtualInfo.blockIndexes = this.includePrevPage ? this.currentInfo.blockIndexes.slice(1) : this.currentInfo.blockIndexes.slice(0, this.currentInfo.blockIndexes.length - 1);\n      isManualRefresh = true;\n    }\n\n    if (isFrozen && this.parent.getFrozenMode() !== leftRight && !e.renderMovableContent || this.parent.getFrozenMode() === leftRight && !e.renderMovableContent && !e.renderFrozenRightContent || !isFrozen) {\n      this.checkAndResetCache(e.requestType);\n    }\n\n    if (isGroupAdaptive(this.parent) && this.parent.vcRows.length) {\n      var dataRows = this.parent.vcRows.filter(function (row$$1) {\n        return row$$1.isDataRow;\n      });\n\n      if (this.parent.isManualRefresh && dataRows.length === data['records'].length || !this.parent.isManualRefresh) {\n        return result = this.parent.vcRows;\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      for (var i = 0; i < info.blockIndexes.length; i++) {\n        if (this.isBlockAvailable(info.blockIndexes[i])) {\n          this.cache[info.blockIndexes[i]] = this.rowModelGenerator.refreshRows(this.cache[info.blockIndexes[i]]);\n        }\n\n        if (e.renderMovableContent && this.isMovableBlockAvailable(info.blockIndexes[i]) || e.renderFrozenRightContent && this.isFrozenRightBlockAvailable(info.blockIndexes[i])) {\n          var cache = e.renderMovableContent ? this.movableCache : this.frozenRightCache;\n          cache[info.blockIndexes[i]] = this.rowModelGenerator.refreshRows(cache[info.blockIndexes[i]]);\n        }\n      }\n    }\n\n    var values = info.blockIndexes;\n\n    for (var i = 0; i < values.length; i++) {\n      if (!this.isBlockAvailable(values[i])) {\n        var startIdx = !isNullOrUndefined(this.startIndex) ? this.startIndex : this.getStartIndex(values[i], data);\n        var rows = this.rowModelGenerator.generateRows(data, {\n          virtualInfo: info,\n          startIndex: startIdx\n        });\n\n        if (isGroupAdaptive(this.parent) && !this.parent.vcRows.length) {\n          this.parent.vRows = rows;\n          this.parent.vcRows = rows;\n          this.parent.notify(refreshVirtualMaxPage, {});\n        }\n\n        var median = void 0;\n\n        if (isGroupAdaptive(this.parent)) {\n          this.getGroupVirtualRecordsByIndex(rows);\n        } else {\n          if (isManualRefresh) {\n            this.setBlockForManualRefresh(this.cache, indexes, rows);\n          } else {\n            median = ~~Math.max(rows.length, this.model.pageSize) / 2;\n\n            if (!this.isBlockAvailable(indexes[0])) {\n              this.cache[indexes[0]] = rows.slice(0, median);\n            }\n\n            if (!this.isBlockAvailable(indexes[1])) {\n              this.cache[indexes[1]] = rows.slice(median);\n            }\n          }\n        }\n      }\n\n      if (this.parent.groupSettings.columns.length && !xAxis && this.cache[values[i]]) {\n        this.cache[values[i]] = this.updateGroupRow(this.cache[values[i]], values[i]);\n      }\n\n      if (e.renderMovableContent && !this.isMovableBlockAvailable(values[i]) || e.renderFrozenRightContent && !this.isFrozenRightBlockAvailable(values[i])) {\n        var cache = e.renderMovableContent ? this.movableCache : this.frozenRightCache;\n        var startIdx = !isNullOrUndefined(this.startIndex) ? this.startIndex : this.getStartIndex(values[i], data);\n        var rows = this.rowModelGenerator.generateRows(data, {\n          virtualInfo: info,\n          startIndex: startIdx\n        });\n\n        if (isManualRefresh) {\n          this.setBlockForManualRefresh(cache, indexes, rows);\n        } else {\n          var median = ~~Math.max(rows.length, this.model.pageSize) / 2;\n\n          if (e.renderFrozenRightContent && !this.isFrozenRightBlockAvailable(indexes[0]) || e.renderMovableContent && !this.isMovableBlockAvailable(indexes[0])) {\n            cache[indexes[0]] = rows.slice(0, median);\n          }\n\n          if (e.renderFrozenRightContent && !this.isFrozenRightBlockAvailable(indexes[1]) || e.renderMovableContent && !this.isMovableBlockAvailable(indexes[1])) {\n            cache[indexes[1]] = rows.slice(median);\n          }\n        }\n      }\n\n      if (!e.renderMovableContent && !e.renderFrozenRightContent && this.cache[values[i]]) {\n        result.push.apply(result, this.cache[values[i]]);\n      } else {\n        var cache = e.renderMovableContent ? this.movableCache : this.frozenRightCache;\n\n        if (cache[values[i]]) {\n          result.push.apply(result, cache[values[i]]);\n        }\n      }\n\n      if (this.isBlockAvailable(values[i])) {\n        loadedBlocks.push(values[i]);\n      }\n    }\n\n    info.blockIndexes = loadedBlocks;\n    var grouping = 'records';\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n      this.parent.currentViewData[grouping] = result.map(function (m) {\n        return m.data;\n      });\n    } else if (isFrozen) {\n      if (e.renderMovableContent && (this.parent.getFrozenMode() === 'Left' || this.parent.getFrozenMode() === 'Right' || this.parent.getFrozenColumns()) || e.renderFrozenRightContent) {\n        this.parent.currentViewData = result.map(function (m) {\n          return m.data;\n        });\n      }\n    } else {\n      this.parent.currentViewData = result.map(function (m) {\n        return m.data;\n      });\n    }\n\n    return result;\n  };\n\n  VirtualRowModelGenerator.prototype.setBlockForManualRefresh = function (cache, blocks, rows) {\n    var size = this.model.pageSize / 2;\n\n    if (this.includePrevPage) {\n      cache[blocks[0] - 1] = rows.slice(0, size);\n      cache[blocks[0]] = rows.slice(size, size * 2);\n      cache[blocks[1]] = rows.slice(size * 2, size * 3);\n      cache[blocks[2]] = rows.slice(size * 3, size * 4);\n    } else {\n      cache[blocks[0]] = rows.slice(0, size);\n      cache[blocks[1]] = rows.slice(size, size * 2);\n      cache[blocks[2]] = rows.slice(size * 2, size * 3);\n      cache[blocks[2] + 1] = rows.slice(size * 3, size * 4);\n    }\n  };\n\n  VirtualRowModelGenerator.prototype.getBlockIndexes = function (page) {\n    return [page + (page - 1), page * 2];\n  };\n\n  VirtualRowModelGenerator.prototype.getPage = function (block) {\n    return block % 2 === 0 ? block / 2 : (block + 1) / 2;\n  };\n\n  VirtualRowModelGenerator.prototype.isBlockAvailable = function (value) {\n    return value in this.cache;\n  };\n\n  VirtualRowModelGenerator.prototype.isMovableBlockAvailable = function (value) {\n    return value in this.movableCache;\n  };\n\n  VirtualRowModelGenerator.prototype.isFrozenRightBlockAvailable = function (value) {\n    return value in this.frozenRightCache;\n  };\n\n  VirtualRowModelGenerator.prototype.getData = function () {\n    return {\n      page: this.model.currentPage,\n      blockIndexes: this.getBlockIndexes(this.model.currentPage),\n      direction: 'down',\n      columnIndexes: this.parent.getColumnIndexesInView()\n    };\n  };\n\n  VirtualRowModelGenerator.prototype.getStartIndex = function (blk, data, full) {\n    if (full === void 0) {\n      full = true;\n    }\n\n    var page = this.getPage(blk);\n    var even = blk % 2 === 0;\n    var index = (page - 1) * this.model.pageSize;\n    return full || !even ? index : index + ~~(this.model.pageSize / 2);\n  };\n\n  VirtualRowModelGenerator.prototype.getColumnIndexes = function (content$$1) {\n    var _this = this;\n\n    if (content$$1 === void 0) {\n      content$$1 = this.parent.getHeaderContent().querySelector('.' + headerContent);\n    }\n\n    if (this.parent.isFrozenGrid()) {\n      content$$1 = content$$1.querySelector('.' + movableHeader);\n    }\n\n    var indexes = [];\n    var sLeft = content$$1.scrollLeft | 0;\n    var keys = Object.keys(this.cOffsets);\n    var cWidth = content$$1.getBoundingClientRect().width;\n    sLeft = Math.min(this.cOffsets[keys.length - 1] - cWidth, sLeft);\n    var calWidth = Browser.isDevice ? 2 * cWidth : cWidth / 2;\n    var left = sLeft + cWidth + (sLeft === 0 ? calWidth : 0);\n    keys.some(function (offset) {\n      var iOffset = Number(offset);\n      var offsetVal = _this.cOffsets[offset];\n      var border = sLeft - calWidth <= offsetVal && left + calWidth >= offsetVal;\n\n      if (border) {\n        indexes.push(iOffset);\n      }\n\n      return left + calWidth < offsetVal;\n    });\n    this.addFrozenIndex(indexes);\n    return indexes;\n  };\n\n  VirtualRowModelGenerator.prototype.addFrozenIndex = function (indexes) {\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization && indexes[0] === 0) {\n      for (var i = 0; i < this.parent.getFrozenColumns(); i++) {\n        indexes.push(indexes[indexes.length - 1] + 1);\n      }\n    }\n  };\n\n  VirtualRowModelGenerator.prototype.checkAndResetCache = function (action) {\n    var actions = ['paging', 'refresh', 'sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'save', 'delete'];\n\n    if (this.parent.getFrozenColumns() && this.parent.frozenRows && this.parent.enableColumnVirtualization && action === 'reorder') {\n      actions.splice(actions.indexOf(action), 1);\n    }\n\n    var clear = actions.some(function (value) {\n      return action === value;\n    });\n\n    if (clear) {\n      this.cache = {};\n      this.data = {};\n      this.groups = {};\n      this.movableCache = {};\n      this.frozenRightCache = {};\n    }\n\n    return clear;\n  };\n\n  VirtualRowModelGenerator.prototype.refreshColOffsets = function () {\n    var _this = this;\n\n    var col = 0;\n    this.cOffsets = {};\n    var gLen = this.parent.groupSettings.columns.length;\n    var cols = this.parent.columns;\n    var cLen = cols.length;\n\n    var isVisible = function (column) {\n      return column.visible && (!_this.parent.groupSettings.showGroupedColumn ? _this.parent.groupSettings.columns.indexOf(column.field) < 0 : column.visible);\n    };\n\n    var c = this.parent.groupSettings.columns;\n\n    for (var i = 0; i < c.length; i++) {\n      this.cOffsets[i] = (this.cOffsets[i - 1] | 0) + 30;\n    } // eslint-disable-next-line prefer-spread\n\n\n    var blocks = Array.apply(null, Array(cLen)).map(function () {\n      return col++;\n    });\n\n    for (var j = 0; j < blocks.length; j++) {\n      blocks[j] = blocks[j] + gLen;\n      this.cOffsets[blocks[j]] = (this.cOffsets[blocks[j] - 1] | 0) + (isVisible(cols[j]) ? parseInt(cols[j].width, 10) : 0);\n    }\n  };\n\n  VirtualRowModelGenerator.prototype.updateGroupRow = function (current, block) {\n    var currentFirst = current[0];\n    var rows = [];\n    var keys = Object.keys(this.cache);\n\n    for (var i = 0; i < keys.length; i++) {\n      if (Number(keys[i]) < block) {\n        rows = rows.concat(this.cache[keys[i]]);\n      }\n    }\n\n    if (currentFirst && currentFirst.isDataRow || block % 2 === 0) {\n      return current;\n    }\n\n    return this.iterateGroup(current, rows);\n  };\n\n  VirtualRowModelGenerator.prototype.iterateGroup = function (current, rows) {\n    var currentFirst = current[0];\n    var offset = 0;\n\n    if (currentFirst && currentFirst.isDataRow) {\n      return current;\n    }\n\n    var isPresent = current.some(function (row$$1) {\n      return rows.some(function (oRow, index) {\n        var res = oRow && oRow.data.field !== undefined && oRow.data.field === row$$1.data.field && oRow.data.key === row$$1.data.key;\n\n        if (res) {\n          offset = index;\n        }\n\n        return res;\n      });\n    });\n\n    if (isPresent) {\n      current.shift();\n      current = this.iterateGroup(current, rows.slice(offset));\n    }\n\n    return current;\n  };\n\n  VirtualRowModelGenerator.prototype.getRows = function () {\n    var rows = [];\n    var keys = Object.keys(this.cache);\n\n    for (var i = 0; i < keys.length; i++) {\n      rows = rows.concat(this.cache[keys[i]]);\n    }\n\n    return rows;\n  };\n\n  VirtualRowModelGenerator.prototype.generateCells = function (foreignKeyData$$1) {\n    var cells = [];\n    var cols = this.parent.columnModel;\n\n    for (var i = 0; i < cols.length; i++) {\n      cells.push(this.rowModelGenerator.generateCell(cols[i], null, null, null, null, foreignKeyData$$1));\n    }\n\n    return cells;\n  };\n\n  VirtualRowModelGenerator.prototype.getGroupVirtualRecordsByIndex = function (rows) {\n    var blocks = this.parent.contentModule.getGroupedTotalBlocks();\n    var blockSize = this.parent.contentModule.getBlockSize();\n\n    for (var i = 1; i <= blocks; i++) {\n      var count = 0;\n      this.cache[i] = [];\n\n      for (var j = (i - 1) * blockSize; j < rows.length; j++) {\n        if (count === blockSize) {\n          break;\n        }\n\n        this.cache[i].push(rows[j]);\n\n        if (rows[j].isDataRow) {\n          count++;\n        }\n      }\n    }\n  };\n\n  return VirtualRowModelGenerator;\n}();\n\nvar __extends$24 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * VirtualContentRenderer\n *\n * @hidden\n */\n\n\nvar VirtualContentRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$24(VirtualContentRenderer, _super);\n\n  function VirtualContentRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.prevHeight = 0;\n    /** @hidden */\n\n    _this.startIndex = 0;\n    _this.preStartIndex = 0;\n    _this.preventEvent = false;\n    _this.actions = ['filtering', 'searching', 'grouping', 'ungrouping'];\n    /** @hidden */\n\n    _this.offsets = {};\n    _this.tmpOffsets = {};\n    /** @hidden */\n\n    _this.virtualEle = new VirtualElementHandler();\n    _this.offsetKeys = [];\n    _this.isFocused = false;\n    _this.isSelection = false;\n    _this.isBottom = false;\n    _this.rndrCount = 0;\n    _this.empty = undefined;\n    _this.isCancel = false;\n    _this.requestTypes = ['beginEdit', 'cancel', 'delete', 'add', 'save'];\n    _this.isNormaledit = _this.parent.editSettings.mode === 'Normal';\n    /** @hidden */\n\n    _this.virtualData = {};\n    _this.emptyRowData = {};\n    _this.vfColIndex = [];\n    _this.frzIdx = 1;\n    _this.isContextMenuOpen = false;\n    _this.isSelectionScroll = false;\n    _this.validationCheck = false;\n    _this.locator = locator;\n\n    _this.eventListener('on');\n\n    _this.parent.on(columnVisibilityChanged, _this.setVisible, _this);\n\n    _this.vgenerator = _this.generator;\n    return _this;\n  }\n\n  VirtualContentRenderer.prototype.renderTable = function () {\n    this.header = this.locator.getService('rendererFactory').getRenderer(RenderType.Header);\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.content = this.getPanel().querySelector('.' + content);\n    this.virtualEle.renderWrapper(this.parent.height);\n    this.virtualEle.renderPlaceHolder();\n    this.virtualEle.wrapper.style.position = 'absolute';\n    var debounceEvent = this.parent.dataSource instanceof DataManager && !this.parent.dataSource.dataSource.offline;\n    var opt = {\n      container: this.content,\n      pageHeight: this.getBlockHeight() * 2,\n      debounceEvent: debounceEvent,\n      axes: this.parent.enableColumnVirtualization ? ['X', 'Y'] : ['Y']\n    };\n    this.observer = new InterSectionObserver(this.virtualEle.wrapper, opt);\n  };\n\n  VirtualContentRenderer.prototype.renderEmpty = function (tbody$$1) {\n    this.getTable().appendChild(tbody$$1);\n    this.virtualEle.adjustTable(0, 0);\n  };\n\n  VirtualContentRenderer.prototype.getReorderedFrozenRows = function (args) {\n    var blockIndex = args.virtualInfo.blockIndexes;\n    var colsIndex = args.virtualInfo.columnIndexes;\n    var page = args.virtualInfo.page;\n    args.virtualInfo.blockIndexes = [1, 2];\n    args.virtualInfo.page = 1;\n\n    if (!args.renderMovableContent) {\n      args.virtualInfo.columnIndexes = [];\n    }\n\n    var recordslength = this.parent.getCurrentViewRecords().length;\n    var firstRecords = this.parent.renderModule.data.dataManager.dataSource.json.slice(0, recordslength);\n    var virtualRows = this.vgenerator.generateRows(firstRecords, args);\n    args.virtualInfo.blockIndexes = blockIndex;\n    args.virtualInfo.columnIndexes = colsIndex;\n    args.virtualInfo.page = page;\n    return virtualRows.splice(0, this.parent.frozenRows);\n  };\n\n  VirtualContentRenderer.prototype.scrollListener = function (scrollArgs) {\n    this.scrollAfterEdit();\n\n    if (this.parent.enablePersistence) {\n      this.parent.scrollPosition = scrollArgs.offset;\n    }\n\n    if (this.preventEvent || this.parent.isDestroyed) {\n      this.preventEvent = false;\n      return;\n    }\n\n    if (isNullOrUndefined(document.activeElement)) {\n      this.isFocused = false;\n    } else {\n      this.isFocused = this.content === closest(document.activeElement, '.' + content) || this.content === document.activeElement;\n    }\n\n    var info = scrollArgs.sentinel;\n    var viewInfo = this.currentInfo = this.getInfoFromView(scrollArgs.direction, info, scrollArgs.offset);\n\n    if (isGroupAdaptive(this.parent)) {\n      if (viewInfo.blockIndexes && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString()) {\n        this.parent.removeMaskRow();\n        return;\n      } else {\n        viewInfo.event = 'refresh-virtual-block';\n\n        if (!isNullOrUndefined(viewInfo.offsets)) {\n          viewInfo.offsets.top = this.content.scrollTop;\n        }\n\n        this.parent.pageSettings.currentPage = viewInfo.page;\n\n        if (this.parent.enableVirtualMaskRow) {\n          this.parent.showMaskRow(info.axis);\n          this.parent.addShimmerEffect();\n        }\n\n        this.parent.notify(viewInfo.event, {\n          requestType: 'virtualscroll',\n          virtualInfo: viewInfo,\n          focusElement: scrollArgs.focusElement\n        });\n        return;\n      }\n    }\n\n    if (this.prevInfo && (info.axis === 'Y' && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString() || info.axis === 'X' && this.prevInfo.columnIndexes.toString() === viewInfo.columnIndexes.toString())) {\n      this.parent.removeMaskRow();\n\n      if (Browser.isIE) {\n        this.parent.hideSpinner();\n      }\n\n      this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n\n      if (info.axis === 'Y') {\n        this.restoreEdit();\n      }\n\n      return;\n    }\n\n    this.parent.setColumnIndexesInView(this.parent.enableColumnVirtualization ? viewInfo.columnIndexes : []);\n    this.parent.pageSettings.currentPage = viewInfo.loadNext && !viewInfo.loadSelf ? viewInfo.nextInfo.page : viewInfo.page;\n    this.requestType = 'virtualscroll';\n\n    if (this.parent.enableVirtualMaskRow) {\n      this.parent.showMaskRow(info.axis);\n      this.parent.addShimmerEffect();\n    }\n\n    this.parent.notify(viewInfo.event, {\n      requestType: 'virtualscroll',\n      virtualInfo: viewInfo,\n      focusElement: scrollArgs.focusElement\n    });\n  };\n\n  VirtualContentRenderer.prototype.block = function (blk) {\n    return this.vgenerator.isBlockAvailable(blk);\n  };\n\n  VirtualContentRenderer.prototype.getInfoFromView = function (direction, info, e) {\n    var isBlockAdded = false;\n    var tempBlocks = [];\n    var infoType = {\n      direction: direction,\n      sentinelInfo: info,\n      offsets: e,\n      startIndex: this.preStartIndex,\n      endIndex: this.preEndIndex\n    };\n    infoType.page = this.getPageFromTop(e.top, infoType);\n    infoType.blockIndexes = tempBlocks = this.vgenerator.getBlockIndexes(infoType.page);\n    infoType.loadSelf = !this.vgenerator.isBlockAvailable(tempBlocks[infoType.block]);\n    var blocks = this.ensureBlocks(infoType);\n\n    if (this.activeKey === 'upArrow' && infoType.blockIndexes.toString() !== blocks.toString()) {\n      // To avoid dupilcate row index problem in key focus support\n      var newBlock = blocks[blocks.length - 1];\n\n      if (infoType.blockIndexes.indexOf(newBlock) === -1) {\n        isBlockAdded = true;\n      }\n    }\n\n    infoType.blockIndexes = blocks;\n    infoType.loadNext = !blocks.filter(function (val) {\n      return tempBlocks.indexOf(val) === -1;\n    }).every(this.block.bind(this));\n    infoType.event = infoType.loadNext || infoType.loadSelf ? modelChanged : refreshVirtualBlock;\n    infoType.nextInfo = infoType.loadNext ? {\n      page: Math.max(1, infoType.page + (direction === 'down' ? 1 : -1))\n    } : {};\n\n    if (isBlockAdded) {\n      infoType.blockIndexes = [infoType.blockIndexes[0] - 1, infoType.blockIndexes[0], infoType.blockIndexes[0] + 1];\n    }\n\n    if (this.activeKey === 'downArrow') {\n      var firstBlock = Math.ceil(this.rowIndex / this.getBlockSize());\n\n      if (firstBlock !== 1 && (infoType.blockIndexes[1] !== firstBlock || infoType.blockIndexes.length < 3)) {\n        infoType.blockIndexes = [firstBlock - 1, firstBlock, firstBlock + 1];\n      }\n    }\n\n    infoType.columnIndexes = info.axis === 'X' ? this.vgenerator.getColumnIndexes() : this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization && info.axis === 'X') {\n      infoType.event = refreshVirtualBlock;\n    }\n\n    return infoType;\n  };\n\n  VirtualContentRenderer.prototype.setKeyboardNavIndex = function () {\n    this.blazorDataLoad = true;\n\n    if (this.activeKey === 'downArrow' || this.activeKey === 'upArrow') {\n      this.blzRowIndex = this.activeKey === 'downArrow' ? this.rowIndex + 1 : this.rowIndex - 1;\n      document.activeElement.blur();\n    }\n  };\n\n  VirtualContentRenderer.prototype.ensureBlocks = function (info) {\n    var _this = this;\n\n    var index = info.blockIndexes[info.block];\n    var mIdx;\n    var old = index;\n    var max = Math.max;\n    var indexes = info.direction === 'down' ? [max(index, 1), ++index, ++index] : [max(index - 1, 1), index, index + 1];\n\n    if (this.parent.enableColumnVirtualization && this.parent.isFrozenGrid()) {\n      // To avoid frozen content white space issue\n      if (info.sentinelInfo.axis === 'X' || info.sentinelInfo.axis === 'Y' && info.page === this.prevInfo.page) {\n        indexes = this.prevInfo.blockIndexes;\n      }\n    }\n\n    indexes = indexes.filter(function (val, ind) {\n      return indexes.indexOf(val) === ind;\n    });\n\n    if (this.prevInfo.blockIndexes.toString() === indexes.toString()) {\n      return indexes;\n    }\n\n    if (info.loadSelf || info.direction === 'down' && this.isEndBlock(old)) {\n      indexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    indexes.some(function (val, ind) {\n      var result = val === (isGroupAdaptive(_this.parent) ? _this.getGroupedTotalBlocks() : _this.getTotalBlocks());\n\n      if (result) {\n        mIdx = ind;\n      }\n\n      return result;\n    });\n\n    if (mIdx !== undefined) {\n      indexes = indexes.slice(0, mIdx + 1);\n\n      if (info.block === 0 && indexes.length === 1 && this.vgenerator.isBlockAvailable(indexes[0] - 1)) {\n        indexes = [indexes[0] - 1, indexes[0]];\n      }\n    }\n\n    return indexes;\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  VirtualContentRenderer.prototype.appendContent = function (target, newChild, e) {\n    var _this = this; // currentInfo value will be used if there are multiple dom updates happened due to mousewheel\n\n\n    var isFrozen = this.parent.isFrozenGrid();\n    var frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n    var colVFtable = this.parent.enableColumnVirtualization && isFrozen;\n    this.checkFirstBlockColIndexes(e);\n    var info = e.virtualInfo.sentinelInfo && e.virtualInfo.sentinelInfo.axis === 'Y' && this.currentInfo.page && this.currentInfo.page !== e.virtualInfo.page ? this.currentInfo : e.virtualInfo;\n    this.prevInfo = this.prevInfo || e.virtualInfo;\n    var cBlock = info.columnIndexes[0] - 1;\n\n    if (colVFtable && info.columnIndexes[0] === frzCols) {\n      cBlock = info.columnIndexes[0] - frzCols - 1;\n    }\n\n    var cOffset = this.getColumnOffset(cBlock);\n    var width;\n    var blocks = info.blockIndexes;\n\n    if (this.parent.groupSettings.columns.length) {\n      this.refreshOffsets();\n    }\n\n    if (this.parent.height === '100%') {\n      this.parent.element.style.height = '100%';\n    }\n\n    var vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height : this.parent.element.getBoundingClientRect().height;\n\n    if (!this.requestTypes.some(function (value) {\n      return value === _this.requestType;\n    })) {\n      var translate = this.getTranslateY(this.content.scrollTop, vHeight, info);\n      this.virtualEle.adjustTable(colVFtable ? 0 : cOffset, translate);\n\n      if (colVFtable) {\n        this.virtualEle.adjustMovableTable(cOffset, 0);\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      this.header.virtualEle.adjustTable(colVFtable ? 0 : cOffset, 0);\n\n      if (colVFtable) {\n        this.header.virtualEle.adjustMovableTable(cOffset, 0);\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      var cIndex = info.columnIndexes;\n      width = this.getColumnOffset(cIndex[cIndex.length - 1]) - this.getColumnOffset(cIndex[0] - 1) + '';\n\n      if (colVFtable) {\n        this.header.virtualEle.setMovableWrapperWidth(width);\n      } else {\n        this.header.virtualEle.setWrapperWidth(width);\n      }\n    }\n\n    if (colVFtable) {\n      this.virtualEle.setMovableWrapperWidth(width, Browser.isIE || Browser.info.name === 'edge');\n    } else {\n      this.virtualEle.setWrapperWidth(width, Browser.isIE || Browser.info.name === 'edge');\n    }\n\n    if (!isNullOrUndefined(target.parentNode)) {\n      remove(target);\n    }\n\n    var tbody$$1;\n\n    if (isFrozen) {\n      if (e.renderFrozenRightContent) {\n        tbody$$1 = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n      } else if (!e.renderMovableContent) {\n        tbody$$1 = this.parent.getFrozenVirtualContent().querySelector(tbody);\n      } else if (e.renderMovableContent) {\n        tbody$$1 = this.parent.getMovableVirtualContent().querySelector(tbody);\n      }\n    } else {\n      tbody$$1 = this.parent.element.querySelector('.' + content).querySelector(tbody);\n    }\n\n    if (tbody$$1) {\n      remove(tbody$$1);\n      target = null;\n    }\n\n    var isReact = this.parent.isReact && !isNullOrUndefined(this.parent.rowTemplate);\n\n    if (!isReact) {\n      target = this.parent.createElement(tbody, {\n        attrs: {\n          role: 'rowgroup'\n        }\n      });\n      target.appendChild(newChild);\n    } else {\n      target = newChild;\n    }\n\n    if (this.parent.frozenRows && e.requestType === 'virtualscroll' && this.parent.pageSettings.currentPage === 1) {\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        target.children[0].remove();\n      }\n    }\n\n    if (isFrozen) {\n      if (e.renderFrozenRightContent) {\n        this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.' + table).appendChild(target);\n        this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n      } else if (!e.renderMovableContent) {\n        this.parent.getFrozenVirtualContent().querySelector('.' + table).appendChild(target);\n      } else if (e.renderMovableContent) {\n        this.parent.getMovableVirtualContent().querySelector('.' + table).appendChild(target);\n\n        if (this.parent.getFrozenMode() !== leftRight) {\n          this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n        }\n      }\n\n      if (this.vfColIndex.length) {\n        e.virtualInfo.columnIndexes = info.columnIndexes = extend([], this.vfColIndex);\n        this.vfColIndex = e.renderMovableContent ? [] : this.vfColIndex;\n      }\n    } else {\n      this.getTable().appendChild(target);\n      this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n    }\n\n    if (this.parent.groupSettings.columns.length) {\n      if (!isGroupAdaptive(this.parent) && info.direction === 'up') {\n        var blk = this.offsets[this.getTotalBlocks()] - this.prevHeight;\n        this.preventEvent = true;\n        var sTop = this.content.scrollTop;\n        this.content.scrollTop = sTop + blk;\n      }\n\n      this.setVirtualHeight();\n      this.observer.setPageHeight(this.getOffset(blocks[blocks.length - 1]) - this.getOffset(blocks[0] - 1));\n    }\n\n    this.prevInfo = info;\n\n    if (this.isFocused && this.activeKey !== 'downArrow' && this.activeKey !== 'upArrow') {\n      this.content.focus();\n    }\n\n    var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n\n    if (this.isBottom) {\n      this.isBottom = false;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 1];\n    }\n\n    if (this.parent.pageSettings.currentPage === lastPage && blocks.length === 1) {\n      this.isBottom = true;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 2];\n    }\n\n    if (this.parent.isFrozenGrid() && this.parent.pageSettings.currentPage === lastPage - 1 && info.direction === 'up') {\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 3];\n    }\n\n    if (e.requestType === 'virtualscroll' && e.virtualInfo.sentinelInfo.axis === 'X') {\n      this.parent.notify(autoCol, {});\n    }\n\n    this.focusCell(e);\n    this.restoreEdit(e);\n    this.restoreAdd(e);\n    this.ensureSelectedRowPosition();\n    this.validationScrollLeft(e, isFrozen);\n\n    if (!this.initialRowTop) {\n      var gridTop = this.parent.element.getBoundingClientRect().top;\n      this.initialRowTop = this.parent.getRowByIndex(0).getBoundingClientRect().top - gridTop;\n    }\n\n    var tableName = e.tableName;\n    var isLoaded = this.parent.getFrozenMode() === 'Left-Right' ? tableName === 'frozen-right' : tableName === 'movable';\n\n    if (!isFrozen || isLoaded) {\n      this.vgenerator.startIndex = null;\n      this.vgenerator.currentInfo = {};\n      this.vgenerator.includePrevPage = null;\n    }\n  };\n\n  VirtualContentRenderer.prototype.validationScrollLeft = function (e, isFrozen) {\n    var left = this.parent.getFrozenColumns();\n    var table$$1 = this.parent.getFrozenMode();\n    var trigger = !isFrozen || e && (left || table$$1 === 'Left' || table$$1 === 'Right' ? e.renderMovableContent : e.renderFrozenRightContent);\n\n    if (this.validationCheck && trigger) {\n      if (this.validationCol) {\n        var offset = this.vgenerator.cOffsets[this.validationCol.index - this.parent.getVisibleFrozenColumns() - 1];\n        this.validationCol = null;\n\n        if (this.parent.isFrozenGrid()) {\n          this.movableContent.scrollLeft = offset;\n        } else {\n          this.content.scrollLeft = offset;\n        }\n      } else {\n        this.validationCheck = false;\n        this.parent.editModule.editFormValidate();\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.ensureSelectedRowPosition = function () {\n    if (!this.isSelection && this.isSelectionScroll && !isNullOrUndefined(this.selectRowIndex)) {\n      this.isSelectionScroll = false;\n      var row$$1 = this.parent.getRowByIndex(this.selectRowIndex);\n\n      if (row$$1 && !this.isRowInView(row$$1)) {\n        this.rowSelected({\n          rowIndex: this.selectRowIndex,\n          row: row$$1\n        }, true);\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.checkFirstBlockColIndexes = function (e) {\n    if (this.parent.enableColumnVirtualization && this.parent.isFrozenGrid() && e.virtualInfo.columnIndexes[0] === 0) {\n      var indexes = [];\n      var frozenCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount();\n\n      if (!e.renderMovableContent && e.virtualInfo.columnIndexes.length > frozenCols) {\n        this.vfColIndex = e.virtualInfo.columnIndexes;\n\n        for (var i = 0; i < frozenCols; i++) {\n          indexes.push(i);\n        }\n\n        e.virtualInfo.columnIndexes = indexes;\n      } else if (e.renderMovableContent) {\n        if (!this.vfColIndex.length) {\n          this.vfColIndex = extend([], e.virtualInfo.columnIndexes);\n        }\n\n        e.virtualInfo.columnIndexes = extend([], this.vfColIndex);\n        e.virtualInfo.columnIndexes.splice(0, frozenCols);\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  VirtualContentRenderer.prototype.focusCell = function (e) {\n    if (this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow') {\n      return;\n    }\n\n    var row$$1 = this.parent.getRowByIndex(this.rowIndex); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var cell = row$$1.cells[this.cellIndex];\n    cell.focus({\n      preventScroll: true\n    });\n    this.parent.selectRow(parseInt(row$$1.getAttribute(dataRowIndex), 10));\n    this.activeKey = this.empty;\n  };\n\n  VirtualContentRenderer.prototype.restoreEdit = function (e) {\n    if (this.isNormaledit) {\n      var left = this.parent.getFrozenColumns();\n      var isFrozen = e && this.parent.isFrozenGrid();\n      var table$$1 = this.parent.getFrozenMode();\n      var trigger = e && (left || table$$1 === 'Left' || table$$1 === 'Right' ? e.renderMovableContent : e.renderFrozenRightContent);\n\n      if ((!isFrozen || isFrozen && trigger) && this.parent.editSettings.allowEditing && this.parent.editModule && !isNullOrUndefined(this.editedRowIndex)) {\n        var row$$1 = this.getRowByIndex(this.editedRowIndex);\n        var content$$1 = this.content;\n        var keys = Object.keys(this.virtualData);\n        var isXaxis = e && e.virtualInfo && e.virtualInfo.sentinelInfo.axis === 'X';\n\n        if (isFrozen && isXaxis) {\n          row$$1 = this.parent.getMovableRowByIndex(this.editedRowIndex);\n          content$$1 = this.movableContent;\n        }\n\n        if (keys.length && row$$1 && !content$$1.querySelector('.' + editedRow)) {\n          var top_1 = row$$1.getBoundingClientRect().top;\n\n          if (isXaxis || top_1 < this.content.offsetHeight && top_1 > this.parent.getRowHeight()) {\n            this.parent.isEdit = false;\n            this.parent.editModule.startEdit(row$$1);\n          }\n        }\n\n        if (row$$1 && this.content.querySelector('.' + editedRow) && !keys.length) {\n          var rowData = extend({}, this.getRowObjectByIndex(this.editedRowIndex));\n          this.virtualData = this.getVirtualEditedData(rowData);\n        }\n      }\n\n      this.restoreAdd(e);\n    }\n  };\n\n  VirtualContentRenderer.prototype.getVirtualEditedData = function (rowData) {\n    var editForms = [].slice.call(this.parent.element.getElementsByClassName('e-gridform'));\n    var isFormDestroyed = this.parent.editModule && this.parent.editModule.formObj && this.parent.editModule.formObj.isDestroyed;\n\n    if (!isFormDestroyed) {\n      for (var i = 0; i < editForms.length; i++) {\n        rowData = this.parent.editModule.getCurrentEditedData(editForms[i], rowData);\n      }\n    }\n\n    return rowData;\n  };\n\n  VirtualContentRenderer.prototype.restoreAdd = function (e) {\n    var left = this.parent.getFrozenColumns();\n    var isFrozen = e && this.parent.isFrozenGrid();\n    var table$$1 = this.parent.getFrozenMode();\n    var isXaxis = e && e.virtualInfo && e.virtualInfo.sentinelInfo && e.virtualInfo.sentinelInfo.axis === 'X';\n    var startAdd = isXaxis && isFrozen ? !(this.parent.getMovableVirtualHeader().querySelector('.' + addedRow) || this.parent.getMovableVirtualContent().querySelector('.' + addedRow)) : !this.parent.element.querySelector('.' + addedRow);\n    var trigger = e && (left || table$$1 === 'Left' || table$$1 === 'Right' ? e.renderMovableContent : e.renderFrozenRightContent);\n\n    if ((!isFrozen || isFrozen && trigger) && this.isNormaledit && this.isAdd && startAdd) {\n      var isTop = this.parent.editSettings.newRowPosition === 'Top' && this.content.scrollTop < this.parent.getRowHeight();\n      var isBottom = this.parent.editSettings.newRowPosition === 'Bottom' && this.parent.pageSettings.currentPage === this.maxPage;\n\n      if (isTop || isBottom) {\n        this.parent.isEdit = false;\n        this.parent.addRecord();\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.onDataReady = function (e) {\n    if (!isNullOrUndefined(e.count)) {\n      this.count = e.count;\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n\n    this.vgenerator.checkAndResetCache(e.requestType);\n\n    if (['refresh', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', undefined].some(function (value) {\n      return e.requestType === value;\n    })) {\n      this.refreshOffsets();\n    }\n\n    this.setVirtualHeight();\n    this.resetScrollPosition(e.requestType);\n  };\n  /**\n   * @param {number} height - specifies the height\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  VirtualContentRenderer.prototype.setVirtualHeight = function (height) {\n    var width = this.parent.enableColumnVirtualization ? this.getColumnOffset(this.parent.columns.length + this.parent.groupSettings.columns.length - 1) + 'px' : '100%';\n\n    if (this.parent.isFrozenGrid()) {\n      var virtualHeightTemp = this.parent.pageSettings.currentPage === 1 && Object.keys(this.offsets).length <= 2 ? this.offsets[1] : this.offsets[this.getTotalBlocks() - 2];\n      var scrollableElementHeight = this.content.clientHeight;\n      virtualHeightTemp = virtualHeightTemp > scrollableElementHeight ? virtualHeightTemp : 0; // To overcome the white space issue in last page (instead of position absolute)\n\n      this.virtualEle.setVirtualHeight(virtualHeightTemp, width);\n    } else {\n      var virtualHeight = this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()];\n      this.virtualEle.setVirtualHeight(virtualHeight, width);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      this.header.virtualEle.setVirtualHeight(1, width);\n\n      if (this.parent.isFrozenGrid()) {\n        this.virtualEle.setMovableVirtualHeight(1, width);\n        this.header.virtualEle.setMovableVirtualHeight(1, width);\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.getPageFromTop = function (sTop, info) {\n    var _this = this;\n\n    var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    var page = 0;\n    this.offsetKeys.some(function (offset) {\n      var iOffset = Number(offset);\n      var border = sTop <= _this.offsets[offset] || iOffset === total && sTop > _this.offsets[offset];\n\n      if (border) {\n        if (_this.offsetKeys.length % 2 !== 0 && iOffset.toString() === _this.offsetKeys[_this.offsetKeys.length - 2] && sTop <= _this.offsets[_this.offsetKeys.length - 1]) {\n          iOffset = iOffset + 1;\n        }\n\n        info.block = iOffset % 2 === 0 ? 1 : 0;\n        page = Math.max(1, Math.min(_this.vgenerator.getPage(iOffset), _this.maxPage));\n      }\n\n      return border;\n    });\n    return page;\n  };\n\n  VirtualContentRenderer.prototype.getTranslateY = function (sTop, cHeight, info, isOnenter) {\n    if (info === undefined) {\n      info = {\n        page: this.getPageFromTop(sTop, {})\n      };\n      info.blockIndexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    var block = (info.blockIndexes[0] || 1) - 1;\n    var translate = this.getOffset(block);\n    var endTranslate = this.getOffset(info.blockIndexes[info.blockIndexes.length - 1]);\n\n    if (isOnenter) {\n      info = this.prevInfo;\n    }\n\n    var result = translate > sTop ? this.getOffset(block - 1) : endTranslate < sTop + cHeight ? this.getOffset(block + 1) : translate;\n    var blockHeight = this.offsets[info.blockIndexes[info.blockIndexes.length - 1]] - this.tmpOffsets[info.blockIndexes[0]];\n    var totalBlocks = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n\n    if (result + blockHeight > this.offsets[totalBlocks]) {\n      result -= result + blockHeight - this.offsets[totalBlocks];\n    }\n\n    return result;\n  };\n\n  VirtualContentRenderer.prototype.getOffset = function (block) {\n    return Math.min(this.offsets[block] | 0, this.offsets[this.maxBlock] | 0);\n  };\n\n  VirtualContentRenderer.prototype.onEntered = function () {\n    var _this = this;\n\n    return function (element, current, direction, e, isWheel, check) {\n      if (Browser.isIE && !isWheel && check && !_this.preventEvent && !_this.parent.enableVirtualMaskRow) {\n        _this.parent.showSpinner();\n      }\n\n      if (_this.parent.enableVirtualMaskRow && !_this.preventEvent) {\n        setTimeout(function () {\n          _this.parent.showMaskRow(current.axis);\n        }, 0);\n      }\n\n      var colVFtable = _this.parent.enableColumnVirtualization && _this.parent.isFrozenGrid();\n\n      var xAxis = current.axis === 'X';\n      var top = _this.prevInfo.offsets ? _this.prevInfo.offsets.top : null;\n\n      var height = _this.content.getBoundingClientRect().height;\n\n      var x = _this.getColumnOffset(xAxis ? _this.vgenerator.getColumnIndexes()[0] - 1 : _this.prevInfo.columnIndexes[0] - 1);\n\n      if (xAxis && !colVFtable) {\n        var idx = Object.keys(_this.vgenerator.cOffsets).length - _this.prevInfo.columnIndexes.length;\n\n        var maxLeft = _this.vgenerator.cOffsets[idx - 1];\n        x = x > maxLeft ? maxLeft : x; //TODO: This fix horizontal scrollbar jumping issue in column virtualization.\n      }\n\n      var y = _this.getTranslateY(e.top, height, xAxis && top === e.top ? _this.prevInfo : undefined, true);\n\n      _this.virtualEle.adjustTable(colVFtable ? 0 : x, Math.min(y, _this.offsets[_this.maxBlock]));\n\n      if (colVFtable) {\n        _this.virtualEle.adjustMovableTable(x, 0);\n      }\n\n      if (_this.parent.enableColumnVirtualization) {\n        _this.header.virtualEle.adjustTable(colVFtable ? 0 : x, 0);\n\n        if (colVFtable) {\n          _this.header.virtualEle.adjustMovableTable(x, 0);\n        }\n      }\n    };\n  };\n\n  VirtualContentRenderer.prototype.dataBound = function () {\n    this.parent.notify(refreshVirtualFrozenHeight, {});\n\n    if (this.isSelection && this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow') {\n      this.parent.selectRow(this.selectedRowIndex);\n    } else {\n      this.activeKey = this.empty;\n    }\n  };\n\n  VirtualContentRenderer.prototype.rowSelected = function (args, isSelection) {\n    if ((this.isSelection || isSelection) && !this.isLastBlockRow(args.rowIndex)) {\n      var transform = getTransformValues(this.content.firstElementChild);\n      var gridTop = this.parent.element.getBoundingClientRect().top;\n      var rowTop = args.row.getBoundingClientRect().top - gridTop;\n      var height = this.content.getBoundingClientRect().height;\n      var isBottom = height < rowTop;\n      var remainHeight = isBottom ? rowTop - height : this.initialRowTop - rowTop;\n      var translateY = isBottom ? transform.height - remainHeight : transform.height + remainHeight;\n      this.virtualEle.adjustTable(transform.width, translateY);\n      var lastRowTop = this.content.querySelector('tbody').lastElementChild.getBoundingClientRect().top - gridTop;\n\n      if (lastRowTop < height) {\n        translateY = translateY + (height - (args.row.getBoundingClientRect().top - gridTop));\n        this.virtualEle.adjustTable(transform.width, translateY - this.parent.getRowHeight() / 2);\n      }\n    }\n\n    this.isSelection = false;\n  };\n\n  VirtualContentRenderer.prototype.isLastBlockRow = function (index) {\n    var scrollEle = this.parent.getContent().firstElementChild;\n    var visibleRowCount = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n    var startIdx = this.maxPage * this.parent.pageSettings.pageSize - visibleRowCount;\n    return index >= startIdx;\n  };\n\n  VirtualContentRenderer.prototype.refreshMaxPage = function () {\n    if (this.parent.groupSettings.columns.length && this.parent.vcRows.length) {\n      this.maxPage = Math.ceil(this.parent.vcRows.length / this.parent.pageSettings.pageSize);\n    }\n  };\n\n  VirtualContentRenderer.prototype.setVirtualPageQuery = function (args) {\n    var row$$1 = this.parent.getContent().querySelector('.e-row');\n\n    if (row$$1 && this.parent.isManualRefresh && this.currentInfo.blockIndexes && this.currentInfo.blockIndexes.length === 3) {\n      this.vgenerator.startIndex = parseInt(row$$1.getAttribute('data-rowindex'), 10);\n      this.vgenerator.currentInfo = extend({}, this.currentInfo);\n      this.vgenerator.currentInfo.blockIndexes = this.currentInfo.blockIndexes.slice();\n      var includePrevPage = this.vgenerator.includePrevPage = this.currentInfo.blockIndexes[0] % 2 === 0;\n\n      if (includePrevPage) {\n        this.vgenerator.startIndex = this.vgenerator.startIndex - this.getBlockSize();\n        this.vgenerator.currentInfo.blockIndexes.unshift(this.currentInfo.blockIndexes[0] - 1);\n      } else {\n        this.vgenerator.currentInfo.blockIndexes.push(this.currentInfo.blockIndexes[this.currentInfo.blockIndexes.length - 1] + 1);\n      }\n\n      var skip = (this.vgenerator.currentInfo.blockIndexes[0] - 1) * this.getBlockSize();\n      var take = this.vgenerator.currentInfo.blockIndexes.length * this.getBlockSize();\n      args.query.skip(skip);\n      args.query.take(take);\n      args.skipPage = true;\n    }\n  };\n\n  VirtualContentRenderer.prototype.eventListener = function (action) {\n    var _this = this;\n\n    this.parent[action](dataReady, this.onDataReady, this);\n    this.parent.addEventListener(dataBound, this.dataBound.bind(this));\n    this.parent.addEventListener(actionBegin, this.actionBegin.bind(this));\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent.addEventListener(rowSelected, this.rowSelected.bind(this));\n    this.parent[action](refreshVirtualBlock, this.refreshContentRows, this);\n    this.parent[action](selectVirtualRow, this.selectVirtualRow, this);\n    this.parent[action](virtaulCellFocus, this.virtualCellFocus, this);\n    this.parent[action](virtualScrollEditActionBegin, this.editActionBegin, this);\n    this.parent[action](virtualScrollAddActionBegin, this.addActionBegin, this);\n    this.parent[action](virtualScrollEdit, this.restoreEdit, this);\n    this.parent[action](virtualScrollEditSuccess, this.editSuccess, this);\n    this.parent[action](refreshVirtualCache, this.refreshCache, this);\n    this.parent[action](editReset, this.resetIsedit, this);\n    this.parent[action](getVirtualData, this.getVirtualData, this);\n    this.parent[action](virtualScrollEditCancel, this.editCancel, this);\n    this.parent[action](refreshVirtualMaxPage, this.refreshMaxPage, this);\n    this.parent[action](setVirtualPageQuery, this.setVirtualPageQuery, this);\n    this.parent[action](selectRowOnContextOpen, this.selectRowOnContextOpen, this);\n    this.parent[action](resetVirtualFocus, this.resetVirtualFocus, this);\n    this.parent[action](refreshVirtualEditFormCells, this.refreshCells, this);\n    this.parent[action](scrollToEdit, this.scrollToEdit, this);\n    var event = this.actions;\n\n    for (var i = 0; i < event.length; i++) {\n      this.parent[action](event[i] + \"-begin\", this.onActionBegin, this);\n    }\n\n    var fn = function () {\n      _this.observer.observe(function (scrollArgs) {\n        return _this.scrollListener(scrollArgs);\n      }, _this.onEntered());\n\n      var gObj = _this.parent;\n\n      if (gObj.enablePersistence && gObj.scrollPosition) {\n        _this.content.scrollTop = gObj.scrollPosition.top;\n        var scrollValues = {\n          direction: 'down',\n          sentinel: _this.observer.sentinelInfo.down,\n          offset: gObj.scrollPosition,\n          focusElement: gObj.element\n        };\n\n        _this.scrollListener(scrollValues);\n\n        if (gObj.enableColumnVirtualization) {\n          _this.content.scrollLeft = gObj.scrollPosition.left;\n        }\n      }\n\n      _this.parent.off(contentReady, fn);\n    };\n\n    this.parent.on(contentReady, fn, this);\n  };\n\n  VirtualContentRenderer.prototype.scrollToEdit = function (col) {\n    var isFrozen = this.parent.isFrozenGrid();\n    var allowScroll = true;\n    this.validationCheck = true;\n\n    if (this.isAdd && this.content.scrollTop > 0) {\n      allowScroll = false;\n      var keys = Object.keys(this.offsets);\n      this.content.scrollTop = this.parent.editSettings.newRowPosition === 'Top' ? 0 : this.offsets[keys.length - 1];\n    }\n\n    var row$$1 = this.parent.getRowByIndex(this.editedRowIndex);\n\n    if (!row$$1 && !isNullOrUndefined(this.editedRowIndex)) {\n      if (!row$$1 || !this.isRowInView(row$$1)) {\n        var rowIndex = this.parent.getRowHeight();\n        var scrollTop = this.editedRowIndex * rowIndex;\n\n        if (!isNullOrUndefined(scrollTop)) {\n          allowScroll = false;\n          this.content.scrollTop = scrollTop;\n        }\n      }\n    }\n\n    if (col && allowScroll) {\n      var offset = this.vgenerator.cOffsets[col.index - this.parent.getVisibleFrozenColumns() - 1];\n\n      if (!this.parent.enableColumnVirtualization) {\n        var header = this.parent.getHeaderContent().querySelector('.e-headercelldiv[e-mappinguid=\"' + col.uid + '\"]');\n        offset = isFrozen ? header.parentElement.offsetLeft - this.parent.getFrozenVirtualHeader().offsetWidth : header.parentElement.offsetLeft;\n      }\n\n      if (isFrozen) {\n        this.parent.getMovableVirtualContent().scrollLeft = this.parent.enableRtl ? -Math.abs(offset) : offset;\n      } else {\n        this.content.scrollLeft = this.parent.enableRtl ? -Math.abs(offset) : offset;\n      }\n    }\n\n    if (col && !allowScroll) {\n      this.validationCol = col;\n    }\n  };\n\n  VirtualContentRenderer.prototype.refreshCells = function (rowObj) {\n    rowObj.cells = this.vgenerator.generateCells(rowObj.foreignKeyData);\n  };\n\n  VirtualContentRenderer.prototype.resetVirtualFocus = function (e) {\n    this.isCancel = e.isCancel;\n  };\n  /**\n   * @param {Object} data - specifies the data\n   * @param {Object} data.virtualData -specifies the data\n   * @param {boolean} data.isAdd - specifies isAdd\n   * @param {boolean} data.isCancel - specifies boolean in cancel\n   * @param {boolean} data.isScroll - specifies boolean for scroll\n   * @returns {void}\n   * @hidden\n   */\n\n\n  VirtualContentRenderer.prototype.getVirtualData = function (data) {\n    if (this.isNormaledit) {\n      var error = this.parent.element.querySelector('.e-griderror:not([style*=\"display: none\"])');\n      var keys = Object.keys(this.virtualData);\n      data.isScroll = keys.length !== 0 && this.currentInfo.sentinelInfo && this.currentInfo.sentinelInfo.axis === 'X';\n\n      if (error) {\n        return;\n      }\n\n      this.virtualData = keys.length ? this.virtualData : data.virtualData;\n      this.getVirtualEditedData(this.virtualData);\n      data.virtualData = this.virtualData;\n      data.isAdd = this.isAdd;\n      data.isCancel = this.isCancel;\n    }\n  };\n\n  VirtualContentRenderer.prototype.selectRowOnContextOpen = function (args) {\n    this.isContextMenuOpen = args.isOpen;\n  };\n\n  VirtualContentRenderer.prototype.editCancel = function (args) {\n    var dataIndex = getEditedDataIndex(this.parent, args.data);\n\n    if (!isNullOrUndefined(dataIndex)) {\n      args.data = this.parent.getCurrentViewRecords()[dataIndex];\n    }\n  };\n\n  VirtualContentRenderer.prototype.editSuccess = function (args) {\n    if (this.isNormaledit) {\n      if (!this.isAdd && args.data) {\n        this.updateCurrentViewData(args.data);\n      }\n\n      this.isAdd = false;\n    }\n  };\n\n  VirtualContentRenderer.prototype.updateCurrentViewData = function (data) {\n    var dataIndex = getEditedDataIndex(this.parent, data);\n\n    if (!isNullOrUndefined(dataIndex)) {\n      this.parent.getCurrentViewRecords()[dataIndex] = data;\n    }\n  };\n\n  VirtualContentRenderer.prototype.actionBegin = function (args) {\n    if (args.requestType !== 'virtualscroll') {\n      this.requestType = args.requestType;\n    }\n\n    if (!args.cancel) {\n      this.parent.notify(refreshVirtualFrozenRows, args);\n    }\n  };\n\n  VirtualContentRenderer.prototype.virtualCellFocus = function (e) {\n    // To decide the action (select or scroll), when using arrow keys for cell focus\n    var ele = document.activeElement;\n\n    if (ele.classList.contains(rowCell) && e && (e.action === 'upArrow' || e.action === 'downArrow')) {\n      var rowIndex = parseInt(ele.parentElement.getAttribute(dataRowIndex), 10);\n\n      if (e && (e.action === 'downArrow' || e.action === 'upArrow')) {\n        var scrollEle = this.parent.getContent().firstElementChild;\n\n        if (e.action === 'downArrow') {\n          rowIndex += 1;\n        } else {\n          rowIndex -= 1;\n        }\n\n        this.rowIndex = rowIndex;\n        this.cellIndex = parseInt(ele.getAttribute(dataColIndex), 10);\n        var row$$1 = this.parent.getRowByIndex(rowIndex);\n        var page = this.parent.pageSettings.currentPage;\n        var visibleRowCount = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n        var emptyRow = false;\n\n        if (isNullOrUndefined(row$$1)) {\n          emptyRow = true;\n\n          if (e.action === 'downArrow' && page === this.maxPage - 1 || e.action === 'upArrow' && page === 1) {\n            emptyRow = false;\n          }\n        }\n\n        if (emptyRow || ensureLastRow(row$$1, this.parent) && e.action === 'downArrow' || ensureFirstRow(row$$1, this.parent.getRowHeight() * 2) && e.action === 'upArrow') {\n          this.activeKey = e.action;\n          scrollEle.scrollTop = e.action === 'downArrow' ? (rowIndex - visibleRowCount) * this.parent.getRowHeight() : rowIndex * this.parent.getRowHeight();\n        } else {\n          this.activeKey = this.empty;\n        }\n\n        if (!this.parent.selectionSettings.checkboxOnly) {\n          this.parent.selectRow(rowIndex);\n        }\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.editActionBegin = function (e) {\n    this.editedRowIndex = e.index;\n    var rowData = extend({}, this.getRowObjectByIndex(e.index));\n    var keys = Object.keys(this.virtualData);\n    e.data = keys.length ? this.virtualData : rowData;\n    e.isScroll = keys.length !== 0 && this.currentInfo.sentinelInfo && this.currentInfo.sentinelInfo.axis === 'X';\n  };\n\n  VirtualContentRenderer.prototype.refreshCache = function (args) {\n    var block = Math.ceil((this.editedRowIndex + 1) / this.getBlockSize());\n    var index = this.editedRowIndex - (block - 1) * this.getBlockSize();\n    this.vgenerator.cache[block][index].data = args.data;\n\n    if (this.vgenerator.movableCache[block]) {\n      this.vgenerator.movableCache[block][index].data = args.data;\n    }\n\n    if (this.vgenerator.frozenRightCache[block]) {\n      this.vgenerator.frozenRightCache[block][index].data = args.data;\n    }\n  };\n\n  VirtualContentRenderer.prototype.actionComplete = function (args) {\n    if (!this.parent.enableVirtualization) {\n      return;\n    }\n\n    var editRequestTypes = ['delete', 'save', 'cancel'];\n    var dataActionRequestTypes = ['sorting', 'filtering', 'grouping', 'refresh', 'searching', 'ungrouping', 'reorder'];\n\n    if (editRequestTypes.some(function (value) {\n      return value === args.requestType;\n    })) {\n      this.refreshOffsets();\n\n      if (this.parent.isFrozenGrid()) {\n        this.vgenerator.refreshColOffsets();\n        this.parent.contentModule.virtualRenderer.virtualEle.setVirtualHeight();\n      } else {\n        this.refreshVirtualElement();\n      }\n    }\n\n    if (this.isNormaledit && (dataActionRequestTypes.some(function (value) {\n      return value === args.requestType;\n    }) || editRequestTypes.some(function (value) {\n      return value === args.requestType;\n    }))) {\n      this.isCancel = true;\n      this.isAdd = false;\n      this.editedRowIndex = this.empty;\n      this.virtualData = {};\n\n      if (this.parent.editModule) {\n        this.parent.editModule.editModule.previousData = undefined;\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization && args.requestType === 'filterafteropen' && this.currentInfo.columnIndexes && this.currentInfo.columnIndexes[0] > 0) {\n      this.parent.resetFilterDlgPosition(args.columnName);\n    }\n  };\n\n  VirtualContentRenderer.prototype.resetIsedit = function () {\n    if (this.parent.enableVirtualization && this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && Object.keys(this.virtualData).length || this.parent.editSettings.allowAdding && this.isAdd) {\n        this.parent.isEdit = true;\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.scrollAfterEdit = function () {\n    if (this.parent.editModule && this.parent.editSettings.allowEditing && this.isNormaledit) {\n      if (this.parent.element.querySelector('.e-gridform')) {\n        var editForm = this.parent.element.querySelector('.' + editedRow);\n        var addForm = this.parent.element.querySelector('.' + addedRow);\n\n        if (editForm || addForm) {\n          var rowData = editForm ? extend({}, this.getRowObjectByIndex(this.editedRowIndex)) : extend({}, this.emptyRowData);\n          var keys = Object.keys(this.virtualData);\n          this.virtualData = keys.length ? this.getVirtualEditedData(this.virtualData) : this.getVirtualEditedData(rowData);\n        }\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.createEmptyRowdata = function () {\n    var _this = this;\n\n    this.parent.columnModel.filter(function (e) {\n      _this.emptyRowData[e.field] = _this.empty;\n    });\n  };\n\n  VirtualContentRenderer.prototype.addActionBegin = function (args) {\n    if (this.isNormaledit) {\n      if (!Object.keys(this.emptyRowData).length) {\n        this.createEmptyRowdata();\n      }\n\n      this.isAdd = true;\n      var page = this.parent.pageSettings.currentPage;\n\n      if (!this.parent.frozenRows && this.content.scrollTop > 0 && this.parent.editSettings.newRowPosition === 'Top') {\n        this.isAdd = true;\n        this.onActionBegin();\n        args.startEdit = false;\n        this.content.scrollTop = 0;\n      }\n\n      if (page < this.maxPage - 1 && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.isAdd = true;\n        this.parent.setProperties({\n          pageSettings: {\n            currentPage: this.maxPage - 1\n          }\n        }, true);\n        args.startEdit = false;\n        this.content.scrollTop = this.offsets[this.offsetKeys.length];\n      }\n    }\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Object} returns the object\n   * @hidden\n   */\n\n\n  VirtualContentRenderer.prototype.getRowObjectByIndex = function (index) {\n    var data = this.getRowCollection(index, false, true);\n    return data;\n  };\n\n  VirtualContentRenderer.prototype.getBlockSize = function () {\n    return this.parent.pageSettings.pageSize >> 1;\n  };\n\n  VirtualContentRenderer.prototype.getBlockHeight = function () {\n    return this.getBlockSize() * this.parent.getRowHeight();\n  };\n\n  VirtualContentRenderer.prototype.isEndBlock = function (index) {\n    var totalBlocks = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    return index >= totalBlocks || index === totalBlocks - 1;\n  };\n\n  VirtualContentRenderer.prototype.getGroupedTotalBlocks = function () {\n    var rows = this.parent.vcRows;\n    return Math.floor(rows.length / this.getBlockSize() < 1 ? 1 : rows.length / this.getBlockSize());\n  };\n\n  VirtualContentRenderer.prototype.getTotalBlocks = function () {\n    return Math.ceil(this.count / this.getBlockSize());\n  };\n\n  VirtualContentRenderer.prototype.getColumnOffset = function (block) {\n    return this.vgenerator.cOffsets[block] | 0;\n  };\n\n  VirtualContentRenderer.prototype.getModelGenerator = function () {\n    return new VirtualRowModelGenerator(this.parent);\n  };\n\n  VirtualContentRenderer.prototype.resetScrollPosition = function (action) {\n    if (this.actions.some(function (value) {\n      return value === action;\n    })) {\n      this.preventEvent = this.content.scrollTop !== 0;\n      this.content.scrollTop = 0;\n    }\n\n    if (action !== 'virtualscroll') {\n      this.isAdd = false;\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  VirtualContentRenderer.prototype.onActionBegin = function (e) {\n    //Update property silently..\n    this.parent.setProperties({\n      pageSettings: {\n        currentPage: 1\n      }\n    }, true);\n  };\n\n  VirtualContentRenderer.prototype.getRows = function () {\n    return this.vgenerator.getRows();\n  };\n\n  VirtualContentRenderer.prototype.getRowByIndex = function (index) {\n    var row$$1;\n\n    if (isGroupAdaptive(this.parent)) {\n      row$$1 = this.parent.getDataRows()[index];\n    } else if (this.prevInfo) {\n      row$$1 = this.getRowCollection(index, false);\n    }\n\n    return row$$1;\n  };\n\n  VirtualContentRenderer.prototype.getMovableVirtualRowByIndex = function (index) {\n    return this.getRowCollection(index, true);\n  };\n\n  VirtualContentRenderer.prototype.getFrozenRightVirtualRowByIndex = function (index) {\n    return this.getRowCollection(index, false, false, true);\n  };\n\n  VirtualContentRenderer.prototype.getRowCollection = function (index, isMovable, isRowObject, isFrozenRight) {\n    var prev = this.prevInfo.blockIndexes;\n    var startIdx = (prev[0] - 1) * this.getBlockSize();\n    var rowCollection = isMovable ? this.parent.getMovableDataRows() : this.parent.getDataRows();\n    rowCollection = isFrozenRight ? this.parent.getFrozenRightDataRows() : rowCollection;\n    var collection = isRowObject ? this.parent.getCurrentViewRecords() : rowCollection;\n\n    if (isRowObject && this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n      startIdx = parseInt(this.parent.getRows()[0].getAttribute(dataRowIndex), 10);\n      collection = collection.filter(function (m) {\n        return isNullOrUndefined(m.items);\n      });\n    }\n\n    var selectedRow = collection[index - startIdx];\n\n    if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n      if (!isRowObject) {\n        selectedRow = index <= this.parent.frozenRows ? rowCollection[index] : rowCollection[index - startIdx + this.parent.frozenRows];\n      } else {\n        selectedRow = index <= this.parent.frozenRows ? this.parent.getRowsObject()[index].data : selectedRow;\n      }\n    }\n\n    return selectedRow;\n  };\n\n  VirtualContentRenderer.prototype.getVirtualRowIndex = function (index) {\n    var prev = this.prevInfo.blockIndexes;\n    var startIdx = (prev[0] - 1) * this.getBlockSize();\n    return startIdx + index;\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  VirtualContentRenderer.prototype.refreshOffsets = function () {\n    var gObj = this.parent;\n    var row$$1 = 0;\n    var bSize = this.getBlockSize();\n    var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    this.prevHeight = this.offsets[total];\n    this.maxBlock = total % 2 === 0 ? total - 2 : total - 1;\n    this.offsets = {}; //Row offset update\n    // eslint-disable-next-line prefer-spread\n\n    var blocks = Array.apply(null, Array(total)).map(function () {\n      return ++row$$1;\n    });\n\n    for (var i = 0; i < blocks.length; i++) {\n      var tmp = (this.vgenerator.cache[blocks[i]] || []).length;\n      var rem = !isGroupAdaptive(this.parent) ? this.count % bSize : gObj.vcRows.length % bSize;\n      var size = !isGroupAdaptive(this.parent) && blocks[i] in this.vgenerator.cache ? tmp * this.parent.getRowHeight() : rem && blocks[i] === total ? rem * this.parent.getRowHeight() : this.getBlockHeight(); // let size: number = this.parent.groupSettings.columns.length && block in this.vgenerator.cache ?\n      // tmp * getRowHeight() : this.getBlockHeight();\n\n      this.offsets[blocks[i]] = (this.offsets[blocks[i] - 1] | 0) + size;\n      this.tmpOffsets[blocks[i]] = this.offsets[blocks[i] - 1] | 0;\n    }\n\n    this.offsetKeys = Object.keys(this.offsets);\n\n    if (isGroupAdaptive(this.parent)) {\n      this.parent.vGroupOffsets = this.offsets;\n    } //Column offset update\n\n\n    if (this.parent.enableColumnVirtualization) {\n      this.vgenerator.refreshColOffsets();\n    }\n  };\n\n  VirtualContentRenderer.prototype.refreshVirtualElement = function () {\n    this.vgenerator.refreshColOffsets();\n    this.setVirtualHeight();\n  };\n\n  VirtualContentRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var frozenCols = this.parent.getFrozenColumns();\n    var fcntColGrp;\n    var mcntColGrp;\n\n    if (frozenCols) {\n      fcntColGrp = [].slice.call(this.parent.getFrozenVirtualContent().querySelectorAll('col'));\n      mcntColGrp = [].slice.call(this.parent.getMovableVirtualContent().querySelectorAll('col'));\n    }\n\n    var rows = [];\n    rows = this.getRows();\n    var testRow;\n    rows.some(function (r) {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    var isRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      isRefresh = false;\n    }\n\n    var tr = gObj.getDataRows();\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      var idx = gObj.getNormalizedColumnIndex(column.uid);\n      var displayVal = column.visible === true ? '' : 'none';\n      var colGrp = void 0;\n\n      if (fcntColGrp && mcntColGrp) {\n        if (idx >= frozenCols) {\n          colGrp = mcntColGrp;\n          tr = this.parent.getMovableRows();\n          idx = idx - frozenCols;\n        } else {\n          colGrp = fcntColGrp;\n        }\n      } else {\n        colGrp = this.getColGroup().children;\n      }\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        setStyleAttribute(colGrp[idx], {\n          'display': displayVal\n        });\n      }\n\n      if (!isRefresh) {\n        var width = void 0;\n\n        if (column.width) {\n          if (column.visible) {\n            width = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n          } else {\n            width = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n          }\n        }\n\n        if (width > gObj.width) {\n          this.setDisplayNone(tr, idx, displayVal, rows);\n\n          if (this.parent.enableColumnVirtualization) {\n            this.virtualEle.setWrapperWidth(width + '');\n          }\n\n          this.refreshVirtualElement();\n        } else {\n          isRefresh = true;\n        }\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (isRefresh || frozenCols) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      this.parent.notify(partialRefresh, {\n        rows: rows,\n        args: {\n          isFrozen: false,\n          rows: rows\n        }\n      });\n    }\n  };\n\n  VirtualContentRenderer.prototype.selectVirtualRow = function (args) {\n    var _this = this;\n\n    args.isAvailable = args.selectedIndex < this.count;\n\n    if (args.isAvailable && !this.isContextMenuOpen && this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow' && !this.isSelection && !this.requestTypes.some(function (value) {\n      return value === _this.requestType;\n    }) && !this.parent.selectionModule.isInteracted) {\n      var selectedRow = this.parent.getRowByIndex(args.selectedIndex);\n      var rowHeight = this.parent.getRowHeight();\n\n      if (!selectedRow || !this.isRowInView(selectedRow)) {\n        this.isSelection = true;\n        this.selectedRowIndex = args.selectedIndex;\n        var scrollTop = (args.selectedIndex + 1) * rowHeight;\n\n        if (!isNullOrUndefined(scrollTop)) {\n          var direction = this.content.scrollTop < scrollTop ? 'down' : 'up';\n          this.selectRowIndex = args.selectedIndex;\n          this.content.scrollTop = scrollTop;\n          this.isSelectionScroll = this.observer.check(direction);\n        }\n      }\n    }\n\n    if (this.parent.isFrozenGrid() && this.requestType) {\n      if (this.parent.getTablesCount() === this.frzIdx) {\n        this.requestType = this.empty;\n        this.frzIdx = 1;\n      } else {\n        this.frzIdx++;\n      }\n    } else {\n      this.requestType = this.empty;\n    }\n  };\n\n  VirtualContentRenderer.prototype.isRowInView = function (row$$1) {\n    var top = row$$1.getBoundingClientRect().top;\n    var bottom = row$$1.getBoundingClientRect().bottom;\n    return top >= this.content.getBoundingClientRect().top && bottom <= this.content.getBoundingClientRect().bottom;\n  };\n\n  return VirtualContentRenderer;\n}(ContentRender);\n/**\n * @hidden\n */\n\n\nvar VirtualHeaderRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$24(VirtualHeaderRenderer, _super);\n\n  function VirtualHeaderRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.virtualEle = new VirtualElementHandler();\n    _this.isMovable = false;\n    _this.gen = new VirtualRowModelGenerator(_this.parent);\n\n    _this.parent.on(columnVisibilityChanged, _this.setVisible, _this);\n\n    _this.parent.on(refreshVirtualBlock, function (e) {\n      return e.virtualInfo.sentinelInfo.axis === 'X' ? _this.refreshUI() : null;\n    }, _this);\n\n    return _this;\n  }\n\n  VirtualHeaderRenderer.prototype.renderTable = function () {\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().querySelector('.' + headerContent)));\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.getPanel().querySelector('.' + headerContent);\n    this.virtualEle.content.style.position = 'relative';\n    this.virtualEle.renderWrapper();\n    this.virtualEle.renderPlaceHolder('absolute');\n  };\n\n  VirtualHeaderRenderer.prototype.appendContent = function (table$$1) {\n    if (!this.isMovable) {\n      this.virtualEle.wrapper.appendChild(table$$1);\n    } else {\n      this.virtualEle.movableWrapper.appendChild(table$$1);\n      this.isMovable = false;\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.refreshUI = function () {\n    this.isMovable = this.parent.isFrozenGrid();\n    this.setFrozenTable(this.parent.getMovableVirtualContent());\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().querySelector('.' + headerContent)));\n\n    _super.prototype.refreshUI.call(this);\n\n    this.setFrozenTable(this.parent.getFrozenVirtualContent());\n  };\n\n  VirtualHeaderRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var displayVal;\n    var idx;\n    var needFullRefresh;\n    var frozenCols = this.parent.getFrozenColumns();\n    var fhdrColGrp;\n    var mhdrColGrp;\n\n    if (frozenCols) {\n      fhdrColGrp = [].slice.call(this.parent.getFrozenVirtualHeader().querySelectorAll('col'));\n      mhdrColGrp = [].slice.call(this.parent.getMovableVirtualHeader().querySelectorAll('col'));\n    }\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n      var colGrp = void 0;\n\n      if (fhdrColGrp && mhdrColGrp) {\n        if (idx >= frozenCols) {\n          colGrp = mhdrColGrp;\n          idx = idx - frozenCols;\n        } else {\n          colGrp = fhdrColGrp;\n        }\n      } else {\n        colGrp = this.getColGroup().children;\n      }\n\n      setStyleAttribute(colGrp[idx], {\n        'display': displayVal\n      });\n\n      if (gObj.enableColumnVirtualization && !gObj.groupSettings.columns.length) {\n        var tablewidth = void 0;\n\n        if (column.visible) {\n          tablewidth = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n        } else {\n          tablewidth = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n        }\n\n        if (tablewidth > gObj.width) {\n          this.setDisplayNone(column, displayVal);\n          this.virtualEle.setWrapperWidth(tablewidth + '');\n          this.gen.refreshColOffsets();\n        } else {\n          needFullRefresh = true;\n        }\n      } else {\n        needFullRefresh = true;\n      }\n\n      if (needFullRefresh && !frozenCols) {\n        this.refreshUI();\n      }\n    }\n\n    if (frozenCols) {\n      this.parent.notify(columnPositionChanged, {});\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.setFrozenTable = function (content$$1) {\n    if (this.parent.isFrozenGrid() && this.parent.enableColumnVirtualization && this.parent.contentModule.isXaxis()) {\n      this.parent.contentModule.setTable(content$$1.querySelector('.' + table + ':not(.e-masked-table)'));\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.setDisplayNone = function (col, displayVal) {\n    var frozenCols = this.parent.isFrozenGrid();\n    var table$$1 = this.getTable();\n\n    if (frozenCols && col.getFreezeTableName() === 'movable') {\n      table$$1 = this.parent.getMovableVirtualHeader().querySelector('.' + table);\n    }\n\n    for (var _i = 0, _a = [].slice.apply(table$$1.querySelectorAll('th.e-headercell')); _i < _a.length; _i++) {\n      var ele = _a[_i];\n\n      if (ele.querySelector('[e-mappinguid]') && ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === col.uid) {\n        setStyleAttribute(ele, {\n          'display': displayVal\n        });\n\n        if (displayVal === '') {\n          removeClass([ele], 'e-hide');\n        }\n\n        break;\n      }\n    }\n  };\n\n  return VirtualHeaderRenderer;\n}(HeaderRender);\n/**\n * @hidden\n */\n\n\nvar VirtualElementHandler =\n/** @__PURE__ @class */\nfunction () {\n  function VirtualElementHandler() {}\n\n  VirtualElementHandler.prototype.renderWrapper = function (height) {\n    this.wrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: \"min-height:\" + formatUnit(height)\n    });\n    this.wrapper.appendChild(this.table);\n    this.content.appendChild(this.wrapper);\n  };\n\n  VirtualElementHandler.prototype.renderPlaceHolder = function (position) {\n    if (position === void 0) {\n      position = 'relative';\n    }\n\n    this.placeholder = createElement('div', {\n      className: 'e-virtualtrack',\n      styles: \"position:\" + position\n    });\n    this.content.appendChild(this.placeholder);\n  };\n\n  VirtualElementHandler.prototype.renderFrozenWrapper = function (height) {\n    this.wrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: \"min-height:\" + formatUnit(height) + \"; display: flex\"\n    });\n    this.content.appendChild(this.wrapper);\n  };\n\n  VirtualElementHandler.prototype.renderFrozenPlaceHolder = function () {\n    this.placeholder = createElement('div', {\n      className: 'e-virtualtrack'\n    });\n    this.content.appendChild(this.placeholder);\n  };\n\n  VirtualElementHandler.prototype.renderMovableWrapper = function (height) {\n    this.movableWrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: \"min-height:\" + formatUnit(height)\n    });\n    this.movableContent.appendChild(this.movableWrapper);\n  };\n\n  VirtualElementHandler.prototype.renderMovablePlaceHolder = function () {\n    this.movablePlaceholder = createElement('div', {\n      className: 'e-virtualtrack'\n    });\n    this.movableContent.appendChild(this.movablePlaceholder);\n  };\n\n  VirtualElementHandler.prototype.adjustTable = function (xValue, yValue) {\n    this.wrapper.style.transform = \"translate(\" + xValue + \"px, \" + yValue + \"px)\";\n  };\n\n  VirtualElementHandler.prototype.adjustMovableTable = function (xValue, yValue) {\n    this.movableWrapper.style.transform = \"translate(\" + xValue + \"px, \" + yValue + \"px)\";\n  };\n\n  VirtualElementHandler.prototype.setMovableWrapperWidth = function (width, full) {\n    this.movableWrapper.style.width = width ? width + \"px\" : full ? '100%' : '';\n  };\n\n  VirtualElementHandler.prototype.setMovableVirtualHeight = function (height, width) {\n    this.movablePlaceholder.style.height = height + \"px\";\n    this.movablePlaceholder.style.width = width;\n  };\n\n  VirtualElementHandler.prototype.setWrapperWidth = function (width, full) {\n    this.wrapper.style.width = width ? width + \"px\" : full ? '100%' : '';\n  };\n\n  VirtualElementHandler.prototype.setVirtualHeight = function (height, width) {\n    this.placeholder.style.height = !isNullOrUndefined(height) ? height + \"px\" : '0px';\n    this.placeholder.style.width = width;\n  };\n\n  VirtualElementHandler.prototype.setFreezeWrapperWidth = function (wrapper, width, full) {\n    wrapper.style.width = width ? width + \"px\" : full ? '100%' : '';\n  };\n\n  return VirtualElementHandler;\n}();\n/**\n * Virtual Scrolling class\n */\n\n\nvar VirtualScroll =\n/** @__PURE__ @class */\nfunction () {\n  function VirtualScroll(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.addEventListener();\n  }\n\n  VirtualScroll.prototype.getModuleName = function () {\n    return 'virtualscroll';\n  };\n\n  VirtualScroll.prototype.instantiateRenderer = function () {\n    this.parent.log(['limitation', 'virtual_height'], 'virtualization');\n    var renderer = this.locator.getService('rendererFactory');\n\n    if (!this.parent.isFrozenGrid()) {\n      if (this.parent.enableColumnVirtualization) {\n        renderer.addRenderer(RenderType.Header, new VirtualHeaderRenderer(this.parent, this.locator));\n      }\n\n      renderer.addRenderer(RenderType.Content, new VirtualContentRenderer(this.parent, this.locator));\n    }\n\n    this.ensurePageSize();\n  };\n\n  VirtualScroll.prototype.ensurePageSize = function () {\n    var rowHeight = this.parent.getRowHeight();\n    var vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.parent.height : this.parent.element.getBoundingClientRect().height;\n    this.blockSize = ~~(vHeight / rowHeight);\n    var height = this.blockSize * 2;\n    var size = this.parent.pageSettings.pageSize;\n    this.parent.setProperties({\n      pageSettings: {\n        pageSize: size < height ? height : size\n      }\n    }, true);\n  };\n\n  VirtualScroll.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on(columnWidthChanged, this.refreshVirtualElement, this);\n    this.parent.on(createVirtualValidationForm, this.createVirtualValidationForm, this);\n    this.parent.on(validateVirtualForm, this.virtualEditFormValidation, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n\n  VirtualScroll.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.instantiateRenderer);\n    this.parent.off(columnWidthChanged, this.refreshVirtualElement);\n    this.parent.off(createVirtualValidationForm, this.createVirtualValidationForm);\n    this.parent.off(validateVirtualForm, this.virtualEditFormValidation);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  VirtualScroll.prototype.getCurrentEditedData = function (prevData) {\n    var data = {\n      virtualData: extend({}, {}, prevData, true),\n      isAdd: false,\n      isScroll: false,\n      endEdit: true\n    };\n    this.parent.notify(getVirtualData, data);\n    return data.virtualData;\n  };\n\n  VirtualScroll.prototype.createVirtualValidationForm = function (e) {\n    var gObj = this.parent;\n\n    if (gObj.enableVirtualization && gObj.editSettings.mode === 'Normal') {\n      var cols = gObj.columns;\n      var rowRenderer = new RowRenderer(this.locator, null, this.parent);\n      var rowObj = extend({}, {}, gObj.getRowObjectFromUID(e.uid), true);\n      gObj.notify(refreshVirtualEditFormCells, rowObj);\n      var args = e.argsCreator(this.getCurrentEditedData(e.prevData), {}, false);\n      args.isCustomFormValidation = true;\n      args.row = rowRenderer.render(rowObj, cols);\n      e.renderer.update(args);\n      var rules = {};\n\n      for (var i = 0; i < cols.length; i++) {\n        if (!cols[i].visible) {\n          continue;\n        }\n\n        if (cols[i].validationRules) {\n          setValidationRuels(cols[i], 0, rules, {}, {}, cols.length, true);\n        }\n      }\n\n      args.form.classList.add('e-virtual-validation');\n      gObj.editModule.virtualFormObj = gObj.editModule.createFormObj(args.form, rules);\n    }\n  };\n\n  VirtualScroll.prototype.virtualEditFormValidation = function (args) {\n    var gObj = this.parent;\n    var error = gObj.element.querySelector('.e-griderror:not([style*=\"display: none\"])');\n\n    if (gObj.editModule.virtualFormObj) {\n      if (error && error.style.display !== 'none') {\n        var errorDomRect = error.getBoundingClientRect();\n        var forms = gObj.element.querySelectorAll('.e-gridform');\n        var form = forms[0];\n        var contentLeft = gObj.getContent().getBoundingClientRect().left;\n\n        if (forms.length > 1) {\n          form = gObj.getFrozenMode() !== 'Right' ? forms[1] : forms[0];\n          contentLeft = gObj.getMovableVirtualContent().getBoundingClientRect().left;\n        }\n\n        if (errorDomRect.left < contentLeft || errorDomRect.right > gObj.element.offsetWidth) {\n          var tooltip = form.querySelector('.e-tooltip-wrap:not([style*=\"display: none\"])');\n          this.scrollToEdit(tooltip, {\n            editIdx: args.editIdx,\n            addIdx: args.addIdx\n          }, true);\n        }\n      } else if (gObj.editModule.virtualFormObj && (!error || error.style.display === 'none')) {\n        var existingErrors = gObj.editModule.virtualFormObj.element.querySelectorAll('.e-tooltip-wrap:not([style*=\"display: none\"])');\n\n        for (var i = 0; i < existingErrors.length; i++) {\n          remove(existingErrors[i]);\n        }\n\n        this.setEditedDataToValidationForm(gObj.editModule.virtualFormObj.element, this.getCurrentEditedData(args.prevData));\n        args.isValid = gObj.editModule.virtualFormObj.validate();\n\n        if (!args.isValid) {\n          var tooltip = gObj.editModule.virtualFormObj.element.querySelector('.e-tooltip-wrap:not([style*=\"display: none\"])');\n          this.scrollToEdit(tooltip, {\n            editIdx: args.editIdx,\n            addIdx: args.addIdx\n          });\n        }\n      }\n    }\n  };\n\n  VirtualScroll.prototype.scrollToEdit = function (tooltip, args, isRenderer) {\n    var gObj = this.parent;\n\n    if (tooltip) {\n      var cols = gObj.columnModel;\n      var field = setComplexFieldID(tooltip.id).split('_')[0];\n      var col = gObj.getColumnByField(field);\n      var scrollTop = this.parent.getContent().firstElementChild.scrollTop;\n      var row = gObj.getRowByIndex(args.editIdx);\n\n      if (isRenderer || !col || !isNullOrUndefined(args.addIdx) && scrollTop > 0 || !isNullOrUndefined(args.editIdx) && !row) {\n        var validationCol = void 0;\n\n        for (var i = 0; i < cols.length && !col; i++) {\n          if (cols[i].field === field) {\n            validationCol = cols[i];\n            break;\n          }\n        }\n\n        if (isRenderer) {\n          validationCol = col;\n        }\n\n        this.parent.notify(scrollToEdit, validationCol);\n      }\n    }\n  };\n\n  VirtualScroll.prototype.setEditedDataToValidationForm = function (form, editedData) {\n    var inputs = [].slice.call(form.getElementsByClassName('e-field'));\n\n    for (var i = 0, len = inputs.length; i < len; i++) {\n      var col = getColumnModelByUid(this.parent, inputs[i].getAttribute('e-mappinguid'));\n      var value = getValue(col.field, editedData);\n      value = isNullOrUndefined(value) ? '' : value;\n      inputs[i].value = value;\n    }\n  };\n\n  VirtualScroll.prototype.refreshVirtualElement = function (args) {\n    if (this.parent.enableColumnVirtualization && args.module === 'resize') {\n      var renderer = this.locator.getService('rendererFactory');\n      renderer.getRenderer(RenderType.Content).refreshVirtualElement();\n    }\n  };\n\n  VirtualScroll.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  return VirtualScroll;\n}();\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nvar InlineEditRender =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - returns the IGrid\n   */\n  function InlineEditRender(parent) {\n    this.parent = parent;\n  }\n\n  InlineEditRender.prototype.addNew = function (elements, args) {\n    this.isEdit = false;\n    var tbody$$1;\n    var mTbody = getMovableTbody(this.parent);\n    var frTbody = getFrozenRightTbody(this.parent);\n    var isFrozenGrid = this.parent.isFrozenGrid();\n    var isVirtualFrozen = isFrozenGrid && this.parent.enableColumnVirtualization && args.isScroll;\n\n    if (this.parent.frozenRows && this.parent.editSettings.newRowPosition === 'Top') {\n      tbody$$1 = isVirtualFrozen ? this.parent.getMovableHeaderTbody() : this.parent.getHeaderTable().querySelector(tbody);\n    } else {\n      tbody$$1 = isVirtualFrozen ? this.parent.getMovableContentTbody() : this.parent.getContentTable().querySelector(tbody);\n    }\n\n    args.row = this.parent.createElement('tr', {\n      className: 'e-row e-addedrow',\n      attrs: {\n        role: 'row'\n      }\n    });\n\n    if (tbody$$1.querySelector('.e-emptyrow')) {\n      var emptyRow = tbody$$1.querySelector('.e-emptyrow');\n      emptyRow.parentNode.removeChild(emptyRow);\n\n      if (isFrozenGrid && !isVirtualFrozen) {\n        var moveTbody = this.parent.getContent().querySelector('.' + movableContent).querySelector(tbody);\n        moveTbody.firstElementChild.parentNode.removeChild(moveTbody.firstElementChild);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          var frTbody_1 = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n          frTbody_1.firstElementChild.parentNode.removeChild(frTbody_1.firstElementChild);\n        }\n      }\n    }\n\n    if (this.parent.editSettings.newRowPosition === 'Top') {\n      tbody$$1.insertBefore(args.row, tbody$$1.firstChild);\n    } else {\n      tbody$$1.appendChild(args.row);\n    }\n\n    args.row.appendChild(this.getEditElement(elements, false, undefined, args, true));\n    this.parent.editModule.checkLastRow(args.row, args);\n\n    if (isFrozenGrid && !isVirtualFrozen) {\n      var mEle = this.renderMovableform(args.row, args);\n\n      if (this.parent.editSettings.newRowPosition === 'Top') {\n        mTbody.insertBefore(mEle, mTbody.firstChild);\n      } else {\n        mTbody.appendChild(mEle);\n      }\n\n      args.row.querySelector('.e-normaledit').setAttribute('colspan', this.parent.getVisibleFrozenColumns() + '');\n      mEle.querySelector('.e-normaledit').setAttribute('colspan', '' + (this.parent.getVisibleColumns().length - this.parent.getVisibleFrozenColumns()));\n\n      if (frTbody) {\n        var frEle = this.renderFrozenRightForm(args.row, args);\n\n        if (this.parent.editSettings.newRowPosition === 'Top') {\n          frTbody.insertBefore(frEle, frTbody.firstChild);\n        } else {\n          frTbody.appendChild(frEle);\n        }\n\n        var colSpan = this.parent.getVisibleFrozenColumns() - this.parent.getFrozenRightColumnsCount();\n        args.row.querySelector('.e-normaledit').setAttribute('colspan', colSpan + '');\n        frEle.querySelector('.e-normaledit').setAttribute('colspan', '' + this.parent.getFrozenRightColumnsCount());\n      }\n\n      if (this.parent.height === 'auto') {\n        this.parent.notify(frozenHeight, {});\n      }\n    }\n  };\n\n  InlineEditRender.prototype.renderFrozenRightForm = function (ele, args) {\n    var frEle = ele.cloneNode(true);\n    var form = args.frozenRightForm = frEle.querySelector('form');\n\n    if (this.parent.editSettings.template) {\n      form.innerHTML = '';\n      this.appendChildren(form, args.rowData, false);\n      return frEle;\n    }\n\n    this.renderRightFrozen(ele, frEle);\n    frEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup).innerHTML;\n    return frEle;\n  };\n\n  InlineEditRender.prototype.renderMovableform = function (ele, args) {\n    var mEle = ele.cloneNode(true);\n    var form = args.movableForm = mEle.querySelector('form');\n\n    if (this.parent.editSettings.template) {\n      form.innerHTML = '';\n      this.appendChildren(form, args.rowData, false);\n      return mEle;\n    }\n\n    this.renderMovable(ele, mEle);\n    mEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).innerHTML;\n    return mEle;\n  };\n\n  InlineEditRender.prototype.updateFreezeEdit = function (row$$1, td) {\n    td = td.concat([].slice.call(this.getFreezeRow(row$$1).querySelectorAll('td.e-rowcell')));\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      td = td.concat([].slice.call(this.getFreezeRightRow(row$$1).querySelectorAll('td.e-rowcell')));\n    }\n\n    return td;\n  };\n\n  InlineEditRender.prototype.getFreezeRightRow = function (row$$1) {\n    var idx = parseInt(row$$1.getAttribute(dataRowIndex), 10);\n    var fCont = this.parent.getFrozenLeftContentTbody();\n    var fHdr = this.parent.getFrozenHeaderTbody();\n    var frHdr = this.parent.getFrozenRightHeaderTbody();\n    var frCont = this.parent.getFrozenRightContentTbody();\n\n    if (fCont.contains(row$$1) || fHdr.contains(row$$1)) {\n      return this.parent.getFrozenRightRowByIndex(idx);\n    } else if (frCont.contains(row$$1) || frHdr.contains(row$$1)) {\n      return this.parent.getRowByIndex(idx);\n    }\n\n    return row$$1;\n  };\n\n  InlineEditRender.prototype.getFreezeRow = function (row$$1) {\n    if (this.parent.isFrozenGrid()) {\n      var idx = parseInt(row$$1.getAttribute(dataRowIndex), 10);\n      var fCont = this.parent.getFrozenLeftContentTbody();\n      var mCont = this.parent.getMovableContentTbody();\n      var fHdr = this.parent.getFrozenHeaderTbody();\n      var mHdr = this.parent.getMovableHeaderTbody();\n\n      if (fCont.contains(row$$1) || fHdr.contains(row$$1)) {\n        return this.parent.getMovableRowByIndex(idx);\n      } else if (mCont.contains(row$$1) || mHdr.contains(row$$1)) {\n        return this.parent.getRowByIndex(idx);\n      }\n    }\n\n    return row$$1;\n  };\n\n  InlineEditRender.prototype.update = function (elements, args) {\n    this.isEdit = true;\n    var isCustomFormValidation = args.isCustomFormValidation;\n    var isScroll = args.isScroll;\n\n    if (!isScroll && (closest(args.row, '.' + movableContent) || closest(args.row, '.' + movableHeader))) {\n      args.row = this.getFreezeRow(args.row);\n    }\n\n    if (closest(args.row, '.e-frozen-right-content') || closest(args.row, '.e-frozen-right-header')) {\n      args.row = this.getFreezeRightRow(args.row);\n    }\n\n    var isVirtualFrozen = this.parent.isFrozenGrid() && this.parent.enableColumnVirtualization && isScroll;\n    var tdElement = [].slice.call(args.row.querySelectorAll('td.e-rowcell'));\n    args.row.innerHTML = '';\n\n    if (!isVirtualFrozen && !isCustomFormValidation) {\n      tdElement = this.updateFreezeEdit(args.row, tdElement);\n    }\n\n    args.row.appendChild(this.getEditElement(elements, true, tdElement, args, true));\n    args.row.classList.add(editedRow);\n    this.parent.editModule.checkLastRow(args.row, args);\n\n    if (!isVirtualFrozen && !isCustomFormValidation) {\n      this.refreshFreezeEdit(args.row, args);\n    }\n  };\n\n  InlineEditRender.prototype.refreshFreezeEdit = function (row$$1, args) {\n    var td = row$$1.firstChild;\n\n    if (this.parent.getVisibleFrozenColumns() && this.parent.editSettings.template) {\n      td.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(colGroup).innerHTML;\n    }\n\n    var fCls;\n    var cont;\n    var idx = parseInt(row$$1.getAttribute(dataRowIndex), 10);\n\n    if (this.parent.isFrozenGrid()) {\n      if (idx < this.parent.frozenRows) {\n        cont = this.parent.getHeaderContent();\n        fCls = '.' + frozenHeader;\n      } else {\n        cont = this.parent.getContent();\n        fCls = '.' + frozenContent;\n      }\n\n      var mTd = td.cloneNode(true);\n      var frTd = td.cloneNode(true);\n      var form = args.movableForm = mTd.querySelector('form');\n\n      if (this.parent.editSettings.template) {\n        this.refreshEditForm(form, args.rowData);\n      }\n\n      var fRows = void 0;\n      var frRows = void 0;\n\n      if (cont.querySelector(fCls).contains(row$$1)) {\n        fRows = this.parent.getMovableRowByIndex(idx);\n        this.updateFrozenCont(fRows, td, mTd);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          args.frozenRightForm = frTd.querySelector('form');\n          this.refreshEditForm(args.frozenRightForm, args.rowData);\n          frRows = this.parent.getFrozenRightRowByIndex(idx);\n          this.updateFrozenRightCont(frRows, td, frTd);\n        }\n      } else {\n        fRows = this.parent.getRowByIndex(idx);\n        this.updateFrozenCont(fRows, mTd, td);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          args.frozenRightForm = frTd.querySelector('form');\n          this.refreshEditForm(args.frozenRightForm, args.rowData);\n          frRows = this.parent.getFrozenRightRowByIndex(idx);\n          this.updateFrozenRightCont(frRows, frTd, td);\n        }\n      }\n\n      fRows.appendChild(mTd);\n      fRows.classList.add(editedRow);\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        frRows.appendChild(frTd);\n        frRows.classList.add(editedRow);\n        alignFrozenEditForm(args.frozenRightForm.querySelector('td:not(.e-hide)'), args.form.querySelector('td:not(.e-hide)'));\n      }\n\n      alignFrozenEditForm(args.movableForm.querySelector('td:not(.e-hide)'), args.form.querySelector('td:not(.e-hide)'));\n    }\n  };\n\n  InlineEditRender.prototype.refreshEditForm = function (form, data) {\n    if (this.parent.editSettings.template) {\n      form.innerHTML = '';\n      this.appendChildren(form, data, false);\n    }\n  };\n\n  InlineEditRender.prototype.updateFrozenRightCont = function (row$$1, ele, frEle) {\n    row$$1.innerHTML = '';\n    this.renderRightFrozen(ele, frEle);\n    frEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup).innerHTML;\n    ele.setAttribute('colspan', this.parent.getVisibleFrozenColumns() - this.parent.getFrozenRightColumnsCount() + '');\n    frEle.setAttribute('colspan', this.parent.getFrozenRightColumnsCount() + '');\n  };\n\n  InlineEditRender.prototype.updateFrozenCont = function (row$$1, ele, mEle) {\n    row$$1.innerHTML = '';\n    this.renderMovable(ele, mEle);\n    mEle.querySelector(colGroup).innerHTML = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).innerHTML;\n    ele.setAttribute('colspan', this.parent.getVisibleFrozenColumns() + '');\n    mEle.setAttribute('colspan', this.parent.getCurrentVisibleColumns(this.parent.enableColumnVirtualization).length - this.parent.getVisibleFrozenColumns() + '');\n  };\n\n  InlineEditRender.prototype.renderRightFrozen = function (ele, frEle) {\n    frEle.querySelector('tr').innerHTML = '';\n    var cols = this.parent.getColumns();\n    var k = 0;\n\n    for (var i = 0; i < cols.length; i++, k++) {\n      if (cols[i].getFreezeTableName() === frozenRight) {\n        var index = k - this.parent.getMovableColumnsCount();\n        frEle.querySelector('tr').appendChild(ele.querySelector('tr').removeChild(ele.querySelector('tr').children[index]));\n        k--;\n      }\n    }\n  };\n\n  InlineEditRender.prototype.renderMovable = function (ele, mEle) {\n    mEle.querySelector('tr').innerHTML = '';\n    var cols = this.parent.getColumns();\n    var k = this.parent.isRowDragable() ? 1 : 0;\n\n    for (var i = 0; i < cols.length; i++, k++) {\n      if (cols[i].getFreezeTableName() === 'movable') {\n        mEle.querySelector('tr').appendChild(ele.querySelector('tr').removeChild(ele.querySelector('tr').children[k]));\n        k--;\n      }\n    }\n  }; // eslint-disable-next-line max-len\n\n\n  InlineEditRender.prototype.getEditElement = function (elements, isEdit, tdElement, args, isFrozen) {\n    var gObj = this.parent;\n    var gLen = 0;\n    var isDetail = !isNullOrUndefined(gObj.detailTemplate) || !isNullOrUndefined(gObj.childGrid) ? 1 : 0;\n\n    if (gObj.allowGrouping) {\n      gLen = gObj.groupSettings.columns.length;\n    }\n\n    var td = this.parent.createElement('td', {\n      className: 'e-editcell e-normaledit',\n      attrs: {\n        colspan: (gObj.getCurrentVisibleColumns(this.parent.enableColumnVirtualization).length - gObj.getVisibleFrozenColumns() + this.parent.getIndentCount()).toString()\n      }\n    });\n    var form = args.form = this.parent.createElement('form', {\n      id: gObj.element.id + 'EditForm',\n      className: 'e-gridform'\n    });\n\n    if (this.parent.editSettings.template) {\n      this.appendChildren(form, args.rowData, isFrozen);\n      td.appendChild(form);\n      return td;\n    }\n\n    var table$$1 = this.parent.createElement('table', {\n      className: 'e-table e-inline-edit',\n      attrs: {\n        cellspacing: '0.25',\n        role: 'grid'\n      }\n    });\n    table$$1.appendChild(gObj.getContentTable().querySelector(colGroup).cloneNode(true));\n    var tbody$$1 = this.parent.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    var tr = this.parent.createElement('tr', {\n      attrs: {\n        role: 'row'\n      }\n    });\n    var i = 0;\n\n    if (isDetail) {\n      tr.insertBefore(this.parent.createElement('td', {\n        className: 'e-detailrowcollapse'\n      }), tr.firstChild);\n    }\n\n    if (gObj.isRowDragable()) {\n      tr.appendChild(this.parent.createElement('td', {\n        className: 'e-dragindentcell'\n      }));\n    }\n\n    while (i < gLen) {\n      tr.appendChild(this.parent.createElement('td', {\n        className: 'e-indentcell'\n      }));\n      i++;\n    }\n\n    var m = 0;\n    i = 0;\n    var isVirtualFrozen = gObj.isFrozenGrid() && gObj.enableColumnVirtualization && args.isScroll;\n    var cols = args.isCustomFormValidation ? this.parent.columnModel : gObj.getColumns();\n\n    while (isEdit && m < tdElement.length && i < cols.length || i < cols.length) {\n      var span = isEdit ? tdElement[m].getAttribute('colspan') : null;\n      var col = cols[i];\n\n      if (isVirtualFrozen && col.getFreezeTableName() !== 'movable' || args.isCustomFormValidation && (col.commands || col.commandsTemplate || !col.field)) {\n        i++;\n        continue;\n      }\n\n      var td_1 = this.parent.createElement('td', {\n        className: rowCell,\n        attrs: {\n          style: 'text-align:' + (col.textAlign ? col.textAlign : ''),\n          'colspan': span ? span : ''\n        }\n      });\n\n      if (col.visible) {\n        td_1.appendChild(elements[col.uid]);\n\n        if (this.parent.rowRenderingMode === 'Vertical') {\n          setStyleAndAttributes(td_1, {\n            'data-cell': col.headerText\n          });\n\n          if (i === 0) {\n            td_1.classList.add('e-responsive-editcell');\n          }\n        }\n\n        if (col.editType === 'booleanedit') {\n          td_1.classList.add('e-boolcell');\n        } else if (col.commands || col.commandsTemplate) {\n          addClass([td_1], 'e-unboundcell');\n        }\n      } else {\n        td_1.classList.add('e-hide');\n      }\n\n      tr.appendChild(td_1);\n      i = span ? i + parseInt(span, 10) : i + 1;\n      m++;\n    }\n\n    tbody$$1.appendChild(tr);\n    table$$1.appendChild(tbody$$1);\n    form.appendChild(table$$1);\n    td.appendChild(form);\n    return td;\n  };\n\n  InlineEditRender.prototype.removeEventListener = function () {//To destroy the renderer\n  };\n\n  InlineEditRender.prototype.appendChildren = function (form, data, isFrozen) {\n    var dummyData = extend({}, data, {\n      isAdd: !this.isEdit,\n      isFrozen: isFrozen\n    }, true);\n    var editTemplateID = this.parent.element.id + 'editSettingsTemplate';\n\n    if (this.parent.isReact && typeof this.parent.editSettings.template !== 'string') {\n      this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID, null, null, form);\n      this.parent.renderTemplates();\n    } else {\n      appendChildren(form, this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID));\n    } // eslint-disable-next-line\n\n  };\n\n  return InlineEditRender;\n}();\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nvar BatchEditRender =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   */\n  function BatchEditRender(parent) {\n    this.parent = parent;\n  }\n\n  BatchEditRender.prototype.update = function (elements, args) {\n    if (this.parent.isReact && args.columnObject && args.columnObject.template) {\n      var parentRow = args.cell.parentElement;\n      var newTd = args.cell.cloneNode(true);\n      parentRow.insertBefore(newTd, args.cell);\n      newTd.focus();\n      args.cell.remove();\n      args.cell = newTd;\n    }\n\n    args.cell.innerHTML = '';\n    args.cell.appendChild(this.getEditElement(elements, args));\n    args.cell.classList.remove('e-ellipsistooltip');\n    args.cell.classList.add('e-editedbatchcell');\n    classList(args.row, [editedRow, 'e-batchrow'], []);\n  };\n\n  BatchEditRender.prototype.getEditElement = function (elements, args) {\n    var gObj = this.parent;\n    var form = this.parent.createElement('form', {\n      id: gObj.element.id + 'EditForm',\n      className: 'e-gridform'\n    });\n    form.appendChild(elements[args.columnObject.uid]);\n\n    if (args.columnObject.editType === 'booleanedit') {\n      args.cell.classList.add('e-boolcell');\n    }\n\n    if (!args.columnObject.editType) {\n      args.cell.classList.add('e-inputbox');\n    }\n\n    return form;\n  };\n\n  BatchEditRender.prototype.removeEventListener = function () {//To destroy the renderer\n  };\n\n  return BatchEditRender;\n}();\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nvar DialogEditRender =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   */\n  function DialogEditRender(parent, serviceLocator) {\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(dialogDestroy, this.destroy, this);\n    this.parent.on(destroy, this.destroy, this);\n  }\n\n  DialogEditRender.prototype.setLocaleObj = function () {\n    this.l10n = this.serviceLocator.getService('localization');\n  };\n\n  DialogEditRender.prototype.addNew = function (elements, args) {\n    this.isEdit = false;\n    this.createDialog(elements, args);\n  };\n\n  DialogEditRender.prototype.update = function (elements, args) {\n    this.isEdit = true;\n    this.createDialog(elements, args);\n  };\n\n  DialogEditRender.prototype.createDialogHeader = function (args) {\n    var gObj = this.parent;\n    var header;\n\n    if (this.parent.enableAdaptiveUI) {\n      var responsiveDlgRenderer = new ResponsiveDialogRenderer(this.parent, this.serviceLocator);\n      responsiveDlgRenderer.action = this.isEdit ? ResponsiveDialogAction.isEdit : ResponsiveDialogAction.isAdd;\n      return responsiveDlgRenderer.renderResponsiveHeader(undefined, args);\n    } else {\n      if (gObj.editSettings.headerTemplate) {\n        header = this.getDialogEditTemplateElement('HeaderTemplate', args);\n      } else if (this.isEdit) {\n        header = this.l10n.getConstant('EditFormTitle') + args.primaryKeyValue[0];\n      } else {\n        header = this.l10n.getConstant('AddFormTitle');\n      }\n    }\n\n    return header;\n  };\n\n  DialogEditRender.prototype.createDialog = function (elements, args) {\n    var gObj = this.parent;\n    this.dialog = this.parent.createElement('div', {\n      id: gObj.element.id + '_dialogEdit_wrapper',\n      styles: 'width: auto'\n    });\n\n    if (gObj.enableAdaptiveUI) {\n      this.dialog.classList.add('e-responsive-dialog');\n    }\n\n    gObj.element.appendChild(this.dialog);\n    this.setLocaleObj();\n    this.dialog.setAttribute('aria-label', this.l10n.getConstant('DialogEdit')); // let position: PositionDataModel = this.parent.element.getBoundingClientRect().height < 400 ?\n    //     { X: 'center', Y: 'top' } : { X: 'center', Y: 'center' };\n\n    this.dialogObj = new Dialog(extend({\n      header: this.createDialogHeader(args),\n      isModal: true,\n      visible: true,\n      cssClass: this.parent.cssClass ? 'e-edit-dialog' + ' ' + this.parent.cssClass : 'e-edit-dialog',\n      content: this.getEditElement(elements, args),\n      showCloseIcon: true,\n      allowDragging: true,\n      // position: position,\n      close: this.dialogClose.bind(this),\n      created: this.dialogCreated.bind(this),\n      closeOnEscape: true,\n      width: gObj.editSettings.template ? 'auto' : '330px',\n      target: args.target ? args.target : document.body,\n      animationSettings: {\n        effect: 'None'\n      },\n      footerTemplate: gObj.editSettings.footerTemplate ? this.getDialogEditTemplateElement('FooterTemplate', args) : null,\n      buttons: [{\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('SaveButton'),\n          cssClass: this.parent.cssClass ? 'e-primary' + ' ' + this.parent.cssClass : 'e-primary',\n          isPrimary: true\n        }\n      }, {\n        click: this.btnClick.bind(this),\n        buttonModel: {\n          cssClass: this.parent.cssClass ? 'e-flat' + ' ' + this.parent.cssClass : 'e-flat',\n          content: this.l10n.getConstant('CancelButton')\n        }\n      }]\n    }, gObj.editSettings.dialog ? gObj.editSettings.dialog.params || {} : {}));\n    args.dialog = this.dialogObj;\n    var isStringTemplate = 'isStringTemplate';\n    this.dialogObj[isStringTemplate] = true;\n    this.renderResponsiveDialog();\n    this.dialogObj.appendTo(this.dialog);\n    applyBiggerTheme(this.parent.element, this.dialogObj.element.parentElement);\n\n    if (gObj.enableAdaptiveUI) {\n      this.dialogObj.show(true);\n    }\n  };\n\n  DialogEditRender.prototype.dialogCreated = function () {\n    addBiggerDialog(this.parent);\n  };\n\n  DialogEditRender.prototype.renderResponsiveDialog = function () {\n    var _this = this;\n\n    if (this.parent.enableAdaptiveUI) {\n      if (this.parent.adaptiveDlgTarget) {\n        this.dialogObj.target = this.parent.adaptiveDlgTarget;\n      }\n\n      this.dialogObj.buttons = [{}];\n      this.dialogObj.showCloseIcon = true;\n      this.dialogObj.visible = false;\n      this.dialogObj.width = '100%';\n\n      this.dialogObj.open = function () {\n        _this.dialogObj.element.style.maxHeight = '100%';\n      };\n    }\n  };\n\n  DialogEditRender.prototype.btnClick = function (e) {\n    if (this.l10n.getConstant('CancelButton').toLowerCase() === e.target.innerText.trim().toLowerCase()) {\n      this.dialogClose();\n    } else {\n      this.parent.endEdit();\n    }\n  };\n\n  DialogEditRender.prototype.dialogClose = function () {\n    this.parent.closeEdit();\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  DialogEditRender.prototype.destroy = function (args) {\n    var dialogEditTemplates = ['template', 'headerTemplate', 'footerTemplate'];\n\n    for (var i = 0; i < dialogEditTemplates.length; i++) {\n      if (this.parent.editSettings[dialogEditTemplates[i]]) {\n        var templateName = dialogEditTemplates[i].charAt(0).toUpperCase() + dialogEditTemplates[i].slice(1);\n        var editTemplateID = this.parent.element.id + 'editSettings' + templateName;\n        updateBlazorTemplate(editTemplateID, templateName, this.parent.editSettings);\n      }\n    }\n\n    this.parent.notify(destroyForm, {});\n    this.parent.isEdit = false;\n    this.parent.notify(toolbarRefresh, {});\n\n    if (this.dialog && !this.dialogObj.isDestroyed) {\n      this.dialogObj.destroy();\n      remove(this.dialog);\n    }\n  };\n\n  DialogEditRender.prototype.getDialogEditTemplateElement = function (dialogTemp, args) {\n    var tempDiv = this.parent.createElement('div', {\n      className: 'e-dialog' + dialogTemp\n    });\n    var dummyData = extend({}, args.rowData, {\n      isAdd: !this.isEdit\n    }, true);\n    var templateID = this.parent.element.id + 'editSettings' + dialogTemp;\n    appendChildren(tempDiv, (dialogTemp === 'HeaderTemplate' ? this.parent.getEditHeaderTemplate() : this.parent.getEditFooterTemplate())(dummyData, this.parent, 'editSettings' + dialogTemp, templateID));\n    updateBlazorTemplate(templateID, dialogTemp, this.parent.editSettings);\n    return tempDiv;\n  };\n\n  DialogEditRender.prototype.getEditElement = function (elements, args) {\n    var _this = this;\n\n    var gObj = this.parent;\n    var div = this.parent.createElement('div', {\n      className: this.isEdit ? editedRow : 'e-insertedrow'\n    });\n    var form = args.form = this.parent.createElement('form', {\n      id: gObj.element.id + 'EditForm',\n      className: 'e-gridform'\n    });\n\n    if (this.parent.editSettings.template) {\n      var editTemplateID = this.parent.element.id + 'editSettingsTemplate';\n      var dummyData = extend({}, args.rowData, {\n        isAdd: !this.isEdit\n      }, true);\n      var isReactCompiler = this.parent.isReact && typeof this.parent.editSettings.template !== 'string';\n      var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n\n      if (isReactCompiler || isReactChild) {\n        this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID, null, null, form);\n        this.parent.renderTemplates();\n      } else {\n        appendChildren(form, this.parent.getEditTemplate()(dummyData, this.parent, 'editSettingsTemplate', editTemplateID));\n      }\n\n      var setRules = function () {\n        var columns = _this.parent.getColumns();\n\n        for (var i = 0; i < columns.length; i++) {\n          if (columns[i].validationRules) {\n            _this.parent.editModule.formObj.rules[columns[i].field] = columns[i].validationRules;\n          }\n        }\n      };\n\n      updateBlazorTemplate(editTemplateID, 'Template', this.parent.editSettings, true, setRules);\n      div.appendChild(form);\n      return div;\n    }\n\n    var table$$1 = this.parent.createElement('table', {\n      className: table,\n      attrs: {\n        cellspacing: '6px',\n        role: 'grid'\n      }\n    });\n    var tbody$$1 = this.parent.createElement(tbody, {\n      attrs: {\n        role: 'rowgroup'\n      }\n    });\n    var cols = gObj.getColumns();\n\n    for (var i = 0; i < cols.length; i++) {\n      if (this.parent.editModule.checkColumnIsGrouped(cols[i]) || cols[i].commands || cols[i].commandsTemplate || cols[i].type === 'checkbox') {\n        continue;\n      }\n\n      var tr = this.parent.createElement('tr', {\n        attrs: {\n          role: 'row'\n        }\n      });\n      var dataCell = this.parent.createElement('td', {\n        className: rowCell,\n        attrs: {\n          style: 'text-align:' + (this.parent.enableRtl ? 'right' : 'left') + ';width:190px'\n        }\n      });\n      elements[cols[i].uid].classList.remove('e-input');\n      dataCell.appendChild(elements[cols[i].uid]);\n      tr.appendChild(dataCell);\n      tbody$$1.appendChild(tr);\n    }\n\n    table$$1.appendChild(tbody$$1);\n    form.appendChild(table$$1);\n    div.appendChild(form);\n    return div;\n  };\n\n  DialogEditRender.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(dialogDestroy, this.destroy);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  return DialogEditRender;\n}();\n/**\n * Edit render module is used to render grid edit row.\n *\n * @hidden\n */\n\n\nvar EditRender =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for render module\n   *\n   * @param {IGrid} parent -specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   */\n  function EditRender(parent, serviceLocator) {\n    //Internal variables\n    this.editType = {\n      'Inline': InlineEditRender,\n      'Normal': InlineEditRender,\n      'Batch': BatchEditRender,\n      'Dialog': DialogEditRender\n    };\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.renderer = new this.editType[this.parent.editSettings.mode](parent, serviceLocator);\n    this.focus = serviceLocator.getService('focus');\n  }\n\n  EditRender.prototype.addNew = function (args) {\n    this.renderer.addNew(this.getEditElements(args), args);\n    this.convertWidget(args);\n  };\n\n  EditRender.prototype.update = function (args) {\n    this.renderer.update(this.getEditElements(args), args);\n    var isCustomFormValidation = args.isCustomFormValidation;\n\n    if (!isCustomFormValidation) {\n      this.parent.notify(beforeStartEdit, args);\n      this.convertWidget(args);\n    }\n  };\n\n  EditRender.prototype.convertWidget = function (args) {\n    var gObj = this.parent;\n    var isFocused;\n    var cell;\n    var value;\n    var fForm;\n    var frForm;\n    var frzCols = gObj.isFrozenGrid();\n    var index = gObj.getFrozenMode() === 'Right' && gObj.editSettings.mode === 'Normal' ? 1 : 0;\n    var form = gObj.editSettings.mode === 'Dialog' ? select('#' + gObj.element.id + '_dialogEdit_wrapper .e-gridform', document) : gObj.element.getElementsByClassName('e-gridform')[index];\n    var isVirtualFrozen = frzCols && this.parent.enableColumnVirtualization && args.isScroll;\n\n    if (frzCols && gObj.editSettings.mode === 'Normal') {\n      var rowIndex = parseInt(args.row.getAttribute(dataRowIndex), 10);\n\n      if (gObj.frozenRows && (args.requestType === 'add' && gObj.editSettings.newRowPosition === 'Top' || rowIndex < gObj.frozenRows)) {\n        fForm = gObj.element.querySelector('.' + movableHeader).querySelector('.e-gridform');\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          frForm = args.frozenRightForm;\n        }\n      } else {\n        fForm = gObj.element.querySelector('.' + movableContent).querySelector('.e-gridform');\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          frForm = args.frozenRightForm;\n        }\n      }\n    }\n\n    var cols = gObj.editSettings.mode !== 'Batch' ? gObj.getColumns() : [gObj.getColumnByField(args.columnName)];\n\n    for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n      var col = cols_1[_i];\n\n      if (isVirtualFrozen && col.getFreezeTableName() !== 'movable') {\n        continue;\n      }\n\n      if (this.parent.editSettings.template && !isNullOrUndefined(col.field)) {\n        var cellArgs = extend({}, args);\n        cellArgs.element = form.querySelector('[name=' + getComplexFieldID(col.field) + ']');\n\n        if (isNullOrUndefined(cellArgs.element) && frzCols) {\n          cellArgs.element = fForm.querySelector('[name=' + getComplexFieldID(col.field) + ']');\n        }\n\n        if (typeof col.edit.write === 'string') {\n          getObject(col.edit.write, window)(cellArgs);\n        } else {\n          col.edit.write(cellArgs);\n        }\n\n        continue;\n      }\n\n      if (this.parent.editModule.checkColumnIsGrouped(col) || col.commands) {\n        continue;\n      } // eslint-disable-next-line\n\n\n      value = col.valueAccessor(col.field, args.rowData, col);\n\n      if (col.getFreezeTableName() === 'movable' && gObj.editSettings.mode === 'Normal') {\n        cell = fForm.querySelector('[e-mappinguid=' + col.uid + ']');\n      } else if (frForm && col.getFreezeTableName() === frozenRight && gObj.editSettings.mode === 'Normal') {\n        cell = frForm.querySelector('[e-mappinguid=' + col.uid + ']');\n      } else {\n        cell = form.querySelector('[e-mappinguid=' + col.uid + ']');\n      }\n\n      var temp = col.edit.write;\n\n      if (!isNullOrUndefined(cell)) {\n        if (typeof temp === 'string') {\n          temp = getObject(temp, window);\n          temp({\n            rowData: args.rowData,\n            element: cell,\n            column: col,\n            requestType: args.requestType,\n            row: args.row,\n            foreignKeyData: col.isForeignColumn() && getObject(col.field, args.foreignKeyData)\n          });\n        } else {\n          col.edit.write({\n            rowData: args.rowData,\n            element: cell,\n            column: col,\n            requestType: args.requestType,\n            row: args.row,\n            foreignKeyData: col.isForeignColumn() && getObject(col.field, args.foreignKeyData)\n          });\n        }\n\n        if (!isFocused && !cell.getAttribute('disabled') && !parentsUntil(cell, 'e-checkbox-disabled')) {\n          this.focusElement(cell, args.type);\n          isFocused = true;\n        }\n      }\n    }\n\n    if (frzCols && !this.parent.allowTextWrap && (args.requestType === 'add' || args.requestType === 'beginEdit') && this.parent.editSettings.mode !== 'Dialog' && !isNullOrUndefined(form) && !isNullOrUndefined(fForm)) {\n      var mTdElement = fForm.querySelector('tr').children[0];\n      var fTdElement = form.querySelector('tr').children[0];\n\n      if (fTdElement.offsetHeight > mTdElement.offsetHeight) {\n        mTdElement.style.height = fTdElement.offsetHeight + 'px';\n\n        if (frForm) {\n          var frTdElement = fForm.querySelector('tr').children[0];\n          frTdElement.style.height = fTdElement.offsetHeight + 'px';\n        }\n      } else {\n        fTdElement.style.height = mTdElement.offsetHeight + 'px';\n\n        if (frForm) {\n          var frTdElement = fForm.querySelector('tr').children[0];\n          frTdElement.style.height = mTdElement.offsetHeight + 'px';\n        }\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  EditRender.prototype.focusElement = function (elem, type) {\n    var chkBox = this.parent.element.querySelector('.e-edit-checkselect');\n\n    if (!isNullOrUndefined(chkBox) && chkBox.nextElementSibling) {\n      chkBox.nextElementSibling.classList.add('e-focus');\n    }\n\n    if (this.parent.editSettings.mode === 'Batch') {\n      this.focus.onClick({\n        target: closest(elem, 'td')\n      }, true);\n    } else {\n      var isFocus = this.parent.enableVirtualization && this.parent.editSettings.mode === 'Normal' ? false : true;\n\n      if (isFocus || this.parent.enableVirtualization && this.parent.editSettings.newRowPosition === 'Bottom' && parentsUntil(elem, addedRow)) {\n        elem.focus();\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        elem.focus({\n          preventScroll: true\n        });\n      }\n    }\n\n    if (elem.classList.contains('e-defaultcell')) {\n      elem.setSelectionRange(elem.value.length, elem.value.length);\n    }\n  };\n\n  EditRender.prototype.getEditElements = function (args) {\n    var gObj = this.parent;\n    var elements = {};\n    var cols = gObj.editSettings.mode !== 'Batch' ? gObj.getColumns() : [gObj.getColumnByField(args.columnName)];\n\n    if (args.isCustomFormValidation) {\n      cols = this.parent.columnModel;\n    }\n\n    if (this.parent.editSettings.template) {\n      return {};\n    }\n\n    var isVirtualFrozen = gObj.isFrozenGrid() && gObj.enableColumnVirtualization && args.isScroll;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      var col = cols[i];\n\n      if (this.parent.editModule.checkColumnIsGrouped(col) || isVirtualFrozen && cols[i].getFreezeTableName() !== 'movable' || args.isCustomFormValidation && (col.commands || col.commandsTemplate || !col.field)) {\n        continue;\n      }\n\n      if (col.commands || col.commandsTemplate) {\n        var cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n        var model = new RowModelGenerator(this.parent);\n        var cellRenderer = cellRendererFact.getCellRenderer(CellType.CommandColumn);\n        var cells = model.generateRows(args.rowData)[0].cells;\n        var cell = cells.filter(function (cell) {\n          return cell.rowID;\n        });\n        var td = cellRenderer.render(cell[i], args.rowData, {\n          'index': args.row ? args.row.getAttribute(dataRowIndex) : 0\n        }, this.parent.enableVirtualization);\n        var div = td.firstElementChild;\n        div.setAttribute('textAlign', td.getAttribute('textAlign'));\n        elements[col.uid] = div;\n        continue;\n      }\n\n      var value = col.valueAccessor(col.field, args.rowData, col);\n      var tArgs = {\n        column: col,\n        value: value,\n        type: args.requestType,\n        data: args.rowData\n      };\n      var temp = col.edit.create;\n      var input = void 0;\n\n      if (col.editTemplate) {\n        input = this.parent.createElement('span', {\n          attrs: {\n            'e-mappinguid': col.uid\n          }\n        });\n        var tempID = this.parent.element.id + col.uid + 'editTemplate';\n        var tempData = extendObjWithFn({}, args.rowData, {\n          column: col\n        });\n        var isReactCompiler = this.parent.isReact && typeof col.editTemplate !== 'string';\n        var isReactChild = this.parent.parentDetails && this.parent.parentDetails.parentInstObj && this.parent.parentDetails.parentInstObj.isReact;\n\n        if (isReactCompiler || isReactChild) {\n          col.getEditTemplate()(extend({\n            'index': args.rowIndex\n          }, tempData), this.parent, 'editTemplate', tempID, null, null, input);\n          this.parent.renderTemplates();\n        } else {\n          var template = col.getEditTemplate()(extend({\n            'index': args.rowIndex\n          }, tempData), this.parent, 'editTemplate', tempID);\n          appendChildren(input, template);\n        }\n      } else {\n        if (typeof temp === 'string') {\n          temp = getObject(temp, window);\n          input = temp(tArgs);\n        } else {\n          input = col.edit.create(tArgs);\n        }\n\n        if (typeof input === 'string') {\n          var div = this.parent.createElement('div');\n          div.innerHTML = input;\n          input = div.firstChild;\n        }\n\n        var isInput = input.tagName !== 'input' && input.querySelectorAll('input').length;\n        var complexFieldName = getComplexFieldID(col.field);\n        attributes(isInput ? input.querySelector('input') : input, {\n          name: complexFieldName,\n          'e-mappinguid': col.uid,\n          id: gObj.element.id + complexFieldName\n        });\n        classList(input, ['e-input', 'e-field'], []);\n\n        if (col.textAlign === 'Right') {\n          input.classList.add('e-ralign');\n        }\n\n        if ((col.isPrimaryKey || col.isIdentity) && args.requestType === 'beginEdit' || col.isIdentity && args.requestType === 'add') {\n          // already disabled in cell plugins\n          input.setAttribute('disabled', '');\n        }\n      }\n\n      elements[col.uid] = input;\n    }\n\n    return elements;\n  };\n\n  EditRender.prototype.destroy = function () {\n    this.renderer.removeEventListener();\n  };\n\n  return EditRender;\n}();\n/**\n * `DropDownEditCell` is used to handle dropdown cell type editing.\n *\n * @hidden\n */\n\n\nvar EditCellBase =\n/** @__PURE__ @class */\nfunction () {\n  function EditCellBase(parent) {\n    this.parent = parent;\n  }\n\n  EditCellBase.prototype.create = function (args) {\n    return createEditElement(this.parent, args.column, 'e-field', {\n      type: 'text'\n    });\n  };\n\n  EditCellBase.prototype.read = function (element) {\n    return element.ej2_instances[0].value;\n  };\n\n  EditCellBase.prototype.destroy = function () {\n    if (this.obj && !this.obj.isDestroyed) {\n      if (this.removeEventHandler) {\n        this.removeEventHandler();\n      }\n\n      this.obj.destroy();\n    }\n  };\n\n  return EditCellBase;\n}();\n\nvar __extends$25 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `BooleanEditCell` is used to handle boolean cell type editing.\n *\n * @hidden\n */\n\n\nvar BooleanEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$25(BooleanEditCell, _super);\n\n  function BooleanEditCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.activeClasses = ['e-selectionbackground', 'e-active'];\n    return _this;\n  }\n\n  BooleanEditCell.prototype.create = function (args) {\n    var col = args.column;\n    var classNames = 'e-field e-boolcell';\n\n    if (col.type === 'checkbox') {\n      classNames = 'e-field e-boolcell e-edit-checkselect';\n    }\n\n    this.removeEventHandler = this.removeEventListener;\n    return createEditElement(this.parent, args.column, classNames, {\n      type: 'checkbox',\n      value: args.value\n    });\n  };\n\n  BooleanEditCell.prototype.read = function (element) {\n    return element.checked;\n  };\n\n  BooleanEditCell.prototype.write = function (args) {\n    var selectChkBox;\n    var chkState;\n\n    if (!isNullOrUndefined(args.row)) {\n      selectChkBox = args.row.querySelector('.e-edit-checkselect');\n    }\n\n    if (getObject(args.column.field, args.rowData)) {\n      chkState = JSON.parse(getObject(args.column.field, args.rowData).toString().toLowerCase());\n    }\n\n    if (!isNullOrUndefined(selectChkBox) && args.column.type === 'checkbox') {\n      this.editType = this.parent.editSettings.mode;\n      this.editRow = args.row;\n\n      if (args.requestType !== 'add') {\n        var row$$1 = this.parent.getRowObjectFromUID(args.row.getAttribute('data-uid'));\n        chkState = row$$1 ? row$$1.isSelected : false;\n      }\n\n      addRemoveActiveClasses.apply(void 0, [[].slice.call(args.row.getElementsByClassName(rowCell)), chkState].concat(this.activeClasses));\n    }\n\n    this.obj = new CheckBox(extend({\n      label: this.parent.editSettings.mode !== 'Dialog' ? ' ' : args.column.headerText,\n      checked: chkState,\n      disabled: !isEditable(args.column, args.requestType, args.element),\n      enableRtl: this.parent.enableRtl,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    }, args.column.edit.params));\n    this.addEventListener();\n    this.obj.appendTo(args.element);\n  };\n\n  BooleanEditCell.prototype.addEventListener = function () {\n    this.cbChange = this.checkBoxChange.bind(this);\n    this.obj.addEventListener(change, this.cbChange);\n  };\n\n  BooleanEditCell.prototype.removeEventListener = function () {\n    if (this.obj.isDestroyed) {\n      return;\n    }\n\n    this.obj.removeEventListener(change, this.cbChange);\n  };\n\n  BooleanEditCell.prototype.checkBoxChange = function (args) {\n    if (this.editRow && this.editType !== 'Dialog') {\n      var add = false;\n\n      if (!args.checked) {\n        this.editRow.removeAttribute('aria-selected');\n      } else {\n        add = true;\n        this.editRow.setAttribute('aria-selected', add.toString());\n      }\n\n      addRemoveActiveClasses.apply(void 0, [[].slice.call(this.editRow.getElementsByClassName(rowCell)), add].concat(this.activeClasses));\n    }\n  };\n\n  return BooleanEditCell;\n}(EditCellBase);\n\nvar __extends$26 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `DropDownEditCell` is used to handle dropdown cell type editing.\n *\n * @hidden\n */\n\n\nvar DropDownEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$26(DropDownEditCell, _super);\n\n  function DropDownEditCell(parent) {\n    var _this = //constructor\n    _super.call(this) || this;\n\n    _this.parent = parent;\n    _this.flag = false;\n    _this.removeEventHandler = _this.removeEventListener;\n    return _this;\n  }\n\n  DropDownEditCell.prototype.write = function (args) {\n    var isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.column = args.column;\n    var pred = new Predicate(args.column.field, 'notequal', null, true, false);\n    var params = {};\n\n    if (args.column.edit.params) {\n      var keys = Object.keys(args.column.edit.params);\n\n      for (var i = 0; i < keys.length; i++) {\n        params[keys[i]] = keys[i] === 'query' ? args.column.edit.params[keys[i]].clone() : args.column.edit.params[keys[i]];\n      }\n    }\n\n    this.obj = new DropDownList(extend({\n      dataSource: this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource),\n      query: new Query().where(pred).select(args.column.field),\n      enabled: isEditable(args.column, args.requestType, args.element),\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      enableRtl: this.parent.enableRtl,\n      placeholder: isInline ? '' : args.column.headerText,\n      popupHeight: '200px',\n      floatLabelType: isInline ? 'Never' : 'Always',\n      sortOrder: 'Ascending',\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null,\n      close: this.dropDownClose.bind(this)\n    }, params));\n\n    if (this.parent.enableVirtualization) {\n      this.obj.dataSource = args.column.isForeignColumn() ? [args.foreignKeyData[0]] : [args.rowData];\n    }\n\n    this.addEventListener();\n    this.obj.query.params = this.parent.query.params;\n    this.obj.appendTo(args.element);\n    /* tslint:disable-next-line:no-any */\n\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n  };\n\n  DropDownEditCell.prototype.dropDownClose = function (args) {// if (args.event && (args.event as KeyboardEventArgs).action === 'escape') {\n    //     (this as DropDownEditCell).parent.editModule.editCellDialogClose = true;\n    // }\n  };\n\n  DropDownEditCell.prototype.addEventListener = function () {\n    this.ddCreated = this.dropdownCreated.bind(this);\n    this.ddOpen = this.dropDownOpen.bind(this);\n    this.ddBeforeOpen = this.dropdownBeforeOpen.bind(this);\n    this.ddComplete = this.ddActionComplete.bind(this);\n    this.obj.addEventListener(create, this.ddCreated);\n    this.obj.addEventListener(open, this.ddOpen);\n    this.obj.addEventListener(beforeOpen, this.ddBeforeOpen);\n    this.obj.addEventListener(actionComplete, this.ddComplete);\n  };\n\n  DropDownEditCell.prototype.removeEventListener = function () {\n    if (this.obj.isDestroyed) {\n      return;\n    }\n\n    this.obj.removeEventListener(create, this.ddCreated);\n    this.obj.removeEventListener(open, this.ddOpen);\n    this.obj.removeEventListener(beforeOpen, this.ddBeforeOpen);\n    this.obj.removeEventListener(actionComplete, this.ddComplete);\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  DropDownEditCell.prototype.dropdownCreated = function (e) {\n    this.flag = true;\n  };\n\n  DropDownEditCell.prototype.dropdownBeforeOpen = function () {\n    if (this.parent.enableVirtualization) {\n      this.obj.dataSource = !this.column.isForeignColumn() ? this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource) : this.column.dataSource instanceof DataManager ? this.column.dataSource : new DataManager(this.column.dataSource);\n    }\n  };\n\n  DropDownEditCell.prototype.ddActionComplete = function (e) {\n    e.result = DataUtil.distinct(e.result, this.obj.fields.value, true);\n\n    if (this.flag && this.column.dataSource && !(this.column.edit.params && this.column.edit.params.ddEditedData)) {\n      if ('result' in this.column.dataSource) {\n        this.column.dataSource.result = e.result;\n      } else if (this.column.dataSource instanceof DataManager) {\n        this.column.dataSource.dataSource.json = e.result;\n      }\n    }\n\n    this.flag = false;\n  };\n\n  DropDownEditCell.prototype.dropDownOpen = function (args) {\n    var dlgElement = parentsUntil(this.obj.element, 'e-dialog');\n\n    if (this.parent.editSettings.mode === 'Dialog' && !isNullOrUndefined(dlgElement)) {\n      var dlgObj = select('#' + dlgElement.id, document).ej2_instances[0];\n      args.popup.element.style.zIndex = (dlgObj.zIndex + 1).toString();\n    }\n  };\n\n  return DropDownEditCell;\n}(EditCellBase);\n/**\n * `NumericEditCell` is used to handle numeric cell type editing.\n *\n * @hidden\n */\n\n\nvar NumericEditCell =\n/** @__PURE__ @class */\nfunction () {\n  function NumericEditCell(parent) {\n    this.parent = parent;\n  }\n\n  NumericEditCell.prototype.keyEventHandler = function (args) {\n    if (args.keyCode === 13 || args.keyCode === 9) {\n      var evt = document.createEvent('HTMLEvents');\n      evt.initEvent('change', false, true); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.dispatchEvent(evt);\n    }\n  };\n\n  NumericEditCell.prototype.create = function (args) {\n    this.instances = new Internationalization(this.parent.locale);\n    return createEditElement(this.parent, args.column, 'e-field', {});\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  NumericEditCell.prototype.read = function (element) {\n    return this.obj.value;\n  };\n\n  NumericEditCell.prototype.write = function (args) {\n    var col = args.column;\n    var isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new NumericTextBox(extend({\n      value: parseFloat(getObject(args.column.field, args.rowData)),\n      enableRtl: this.parent.enableRtl,\n      placeholder: isInline ? '' : args.column.headerText,\n      enabled: isEditable(args.column, args.requestType, args.element),\n      floatLabelType: this.parent.editSettings.mode !== 'Dialog' ? 'Never' : 'Always',\n      locale: this.parent.locale,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, col.edit.params));\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n    this.obj.appendTo(args.element);\n    this.obj.element.addEventListener('keydown', this.keyEventHandler);\n  };\n\n  NumericEditCell.prototype.destroy = function () {\n    if (this.obj && !this.obj.isDestroyed) {\n      this.obj.element.removeEventListener('keydown', this.keyEventHandler);\n      this.obj.destroy();\n    }\n  };\n\n  return NumericEditCell;\n}();\n\nvar __extends$27 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `DefaultEditCell` is used to handle default cell type editing.\n *\n * @hidden\n */\n\n\nvar DefaultEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$27(DefaultEditCell, _super);\n\n  function DefaultEditCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultEditCell.prototype.create = function (args) {\n    var attr = {\n      type: 'text',\n      value: !isNullOrUndefined(args.value) ? args.value : '',\n      style: 'text-align:' + args.column.textAlign\n    };\n    return createEditElement(this.parent, args.column, 'e-field e-input e-defaultcell', attr);\n  };\n\n  DefaultEditCell.prototype.read = function (element) {\n    return element.value;\n  };\n\n  DefaultEditCell.prototype.write = function (args) {\n    var col = args.column;\n    var isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new TextBox(extend({\n      element: args.element,\n      floatLabelType: this.parent.editSettings.mode !== 'Dialog' ? 'Never' : 'Always',\n      enableRtl: this.parent.enableRtl,\n      enabled: isEditable(args.column, args.requestType, args.element),\n      placeholder: isInline ? '' : args.column.headerText,\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    }, col.edit.params));\n    this.obj.appendTo(args.element);\n  };\n\n  return DefaultEditCell;\n}(EditCellBase);\n/**\n * `NormalEdit` module is used to handle normal('inline, dialog, external') editing actions.\n *\n * @hidden\n */\n\n\nvar NormalEdit =\n/** @__PURE__ @class */\nfunction () {\n  function NormalEdit(parent, serviceLocator, renderer) {\n    this.args = {};\n    this.currentVirtualData = {};\n    this.parent = parent;\n    this.renderer = renderer;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  NormalEdit.prototype.clickHandler = function (e) {\n    var target = e.target;\n    var gObj = this.parent;\n\n    if ((parentsUntil(target, gridContent) && parentsUntil(parentsUntil(target, gridContent), 'e-grid').id === gObj.element.id || gObj.frozenRows && parentsUntil(target, headerContent)) && !parentsUntil(target, 'e-unboundcelldiv')) {\n      this.rowIndex = parentsUntil(target, rowCell) ? parseInt(target.parentElement.getAttribute(dataRowIndex), 10) : -1;\n\n      if (gObj.isEdit) {\n        gObj.editModule.endEdit();\n      }\n    }\n  };\n\n  NormalEdit.prototype.dblClickHandler = function (e) {\n    if (parentsUntil(e.target, rowCell) && this.parent.editSettings.allowEditOnDblClick) {\n      this.parent.editModule.startEdit(parentsUntil(e.target, row));\n    }\n  };\n  /**\n   * The function used to trigger editComplete\n   *\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NormalEdit.prototype.editComplete = function (e) {\n    this.parent.isEdit = false;\n    var action = 'action';\n\n    switch (e.requestType) {\n      case 'save':\n        if (!(this.parent.isCheckBoxSelection || this.parent.selectionSettings.type === 'Multiple') || !this.parent.isPersistSelection) {\n          if (e[action] !== 'edit') {\n            this.parent.selectRow(0);\n          }\n        }\n\n        this.parent.trigger(actionComplete, extend(e, {\n          requestType: 'save',\n          type: actionComplete\n        }));\n        break;\n\n      case 'delete':\n        this.parent.trigger(actionComplete, extend(e, {\n          requestType: 'delete',\n          type: actionComplete\n        }));\n\n        if (!this.parent.isCheckBoxSelection) {\n          this.parent.selectRow(this.editRowIndex);\n        }\n\n        break;\n    }\n  };\n\n  NormalEdit.prototype.getEditArgs = function (editedData, rowObj, isScroll) {\n    var primaryKeys = this.parent.getPrimaryKeyFieldNames();\n    var primaryKeyValues = [];\n\n    for (var i = 0; i < primaryKeys.length; i++) {\n      primaryKeyValues.push(getObject(primaryKeys[i], editedData));\n    }\n\n    var args = {\n      primaryKey: primaryKeys,\n      primaryKeyValue: primaryKeyValues,\n      requestType: 'beginEdit',\n      rowData: editedData,\n      rowIndex: this.rowIndex,\n      type: 'edit',\n      cancel: false,\n      foreignKeyData: rowObj && rowObj.foreignKeyData,\n      target: undefined,\n      isScroll: isScroll\n    };\n    return args;\n  };\n\n  NormalEdit.prototype.startEdit = function (tr) {\n    var _this = this;\n\n    var gObj = this.parent;\n    this.rowIndex = this.editRowIndex = parseInt(tr.getAttribute(dataRowIndex), 10);\n\n    if (gObj.enableVirtualization || gObj.enableInfiniteScrolling) {\n      var selector = '.e-row[data-rowindex=\"' + this.rowIndex + '\"]';\n      var virtualRow = this.parent.element.querySelector(selector);\n\n      if (!virtualRow) {\n        return;\n      }\n    }\n\n    var e = {\n      data: undefined,\n      index: this.rowIndex,\n      isScroll: false\n    };\n    this.parent.notify(virtualScrollEditActionBegin, e);\n\n    if (isGroupAdaptive(gObj)) {\n      var rObj = gObj.getRowObjectFromUID(tr.getAttribute('data-uid'));\n      this.previousData = rObj.data;\n    } else if (!this.previousData && (this.parent.enableVirtualization || this.parent.enableInfiniteScrolling)) {\n      this.previousData = e.data;\n    } else if (!this.parent.enableVirtualization) {\n      this.previousData = extend({}, {}, gObj.getCurrentViewRecords()[this.rowIndex], true);\n    }\n\n    var editedData = extend({}, {}, e.data || this.previousData, true);\n    this.uid = tr.getAttribute('data-uid');\n    var rowObj = gObj.getRowObjectFromUID(this.uid);\n    var args = this.getEditArgs(editedData, rowObj, e.isScroll);\n    args.row = tr;\n\n    if (!args.isScroll) {\n      this.parent.notify(createVirtualValidationForm, {\n        uid: this.uid,\n        prevData: this.previousData,\n        argsCreator: this.getEditArgs.bind(this),\n        renderer: this.renderer\n      });\n      gObj.trigger(beginEdit, args, function (begineditargs) {\n        begineditargs.type = 'actionBegin';\n        gObj.trigger(actionBegin, begineditargs, function (editargs) {\n          if (!editargs.cancel) {\n            _this.inlineEditHandler(editargs, tr);\n          }\n        });\n      });\n    } else {\n      this.inlineEditHandler(args, tr);\n    }\n  };\n\n  NormalEdit.prototype.inlineEditHandler = function (editargs, tr) {\n    var gObj = this.parent;\n    gObj.isEdit = true;\n    editargs.row = editargs.row ? editargs.row : tr;\n\n    if (gObj.editSettings.mode !== 'Dialog') {\n      gObj.clearSelection();\n    }\n\n    if (gObj.editSettings.mode === 'Dialog' && gObj.selectionModule) {\n      gObj.selectionModule.preventFocus = true;\n      editargs.row.classList.add('e-dlgeditrow');\n    }\n\n    this.renderer.update(editargs);\n    this.uid = tr.getAttribute('data-uid');\n    gObj.editModule.applyFormValidation();\n    editargs.type = 'actionComplete';\n    gObj.trigger(actionComplete, editargs);\n    this.args = editargs;\n\n    if (this.parent.allowTextWrap) {\n      this.parent.notify(freezeRender, {\n        case: 'textwrap'\n      });\n    }\n  };\n\n  NormalEdit.prototype.updateRow = function (index, data) {\n    var _this = this;\n\n    var gObj = this.parent;\n    this.editRowIndex = index;\n    var args = {\n      requestType: 'save',\n      action: 'edit',\n      type: actionBegin,\n      data: data,\n      cancel: false,\n      previousData: gObj.getCurrentViewRecords()[index],\n      row: gObj.getRowByIndex(index)\n    };\n    gObj.showSpinner();\n\n    if (gObj.enableInfiniteScrolling) {\n      this.uid = args.row.getAttribute('data-uid');\n      var index_1 = parseInt(args.row.getAttribute('data-rowindex'), 10);\n      this.parent.notify(refreshInfiniteEditrowindex, {\n        index: index_1\n      });\n    }\n\n    gObj.notify(updateData, args);\n\n    if (args.promise) {\n      args.promise.then(function () {\n        return gObj.refresh();\n      }).catch(function (e) {\n        return _this.edFail(e);\n      });\n    } else {\n      if (!gObj.enableInfiniteScrolling) {\n        gObj.refresh();\n      }\n    }\n  };\n\n  NormalEdit.prototype.editFormValidate = function () {\n    var gObj = this.parent;\n    var isValid = gObj.editModule.editFormValidate();\n    var validationArgs = {\n      prevData: this.previousData,\n      isValid: true,\n      editIdx: this.editRowIndex,\n      addIdx: this.addedRowIndex\n    };\n    gObj.notify(validateVirtualForm, validationArgs);\n    return isValid && validationArgs.isValid;\n  };\n\n  NormalEdit.prototype.endEdit = function () {\n    var _this = this;\n\n    var gObj = this.parent;\n\n    if (!this.parent.isEdit || !this.editFormValidate()) {\n      return;\n    }\n\n    var editedData = extend({}, {}, this.previousData, true);\n    var args = extend(this.args, {\n      requestType: 'save',\n      type: actionBegin,\n      data: editedData,\n      cancel: false,\n      previousData: this.previousData,\n      selectedRow: gObj.selectedRowIndex,\n      foreignKeyData: {}\n    });\n    var index = gObj.getFrozenMode() === 'Right' ? 1 : 0;\n    var isDlg = gObj.editSettings.mode === 'Dialog';\n    var dlgWrapper = select('#' + gObj.element.id + '_dialogEdit_wrapper', document);\n    var dlgForm = isDlg ? dlgWrapper.querySelector('.e-gridform') : gObj.element.getElementsByClassName('e-gridform')[index];\n    var data = {\n      virtualData: extend({}, {}, this.previousData, true),\n      isAdd: false,\n      isScroll: false,\n      endEdit: true\n    };\n    this.parent.notify(getVirtualData, data);\n\n    if ((this.parent.enableVirtualization || this.parent.enableInfiniteScrolling) && this.parent.editSettings.mode === 'Normal' && Object.keys(data.virtualData).length) {\n      if (this.parent.isEdit) {\n        this.currentVirtualData = editedData = args.data = data.virtualData;\n      }\n    } else {\n      editedData = gObj.editModule.getCurrentEditedData(dlgForm, editedData);\n    }\n\n    if (gObj.isFrozenGrid() && gObj.editSettings.mode === 'Normal') {\n      var mhdrFrm = gObj.getMovableVirtualHeader().querySelector('.e-gridform');\n      var mCntFrm = gObj.getMovableVirtualContent().querySelector('.e-gridform');\n      var mvblEle = [mhdrFrm || mCntFrm];\n      var frHdrFrm = void 0;\n      var frCntFrm = void 0;\n      var frEle = [];\n\n      if (gObj.getFrozenMode() === leftRight) {\n        frHdrFrm = gObj.getFrozenRightHeader().querySelector('.e-gridform');\n        frCntFrm = gObj.getFrozenRightContent().querySelector('.e-gridform');\n        frEle = [frHdrFrm || frCntFrm];\n      }\n\n      gridActionHandler(this.parent, function (tableName, elements) {\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n          var ele = elements_1[_i];\n\n          if (ele) {\n            editedData = gObj.editModule.getCurrentEditedData(ele, editedData);\n          }\n        }\n      }, [[], mvblEle, frEle]);\n    }\n\n    var eleLength = [].slice.call(gObj.element.getElementsByClassName(editedRow)).length;\n\n    if (!data.isAdd && Object.keys(this.currentVirtualData).length && !eleLength) {\n      eleLength = 1;\n    }\n\n    if (isDlg ? dlgWrapper.getElementsByClassName(editedRow).length : eleLength) {\n      args.action = 'edit';\n      gObj.trigger(actionBegin, args, function (endEditArgs) {\n        if (endEditArgs.cancel) {\n          return;\n        }\n\n        if (_this.parent.loadingIndicator.indicatorType === 'Spinner') {\n          gObj.showSpinner();\n        }\n\n        if (_this.parent.loadingIndicator.indicatorType === 'Shimmer') {\n          _this.parent.showMaskRow();\n        }\n\n        gObj.notify(updateData, endEditArgs);\n      });\n    } else {\n      args.action = 'add';\n      args.selectedRow = 0;\n      args.index = this.addedRowIndex;\n      gObj.notify(virtualScrollEditSuccess, {});\n      gObj.notify(modelChanged, args);\n      this.addedRowIndex = null;\n\n      if (args.cancel) {\n        return;\n      }\n    }\n  };\n\n  NormalEdit.prototype.destroyElements = function () {\n    var gObj = this.parent;\n    gObj.editModule.destroyWidgets();\n    gObj.editModule.destroyForm();\n    this.parent.notify(dialogDestroy, {});\n  };\n\n  NormalEdit.prototype.editHandler = function (args) {\n    var _this = this;\n\n    if (args.promise) {\n      args.promise.then(function (e) {\n        return _this.edSucc(e, args);\n      }).catch(function (e) {\n        return _this.edFail(e);\n      });\n    } else {\n      this.editSuccess(args.data, args);\n    }\n  };\n\n  NormalEdit.prototype.edSucc = function (e, args) {\n    this.editSuccess(e, args);\n  };\n\n  NormalEdit.prototype.edFail = function (e) {\n    this.editFailure(e);\n  };\n\n  NormalEdit.prototype.updateCurrentViewData = function (data) {\n    if (!this.parent.enableVirtualization && !this.parent.enableInfiniteScrolling) {\n      this.parent.getCurrentViewRecords()[this.editRowIndex] = data;\n    }\n  };\n\n  NormalEdit.prototype.requestSuccess = function (args) {\n    if (this.parent.editModule.formObj && !this.parent.editModule.formObj.isDestroyed) {\n      this.destroyElements();\n      this.stopEditStatus();\n\n      if (this.parent.editSettings.mode === 'Dialog' && args.action !== 'add' && this.parent.selectionModule) {\n        this.parent.element.querySelector('.e-dlgeditrow').classList.remove('e-dlgeditrow');\n      }\n    }\n  };\n\n  NormalEdit.prototype.editSuccess = function (e, args) {\n    if (!isNullOrUndefined(e) && !(e instanceof Array)) {\n      var rowData = 'rowData';\n      args.data = extend({}, extend({}, args[rowData], args.data), e);\n    }\n\n    this.requestSuccess(args);\n    this.parent.trigger(beforeDataBound, args);\n    args.type = actionComplete;\n    this.parent.isEdit = false;\n    this.refreshRow(args.data);\n    this.parent.notify(virtualScrollEditSuccess, args);\n    this.parent.editModule.checkLastRow(args.row);\n    this.parent.editModule.isLastRow = false;\n    this.updateCurrentViewData(args.data);\n    this.blazorTemplate();\n    this.editRowIndex = null;\n    this.parent.trigger(actionComplete, args);\n\n    if (!(this.parent.isCheckBoxSelection || this.parent.selectionSettings.type === 'Multiple') || !this.parent.isPersistSelection && !this.parent.selectionSettings.checkboxOnly) {\n      if (this.parent.editSettings.mode !== 'Dialog') {\n        this.parent.selectRow(this.rowIndex > -1 ? this.rowIndex : this.editRowIndex);\n      }\n    }\n\n    this.parent.removeMaskRow();\n    this.parent.hideSpinner();\n  };\n\n  NormalEdit.prototype.closeForm = function () {\n    if (!this.cloneRow && this.parent.isEdit) {\n      this.stopEditStatus();\n    }\n\n    if (this.cloneRow) {\n      this.cloneRow.remove();\n      this.cloneRow = null;\n      this.originalRow.classList.remove('e-hiddenrow');\n    }\n\n    if (this.parent.isFrozenGrid() && this.cloneFrozen) {\n      this.cloneFrozen.remove();\n      this.frozen.classList.remove('e-hiddenrow');\n    }\n  };\n\n  NormalEdit.prototype.blazorTemplate = function () {\n    var cols = this.parent.getColumns();\n\n    if (this.parent.editSettings.template && this.parent.editSettings.mode === 'Normal') {\n      updateBlazorTemplate(this.parent.element.id + 'editSettingsTemplate', 'Template', this.parent.editSettings);\n    }\n\n    for (var i = 0; i < cols.length; i++) {\n      var col = cols[i];\n\n      if (col.template) {\n        updateBlazorTemplate(this.parent.element.id + col.uid, 'Template', col, false);\n      }\n\n      if (col.editTemplate) {\n        updateBlazorTemplate(this.parent.element.id + col.uid + 'editTemplate', 'EditTemplate', col);\n      }\n    }\n  };\n\n  NormalEdit.prototype.editFailure = function (e) {\n    this.parent.removeMaskRow();\n    this.parent.trigger(actionFailure, {\n      error: e\n    });\n    this.parent.hideSpinner();\n    this.parent.log('actionfailure', {\n      error: e\n    });\n  };\n\n  NormalEdit.prototype.needRefresh = function () {\n    var refresh = true;\n    var editedRow$$1 = this.parent.element.querySelector('.e-gridform');\n\n    if ((this.parent.enableVirtualization || this.parent.infiniteScrollSettings.enableCache) && this.parent.editSettings.mode === 'Normal' && !editedRow$$1) {\n      refresh = false;\n    }\n\n    return refresh;\n  };\n\n  NormalEdit.prototype.refreshRow = function (data) {\n    var frzCols = this.parent.isFrozenGrid();\n    var row$$1 = new RowRenderer(this.serviceLocator, null, this.parent);\n    var rowObj = this.parent.getRowObjectFromUID(this.uid);\n\n    if (rowObj) {\n      rowObj.changes = data;\n      this.parent.notify(refreshVirtualCache, {\n        data: data\n      });\n      refreshForeignData(rowObj, this.parent.getForeignKeyColumns(), rowObj.changes);\n\n      if (this.needRefresh()) {\n        row$$1.refresh(rowObj, this.parent.getColumns(), true);\n      }\n\n      var tr = [].slice.call(this.parent.element.querySelectorAll('[data-rowindex=\"' + rowObj.index + '\"]'));\n\n      if (frzCols && tr.length) {\n        for (var i = 0; i < tr.length; i++) {\n          var rowUid = tr[i].getAttribute('data-uid');\n\n          if (rowUid !== this.uid) {\n            rowObj = this.parent.getRowObjectFromUID(rowUid);\n            rowObj.changes = data;\n            row$$1.refresh(rowObj, this.parent.getColumns(), true);\n            this.parent.editModule.checkLastRow(tr[i]);\n          }\n        }\n      }\n    }\n  };\n\n  NormalEdit.prototype.closeEdit = function () {\n    var _this = this;\n\n    if (!this.parent.isEdit) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var args = extend(this.args, {\n      requestType: 'cancel',\n      type: actionBegin,\n      cancel: false,\n      data: this.previousData,\n      selectedRow: gObj.selectedRowIndex\n    });\n    gObj.notify(virtualScrollEditCancel, args);\n    this.blazorTemplate();\n    gObj.trigger(actionBegin, args, function (closeEditArgs) {\n      if (closeEditArgs.cancel) {\n        return;\n      }\n\n      if (_this.parent.editSettings.mode === 'Dialog') {\n        _this.parent.notify(dialogDestroy, {});\n      }\n\n      gObj.isEdit = false;\n\n      _this.stopEditStatus();\n\n      closeEditArgs.type = actionComplete;\n\n      if (gObj.editSettings.mode !== 'Dialog') {\n        _this.refreshRow(closeEditArgs.data);\n      }\n\n      var isLazyLoad = gObj.groupSettings.enableLazyLoading && gObj.groupSettings.columns.length && !gObj.getContentTable().querySelector('tr.e-emptyrow');\n\n      if (!gObj.getContentTable().querySelector('tr.e-emptyrow') && !gObj.getContentTable().querySelector('tr.e-row') && !isLazyLoad) {\n        gObj.renderModule.emptyRow();\n      }\n\n      if (gObj.editSettings.mode !== 'Dialog') {\n        gObj.selectRow(_this.rowIndex);\n      }\n\n      gObj.trigger(actionComplete, closeEditArgs);\n    });\n  };\n\n  NormalEdit.prototype.addRecord = function (data, index) {\n    var _this = this;\n\n    var gObj = this.parent;\n    this.addedRowIndex = index = !isNullOrUndefined(index) ? index : 0;\n\n    if (data) {\n      gObj.notify(modelChanged, {\n        requestType: 'save',\n        type: actionBegin,\n        data: data,\n        selectedRow: 0,\n        action: 'add',\n        index: index\n      });\n      return;\n    }\n\n    if (gObj.isEdit) {\n      return;\n    }\n\n    this.previousData = {};\n    this.uid = '';\n    var cols = gObj.getColumns();\n    var rowData = {\n      virtualData: {},\n      isScroll: false\n    };\n    this.parent.notify(getVirtualData, rowData);\n\n    for (var i = 0; i < cols.length; i++) {\n      if (rowData.isScroll && cols[i].getFreezeTableName() !== 'movable') {\n        continue;\n      }\n\n      if (cols[i].field) {\n        DataUtil.setValue(cols[i].field, cols[i].defaultValue, this.previousData);\n      }\n    }\n\n    var args = {\n      cancel: false,\n      foreignKeyData: {},\n      requestType: 'add',\n      data: this.previousData,\n      type: actionBegin,\n      index: index,\n      rowData: this.previousData,\n      target: undefined,\n      isScroll: rowData.isScroll\n    };\n\n    if ((this.parent.enableVirtualization || this.parent.infiniteScrollSettings.enableCache) && Object.keys(rowData.virtualData).length) {\n      args.data = args.rowData = rowData.virtualData;\n    }\n\n    if (!args.isScroll) {\n      this.parent.notify(createVirtualValidationForm, {\n        uid: this.uid,\n        prevData: this.previousData,\n        argsCreator: this.getEditArgs.bind(this),\n        renderer: this.renderer\n      });\n      gObj.trigger(actionBegin, args, function (addArgs) {\n        if (addArgs.cancel) {\n          return;\n        }\n\n        _this.inlineAddHandler(addArgs);\n      });\n    } else {\n      this.inlineAddHandler(args);\n    }\n  };\n\n  NormalEdit.prototype.inlineAddHandler = function (addArgs) {\n    var gObj = this.parent;\n    gObj.isEdit = true;\n\n    if (gObj.editSettings.mode !== 'Dialog') {\n      gObj.clearSelection();\n    }\n\n    this.renderer.addNew(addArgs);\n    gObj.editModule.applyFormValidation();\n    addArgs.type = actionComplete;\n    addArgs.row = gObj.element.querySelector('.' + addedRow);\n    gObj.trigger(actionComplete, addArgs);\n    this.args = addArgs;\n  };\n\n  NormalEdit.prototype.deleteRecord = function (fieldname, data) {\n    this.editRowIndex = this.parent.selectedRowIndex;\n\n    if (data) {\n      data = data instanceof Array ? data : [data];\n      var gObj = this.parent;\n      var dataLen = Object.keys(data).length;\n      fieldname = fieldname || this.parent.getPrimaryKeyFieldNames()[0];\n\n      var _loop_1 = function (i) {\n        var _a;\n\n        var tmpRecord;\n        var contained = gObj.currentViewData.some(function (record) {\n          tmpRecord = record;\n          return data[i] === getObject(fieldname, record) || data[i] === record;\n        });\n        data[i] = contained ? tmpRecord : data[i][fieldname] ? data[i] : (_a = {}, _a[fieldname] = data[i], _a);\n      };\n\n      for (var i = 0; i < dataLen; i++) {\n        _loop_1(i);\n      }\n    }\n\n    var args = {\n      requestType: 'delete',\n      type: actionBegin,\n      foreignKeyData: {},\n      data: data ? data : this.parent.getSelectedRecords(),\n      tr: this.parent.getSelectedRows(),\n      cancel: false\n    };\n\n    if (!isNullOrUndefined(this.parent.commandDelIndex)) {\n      args.data[0] = this.parent.getRowObjectFromUID(this.parent.getRowByIndex(this.parent.commandDelIndex).getAttribute('data-uid')).data;\n    }\n\n    if (this.parent.enableVirtualization && args.data.length > 1) {\n      var uid = this.parent.getSelectedRows()[0].getAttribute('data-uid');\n      args.data = [this.parent.getRowObjectFromUID(uid).data];\n    }\n\n    this.parent.notify(modelChanged, args);\n  };\n\n  NormalEdit.prototype.stopEditStatus = function () {\n    var gObj = this.parent;\n    var addElements = [].slice.call(gObj.element.getElementsByClassName(addedRow));\n    var editElements = [].slice.call(gObj.element.getElementsByClassName(editedRow));\n\n    for (var i = 0; i < addElements.length; i++) {\n      remove(addElements[i]);\n    }\n\n    for (var i = 0; i < editElements.length; i++) {\n      editElements[i].classList.remove(editedRow);\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NormalEdit.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: crudAction,\n      handler: this.editHandler\n    }, {\n      event: doubleTap,\n      handler: this.dblClickHandler\n    }, {\n      event: click,\n      handler: this.clickHandler\n    }, {\n      event: recordAdded,\n      handler: this.requestSuccess\n    }, {\n      event: dblclick,\n      handler: this.dblClickHandler\n    }, {\n      event: deleteComplete,\n      handler: this.editComplete\n    }, {\n      event: saveComplete,\n      handler: this.editComplete\n    }, {\n      event: rowModeChange,\n      handler: this.closeEdit\n    }, {\n      event: closeInline,\n      handler: this.closeForm\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NormalEdit.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  NormalEdit.prototype.destroy = function () {\n    this.removeEventListener();\n    this.renderer.destroy();\n  };\n\n  return NormalEdit;\n}();\n\nvar __extends$28 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `InlineEdit` module is used to handle inline editing actions.\n *\n * @hidden\n */\n\n\nvar InlineEdit =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$28(InlineEdit, _super);\n\n  function InlineEdit(parent, serviceLocator, renderer) {\n    var _this = _super.call(this, parent, serviceLocator) || this;\n\n    _this.parent = parent;\n    _this.serviceLocator = serviceLocator;\n    _this.renderer = renderer;\n    return _this;\n  }\n\n  InlineEdit.prototype.closeEdit = function () {\n    _super.prototype.closeEdit.call(this);\n  };\n\n  InlineEdit.prototype.addRecord = function (data, index) {\n    _super.prototype.addRecord.call(this, data, index);\n  };\n\n  InlineEdit.prototype.endEdit = function () {\n    _super.prototype.endEdit.call(this);\n  };\n\n  InlineEdit.prototype.updateRow = function (index, data) {\n    _super.prototype.updateRow.call(this, index, data);\n  };\n\n  InlineEdit.prototype.deleteRecord = function (fieldname, data) {\n    _super.prototype.deleteRecord.call(this, fieldname, data);\n  };\n\n  InlineEdit.prototype.startEdit = function (tr) {\n    _super.prototype.startEdit.call(this, tr);\n  };\n\n  return InlineEdit;\n}(NormalEdit);\n/**\n * `BatchEdit` module is used to handle batch editing actions.\n *\n * @hidden\n */\n\n\nvar BatchEdit =\n/** @__PURE__ @class */\nfunction () {\n  function BatchEdit(parent, serviceLocator, renderer) {\n    this.cellDetails = {};\n    this.originalCell = {};\n    this.cloneCell = {};\n    this.editNext = false;\n    this.preventSaveCell = false;\n    this.initialRender = true;\n    this.validationColObj = [];\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.renderer = renderer;\n    this.focus = serviceLocator.getService('focus');\n    this.addEventListener();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  BatchEdit.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.evtHandlers = [{\n      event: click,\n      handler: this.clickHandler\n    }, {\n      event: dblclick,\n      handler: this.dblClickHandler\n    }, {\n      event: beforeCellFocused,\n      handler: this.onBeforeCellFocused\n    }, {\n      event: cellFocused,\n      handler: this.onCellFocused\n    }, {\n      event: doubleTap,\n      handler: this.dblClickHandler\n    }, {\n      event: keyPressed,\n      handler: this.keyDownHandler\n    }, {\n      event: editNextValCell,\n      handler: this.editNextValCell\n    }, {\n      event: closeBatch,\n      handler: this.closeForm\n    }, {\n      event: destroy,\n      handler: this.destroy\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n    this.dataBoundFunction = this.dataBound.bind(this);\n    this.batchCancelFunction = this.batchCancel.bind(this);\n    this.parent.addEventListener(dataBound, this.dataBoundFunction);\n    this.parent.addEventListener(batchCancel, this.batchCancelFunction);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  BatchEdit.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n    this.parent.removeEventListener(dataBound, this.dataBoundFunction);\n    this.parent.removeEventListener(batchCancel, this.batchCancelFunction);\n  };\n\n  BatchEdit.prototype.batchCancel = function () {\n    this.parent.focusModule.restoreFocus();\n  };\n\n  BatchEdit.prototype.dataBound = function () {\n    this.parent.notify(toolbarRefresh, {});\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  BatchEdit.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  BatchEdit.prototype.clickHandler = function (e) {\n    if (!parentsUntil(e.target, this.parent.element.id + '_add', true)) {\n      if (this.parent.isEdit && closest(this.form, 'td') !== closest(e.target, 'td')) {\n        this.saveCell();\n        this.editNextValCell();\n      }\n\n      if (parentsUntil(e.target, rowCell) && !this.parent.isEdit) {\n        this.setCellIdx(e.target);\n      }\n    }\n  };\n\n  BatchEdit.prototype.dblClickHandler = function (e) {\n    var target = parentsUntil(e.target, rowCell);\n    var tr = parentsUntil(e.target, row);\n    var rowIndex = tr && parseInt(tr.getAttribute(dataRowIndex), 10);\n    var colIndex = target && parseInt(target.getAttribute(dataColIndex), 10);\n\n    if (!isNullOrUndefined(target) && !isNullOrUndefined(rowIndex) && !isNaN(colIndex) && !target.parentElement.classList.contains(editedRow)) {\n      this.editCell(rowIndex, this.parent.getColumns()[colIndex].field, this.isAddRow(rowIndex));\n    }\n  };\n\n  BatchEdit.prototype.onBeforeCellFocused = function (e) {\n    if (this.parent.isEdit && this.validateFormObj() && (e.byClick || ['tab', 'shiftTab', 'enter', 'shiftEnter'].indexOf(e.keyArgs.action) > -1)) {\n      e.cancel = true;\n\n      if (e.byClick) {\n        e.clickArgs.preventDefault();\n      } else {\n        e.keyArgs.preventDefault();\n      }\n    }\n  };\n\n  BatchEdit.prototype.onCellFocused = function (e) {\n    var frzCols = this.parent.getFrozenLeftCount();\n    var frzRightCols = this.parent.getFrozenRightColumnsCount();\n    var mCont = this.parent.getContent().querySelector('.' + movableContent);\n    var mHdr = this.parent.getHeaderContent().querySelector('.' + movableHeader);\n    var clear = (!e.container.isContent || !e.container.isDataCell) && !(this.parent.frozenRows && e.container.isHeader);\n\n    if (!e.byKey || clear || this.parent.isFrozenGrid() && e.element && closest(e.element, '.e-gridheader') && !e.element.parentElement.hasAttribute('data-rowindex')) {\n      if (this.parent.isEdit && clear) {\n        this.saveCell();\n      }\n\n      return;\n    }\n\n    var _a = e.container.indexes,\n        rowIndex = _a[0],\n        cellIndex = _a[1];\n\n    if (frzCols && (mCont.contains(e.element) || this.parent.frozenRows && mHdr.contains(e.element))) {\n      cellIndex += frzCols;\n    }\n\n    if (frzRightCols) {\n      var frHdr = this.parent.getHeaderContent().querySelector('.e-frozen-right-header');\n      var frCont = this.parent.getContent().querySelector('.e-frozen-right-content');\n\n      if (frCont.contains(e.element) || this.parent.frozenRows && frHdr.contains(e.element)) {\n        cellIndex += frzCols + this.parent.getMovableColumnsCount();\n      }\n    }\n\n    if (this.parent.frozenRows && e.container.isContent) {\n      rowIndex += this.parent.frozenRows;\n    }\n\n    var isEdit = this.parent.isEdit;\n\n    if (!this.parent.element.getElementsByClassName('e-popup-open').length) {\n      isEdit = isEdit && !this.validateFormObj();\n\n      switch (e.keyArgs.action) {\n        case 'tab':\n        case 'shiftTab':\n          // eslint-disable-next-line no-case-declarations\n          var indent = this.parent.isRowDragable() && this.parent.isDetail() ? 2 : this.parent.isRowDragable() || this.parent.isDetail() ? 1 : 0; // eslint-disable-next-line no-case-declarations\n\n          var col = this.parent.getColumns()[cellIndex - indent];\n\n          if (col && !this.parent.isEdit) {\n            this.editCell(rowIndex, col.field);\n          }\n\n          if (isEdit || this.parent.isLastCellPrimaryKey) {\n            this.editCellFromIndex(rowIndex, cellIndex);\n          }\n\n          break;\n\n        case 'enter':\n        case 'shiftEnter':\n          e.keyArgs.preventDefault(); // eslint-disable-next-line no-case-declarations\n\n          var args = {\n            cancel: false,\n            keyArgs: e.keyArgs\n          };\n          this.parent.notify('beforeFocusCellEdit', args);\n\n          if (!args.cancel && isEdit) {\n            this.editCell(rowIndex, this.cellDetails.column.field);\n          }\n\n          break;\n\n        case 'f2':\n          this.editCellFromIndex(rowIndex, cellIndex);\n          this.focus.focus();\n          break;\n      }\n    }\n  };\n\n  BatchEdit.prototype.isAddRow = function (index) {\n    return this.parent.getDataRows()[index].classList.contains('e-insertedrow');\n  };\n\n  BatchEdit.prototype.editCellFromIndex = function (rowIdx, cellIdx) {\n    this.cellDetails.rowIndex = rowIdx;\n    this.cellDetails.cellIndex = cellIdx;\n    this.editCell(rowIdx, this.parent.getColumns()[cellIdx].field, this.isAddRow(rowIdx));\n  };\n\n  BatchEdit.prototype.closeEdit = function () {\n    var _this = this;\n\n    var gObj = this.parent;\n    var rows = this.parent.getRowsObject();\n    var argument = {\n      cancel: false,\n      batchChanges: this.getBatchChanges()\n    };\n    gObj.notify(beforeBatchCancel, argument);\n\n    if (argument.cancel) {\n      return;\n    }\n\n    if (gObj.isEdit) {\n      this.saveCell(true);\n    }\n\n    this.isAdded = false;\n    gObj.clearSelection();\n    var allRows = getGridRowObjects(this.parent);\n\n    var _loop_1 = function (i) {\n      var isInsert = false;\n      var isDirty = rows[i].isDirty;\n      gridActionHandler(this_1.parent, function (tableName, rows) {\n        isInsert = _this.removeBatchElementChanges(rows[i], isDirty);\n\n        if (isInsert) {\n          rows.splice(i, 1);\n        }\n      }, allRows);\n\n      if (isInsert) {\n        i--;\n      }\n\n      out_i_1 = i;\n    };\n\n    var this_1 = this,\n        out_i_1;\n\n    for (var i = 0; i < rows.length; i++) {\n      _loop_1(i);\n\n      i = out_i_1;\n    }\n\n    if (!gObj.getContentTable().querySelector('tr.e-row')) {\n      gObj.renderModule.renderEmptyRow();\n    }\n\n    var args = {\n      requestType: 'batchCancel',\n      rows: this.parent.getRowsObject()\n    };\n\n    if (!this.parent.isFrozenGrid()) {\n      gObj.notify(batchCancel, {\n        rows: this.parent.getRowsObject().length ? this.parent.getRowsObject() : [new Row({\n          isDataRow: true,\n          cells: [new Cell({\n            isDataCell: true,\n            visible: true\n          })]\n        })]\n      });\n    } else {\n      if (this.parent.getRowsObject().length) {\n        gObj.notify(batchCancel, {\n          rows: this.parent.getRowsObject(),\n          args: {\n            isFrozen: true\n          }\n        });\n      }\n\n      if (this.parent.getMovableRowsObject().length) {\n        gObj.notify(batchCancel, {\n          rows: this.parent.getMovableRowsObject()\n        });\n      }\n\n      if (this.parent.getFrozenRightRowsObject().length) {\n        gObj.notify(batchCancel, {\n          rows: this.parent.getFrozenRightRowsObject(),\n          args: {\n            renderFrozenRightContent: true\n          }\n        });\n      }\n    }\n\n    gObj.selectRow(this.cellDetails.rowIndex);\n    this.refreshRowIdx();\n    gObj.notify(toolbarRefresh, {});\n    this.parent.notify(tooltipDestroy, {});\n    args = {\n      requestType: 'batchCancel',\n      rows: this.parent.getRowsObject()\n    };\n    gObj.trigger(batchCancel, args);\n  };\n\n  BatchEdit.prototype.removeBatchElementChanges = function (row$$1, isDirty) {\n    var gObj = this.parent;\n    var rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n    var isInstertedRemoved = false;\n\n    if (isDirty) {\n      row$$1.isDirty = isDirty;\n      var tr = gObj.getRowElementByUID(row$$1.uid);\n\n      if (tr) {\n        if (tr.classList.contains('e-insertedrow')) {\n          remove(tr);\n          isInstertedRemoved = true;\n        } else {\n          refreshForeignData(row$$1, this.parent.getForeignKeyColumns(), row$$1.data);\n          delete row$$1.changes;\n          delete row$$1.edit;\n          row$$1.isDirty = false;\n          classList(tr, [], ['e-hiddenrow', 'e-updatedtd']);\n          rowRenderer.refresh(row$$1, gObj.getColumns(), false);\n        }\n\n        if (this.parent.aggregates.length > 0) {\n          var type = 'type';\n          var editType = [];\n          editType[type] = 'cancel';\n          this.parent.notify(refreshFooterRenderer, editType);\n\n          if (this.parent.groupSettings.columns.length > 0) {\n            this.parent.notify(groupAggregates, editType);\n          }\n        }\n      }\n    }\n\n    return isInstertedRemoved;\n  };\n\n  BatchEdit.prototype.removeHideAndSelection = function (tr) {\n    if (tr.classList.contains('e-hiddenrow')) {\n      tr.removeAttribute('aria-selected');\n      var tdElements = [].slice.call(tr.getElementsByClassName('e-selectionbackground'));\n\n      for (var i = 0; i < tdElements.length; i++) {\n        removeClass([tdElements[i]], ['e-selectionbackground', 'e-active']);\n      }\n    }\n\n    classList(tr, [], ['e-hiddenrow', 'e-updatedtd']);\n  };\n\n  BatchEdit.prototype.deleteRecord = function (fieldname, data) {\n    this.saveCell();\n\n    if (this.validateFormObj()) {\n      this.saveCell(true);\n    }\n\n    this.isAdded = false;\n    this.bulkDelete(fieldname, data);\n\n    if (this.parent.aggregates.length > 0) {\n      this.parent.notify(refreshFooterRenderer, {});\n\n      if (this.parent.groupSettings.columns.length > 0) {\n        this.parent.notify(groupAggregates, {});\n      }\n    }\n  };\n\n  BatchEdit.prototype.addRecord = function (data) {\n    this.bulkAddRow(data);\n  };\n\n  BatchEdit.prototype.endEdit = function () {\n    if (this.parent.isEdit && this.validateFormObj()) {\n      return;\n    }\n\n    this.batchSave();\n  };\n\n  BatchEdit.prototype.closeForm = function () {\n    for (var i = 0; i < Object.keys(this.originalCell).length; i++) {\n      for (var j = 0; j < Object.keys(this.cloneCell).length; j++) {\n        if (Object.keys(this.originalCell)[i] === Object.keys(this.cloneCell)[j]) {\n          this.cloneCell[Object.keys(this.cloneCell)[j]].replaceWith(this.originalCell[Object.keys(this.originalCell)[i]]);\n\n          if (this.originalCell[Object.keys(this.originalCell)[i]].classList.contains('e-selectionbackground')) {\n            this.originalCell[Object.keys(this.originalCell)[i]].classList.remove('e-selectionbackground', 'e-cellselectionbackground', 'e-active');\n          }\n        }\n      }\n    }\n\n    this.cloneCell = {};\n    this.originalCell = {};\n  };\n\n  BatchEdit.prototype.validateFormObj = function () {\n    return this.parent.editModule.formObj && !this.parent.editModule.formObj.validate();\n  };\n\n  BatchEdit.prototype.batchSave = function () {\n    var gObj = this.parent;\n    var deletedRecords$$1 = 'deletedRecords';\n\n    if (gObj.isCheckBoxSelection) {\n      var checkAllBox = gObj.element.querySelector('.e-checkselectall').parentElement;\n\n      if (checkAllBox.classList.contains('e-checkbox-disabled') && gObj.pageSettings.totalRecordsCount > gObj.currentViewData.length) {\n        removeClass([checkAllBox], ['e-checkbox-disabled']);\n      }\n    }\n\n    this.saveCell();\n\n    if (gObj.isEdit || this.editNextValCell() || gObj.isEdit) {\n      return;\n    }\n\n    var changes = this.getBatchChanges();\n\n    if (this.parent.selectionSettings.type === 'Multiple' && changes[deletedRecords$$1].length && this.parent.selectionSettings.persistSelection) {\n      changes[deletedRecords$$1] = this.removeSelectedData;\n      this.removeSelectedData = [];\n    }\n\n    var original = {\n      changedRecords: this.parent.getRowsObject().filter(function (row$$1) {\n        return row$$1.isDirty && ['add', 'delete'].indexOf(row$$1.edit) === -1;\n      }).map(function (row$$1) {\n        return row$$1.data;\n      })\n    };\n    var args = {\n      batchChanges: changes,\n      cancel: false\n    };\n    gObj.trigger(beforeBatchSave, args, function (beforeBatchSaveArgs) {\n      if (beforeBatchSaveArgs.cancel) {\n        return;\n      }\n\n      gObj.showSpinner();\n      gObj.notify(bulkSave, {\n        changes: changes,\n        original: original\n      });\n    });\n  };\n\n  BatchEdit.prototype.getBatchChanges = function () {\n    var changes = {\n      addedRecords: [],\n      deletedRecords: [],\n      changedRecords: []\n    };\n    var rows = this.parent.getRowsObject();\n\n    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n      var row$$1 = rows_1[_i];\n\n      if (row$$1.isDirty) {\n        switch (row$$1.edit) {\n          case 'add':\n            changes.addedRecords.push(row$$1.changes);\n            break;\n\n          case 'delete':\n            changes.deletedRecords.push(row$$1.data);\n            break;\n\n          default:\n            changes.changedRecords.push(row$$1.changes);\n        }\n      }\n    }\n\n    return changes;\n  };\n  /**\n   * @param {string} uid - specifes the uid\n   * @returns {void}\n   * @hidden\n   */\n\n\n  BatchEdit.prototype.removeRowObjectFromUID = function (uid) {\n    var rows = this.parent.getRowsObject();\n    var i = 0;\n\n    for (var len = rows.length; i < len; i++) {\n      if (rows[i].uid === uid) {\n        break;\n      }\n    }\n\n    gridActionHandler(this.parent, function (tableName, rows) {\n      rows.splice(i, 1);\n    }, getGridRowObjects(this.parent));\n  };\n  /**\n   * @param {Row<Column>} row - specifies the row object\n   * @param {freezeTable} newTableName - specifies the table name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  BatchEdit.prototype.addRowObject = function (row$$1, newTableName) {\n    var gObj = this.parent;\n    var isTop = gObj.editSettings.newRowPosition === 'Top';\n    gridActionHandler(this.parent, function (tableName, rows) {\n      var rowClone = row$$1.clone();\n\n      if (gObj.isFrozenGrid()) {\n        if (newTableName === tableName) {\n          if (isTop) {\n            rows.unshift(rowClone);\n          } else {\n            rows.push(rowClone);\n          }\n        }\n      } else {\n        if (isTop) {\n          rows.unshift(rowClone);\n        } else {\n          rows.push(rowClone);\n        }\n      }\n    }, getGridRowObjects(this.parent), true);\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  BatchEdit.prototype.bulkDelete = function (fieldname, data) {\n    var _this = this;\n\n    this.removeSelectedData = [];\n    var gObj = this.parent;\n    var index = gObj.selectedRowIndex;\n    var selectedRows = gObj.getSelectedRows();\n    var args = {\n      primaryKey: this.parent.getPrimaryKeyFieldNames(),\n      rowIndex: index,\n      rowData: data ? data : gObj.getSelectedRecords()[0],\n      cancel: false\n    };\n\n    if (data) {\n      args.row = gObj.editModule.deleteRowUid ? gObj.getRowElementByUID(gObj.editModule.deleteRowUid) : gObj.getRows()[gObj.getCurrentViewRecords().indexOf(data)];\n    } else {\n      args.row = data ? gObj.getRows()[index] : selectedRows[0];\n    }\n\n    if (!args.row) {\n      return;\n    } // tslint:disable-next-line:max-func-body-length\n\n\n    gObj.trigger(beforeBatchDelete, args, function (beforeBatchDeleteArgs) {\n      if (beforeBatchDeleteArgs.cancel) {\n        return;\n      }\n\n      _this.removeSelectedData = gObj.getSelectedRecords();\n      gObj.clearSelection();\n      beforeBatchDeleteArgs.row = beforeBatchDeleteArgs.row ? beforeBatchDeleteArgs.row : data ? gObj.getRows()[index] : selectedRows[0];\n\n      if (_this.parent.isFrozenGrid()) {\n        if (data) {\n          index = parseInt(beforeBatchDeleteArgs.row.getAttribute(dataRowIndex), 10);\n          selectedRows = [];\n          selectedRows.push(gObj.getRowByIndex(index));\n          selectedRows.push(gObj.getMovableRowByIndex(index));\n\n          if (gObj.getFrozenMode() === leftRight) {\n            selectedRows.push(gObj.getFrozenRightRowByIndex(index));\n          }\n        }\n\n        for (var i = 0; i < selectedRows.length; i++) {\n          var uid = selectedRows[i].getAttribute('data-uid');\n\n          if (selectedRows[i].classList.contains('e-insertedrow')) {\n            _this.removeRowObjectFromUID(uid);\n\n            remove(selectedRows[i]);\n          } else {\n            var rowObj = gObj.getRowObjectFromUID(uid);\n            rowObj.isDirty = true;\n            rowObj.edit = 'delete';\n            classList(selectedRows[i], ['e-hiddenrow', 'e-updatedtd'], []);\n\n            if (gObj.frozenRows && index < gObj.frozenRows && gObj.getMovableDataRows().length >= gObj.frozenRows) {\n              gObj.getMovableHeaderTbody().appendChild(gObj.getMovableRowByIndex(gObj.frozenRows - 1));\n              gObj.getFrozenHeaderTbody().appendChild(gObj.getRowByIndex(gObj.frozenRows - 1));\n\n              if (gObj.getFrozenMode() === leftRight) {\n                gObj.getFrozenRightHeaderTbody().appendChild(gObj.getFrozenRightRowByIndex(gObj.frozenRows - 1));\n              }\n            }\n\n            if (gObj.frozenRows && index < gObj.frozenRows && gObj.getDataRows().length >= gObj.frozenRows) {\n              gObj.getHeaderTable().querySelector(tbody).appendChild(gObj.getRowByIndex(gObj.frozenRows - 1));\n            }\n          }\n\n          delete selectedRows[i];\n        }\n      } else if (!_this.parent.isFrozenGrid() && (selectedRows.length === 1 || data)) {\n        var uid = beforeBatchDeleteArgs.row.getAttribute('data-uid');\n        uid = data && _this.parent.editModule.deleteRowUid ? uid = _this.parent.editModule.deleteRowUid : uid;\n\n        if (beforeBatchDeleteArgs.row.classList.contains('e-insertedrow')) {\n          _this.removeRowObjectFromUID(uid);\n\n          remove(beforeBatchDeleteArgs.row);\n        } else {\n          var rowObj = gObj.getRowObjectFromUID(uid);\n          rowObj.isDirty = true;\n          rowObj.edit = 'delete';\n          classList(beforeBatchDeleteArgs.row, ['e-hiddenrow', 'e-updatedtd'], []);\n        }\n\n        delete beforeBatchDeleteArgs.row;\n      } else {\n        for (var i = 0; i < selectedRows.length; i++) {\n          var uniqueid = selectedRows[i].getAttribute('data-uid');\n\n          if (selectedRows[i].classList.contains('e-insertedrow')) {\n            _this.removeRowObjectFromUID(uniqueid);\n\n            remove(selectedRows[i]);\n          } else {\n            classList(selectedRows[i], ['e-hiddenrow', 'e-updatedtd'], []);\n            var selectedRow = gObj.getRowObjectFromUID(uniqueid);\n            selectedRow.isDirty = true;\n            selectedRow.edit = 'delete';\n            delete selectedRows[i];\n          }\n        }\n      }\n\n      _this.refreshRowIdx();\n\n      if (data) {\n        gObj.editModule.deleteRowUid = undefined;\n\n        if (gObj.getSelectedRows().length) {\n          index = parseInt(gObj.getSelectedRows()[0].getAttribute(dataRowIndex), 10);\n        }\n      }\n\n      if (!gObj.isCheckBoxSelection) {\n        gObj.selectRow(index);\n      }\n\n      gObj.trigger(batchDelete, beforeBatchDeleteArgs);\n      gObj.notify(batchDelete, {\n        rows: _this.parent.getRowsObject()\n      });\n      gObj.notify(toolbarRefresh, {});\n    });\n  };\n\n  BatchEdit.prototype.refreshRowIdx = function () {\n    var gObj = this.parent;\n    var rows = gObj.getAllDataRows(true);\n    var dataRows = getGridRowElements(this.parent);\n    var dataObjects = getGridRowObjects(this.parent);\n\n    var _loop_2 = function (i, j, len) {\n      if (rows[i].classList.contains(row) && !rows[i].classList.contains('e-hiddenrow')) {\n        gridActionHandler(this_2.parent, function (tableName, rowElements, rowObjects) {\n          rowElements[i].setAttribute(dataRowIndex, j.toString());\n          rowElements[i].setAttribute(ariaRowIndex, (j + 1).toString());\n          rowObjects[i].index = j;\n        }, dataRows, null, dataObjects);\n        j++;\n      } else {\n        gridActionHandler(this_2.parent, function (tableName, rowElements, rowObjects) {\n          rowElements[i].removeAttribute(dataRowIndex);\n          rowElements[i].removeAttribute(ariaRowIndex);\n          rowObjects[i].index = -1;\n        }, dataRows, null, dataObjects);\n      }\n\n      out_j_1 = j;\n    };\n\n    var this_2 = this,\n        out_j_1;\n\n    for (var i = 0, j = 0, len = rows.length; i < len; i++) {\n      _loop_2(i, j, len);\n\n      j = out_j_1;\n    }\n  };\n\n  BatchEdit.prototype.getIndexFromData = function (data) {\n    return inArray(data, this.parent.getCurrentViewRecords());\n  };\n\n  BatchEdit.prototype.bulkAddRow = function (data) {\n    var _this = this;\n\n    var gObj = this.parent;\n\n    if (!gObj.editSettings.allowAdding) {\n      return;\n    }\n\n    if (gObj.isEdit) {\n      this.saveCell();\n      this.parent.notify(editNextValCell, {});\n    }\n\n    if (gObj.isEdit) {\n      return;\n    }\n\n    if (this.initialRender) {\n      var visibleColumns = gObj.getVisibleColumns();\n\n      for (var i = 0; i < visibleColumns.length; i++) {\n        if (visibleColumns[i].validationRules && visibleColumns[i].validationRules['required']) {\n          var obj = {\n            field: visibleColumns[i]['field'].slice(),\n            cellIdx: i\n          };\n          this.validationColObj.push(obj);\n        }\n      }\n\n      this.initialRender = false;\n    }\n\n    this.parent.element.classList.add('e-editing');\n    var defaultData = data ? data : this.getDefaultData();\n    var args = {\n      defaultData: defaultData,\n      primaryKey: gObj.getPrimaryKeyFieldNames(),\n      cancel: false\n    };\n    gObj.trigger(beforeBatchAdd, args, function (beforeBatchAddArgs) {\n      if (beforeBatchAddArgs.cancel) {\n        return;\n      }\n\n      _this.isAdded = true;\n      gObj.clearSelection();\n\n      if (gObj.isFrozenGrid()) {\n        var movableCnt = _this.parent.getMovableColumnsCount();\n\n        var leftCnt = _this.parent.getFrozenLeftCount();\n\n        var rightCnt = _this.parent.getFrozenRightColumnsCount();\n\n        var tbody$$1 = gObj.getContentTable().querySelector(tbody);\n        var totCount = movableCnt + leftCnt + rightCnt;\n        var tableTanName = void 0;\n        var selectedRowAdd = [];\n        var selectedRowAddCells = [];\n        var col = void 0;\n        var index = void 0;\n        var tr = void 0;\n        var mTr = void 0;\n        var frTr = void 0;\n\n        for (var i = 0; i < totCount;) {\n          var row$$1 = new RowRenderer(_this.serviceLocator, null, _this.parent);\n          var model = new RowModelGenerator(_this.parent);\n          var modelData = model.generateRows([beforeBatchAddArgs.defaultData]);\n\n          if (leftCnt > 0) {\n            leftCnt = 0;\n            tableTanName = 'frozen-left';\n            totCount = leftCnt + rightCnt + movableCnt;\n          } else if (movableCnt > 0) {\n            movableCnt = 0;\n            tableTanName = 'movable';\n            totCount = leftCnt + rightCnt + movableCnt;\n          } else {\n            rightCnt = 0;\n            tableTanName = 'frozen-right';\n            totCount = leftCnt + rightCnt + movableCnt;\n          }\n\n          for (var i_1 = 0; i_1 < modelData.length; i_1++) {\n            modelData[i_1].cells = splitFrozenRowObjectCells(_this.parent, modelData[i_1].cells, tableTanName);\n          }\n\n          if (tableTanName === 'frozen-left') {\n            tr = row$$1.render(modelData[0], gObj.getColumns());\n            tr.classList.add('e-insertedrow');\n          } else if (tableTanName === 'movable') {\n            mTr = row$$1.render(modelData[0], gObj.getColumns());\n            mTr.classList.add('e-insertedrow');\n          } else {\n            frTr = row$$1.render(modelData[0], gObj.getColumns());\n            frTr.classList.add('e-insertedrow');\n          }\n\n          for (var i_2 = 0; i_2 < _this.parent.groupSettings.columns.length; i_2++) {\n            tr.insertBefore(_this.parent.createElement('td', {\n              className: 'e-indentcell'\n            }), tr.firstChild);\n            modelData[0].cells.unshift(new Cell({\n              cellType: CellType.Indent\n            }));\n          }\n\n          if (tbody$$1.querySelector('.e-emptyrow')) {\n            var emptyRow = tbody$$1.querySelector('.e-emptyrow');\n            emptyRow.parentNode.removeChild(emptyRow);\n\n            _this.removeFrozenTbody();\n          }\n\n          if (tableTanName === 'frozen-left') {\n            if (gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top') {\n              tbody$$1 = gObj.getHeaderTable().querySelector(tbody);\n            } else {\n              tbody$$1 = gObj.getContentTable().querySelector(tbody);\n            }\n\n            if (_this.parent.editSettings.newRowPosition === 'Top') {\n              tbody$$1.insertBefore(tr, tbody$$1.firstChild);\n              addClass([].slice.call(tr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n            } else {\n              tbody$$1.appendChild(tr);\n              addClass([].slice.call(tr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n            }\n          }\n\n          if (tableTanName === 'movable' || tableTanName === 'frozen-right') {\n            _this.renderFrozenAddRow(mTr, frTr, tableTanName);\n          }\n\n          modelData[0].isDirty = true;\n          modelData[0].changes = extend({}, {}, modelData[0].data, true);\n          modelData[0].edit = 'add';\n\n          _this.addRowObject(modelData[0], tableTanName);\n        }\n\n        _this.refreshRowIdx();\n\n        _this.focus.forgetPrevious();\n\n        gObj.notify(batchAdd, {\n          rows: _this.parent.getRowsObject(),\n          args: {\n            isFrozen: _this.parent.isFrozenGrid()\n          }\n        });\n\n        var changes = _this.getBatchChanges();\n\n        var btmIdx = _this.getBottomIndex();\n\n        if (_this.parent.editSettings.newRowPosition === 'Top') {\n          gObj.selectRow(0);\n        } else {\n          gObj.selectRow(btmIdx);\n        }\n\n        if (!data) {\n          index = _this.findNextEditableCell(0, true);\n          col = gObj.getColumns()[index];\n\n          if (_this.parent.editSettings.newRowPosition === 'Top') {\n            _this.editCell(0, col.field, true);\n          } else {\n            _this.editCell(btmIdx, col.field, true);\n          }\n        }\n\n        if (_this.parent.aggregates.length > 0 && (data || changes[addedRecords].length)) {\n          _this.parent.notify(refreshFooterRenderer, {});\n        }\n\n        if (tr) {\n          alignFrozenEditForm(mTr.querySelector('td:not(.e-hide)'), tr.querySelector('td:not(.e-hide)'));\n          selectedRowAdd.push(tr);\n          selectedRowAddCells.push(tr.cells);\n        }\n\n        selectedRowAdd.push(mTr);\n        selectedRowAddCells.push(mTr.cells);\n\n        if (frTr) {\n          selectedRowAdd.push(frTr);\n          selectedRowAddCells.push(frTr.cells);\n        }\n\n        var args1 = {\n          defaultData: beforeBatchAddArgs.defaultData,\n          row: selectedRowAdd,\n          columnObject: col,\n          columnIndex: index,\n          primaryKey: beforeBatchAddArgs.primaryKey,\n          cell: selectedRowAddCells\n        };\n        gObj.trigger(batchAdd, args1);\n      } else {\n        var row$$1 = new RowRenderer(_this.serviceLocator, null, _this.parent);\n        var model = new RowModelGenerator(_this.parent);\n        var modelData = model.generateRows([beforeBatchAddArgs.defaultData]);\n        var tr = row$$1.render(modelData[0], gObj.getColumns());\n        var col = void 0;\n        var index = void 0;\n\n        for (var i = 0; i < _this.parent.groupSettings.columns.length; i++) {\n          tr.insertBefore(_this.parent.createElement('td', {\n            className: 'e-indentcell'\n          }), tr.firstChild);\n          modelData[0].cells.unshift(new Cell({\n            cellType: CellType.Indent\n          }));\n        }\n\n        var tbody$$1 = gObj.getContentTable().querySelector(tbody);\n        tr.classList.add('e-insertedrow');\n\n        if (tbody$$1.querySelector('.e-emptyrow')) {\n          var emptyRow = tbody$$1.querySelector('.e-emptyrow');\n          emptyRow.parentNode.removeChild(emptyRow);\n\n          _this.removeFrozenTbody();\n        }\n\n        if (gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top') {\n          tbody$$1 = gObj.getHeaderTable().querySelector(tbody);\n        } else {\n          tbody$$1 = gObj.getContentTable().querySelector(tbody);\n        }\n\n        if (_this.parent.editSettings.newRowPosition === 'Top') {\n          tbody$$1.insertBefore(tr, tbody$$1.firstChild);\n        } else {\n          tbody$$1.appendChild(tr);\n        }\n\n        addClass([].slice.call(tr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n        modelData[0].isDirty = true;\n        modelData[0].changes = extend({}, {}, modelData[0].data, true);\n        modelData[0].edit = 'add';\n\n        _this.addRowObject(modelData[0]);\n\n        _this.refreshRowIdx();\n\n        _this.focus.forgetPrevious();\n\n        gObj.notify(batchAdd, {\n          rows: _this.parent.getRowsObject(),\n          args: {\n            isFrozen: _this.parent.isFrozenGrid()\n          }\n        });\n\n        var changes = _this.getBatchChanges();\n\n        var btmIdx = _this.getBottomIndex();\n\n        if (_this.parent.editSettings.newRowPosition === 'Top') {\n          gObj.selectRow(0);\n        } else {\n          gObj.selectRow(btmIdx);\n        }\n\n        if (!data) {\n          index = _this.findNextEditableCell(0, true);\n          col = gObj.getColumns()[index];\n\n          if (_this.parent.editSettings.newRowPosition === 'Top') {\n            _this.editCell(0, col.field, true);\n          } else {\n            _this.editCell(btmIdx, col.field, true);\n          }\n        }\n\n        if (_this.parent.aggregates.length > 0 && (data || changes[addedRecords].length)) {\n          _this.parent.notify(refreshFooterRenderer, {});\n        }\n\n        var args1 = {\n          defaultData: beforeBatchAddArgs.defaultData,\n          row: tr,\n          columnObject: col,\n          columnIndex: index,\n          primaryKey: beforeBatchAddArgs.primaryKey,\n          cell: tr.cells[index]\n        };\n        gObj.trigger(batchAdd, args1);\n      }\n    });\n  };\n\n  BatchEdit.prototype.renderFrozenAddRow = function (mTr, frTr, tableName$$1) {\n    var gObj = this.parent;\n    var mTbody;\n    var frTbody;\n\n    if (tableName$$1 === 'movable') {\n      if (gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top') {\n        mTbody = this.parent.getMovableHeaderTbody();\n      } else {\n        mTbody = this.parent.getContent().querySelector('.e-movablecontent').querySelector(tbody);\n      }\n\n      if (gObj.editSettings.newRowPosition === 'Top') {\n        mTbody.insertBefore(mTr, mTbody.firstChild);\n      } else {\n        mTbody.appendChild(mTr);\n      }\n\n      addClass([].slice.call(mTr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n    }\n\n    if (tableName$$1 === 'frozen-right') {\n      if (gObj.frozenRows && gObj.editSettings.newRowPosition === 'Top') {\n        frTbody = this.parent.getFrozenRightHeaderTbody();\n      } else {\n        frTbody = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n      }\n\n      if (gObj.editSettings.newRowPosition === 'Top') {\n        frTbody.insertBefore(frTr, frTbody.firstChild);\n      } else {\n        frTbody.appendChild(frTr);\n      }\n\n      addClass([].slice.call(frTr.getElementsByClassName(rowCell)), ['e-updatedtd']);\n      alignFrozenEditForm(frTr.querySelector('td:not(.e-hide)'), mTr.querySelector('td:not(.e-hide)'));\n    }\n\n    if (gObj.height === 'auto') {\n      gObj.notify(frozenHeight, {});\n    }\n  };\n\n  BatchEdit.prototype.removeFrozenTbody = function () {\n    var gObj = this.parent;\n\n    if (gObj.isFrozenGrid()) {\n      var moveTbody = gObj.getContent().querySelector('.' + movableContent).querySelector(tbody);\n      moveTbody.firstElementChild.parentNode.removeChild(moveTbody.firstElementChild);\n\n      if (gObj.getFrozenMode() === leftRight) {\n        var frTbody = gObj.getContent().querySelector('.e-frozen-right-content').querySelector(tbody);\n        frTbody.firstElementChild.parentNode.removeChild(frTbody.firstElementChild);\n      }\n    }\n  };\n\n  BatchEdit.prototype.renderMovable = function (ele, rightEle) {\n    var mEle = ele.cloneNode(true);\n    var movable = this.parent.getMovableColumnsCount();\n    var left = this.parent.getFrozenLeftCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n    sliceElements(ele, 0, left);\n    sliceElements(mEle, left, right ? mEle.children.length - right : mEle.children.length);\n    sliceElements(rightEle, left + movable, rightEle.children.length);\n    return mEle;\n  };\n\n  BatchEdit.prototype.findNextEditableCell = function (columnIndex, isAdd, isValOnly) {\n    var cols = this.parent.getColumns();\n    var endIndex = cols.length;\n    var validation;\n\n    for (var i = columnIndex; i < endIndex; i++) {\n      validation = isValOnly ? isNullOrUndefined(cols[i].validationRules) : false;\n\n      if (!isAdd && this.checkNPCell(cols[i])) {\n        return i;\n      } else if (isAdd && (!cols[i].template || cols[i].field) && cols[i].visible && cols[i].allowEditing && !(cols[i].isIdentity && cols[i].isPrimaryKey) && !validation) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  BatchEdit.prototype.checkNPCell = function (col) {\n    return !col.template && col.visible && !col.isPrimaryKey && !col.isIdentity && col.allowEditing;\n  };\n\n  BatchEdit.prototype.getDefaultData = function () {\n    var gObj = this.parent;\n    var data = {};\n    var dValues = {\n      'number': 0,\n      'string': null,\n      'boolean': false,\n      'date': null,\n      'datetime': null\n    };\n\n    for (var _i = 0, _a = gObj.columnModel; _i < _a.length; _i++) {\n      var col = _a[_i];\n\n      if (col.field) {\n        setValue(col.field, Object.keys(col).indexOf('defaultValue') >= 0 ? col.defaultValue : dValues[col.type], data);\n      }\n    }\n\n    return data;\n  };\n\n  BatchEdit.prototype.setCellIdx = function (target) {\n    var gLen = 0;\n\n    if (this.parent.allowGrouping) {\n      gLen = this.parent.groupSettings.columns.length;\n    }\n\n    this.cellDetails.cellIndex = target.cellIndex - gLen;\n    this.cellDetails.rowIndex = parseInt(target.getAttribute('index'), 10);\n  };\n\n  BatchEdit.prototype.editCell = function (index, field, isAdd) {\n    var gObj = this.parent;\n    var col = gObj.getColumnByField(field);\n    this.index = index;\n    this.field = field;\n    this.isAdd = isAdd;\n    var checkEdit = gObj.isEdit && !(this.cellDetails.column.field === field && this.cellDetails.rowIndex === index && this.parent.getDataRows().length - 1 !== index);\n\n    if (gObj.editSettings.allowEditing) {\n      if (!checkEdit && col.allowEditing) {\n        this.editCellExtend(index, field, isAdd);\n      } else if (checkEdit) {\n        this.editNext = true;\n        this.saveCell();\n      }\n    }\n  };\n\n  BatchEdit.prototype.editCellExtend = function (index, field, isAdd) {\n    var _this = this;\n\n    var gObj = this.parent;\n    var col = gObj.getColumnByField(field);\n    var keys = gObj.getPrimaryKeyFieldNames();\n\n    if (gObj.isEdit) {\n      return;\n    }\n\n    var row$$1;\n    var mRowData;\n    var rowData = extend({}, {}, this.getDataByIndex(index), true);\n\n    if (col.getFreezeTableName() === 'movable' || col.getFreezeTableName() === frozenRight) {\n      row$$1 = col.getFreezeTableName() === 'movable' ? gObj.getMovableDataRows()[index] : gObj.getFrozenRightDataRows()[index];\n      mRowData = this.parent.getRowObjectFromUID(row$$1.getAttribute('data-uid'));\n      rowData = mRowData.changes ? extend({}, {}, mRowData.changes, true) : rowData;\n    } else {\n      row$$1 = gObj.getDataRows()[index];\n      rowData = extend({}, {}, this.getDataByIndex(index), true);\n    }\n\n    if (keys[0] === col.field && !row$$1.classList.contains('e-insertedrow') || col.columns || col.isPrimaryKey && col.isIdentity || col.commands) {\n      this.parent.isLastCellPrimaryKey = true;\n      return;\n    }\n\n    this.parent.isLastCellPrimaryKey = false;\n    this.parent.element.classList.add('e-editing');\n    var rowObj = gObj.getRowObjectFromUID(row$$1.getAttribute('data-uid'));\n    var cells = [].slice.apply(row$$1.cells);\n    var args = {\n      columnName: col.field,\n      isForeignKey: !isNullOrUndefined(col.foreignKeyValue),\n      primaryKey: keys,\n      rowData: rowData,\n      validationRules: extend({}, col.validationRules ? col.validationRules : {}),\n      value: getObject(col.field, rowData),\n      type: !isAdd ? 'edit' : 'add',\n      cancel: false,\n      foreignKeyData: rowObj && rowObj.foreignKeyData\n    };\n    args.cell = cells[this.getColIndex(cells, this.getCellIdx(col.uid))];\n    args.row = row$$1;\n    args.columnObject = col;\n\n    if (!args.cell) {\n      return;\n    }\n\n    gObj.trigger(cellEdit, args, function (cellEditArgs) {\n      if (cellEditArgs.cancel) {\n        return;\n      }\n\n      cellEditArgs.cell = cellEditArgs.cell ? cellEditArgs.cell : cells[_this.getColIndex(cells, _this.getCellIdx(col.uid))];\n      cellEditArgs.row = cellEditArgs.row ? cellEditArgs.row : row$$1;\n      cellEditArgs.columnObject = cellEditArgs.columnObject ? cellEditArgs.columnObject : col;\n      cellEditArgs.columnObject.index = isNullOrUndefined(cellEditArgs.columnObject.index) ? 0 : cellEditArgs.columnObject.index;\n      _this.cellDetails = {\n        rowData: rowData,\n        column: col,\n        value: cellEditArgs.value,\n        isForeignKey: cellEditArgs.isForeignKey,\n        rowIndex: index,\n        cellIndex: parseInt(cellEditArgs.cell.getAttribute(dataColIndex), 10),\n        foreignKeyData: cellEditArgs.foreignKeyData\n      };\n\n      if (cellEditArgs.cell.classList.contains('e-updatedtd')) {\n        _this.isColored = true;\n        cellEditArgs.cell.classList.remove('e-updatedtd');\n      }\n\n      gObj.isEdit = true;\n      gObj.clearSelection();\n\n      if (!gObj.isCheckBoxSelection || !gObj.isPersistSelection) {\n        gObj.selectRow(_this.cellDetails.rowIndex, true);\n      }\n\n      _this.renderer.update(cellEditArgs);\n\n      _this.parent.notify(batchEditFormRendered, cellEditArgs);\n\n      _this.form = select('#' + gObj.element.id + 'EditForm', gObj.element);\n      gObj.editModule.applyFormValidation([col]);\n      _this.parent.element.querySelector('.e-gridpopup').style.display = 'none';\n    });\n  };\n\n  BatchEdit.prototype.updateCell = function (rowIndex, field, value) {\n    var gObj = this.parent;\n    var col = gObj.getColumnByField(field);\n    var index = gObj.getColumnIndexByField(field);\n\n    if (col && !col.isPrimaryKey && col.allowEditing) {\n      var td = getCellByColAndRowIndex(this.parent, col, rowIndex, index);\n      var rowObj = col.getFreezeTableName() === 'movable' ? this.parent.getMovableRowsObject()[rowIndex] : col.getFreezeTableName() === frozenRight ? gObj.getFrozenRightRowsObject()[rowIndex] : gObj.getRowObjectFromUID(td.parentElement.getAttribute('data-uid'));\n      this.refreshTD(td, col, rowObj, value);\n      this.parent.trigger(queryCellInfo, {\n        cell: this.newReactTd || td,\n        column: col,\n        data: rowObj.changes\n      });\n    }\n  };\n\n  BatchEdit.prototype.setChanges = function (rowObj, field, value) {\n    var currentRowObj;\n\n    if (!this.parent.isFrozenGrid()) {\n      if (!rowObj.changes) {\n        rowObj.changes = extend({}, {}, rowObj.data, true);\n      }\n\n      if (!isNullOrUndefined(field)) {\n        DataUtil.setValue(field, value, rowObj.changes);\n      }\n\n      if (rowObj.data[field] !== value) {\n        var type = this.parent.getColumnByField(field).type;\n\n        if (type === 'date' || type === 'datetime') {\n          if (new Date(rowObj.data[field]).toString() !== new Date(value).toString()) {\n            rowObj.isDirty = true;\n          }\n        } else {\n          rowObj.isDirty = true;\n        }\n      }\n    } else {\n      var rowEle = this.parent.getRowElementByUID(rowObj.uid);\n      var rowIndex = parseInt(rowEle.getAttribute(dataRowIndex), 10);\n      currentRowObj = this.parent.getRowsObject()[rowIndex];\n\n      if (!currentRowObj.changes) {\n        currentRowObj.changes = extend({}, {}, rowObj.data, true);\n      }\n\n      if (!isNullOrUndefined(field)) {\n        setValue(field, value, currentRowObj.changes);\n      }\n\n      var movableRowObject = this.parent.getMovableRowsObject()[rowIndex];\n      movableRowObject.changes = extend({}, {}, currentRowObj.changes, true);\n\n      if (rowObj.data[field] !== value) {\n        movableRowObject.isDirty = true;\n        currentRowObj.isDirty = true;\n      }\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        var frRowObject = this.parent.getFrozenRightRowsObject()[rowIndex];\n        frRowObject.changes = extend({}, {}, currentRowObj.changes, true);\n\n        if (rowObj.data[field] !== value) {\n          frRowObject.isDirty = true;\n        }\n      }\n    }\n  };\n\n  BatchEdit.prototype.updateRow = function (index, data) {\n    var keys = Object.keys(data);\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var col = keys_1[_i];\n      this.updateCell(index, col, data[col]);\n    }\n  };\n\n  BatchEdit.prototype.getCellIdx = function (uid) {\n    var cIdx = this.parent.getColumnIndexByUid(uid) + this.parent.groupSettings.columns.length;\n\n    if (!isNullOrUndefined(this.parent.detailTemplate) || !isNullOrUndefined(this.parent.childGrid)) {\n      cIdx++;\n    }\n\n    if (this.parent.isRowDragable()) {\n      cIdx++;\n    }\n\n    return cIdx;\n  };\n\n  BatchEdit.prototype.refreshTD = function (td, column, rowObj, value) {\n    var cell = new CellRenderer(this.parent, this.serviceLocator);\n    var rowcell;\n    value = column.type === 'number' && !isNullOrUndefined(value) ? parseFloat(value) : value;\n    this.setChanges(rowObj, column.field, value);\n    var frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenRightColumnsCount();\n    frzCols = frzCols && this.parent.isRowDragable() ? frzCols + 1 : frzCols;\n    refreshForeignData(rowObj, this.parent.getForeignKeyColumns(), rowObj.changes);\n\n    if (frzCols && column.getFreezeTableName() === 'movable' && this.parent.getColumns().length === rowObj.cells.length) {\n      rowcell = rowObj.cells.slice(frzCols, rowObj.cells.length);\n    } else {\n      rowcell = rowObj.cells;\n    }\n\n    var parentElement;\n    var cellIndex;\n\n    if (this.parent.isReact) {\n      parentElement = td.parentElement;\n      cellIndex = td.cellIndex;\n    }\n\n    var index = 0;\n\n    if (frzCols) {\n      index = column.getFreezeTableName() === 'movable' && this.parent.getFrozenMode() !== 'Right' ? frzCols : column.getFreezeTableName() === frozenRight ? this.parent.getFrozenLeftColumnsCount() + this.parent.getMovableColumnsCount() : index;\n    }\n\n    cell.refreshTD(td, rowcell[this.getCellIdx(column.uid) - index], rowObj.changes, {\n      'index': this.getCellIdx(column.uid)\n    });\n\n    if (this.parent.isReact) {\n      this.newReactTd = parentElement.cells[cellIndex];\n      parentElement.cells[cellIndex].classList.add('e-updatedtd');\n    } else {\n      td.classList.add('e-updatedtd');\n    }\n\n    td.classList.add('e-updatedtd');\n    this.parent.notify(toolbarRefresh, {});\n  };\n\n  BatchEdit.prototype.getColIndex = function (cells, index) {\n    var cIdx = 0;\n\n    if (this.parent.allowGrouping && this.parent.groupSettings.columns) {\n      cIdx = this.parent.groupSettings.columns.length;\n    }\n\n    if (!isNullOrUndefined(this.parent.detailTemplate) || !isNullOrUndefined(this.parent.childGrid)) {\n      cIdx++;\n    }\n\n    if (this.parent.isRowDragable()) {\n      cIdx++;\n    }\n\n    for (var m = 0; m < cells.length; m++) {\n      var colIndex = parseInt(cells[m].getAttribute(dataColIndex), 10);\n\n      if (colIndex === index - cIdx) {\n        return m;\n      }\n    }\n\n    return -1;\n  };\n\n  BatchEdit.prototype.editNextValCell = function () {\n    var gObj = this.parent;\n    var insertedRows = gObj.element.querySelectorAll('.e-insertedrow');\n    var isSingleInsert = insertedRows.length === 1 ? true : (gObj.getFrozenColumns() > 0 || gObj.getFrozenRightColumnsCount() > 0 || gObj.getFrozenLeftColumnsCount() > 0) && (insertedRows.length === 2 || insertedRows.length === 3) ? true : false;\n\n    if (isSingleInsert && this.isAdded && !gObj.isEdit) {\n      var btmIdx = this.getBottomIndex();\n\n      for (var i = this.cellDetails.cellIndex; i < gObj.getColumns().length; i++) {\n        if (gObj.isEdit) {\n          return;\n        }\n\n        var index = this.findNextEditableCell(this.cellDetails.cellIndex + 1, true, true);\n        var col = gObj.getColumns()[index];\n\n        if (col) {\n          if (this.parent.editSettings.newRowPosition === 'Bottom') {\n            this.editCell(btmIdx, col.field, true);\n          } else {\n            var args = {\n              index: 0,\n              column: col\n            };\n            this.parent.notify(nextCellIndex, args);\n            this.editCell(args.index, col.field, true);\n          }\n\n          this.saveCell();\n        }\n      }\n\n      if (!gObj.isEdit) {\n        this.isAdded = false;\n      }\n    } else if (!isSingleInsert && this.isAdded && !gObj.isEdit && !gObj.isFrozenGrid()) {\n      var editRowIdx = 0;\n\n      if (gObj.editSettings.newRowPosition === 'Bottom') {\n        var changes = this.getBatchChanges();\n        editRowIdx = gObj.getCurrentViewRecords().length - changes[deletedRecords].length;\n      }\n\n      for (var i = 0; i < insertedRows.length; i++, editRowIdx++) {\n        if (!gObj.isEdit) {\n          for (var j = 0; j < this.validationColObj.length; j++) {\n            if (gObj.isEdit) {\n              break;\n            } else if (insertedRows[i].querySelectorAll('td')[this.validationColObj[j].cellIdx].innerText === '') {\n              this.editCell(editRowIdx, this.validationColObj[j].field);\n\n              if (this.validateFormObj()) {\n                this.saveCell();\n              }\n            }\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (!gObj.isEdit) {\n        this.isAdded = false;\n      }\n    } else if (!isSingleInsert && this.isAdded && !gObj.isEdit && gObj.isFrozenGrid()) {\n      var fLeftInsertedRow = gObj.getFrozenLeftContentTbody() ? gObj.getFrozenLeftContentTbody().querySelectorAll('.e-insertedrow') : undefined;\n      var fRightInsertedRow = gObj.getFrozenRightContentTbody() ? gObj.getFrozenRightContentTbody().querySelectorAll('.e-insertedrow') : undefined;\n      var mInsertedRow = gObj.getMovableContentTbody().querySelectorAll('.e-insertedrow');\n      var editRowIdx = 0;\n      var fLeftCount = gObj.getVisibleFrozenLeftCount() ? gObj.getVisibleFrozenLeftCount() : gObj.getFrozenColumns();\n      var fRightCount = gObj.getVisibleFrozenRightCount();\n      var mColumnCount = gObj.getVisibleMovableCount();\n\n      if (gObj.editSettings.newRowPosition === 'Bottom') {\n        var changes = this.getBatchChanges();\n        editRowIdx = gObj.getCurrentViewRecords().length - changes[deletedRecords].length;\n      } else if (gObj.editSettings.newRowPosition === 'Top' && gObj.frozenRows) {\n        fLeftInsertedRow = gObj.getFrozenHeaderTbody() ? gObj.getFrozenHeaderTbody().querySelectorAll('.e-insertedrow') : undefined;\n        fRightInsertedRow = gObj.getFrozenRightHeader() ? gObj.getFrozenRightHeader().querySelectorAll('.e-insertedrow') : undefined;\n        mInsertedRow = gObj.getMovableHeaderTbody().querySelectorAll('.e-insertedrow');\n      }\n\n      for (var i = 0; i < mInsertedRow.length; i++, editRowIdx++) {\n        if (!gObj.isEdit) {\n          for (var j = 0; j < this.validationColObj.length; j++) {\n            if (gObj.isEdit) {\n              break;\n            } else if (fLeftCount && this.validationColObj[j].cellIdx < fLeftCount) {\n              if (fLeftInsertedRow[i].querySelectorAll('td')[this.validationColObj[j].cellIdx].innerText === '') {\n                this.editCell(editRowIdx, this.validationColObj[j].field);\n\n                if (gObj.editModule.formObj.validate()) {\n                  this.saveCell();\n                }\n              }\n            } else if (fRightCount && mColumnCount <= this.validationColObj[j].cellIdx) {\n              if (fRightInsertedRow[i].querySelectorAll('td')[this.validationColObj[j].cellIdx - (mColumnCount + fLeftCount)].innerText === '') {\n                this.editCell(editRowIdx, this.validationColObj[j].field);\n\n                if (gObj.editModule.formObj.validate()) {\n                  this.saveCell();\n                }\n              }\n            } else if (mInsertedRow[i].querySelectorAll('td')[this.validationColObj[j].cellIdx - fLeftCount].innerText === '') {\n              this.editCell(editRowIdx, this.validationColObj[j].field);\n\n              if (gObj.editModule.formObj.validate()) {\n                this.saveCell();\n              }\n            }\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (!gObj.isEdit) {\n        this.isAdded = false;\n      }\n    }\n  };\n\n  BatchEdit.prototype.escapeCellEdit = function () {\n    var args = this.generateCellArgs();\n    args.value = args.previousValue;\n\n    if (args.value || !this.cellDetails.column.validationRules) {\n      this.successCallBack(args, args.cell.parentElement, args.column, true)(args);\n    }\n  };\n\n  BatchEdit.prototype.generateCellArgs = function () {\n    var gObj = this.parent;\n    this.parent.element.classList.remove('e-editing');\n    var column = this.cellDetails.column;\n    var obj = {};\n    obj[column.field] = getObject(column.field, this.cellDetails.rowData);\n    var editedData = gObj.editModule.getCurrentEditedData(this.form, obj);\n    var cloneEditedData = extend({}, editedData);\n    editedData = extend({}, editedData, this.cellDetails.rowData);\n    var value = getObject(column.field, cloneEditedData);\n\n    if (!isNullOrUndefined(column.field) && !isUndefined(value)) {\n      setValue(column.field, value, editedData);\n    }\n\n    var args = {\n      columnName: column.field,\n      value: getObject(column.field, editedData),\n      rowData: this.cellDetails.rowData,\n      column: column,\n      previousValue: this.cellDetails.value,\n      isForeignKey: this.cellDetails.isForeignKey,\n      cancel: false\n    };\n    args.cell = this.form.parentElement;\n    args.columnObject = column;\n    return args;\n  };\n\n  BatchEdit.prototype.saveCell = function (isForceSave) {\n    if (this.preventSaveCell || !this.form) {\n      return;\n    }\n\n    var gObj = this.parent;\n\n    if (!isForceSave && (!gObj.isEdit || this.validateFormObj())) {\n      return;\n    }\n\n    this.preventSaveCell = true;\n    var args = this.generateCellArgs();\n    var tr = args.cell.parentElement;\n    var col = args.column;\n\n    if (!isForceSave) {\n      gObj.trigger(cellSave, args, this.successCallBack(args, tr, col));\n      gObj.notify(batchForm, {\n        formObj: this.form\n      });\n    } else {\n      this.successCallBack(args, tr, col)(args);\n    }\n  };\n\n  BatchEdit.prototype.successCallBack = function (cellSaveArgs, tr, column, isEscapeCellEdit) {\n    var _this = this;\n\n    return function (cellSaveArgs) {\n      var gObj = _this.parent;\n      cellSaveArgs.cell = cellSaveArgs.cell ? cellSaveArgs.cell : _this.form.parentElement;\n      cellSaveArgs.columnObject = cellSaveArgs.columnObject ? cellSaveArgs.columnObject : column;\n      cellSaveArgs.columnObject.index = isNullOrUndefined(cellSaveArgs.columnObject.index) ? 0 : cellSaveArgs.columnObject.index;\n\n      if (cellSaveArgs.cancel) {\n        _this.preventSaveCell = false;\n\n        if (_this.editNext) {\n          _this.editNext = false;\n\n          if (_this.cellDetails.rowIndex === _this.index && _this.cellDetails.column.field === _this.field) {\n            return;\n          }\n\n          _this.editCellExtend(_this.index, _this.field, _this.isAdd);\n        }\n\n        return;\n      }\n\n      gObj.editModule.destroyWidgets([column]);\n      gObj.isEdit = false;\n      gObj.editModule.destroyForm();\n\n      _this.parent.notify(tooltipDestroy, {});\n\n      var rowObj = parentsUntil(cellSaveArgs.cell, movableContent) || parentsUntil(cellSaveArgs.cell, movableHeader) ? gObj.getRowObjectFromUID(tr.getAttribute('data-uid'), true) : gObj.getRowObjectFromUID(tr.getAttribute('data-uid'));\n\n      if (gObj.getFrozenMode() === leftRight && (parentsUntil(cellSaveArgs.cell, 'e-frozen-right-header') || parentsUntil(cellSaveArgs.cell, 'e-frozen-right-content'))) {\n        rowObj = gObj.getRowObjectFromUID(tr.getAttribute('data-uid'), false, true);\n      }\n\n      _this.refreshTD(cellSaveArgs.cell, column, rowObj, cellSaveArgs.value);\n\n      if (_this.parent.isReact) {\n        cellSaveArgs.cell = _this.newReactTd;\n      }\n\n      removeClass([tr], [editedRow, 'e-batchrow']);\n      removeClass([cellSaveArgs.cell], ['e-editedbatchcell', 'e-boolcell']);\n\n      if (!isNullOrUndefined(cellSaveArgs.value) && cellSaveArgs.value.toString() === (!isNullOrUndefined(_this.cellDetails.value) ? _this.cellDetails.value : '').toString() && !_this.isColored || isNullOrUndefined(cellSaveArgs.value) && isNullOrUndefined(rowObj.data[column.field]) && isNullOrUndefined(_this.cellDetails.value) && !cellSaveArgs.cell.parentElement.classList.contains('e-insertedrow')) {\n        cellSaveArgs.cell.classList.remove('e-updatedtd');\n      }\n\n      if (isNullOrUndefined(isEscapeCellEdit)) {\n        gObj.trigger(cellSaved, cellSaveArgs);\n      }\n\n      gObj.notify(toolbarRefresh, {});\n      _this.isColored = false;\n\n      if (_this.parent.aggregates.length > 0) {\n        _this.parent.notify(refreshFooterRenderer, {});\n\n        if (_this.parent.groupSettings.columns.length > 0 && !_this.isAddRow(_this.cellDetails.rowIndex)) {\n          _this.parent.notify(groupAggregates, {});\n        }\n      }\n\n      _this.preventSaveCell = false;\n\n      if (_this.editNext) {\n        _this.editNext = false;\n\n        if (_this.cellDetails.rowIndex === _this.index && _this.cellDetails.column.field === _this.field) {\n          return;\n        }\n\n        var col = gObj.getColumnByField(_this.field);\n\n        if (col && col.allowEditing) {\n          _this.editCellExtend(_this.index, _this.field, _this.isAdd);\n        }\n      }\n\n      if (isEscapeCellEdit) {\n        gObj.notify(restoreFocus, {});\n      }\n    };\n  };\n\n  BatchEdit.prototype.getDataByIndex = function (index) {\n    var row$$1 = this.parent.getRowObjectFromUID(this.parent.getDataRows()[index].getAttribute('data-uid'));\n    return row$$1.changes ? row$$1.changes : row$$1.data;\n  };\n\n  BatchEdit.prototype.keyDownHandler = function (e) {\n    if ((e.action === 'tab' || e.action === 'shiftTab') && this.parent.isEdit) {\n      var gObj = this.parent;\n      var btmIdx = this.getBottomIndex();\n      var rowcell = parentsUntil(e.target, rowCell);\n\n      if (rowcell) {\n        var cell = rowcell.querySelector('.e-field');\n\n        if (cell) {\n          var visibleColumns = this.parent.getVisibleColumns();\n          var columnIndex = e.action === 'tab' ? visibleColumns.length - 1 : 0;\n\n          if (visibleColumns[columnIndex].field === cell.getAttribute('id').slice(this.parent.element.id.length)) {\n            if (this.cellDetails.rowIndex === btmIdx && e.action === 'tab') {\n              if (gObj.editSettings.newRowPosition === 'Top') {\n                gObj.editSettings.newRowPosition = 'Bottom';\n                this.addRecord();\n                gObj.editSettings.newRowPosition = 'Top';\n              } else {\n                this.addRecord();\n              }\n            } else {\n              this.saveCell();\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  BatchEdit.prototype.addCancelWhilePaging = function () {\n    if (this.validateFormObj()) {\n      this.parent.notify(destroyForm, {});\n      this.parent.isEdit = false;\n      this.isColored = false;\n    }\n  };\n\n  BatchEdit.prototype.getBottomIndex = function () {\n    var changes = this.getBatchChanges();\n    return this.parent.getCurrentViewRecords().length + changes[addedRecords].length - changes[deletedRecords].length - 1;\n  };\n\n  return BatchEdit;\n}();\n\nvar __extends$29 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `DialogEdit` module is used to handle dialog editing actions.\n *\n * @hidden\n */\n\n\nvar DialogEdit =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$29(DialogEdit, _super);\n\n  function DialogEdit(parent, serviceLocator, renderer) {\n    var _this = //constructor\n    _super.call(this, parent, serviceLocator) || this;\n\n    _this.parent = parent;\n    _this.serviceLocator = serviceLocator;\n    _this.renderer = renderer;\n    return _this;\n  }\n\n  DialogEdit.prototype.closeEdit = function () {\n    //closeEdit\n    _super.prototype.closeEdit.call(this);\n  };\n\n  DialogEdit.prototype.addRecord = function (data, index) {\n    //addRecord\n    _super.prototype.addRecord.call(this, data, index);\n  };\n\n  DialogEdit.prototype.endEdit = function () {\n    //endEdit\n    _super.prototype.endEdit.call(this);\n  };\n\n  DialogEdit.prototype.updateRow = function (index, data) {\n    _super.prototype.updateRow.call(this, index, data);\n  };\n\n  DialogEdit.prototype.deleteRecord = function (fieldname, data) {\n    //deleteRecord\n    _super.prototype.deleteRecord.call(this, fieldname, data);\n  };\n\n  DialogEdit.prototype.startEdit = function (tr) {\n    _super.prototype.startEdit.call(this, tr);\n  };\n\n  return DialogEdit;\n}(NormalEdit);\n\nvar __extends$30 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `DatePickerEditCell` is used to handle datepicker cell type editing.\n *\n * @hidden\n */\n\n\nvar DatePickerEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$30(DatePickerEditCell, _super);\n\n  function DatePickerEditCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DatePickerEditCell.prototype.write = function (args) {\n    this.edit = this.parent.editModule;\n\n    if (args.column.editType === 'datepickeredit') {\n      this.obj = new DatePicker(extend(dateanddatetimerender(args, this.parent.editSettings.mode, this.parent.enableRtl, this.parent.cssClass, this), args.column.edit.params));\n    } else if (args.column.editType === 'datetimepickeredit') {\n      this.obj = new DateTimePicker(extend(dateanddatetimerender(args, this.parent.editSettings.mode, this.parent.enableRtl, this.parent.cssClass, this), args.column.edit.params));\n    }\n\n    this.obj.appendTo(args.element);\n  };\n\n  return DatePickerEditCell;\n}(EditCellBase); // eslint-disable-next-line\n\n\nfunction dateanddatetimerender(args, mode, rtl, css, datePickerEditCell) {\n  var isInline = mode !== 'Dialog';\n  var format = getCustomDateFormat(args.column.format, args.column.type);\n  var value = getObject(args.column.field, args.rowData);\n  value = value ? new Date(value) : null;\n  return {\n    floatLabelType: isInline ? 'Never' : 'Always',\n    value: value,\n    format: format,\n    placeholder: isInline ? '' : args.column.headerText,\n    enableRtl: rtl,\n    enabled: isEditable(args.column, args.requestType, args.element),\n    cssClass: css ? css : null,\n    close: datePickerClose.bind(datePickerEditCell)\n  };\n} // eslint-disable-next-line\n\n\nfunction datePickerClose(args) {\n  if (args.event && args.event.action === 'escape') {\n    this.edit.editCellDialogClose = true;\n  }\n}\n/**\n * `TemplateEditCell` is used to handle template cell.\n *\n * @hidden\n */\n\n\nvar TemplateEditCell =\n/** @__PURE__ @class */\nfunction () {\n  function TemplateEditCell(parent) {\n    this.parent = parent;\n  }\n\n  TemplateEditCell.prototype.read = function (element, value) {\n    return value;\n  };\n\n  TemplateEditCell.prototype.write = function () {//\n  };\n\n  TemplateEditCell.prototype.destroy = function () {//\n  };\n\n  return TemplateEditCell;\n}();\n/**\n * The `Edit` module is used to handle editing actions.\n */\n\n\nvar Edit =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid editing module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the servicelocator\n   * @hidden\n   */\n  function Edit(parent, serviceLocator) {\n    this.editType = {\n      'Inline': InlineEdit,\n      'Normal': InlineEdit,\n      'Batch': BatchEdit,\n      'Dialog': DialogEdit\n    };\n    /* @hidden */\n\n    this.editCellDialogClose = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.l10n = this.serviceLocator.getService('localization');\n    this.addEventListener();\n    this.updateEditObj();\n    this.createAlertDlg();\n    this.createConfirmDlg();\n  }\n\n  Edit.prototype.updateColTypeObj = function () {\n    var cols = this.parent.columnModel;\n\n    for (var i = 0; i < cols.length; i++) {\n      if (this.parent.editSettings.template || cols[i].editTemplate) {\n        var templteCell = 'templateedit';\n        cols[i].edit = extend(new Edit.editCellType[templteCell](this.parent), cols[i].edit || {});\n      } else {\n        cols[i].edit = extend(new Edit.editCellType[cols[i].editType && Edit.editCellType[cols[i].editType] ? cols[i].editType : 'defaultedit'](this.parent, this.serviceLocator), cols[i].edit || {});\n      }\n    }\n\n    this.parent.log('primary_column_missing');\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  Edit.prototype.getModuleName = function () {\n    return 'edit';\n  };\n  /**\n   * @param {NotifyArgs} e - specifies the notifyargs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    var gObj = this.parent;\n\n    for (var _i = 0, _a = Object.keys(e.properties); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'allowAdding':\n        case 'allowDeleting':\n        case 'allowEditing':\n          if (gObj.editSettings.allowAdding || gObj.editSettings.allowEditing || gObj.editSettings.allowDeleting) {\n            this.initialEnd();\n          }\n\n          break;\n\n        case 'mode':\n          this.updateEditObj();\n          gObj.isEdit = false;\n          gObj.refresh();\n          break;\n      }\n    }\n  };\n\n  Edit.prototype.updateEditObj = function () {\n    if (this.editModule) {\n      this.editModule.destroy();\n    }\n\n    this.renderer = new EditRender(this.parent, this.serviceLocator);\n    this.editModule = new this.editType[this.parent.editSettings.mode](this.parent, this.serviceLocator, this.renderer);\n  };\n\n  Edit.prototype.initialEnd = function () {\n    this.updateColTypeObj();\n  };\n  /**\n   * Edits any bound record in the Grid by TR element.\n   *\n   * @param {HTMLTableRowElement} tr - Defines the table row to be edited.\n   * @returns {void}\n   */\n\n\n  Edit.prototype.startEdit = function (tr) {\n    var gObj = this.parent;\n\n    if (!gObj.editSettings.allowEditing || gObj.isEdit || gObj.editSettings.mode === 'Batch') {\n      return;\n    }\n\n    this.parent.element.classList.add('e-editing');\n\n    if (!gObj.getSelectedRows().length) {\n      if (!tr) {\n        this.showDialog('EditOperationAlert', this.alertDObj);\n        return;\n      }\n    } else if (!tr) {\n      tr = gObj.getSelectedRows()[0];\n    }\n\n    this.isLastRow = tr.rowIndex === this.parent.getContent().querySelector('tr:last-child').rowIndex;\n\n    if (tr.style.display === 'none') {\n      return;\n    }\n\n    this.editModule.startEdit(tr);\n    this.refreshToolbar();\n    gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n    this.parent.notify('start-edit', {});\n  };\n  /**\n   * @param {Element} tr - specifies the tr element\n   * @param {object} args - specifies the object\n   * @param {Element} args.row -specfifes the row\n   * @param {string} args.requestType - specifies the request type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.checkLastRow = function (tr, args) {\n    var checkLastRow = this.isLastRow;\n\n    if (this.parent.height !== 'auto' && this.parent.editSettings.newRowPosition === 'Bottom' && args && args.requestType === 'add' && this.parent.getContent().firstElementChild.offsetHeight > this.parent.getContentTable().scrollHeight) {\n      addClass([].slice.call(tr.getElementsByClassName(rowCell)), 'e-lastrowadded');\n    } else if (checkLastRow && tr && tr.classList) {\n      addClass([].slice.call(tr.getElementsByClassName(rowCell)), 'e-lastrowcell');\n    }\n  };\n  /**\n   * Cancels edited state.\n   *\n   * @returns {void}\n   */\n\n\n  Edit.prototype.closeEdit = function () {\n    if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.showConfirmDialog && this.parent.element.getElementsByClassName('e-updatedtd').length) {\n      this.showDialog('CancelEdit', this.dialogObj);\n      return;\n    }\n\n    this.parent.element.classList.remove('e-editing');\n    this.editModule.closeEdit();\n    this.refreshToolbar();\n    this.parent.notify(closeEdit, {});\n  };\n\n  Edit.prototype.refreshToolbar = function () {\n    this.parent.notify(toolbarRefresh, {});\n  };\n  /**\n   * To adds a new row at the top with the given data. When data is not passed, it will add empty rows.\n   * > `editSettings.allowEditing` should be true.\n   *\n   * @param {Object} data - Defines the new add record data.\n   * @param {number} index - Defines the row index to be added\n   * @returns {void}\n   */\n\n\n  Edit.prototype.addRecord = function (data, index) {\n    if (!this.parent.editSettings.allowAdding) {\n      return;\n    }\n\n    var args = {\n      startEdit: true\n    };\n\n    if (!data) {\n      this.parent.notify(virtualScrollAddActionBegin, args);\n    }\n\n    if (args.startEdit) {\n      this.parent.element.classList.add('e-editing');\n      this.editModule.addRecord(data, index);\n      this.refreshToolbar();\n      this.parent.notify('start-add', {});\n    }\n  };\n  /**\n   * Deletes a record with the given options. If fieldname and data are not given, the Grid will delete the selected record.\n   * > `editSettings.allowDeleting` should be true.\n   *\n   * @param {string} fieldname - Defines the primary key field name of the column.\n   * @param {Object} data - Defines the JSON data record to be deleted.\n   * @returns {void}\n   */\n\n\n  Edit.prototype.deleteRecord = function (fieldname, data) {\n    var gObj = this.parent;\n\n    if (!gObj.editSettings.allowDeleting) {\n      return;\n    }\n\n    if (!data) {\n      if (!gObj.getSelectedRecords().length && isNullOrUndefined(gObj.commandDelIndex)) {\n        this.showDialog('DeleteOperationAlert', this.alertDObj);\n        return;\n      }\n    }\n\n    if (gObj.editSettings.showDeleteConfirmDialog) {\n      this.showDialog('ConfirmDelete', this.dialogObj);\n      return;\n    }\n\n    this.editModule.deleteRecord(fieldname, data);\n  };\n  /**\n   * Deletes a visible row by TR element.\n   *\n   * @param {HTMLTableRowElement} tr - Defines the table row element.\n   * @returns {void}\n   */\n\n\n  Edit.prototype.deleteRow = function (tr) {\n    this.deleteRowUid = tr.getAttribute('data-uid');\n    var rowObj = this.parent.getRowObjectFromUID(this.deleteRowUid);\n\n    if (!isNullOrUndefined(rowObj)) {\n      this.deleteRecord(null, rowObj.data);\n    }\n  };\n  /**\n   * If Grid is in editable state, you can save a record by invoking endEdit.\n   *\n   * @returns {void}\n   */\n\n\n  Edit.prototype.endEdit = function () {\n    if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.showConfirmDialog && (isNullOrUndefined(this.formObj) || this.formObj.validate())) {\n      this.parent.editModule.saveCell();\n      this.parent.notify(editNextValCell, {});\n\n      if (isNullOrUndefined(this.formObj) || this.formObj.validate()) {\n        this.showDialog('BatchSaveConfirm', this.dialogObj);\n        return;\n      }\n    }\n\n    this.endEditing();\n  };\n  /**\n   * To update the specified cell by given value without changing into edited state.\n   *\n   * @param {number} rowIndex Defines the row index.\n   * @param {string} field Defines the column field.\n   * @param {string | number | boolean | Date} value - Defines the value to be changed.\n   * @returns {void}\n   */\n\n\n  Edit.prototype.updateCell = function (rowIndex, field, value) {\n    this.editModule.updateCell(rowIndex, field, value);\n  };\n  /**\n   * To update the specified row by given values without changing into edited state.\n   *\n   * @param {number} index Defines the row index.\n   * @param {Object} data Defines the data object to be updated.\n   * @returns {void}\n   */\n\n\n  Edit.prototype.updateRow = function (index, data) {\n    this.editModule.updateRow(index, data);\n  };\n  /**\n   * Resets added, edited, and deleted records in the batch mode.\n   *\n   * @returns {void}\n   */\n\n\n  Edit.prototype.batchCancel = function () {\n    this.closeEdit();\n  };\n  /**\n   * Bulk saves added, edited, and deleted records in the batch mode.\n   *\n   * @returns {void}\n   */\n\n\n  Edit.prototype.batchSave = function () {\n    this.endEdit();\n  };\n  /**\n   * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.\n   *\n   * @param {number} index - Defines row index to edit a particular cell.\n   * @param {string} field - Defines the field name of the column to perform batch edit.\n   * @returns {void}\n   */\n\n\n  Edit.prototype.editCell = function (index, field) {\n    this.editModule.editCell(index, field);\n  };\n  /**\n   * Checks the status of validation at the time of editing. If validation is passed, it returns true.\n   *\n   * @returns {boolean} returns whether the form is validated\n   */\n\n\n  Edit.prototype.editFormValidate = function () {\n    var form1 = this.formObj ? this.formObj.validate() : true;\n    var form2 = this.mFormObj ? this.mFormObj.validate() : true;\n    var form3 = this.frFormObj ? this.frFormObj.validate() : true;\n    return form1 && form2 && form3;\n  };\n  /**\n   * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.\n   *\n   * @returns {Object} returns the Object\n   */\n\n\n  Edit.prototype.getBatchChanges = function () {\n    return this.editModule.getBatchChanges ? this.editModule.getBatchChanges() : {};\n  };\n  /**\n   * Gets the current value of the edited component.\n   *\n   * @returns {Object} returns the Object\n   */\n\n\n  Edit.prototype.getCurrentEditCellData = function () {\n    var obj = this.getCurrentEditedData(this.formObj.element, {});\n    return obj[Object.keys(obj)[0]];\n  };\n  /**\n   * Saves the cell that is currently edited. It does not save the value to the DataSource.\n   *\n   * @returns {void}\n   */\n\n\n  Edit.prototype.saveCell = function () {\n    this.editModule.saveCell();\n  };\n\n  Edit.prototype.endEditing = function () {\n    this.parent.element.classList.remove('e-editing');\n    this.editModule.endEdit();\n    this.refreshToolbar();\n  };\n\n  Edit.prototype.showDialog = function (content$$1, obj) {\n    obj.content = '<div>' + this.l10n.getConstant(content$$1) + '</div>';\n    obj.dataBind();\n    obj.show();\n  };\n\n  Edit.prototype.getValueFromType = function (col, value) {\n    var val = value;\n\n    switch (col.type) {\n      case 'number':\n        val = !isNaN(parseFloat(value)) ? parseFloat(value) : null;\n        break;\n\n      case 'boolean':\n        if (col.editType !== 'booleanedit') {\n          val = value === this.l10n.getConstant('True') || value === true ? true : false;\n        }\n\n        break;\n\n      case 'date':\n      case 'datetime':\n        if (col.editType !== 'datepickeredit' && col.editType !== 'datetimepickeredit' && value && value.length) {\n          val = new Date(value);\n        } else if (value === '') {\n          val = null;\n        }\n\n        break;\n    }\n\n    return val;\n  };\n\n  Edit.prototype.destroyToolTip = function () {\n    var elements = [].slice.call(this.parent.element.getElementsByClassName('e-griderror'));\n\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var elem = elements_1[_i];\n      remove(elem);\n    }\n\n    this.parent.getContent().firstElementChild.style.position = 'relative';\n  };\n\n  Edit.prototype.createConfirmDlg = function () {\n    this.dialogObj = this.dlgWidget([{\n      click: this.dlgOk.bind(this),\n      buttonModel: {\n        content: this.l10n.getConstant('OKButton'),\n        cssClass: this.parent.cssClass ? 'e-primary' + ' ' + this.parent.cssClass : 'e-primary',\n        isPrimary: true\n      }\n    }, {\n      click: this.dlgCancel.bind(this),\n      buttonModel: {\n        cssClass: this.parent.cssClass ? 'e-flat' + ' ' + this.parent.cssClass : 'e-flat',\n        content: this.l10n.getConstant('CancelButton')\n      }\n    }], 'EditConfirm');\n  };\n\n  Edit.prototype.createAlertDlg = function () {\n    this.alertDObj = this.dlgWidget([{\n      click: this.alertClick.bind(this),\n      buttonModel: {\n        content: this.l10n.getConstant('OKButton'),\n        cssClass: this.parent.cssClass ? 'e-flat' + ' ' + this.parent.cssClass : 'e-flat',\n        isPrimary: true\n      }\n    }], 'EditAlert');\n  };\n\n  Edit.prototype.alertClick = function () {\n    this.alertDObj.hide();\n  };\n\n  Edit.prototype.dlgWidget = function (btnOptions, name) {\n    var div = this.parent.createElement('div', {\n      id: this.parent.element.id + name\n    });\n    this.parent.element.appendChild(div);\n    var options = {\n      showCloseIcon: false,\n      isModal: true,\n      visible: false,\n      closeOnEscape: true,\n      target: this.parent.element,\n      width: '320px',\n      animationSettings: {\n        effect: 'None'\n      },\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    };\n    options.buttons = btnOptions;\n    var obj = new Dialog(options);\n    var isStringTemplate = 'isStringTemplate';\n    obj[isStringTemplate] = true;\n    obj.appendTo(div);\n    return obj;\n  };\n\n  Edit.prototype.dlgCancel = function () {\n    this.parent.focusModule.clearIndicator();\n    this.parent.focusModule.restoreFocus();\n    this.dialogObj.hide();\n  };\n\n  Edit.prototype.dlgOk = function () {\n    switch (this.dialogObj.element.querySelector('.e-dlg-content').firstElementChild.innerText) {\n      case this.l10n.getConstant('ConfirmDelete'):\n        this.editModule.deleteRecord();\n        break;\n\n      case this.l10n.getConstant('CancelEdit'):\n        this.editModule.closeEdit();\n        break;\n\n      case this.l10n.getConstant('BatchSaveConfirm'):\n        this.endEditing();\n        break;\n\n      case this.l10n.getConstant('BatchSaveLostChanges'):\n        if (this.parent.editSettings.mode === 'Batch') {\n          this.editModule.addCancelWhilePaging();\n        }\n\n        this.executeAction();\n        break;\n    }\n\n    this.dlgCancel();\n  };\n\n  Edit.prototype.destroyEditComponents = function () {\n    if (this.parent.isEdit) {\n      this.destroyWidgets();\n      this.destroyForm();\n    }\n\n    this.destroy();\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.eventDetails = [{\n      event: inBoundModelChanged,\n      handler: this.onPropertyChanged\n    }, {\n      event: initialEnd,\n      handler: this.initialEnd\n    }, {\n      event: keyPressed,\n      handler: this.keyPressHandler\n    }, {\n      event: autoCol,\n      handler: this.updateColTypeObj\n    }, {\n      event: tooltipDestroy,\n      handler: this.destroyToolTip\n    }, {\n      event: preventBatch,\n      handler: this.preventBatch\n    }, {\n      event: destroyForm,\n      handler: this.destroyForm\n    }, {\n      event: destroy,\n      handler: this.destroyEditComponents\n    }];\n    addRemoveEventListener(this.parent, this.eventDetails, true, this);\n    this.actionBeginFunction = this.onActionBegin.bind(this);\n    this.actionCompleteFunction = this.actionComplete.bind(this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunction);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.eventDetails, false);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunction);\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n  };\n\n  Edit.prototype.actionComplete = function (e) {\n    var actions = ['add', 'beginEdit', 'save', 'delete', 'cancel'];\n\n    if (actions.indexOf(e.requestType) < 0) {\n      this.parent.isEdit = false;\n    }\n\n    if (e.requestType === 'batchsave') {\n      this.parent.focusModule.restoreFocus();\n    }\n\n    this.refreshToolbar();\n  };\n  /**\n   * @param {Element} form - specifies the element\n   * @param {Object} editedData - specifies the edited data\n   * @returns {Object} returns the object\n   * @hidden\n   */\n\n\n  Edit.prototype.getCurrentEditedData = function (form, editedData) {\n    var gObj = this.parent;\n\n    if (gObj.editSettings.template) {\n      var elements = [].slice.call(form.elements);\n\n      for (var k = 0; k < elements.length; k++) {\n        if ((elements[k].hasAttribute('name') && elements[k].className !== 'e-multi-hidden' || elements[k].classList.contains('e-multiselect')) && !(elements[k].type === 'hidden' && (parentsUntil(elements[k], 'e-switch-wrapper') || parentsUntil(elements[k], 'e-checkbox-wrapper')))) {\n          var field = elements[k].hasAttribute('name') ? setComplexFieldID(elements[k].getAttribute('name')) : setComplexFieldID(elements[k].getAttribute('id'));\n          var column = gObj.getColumnByField(field) || {\n            field: field,\n            type: elements[k].getAttribute('type')\n          };\n          var value = void 0;\n\n          if (column.type === 'checkbox' || column.type === 'boolean') {\n            value = elements[k].checked;\n          } else if (elements[k].value) {\n            value = elements[k].value;\n\n            if (elements[k].ej2_instances && elements[k].ej2_instances.length && !isNullOrUndefined(elements[k].ej2_instances[0].value)) {\n              elements[k].blur();\n              value = elements[k].ej2_instances[0].value;\n            }\n          } else if (elements[k].ej2_instances) {\n            value = elements[k].ej2_instances[0].value;\n          }\n\n          if (column.edit && typeof column.edit.read === 'string') {\n            value = getValue(column.edit.read, window)(elements[k], value);\n          } else if (column.edit && column.edit.read) {\n            value = column.edit.read(elements[k], value);\n          }\n\n          value = gObj.editModule.getValueFromType(column, value);\n\n          if (elements[k].type === 'radio') {\n            if (elements[k].checked) {\n              DataUtil.setValue(column.field, value, editedData);\n            }\n          } else {\n            DataUtil.setValue(column.field, value, editedData);\n          }\n        }\n      }\n\n      return editedData;\n    }\n\n    var col = gObj.columnModel.filter(function (col) {\n      return col.editTemplate;\n    });\n\n    for (var j = 0; j < col.length; j++) {\n      if (form[getComplexFieldID(col[j].field)]) {\n        var inputElements = [].slice.call(form[getComplexFieldID(col[j].field)]);\n        inputElements = inputElements.length ? inputElements : [form[getComplexFieldID(col[j].field)]];\n        var temp = inputElements.filter(function (e) {\n          return !isNullOrUndefined(e.ej2_instances);\n        });\n\n        if (temp.length === 0) {\n          temp = inputElements.filter(function (e) {\n            return e.hasAttribute('name');\n          });\n        }\n\n        for (var k = 0; k < temp.length; k++) {\n          var value = this.getValue(col[j], temp[k], editedData);\n          DataUtil.setValue(col[j].field, value, editedData);\n        }\n      }\n    }\n\n    var inputs = [].slice.call(form.getElementsByClassName('e-field'));\n\n    for (var i = 0, len = inputs.length; i < len; i++) {\n      var col_1 = gObj.getColumnByUid(inputs[i].getAttribute('e-mappinguid'));\n\n      if (col_1 && col_1.field) {\n        var value = this.getValue(col_1, inputs[i], editedData);\n        DataUtil.setValue(col_1.field, value, editedData);\n      }\n    }\n\n    return editedData;\n  };\n\n  Edit.prototype.getValue = function (col, input, editedData) {\n    var value = input.ej2_instances ? input.ej2_instances[0].value : input.value;\n    var gObj = this.parent;\n    var temp = col.edit.read;\n\n    if (col.type === 'checkbox' || col.type === 'boolean') {\n      value = input.checked;\n    }\n\n    if (typeof temp === 'string') {\n      temp = getValue(temp, window);\n      value = gObj.editModule.getValueFromType(col, temp(input, value));\n    } else {\n      value = gObj.editModule.getValueFromType(col, col.edit.read(input, value));\n    }\n\n    if (isNullOrUndefined(editedData[col.field]) && value === '') {\n      value = editedData[col.field];\n    }\n\n    return value;\n  };\n  /**\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.onActionBegin = function (e) {\n    if (e.requestType === 'columnstate' && this.parent.isEdit && this.parent.editSettings.mode !== 'Batch') {\n      this.closeEdit();\n    } else {\n      var editRow = this.parent.element.querySelector('.' + editedRow);\n      var addRow = this.parent.element.querySelector('.' + addedRow);\n\n      if (editRow && this.parent.frozenRows && e.requestType === 'virtualscroll' && parseInt(parentsUntil(editRow, row).getAttribute(dataRowIndex), 10) < this.parent.frozenRows) {\n        return;\n      }\n\n      var restrictedRequestTypes = ['filterafteropen', 'filterbeforeopen', 'filterchoicerequest', 'save', 'infiniteScroll', 'virtualscroll'];\n      var isRestrict = restrictedRequestTypes.indexOf(e.requestType) === -1;\n      var isDestroyVirtualForm = this.parent.enableVirtualization && this.formObj && !this.formObj.isDestroyed && (editRow || addRow || e.requestType === 'cancel') && isRestrict;\n\n      if (!this.parent.enableVirtualization && this.parent.editSettings.mode !== 'Batch' && this.formObj && !this.formObj.isDestroyed && isRestrict && !e.cancel || isDestroyVirtualForm) {\n        this.destroyWidgets();\n        this.destroyForm();\n      }\n    }\n  };\n  /**\n   * @param {Column[]} cols - specfies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.destroyWidgets = function (cols) {\n    var gObj = this.parent;\n\n    if (gObj.editSettings.template) {\n      this.parent.destroyTemplate(['editSettingsTemplate']);\n\n      if (this.parent.isReact) {\n        this.parent.renderTemplates();\n      }\n    }\n\n    cols = cols ? cols : this.parent.getCurrentVisibleColumns(this.parent.enableColumnVirtualization);\n\n    if (cols.some(function (column) {\n      return !isNullOrUndefined(column.editTemplate);\n    })) {\n      this.parent.destroyTemplate(['editTemplate']);\n\n      if (this.parent.isReact) {\n        this.parent.renderTemplates();\n      }\n    }\n\n    for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n      var col = cols_1[_i];\n      var temp = col.edit.destroy;\n\n      if (col.edit.destroy) {\n        if (typeof temp === 'string') {\n          temp = getValue(temp, window);\n          temp();\n        } else {\n          col.edit.destroy();\n        }\n      }\n    }\n\n    var elements = [].slice.call(this.formObj.element.elements);\n\n    for (var i = 0; i < elements.length; i++) {\n      if (elements[i].hasAttribute('name')) {\n        if (elements[i].ej2_instances && elements[i].ej2_instances.length && !elements[i].ej2_instances[0].isDestroyed) {\n          elements[i].ej2_instances[0].destroy();\n        }\n      }\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.destroyForm = function () {\n    this.destroyToolTip();\n    var formObjects = [this.formObj, this.mFormObj, this.frFormObj, this.virtualFormObj];\n\n    for (var i = 0; i < formObjects.length; i++) {\n      if (formObjects[i] && formObjects[i].element && !formObjects[i].isDestroyed) {\n        formObjects[i].destroy();\n      }\n    }\n\n    this.destroyToolTip();\n  };\n  /**\n   * To destroy the editing.\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement) {\n      return;\n    }\n\n    var hasGridChild = gridElement.querySelector('.' + gridHeader) && gridElement.querySelector('.' + gridContent) ? true : false;\n\n    if (hasGridChild) {\n      this.destroyForm();\n    }\n\n    this.removeEventListener();\n    var elem = this.dialogObj.element;\n\n    if (elem.childElementCount > 0) {\n      this.dialogObj.destroy();\n      remove(elem);\n    }\n\n    elem = this.alertDObj.element;\n\n    if (elem.childElementCount > 0) {\n      this.alertDObj.destroy();\n      remove(elem);\n    }\n\n    if (!hasGridChild) {\n      return;\n    }\n\n    if (this.editModule) {\n      this.editModule.destroy();\n    }\n  };\n\n  Edit.prototype.keyPressHandler = function (e) {\n    switch (e.action) {\n      case 'insert':\n        this.addRecord();\n        break;\n\n      case 'delete':\n        if ((e.target.tagName !== 'INPUT' || e.target.classList.contains('e-checkselect')) && !document.querySelector('.e-popup-open.e-edit-dialog')) {\n          this.deleteRecord();\n        }\n\n        break;\n\n      case 'f2':\n        this.startEdit();\n        break;\n\n      case 'enter':\n        if (!parentsUntil(e.target, 'e-unboundcelldiv') && this.parent.editSettings.mode !== 'Batch' && (parentsUntil(e.target, gridContent) || this.parent.frozenRows && parentsUntil(e.target, headerContent)) && !document.getElementsByClassName('e-popup-open').length) {\n          e.preventDefault();\n          this.endEdit();\n        }\n\n        break;\n\n      case 'escape':\n        if (this.parent.isEdit && !this.editCellDialogClose) {\n          if (this.parent.editSettings.mode === 'Batch') {\n            this.editModule.escapeCellEdit();\n          } else {\n            this.curretRowFocus(e);\n          }\n        }\n\n        if (this.editCellDialogClose) {\n          this.editCellDialogClose = false;\n        }\n\n        break;\n\n      case 'tab':\n      case 'shiftTab':\n        this.curretRowFocus(e);\n        break;\n    }\n  };\n\n  Edit.prototype.curretRowFocus = function (e) {\n    if (this.parent.isEdit && this.parent.editSettings.mode !== 'Batch') {\n      var editedRow$$1 = parentsUntil(e.target, 'e-editedrow') || parentsUntil(e.target, 'e-addedrow');\n\n      if (editedRow$$1) {\n        var selector = editedRow$$1.classList.contains('e-addedrow') ? 'e-addedrow' : 'e-editedrow';\n        var focusableEditCells = [].slice.call(editedRow$$1.querySelectorAll('.e-input:not(.e-disabled)'));\n        var commandColCell = [].slice.call(editedRow$$1.querySelectorAll('.e-unboundcell'));\n\n        if (commandColCell) {\n          for (var i = 0; i < commandColCell.length; i++) {\n            focusableEditCells = focusableEditCells.concat([].slice.call(commandColCell[i].querySelectorAll('.e-btn:not(.e-hide)')));\n          }\n        }\n\n        if (this.parent.isFrozenGrid()) {\n          if (!isNullOrUndefined(this.parent.frozenRows) && (!isNullOrUndefined(parentsUntil(e.target, 'e-frozenheader')) || !isNullOrUndefined(parentsUntil(e.target, 'e-movableheader')))) {\n            var movableHeditedRow = this.parent.getHeaderContent().querySelector('.e-movableheader ' + '.' + selector);\n            focusableEditCells.push.apply(focusableEditCells, [].slice.call(movableHeditedRow.querySelectorAll('.e-input:not(.e-disabled)')));\n\n            if (this.parent.getFrozenMode() === 'Left-Right' || this.parent.getFrozenMode() === 'Right') {\n              var rightHEditRow = this.parent.getHeaderContent().querySelector('.e-frozen-right-header ' + '.' + selector);\n              focusableEditCells.push.apply(focusableEditCells, [].slice.call(rightHEditRow.querySelectorAll('.e-input:not(.e-disabled)')));\n            }\n          } else {\n            var movableEditRow = this.parent.getContent().querySelector('.e-movablecontent ' + '.' + selector);\n            focusableEditCells.push.apply(focusableEditCells, [].slice.call(movableEditRow.querySelectorAll('.e-input:not(.e-disabled)')));\n\n            if (this.parent.getFrozenMode() === 'Left-Right' || this.parent.getFrozenMode() === 'Right') {\n              var rightFrEditRow = this.parent.getContent().querySelector('.e-frozen-right-content ' + '.' + selector);\n              focusableEditCells.push.apply(focusableEditCells, [].slice.call(rightFrEditRow.querySelectorAll('.e-input:not(.e-disabled)')));\n            }\n          }\n        }\n\n        var rowCell$$1 = parentsUntil(e.target, 'e-rowcell');\n\n        if (rowCell$$1 === parentsUntil(focusableEditCells[focusableEditCells.length - 1], 'e-rowcell') && e.action === 'tab' && !rowCell$$1.classList.contains('e-unboundcell') || rowCell$$1 === parentsUntil(focusableEditCells[0], 'e-rowcell') && e.action === 'shiftTab' || e.action === 'escape') {\n          var uid = editedRow$$1.getAttribute('data-uid');\n          var rows = this.parent.getRows();\n\n          if (this.parent.getFrozenMode() === 'Left-Right' || this.parent.getFrozenMode() === 'Right') {\n            rows = this.parent.getFrozenRightRows();\n          }\n\n          if (this.parent.getFrozenColumns() || this.parent.getFrozenMode() === 'Left') {\n            rows = this.parent.getMovableRows();\n          }\n\n          var rowIndex = rows.map(function (m) {\n            return m.getAttribute('data-uid');\n          }).indexOf(uid);\n\n          if (this.parent.frozenRows && parentsUntil(editedRow$$1, 'e-content')) {\n            rowIndex = rowIndex - this.parent.frozenRows;\n          }\n\n          if (editedRow$$1.classList.contains('e-addedrow')) {\n            rowIndex = 0;\n          }\n\n          if (e.action === 'escape') {\n            this.closeEdit();\n          } else {\n            this.endEdit();\n          }\n\n          if (this.parent.focusModule.active) {\n            this.parent.focusModule.active.matrix.current = [rowIndex, 0];\n          }\n        }\n      }\n    }\n  };\n\n  Edit.prototype.preventBatch = function (args) {\n    this.preventObj = args;\n    this.showDialog('BatchSaveLostChanges', this.dialogObj);\n  };\n\n  Edit.prototype.executeAction = function () {\n    this.preventObj.handler.call(this.preventObj.instance, this.preventObj.arg1, this.preventObj.arg2, this.preventObj.arg3, this.preventObj.arg4, this.preventObj.arg5, this.preventObj.arg6, this.preventObj.arg7, this.preventObj.arg8);\n  };\n  /**\n   * @param {Column[]} cols - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.applyFormValidation = function (cols) {\n    var gObj = this.parent;\n    var frzCols = gObj.isFrozenGrid();\n    var isInline = this.parent.editSettings.mode === 'Normal';\n    var idx = this.parent.getFrozenMode() === 'Right' && isInline ? 1 : 0;\n    var form = this.parent.editSettings.mode !== 'Dialog' ? gObj.element.getElementsByClassName('e-gridform')[idx] : select('#' + gObj.element.id + '_dialogEdit_wrapper .e-gridform', document);\n    var index = this.parent.getFrozenMode() === 'Right' && isInline ? 0 : 1;\n    var mForm = gObj.element.getElementsByClassName('e-gridform')[index];\n    var rules = {};\n    var mRules = {};\n    var frRules = {};\n    cols = cols ? cols : gObj.getColumns();\n\n    for (var i = 0; i < cols.length; i++) {\n      if (!cols[i].visible && (gObj.editSettings.mode !== 'Dialog' || gObj.groupSettings.columns.indexOf(cols[i].field) === -1 && gObj.editSettings.mode === 'Dialog')) {\n        continue;\n      }\n\n      if (cols[i].validationRules) {\n        setValidationRuels(cols[i], index, rules, mRules, frRules, cols.length);\n      }\n    }\n\n    if (frzCols && this.parent.editSettings.mode !== 'Dialog') {\n      this.parent.editModule.mFormObj = this.createFormObj(mForm, mRules);\n\n      if (this.parent.getFrozenMode() === leftRight) {\n        var frForm = gObj.element.getElementsByClassName('e-gridform')[2];\n        this.parent.editModule.frFormObj = this.createFormObj(frForm, frRules);\n      }\n    } else {\n      rules = extend(rules, mRules, frRules);\n    }\n\n    this.parent.editModule.formObj = this.createFormObj(form, rules);\n  };\n  /**\n   * @param {HTMLFormElement} form - Defined Form element\n   * @param {Object} rules - Defines form rules\n   * @returns {FormValidator} Returns formvalidator instance\n   * @hidden\n   */\n\n\n  Edit.prototype.createFormObj = function (form, rules) {\n    var _this = this;\n\n    return new FormValidator(form, {\n      rules: rules,\n      locale: this.parent.locale,\n      validationComplete: function (args) {\n        _this.validationComplete(args);\n      },\n      customPlacement: function (inputElement, error) {\n        var uid = inputElement.getAttribute('e-mappinguid');\n        var args = {\n          column: _this.parent.getColumnByUid(uid),\n          error: error,\n          inputElement: inputElement,\n          value: inputElement.value\n        };\n\n        _this.valErrorPlacement(inputElement, error);\n\n        _this.parent.notify(valCustomPlacement, args);\n      }\n    });\n  };\n\n  Edit.prototype.valErrorPlacement = function (inputElement, error) {\n    if (this.parent.isEdit) {\n      var id = error.getAttribute('for');\n      var elem = this.getElemTable(inputElement).querySelector('#' + id + '_Error');\n\n      if (!elem) {\n        this.createTooltip(inputElement, error, id, '');\n      } else {\n        elem.querySelector('.e-tip-content').innerHTML = error.outerHTML;\n      }\n    }\n  };\n\n  Edit.prototype.getElemTable = function (inputElement) {\n    var isFHdr;\n    var gObj = this.parent;\n    var table$$1;\n\n    if (gObj.editSettings.mode !== 'Dialog') {\n      isFHdr = gObj.frozenRows && gObj.frozenRows > (parseInt(closest(inputElement, '.' + row).getAttribute(dataRowIndex), 10) || 0);\n      var field = inputElement.name;\n      var col = void 0;\n\n      if (field) {\n        col = getColumnModelByFieldName(this.parent, setComplexFieldID(field));\n      }\n\n      if (col && gObj.isFrozenGrid()) {\n        if (col.getFreezeTableName() === 'frozen-left') {\n          table$$1 = isFHdr ? gObj.getFrozenVirtualHeader().querySelector('table') : gObj.getFrozenVirtualContent().querySelector('table');\n        } else if (col.getFreezeTableName() === 'frozen-right') {\n          table$$1 = isFHdr ? gObj.getFrozenRightHeader().querySelector('table') : gObj.getFrozenRightContent().querySelector('table');\n        } else if (col.getFreezeTableName() === 'movable') {\n          table$$1 = isFHdr ? gObj.getMovableVirtualHeader().querySelector('table') : gObj.getMovableVirtualContent().querySelector('table');\n        }\n      } else {\n        table$$1 = isFHdr ? gObj.getHeaderTable() : gObj.getContentTable();\n      }\n    } else {\n      table$$1 = select('#' + gObj.element.id + '_dialogEdit_wrapper', document);\n    }\n\n    return table$$1;\n  };\n\n  Edit.prototype.resetElemPosition = function (elem, args) {\n    var td = parentsUntil(args.element, rowCell);\n\n    if (td) {\n      var tdRight = td.getBoundingClientRect().right;\n      var elemRight = elem.getBoundingClientRect().right;\n\n      if (elemRight > tdRight) {\n        var offSet = elemRight - tdRight;\n        elem.style.left = elem.offsetLeft - offSet + 'px';\n      }\n    }\n  };\n\n  Edit.prototype.validationComplete = function (args) {\n    if (this.parent.isEdit) {\n      var elem = this.getElemTable(args.element).querySelector('#' + args.inputName + '_Error');\n\n      if (elem) {\n        if (args.status === 'failure') {\n          elem.style.display = '';\n          this.resetElemPosition(elem, args);\n        } else {\n          elem.style.display = 'none';\n        }\n      }\n    }\n  };\n\n  Edit.prototype.createTooltip = function (element, error, name, display) {\n    var column = this.parent.getColumnByField(name);\n    var formObj = this.parent.getFrozenMode() === leftRight && this.parent.editSettings.mode === 'Normal' && column.getFreezeTableName() === frozenRight ? this.frFormObj.element : this.formObj.element;\n    var customForm = parentsUntil(element, 'e-virtual-validation');\n\n    if (customForm) {\n      formObj = this.virtualFormObj.element;\n    }\n\n    var gcontent = this.parent.getContent().firstElementChild;\n    var frzCols = this.parent.getFrozenColumns() || this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenRightColumnsCount();\n\n    if (frzCols) {\n      gcontent = this.parent.getMovableVirtualContent();\n    }\n\n    var isScroll = gcontent.scrollHeight > gcontent.clientHeight || gcontent.scrollWidth > gcontent.clientWidth;\n    var isInline = this.parent.editSettings.mode !== 'Dialog';\n    var td = closest(element, '.' + rowCell);\n    var row$$1 = closest(element, '.' + row);\n    var fCont = this.parent.getContent().querySelector('.' + frozenContent);\n    var isFHdr;\n    var isFHdrLastRow = false;\n    var validationForBottomRowPos;\n    var isBatchModeLastRow = false;\n    var viewPortRowCount = Math.round(this.parent.getContent().clientHeight / this.parent.getRowHeight()) - 1;\n    var rows = !fCont ? [].slice.call(this.parent.getContent().getElementsByClassName(row)) : [].slice.call(this.parent.getFrozenVirtualContent().getElementsByClassName(row));\n\n    if (this.parent.editSettings.mode === 'Batch') {\n      if (viewPortRowCount > 1 && rows.length >= viewPortRowCount && rows[rows.length - 1].getAttribute(dataRowIndex) === row$$1.getAttribute(dataRowIndex)) {\n        isBatchModeLastRow = true;\n      }\n    }\n\n    if (isInline) {\n      if (this.parent.frozenRows) {\n        var fHeraderRows = frzCols ? this.parent.getFrozenVirtualHeader().querySelector(tbody).children : this.parent.getHeaderTable().querySelector(tbody).children;\n        isFHdr = fHeraderRows.length > (parseInt(row$$1.getAttribute(dataRowIndex), 10) || 0);\n        isFHdrLastRow = isFHdr && parseInt(row$$1.getAttribute(dataRowIndex), 10) === fHeraderRows.length - 1;\n      }\n\n      if (isFHdrLastRow || viewPortRowCount > 1 && rows.length >= viewPortRowCount && (this.parent.editSettings.newRowPosition === 'Bottom' && this.editModule.args && this.editModule.args.requestType === 'add' || td.classList.contains('e-lastrowcell') && !row$$1.classList.contains(addedRow)) || isBatchModeLastRow) {\n        validationForBottomRowPos = true;\n      }\n    }\n\n    var table$$1 = isInline ? isFHdr ? this.parent.getHeaderTable() : this.parent.getContentTable() : select('#' + this.parent.element.id + '_dialogEdit_wrapper .e-dlg-content', document);\n    var client = table$$1.getBoundingClientRect();\n    var left = isInline ? this.parent.element.getBoundingClientRect().left : client.left;\n    var input = closest(element, 'td');\n    var inputClient = input ? input.getBoundingClientRect() : element.parentElement.getBoundingClientRect();\n    var div = this.parent.createElement('div', {\n      className: 'e-tooltip-wrap e-lib e-control e-popup e-griderror',\n      id: name + '_Error',\n      styles: 'display:' + display + ';top:' + ((isFHdr ? inputClient.top + inputClient.height : inputClient.bottom - client.top - (frzCols ? fCont.scrollTop : 0)) + table$$1.scrollTop + 9) + 'px;left:' + (inputClient.left - left + table$$1.scrollLeft + inputClient.width / 2) + 'px;' + 'max-width:' + inputClient.width + 'px;text-align:center;'\n    });\n\n    if (this.parent.cssClass) {\n      div.classList.add(this.parent.cssClass);\n    }\n\n    if (isInline && client.left < left) {\n      div.style.left = parseInt(div.style.left, 10) - client.left + left + 'px';\n    }\n\n    var content$$1 = this.parent.createElement('div', {\n      className: 'e-tip-content'\n    });\n    content$$1.appendChild(error);\n    var arrow;\n\n    if (validationForBottomRowPos) {\n      arrow = this.parent.createElement('div', {\n        className: 'e-arrow-tip e-tip-bottom'\n      });\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-outer e-tip-bottom'\n      }));\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-inner e-tip-bottom'\n      }));\n    } else {\n      arrow = this.parent.createElement('div', {\n        className: 'e-arrow-tip e-tip-top'\n      });\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-outer e-tip-top'\n      }));\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-inner e-tip-top'\n      }));\n    }\n\n    div.appendChild(content$$1);\n    div.appendChild(arrow);\n\n    if (!customForm && (frzCols || this.parent.frozenRows) && this.parent.editSettings.mode !== 'Dialog') {\n      var getEditCell = this.parent.editSettings.mode === 'Normal' ? closest(element, '.e-editcell') : closest(element, '.' + table);\n      getEditCell.style.position = 'relative';\n      div.style.position = 'absolute';\n\n      if (this.parent.editSettings.mode === 'Batch' || closest(element, '.' + frozenContent) || closest(element, '.' + frozenHeader) || this.parent.frozenRows && !frzCols) {\n        formObj.appendChild(div);\n      } else {\n        this.mFormObj.element.appendChild(div);\n      }\n    } else {\n      if (customForm) {\n        this.virtualFormObj.element.appendChild(div);\n      } else {\n        this.formObj.element.appendChild(div);\n      }\n    }\n\n    if (!validationForBottomRowPos && isInline && gcontent.getBoundingClientRect().bottom < inputClient.bottom + inputClient.height) {\n      gcontent.scrollTop = gcontent.scrollTop + div.offsetHeight + arrow.scrollHeight;\n    }\n\n    var lineHeight = parseInt(document.defaultView.getComputedStyle(div, null).getPropertyValue('font-size'), 10);\n\n    if (div.getBoundingClientRect().width < inputClient.width && div.querySelector('label').getBoundingClientRect().height / (lineHeight * 1.2) >= 2) {\n      div.style.width = div.style.maxWidth;\n    }\n\n    if ((frzCols || this.parent.frozenRows) && this.parent.editSettings.mode !== 'Dialog') {\n      div.style.left = input.offsetLeft + (input.offsetWidth / 2 - div.offsetWidth / 2) + 'px';\n    } else {\n      div.style.left = parseInt(div.style.left, 10) - div.offsetWidth / 2 + 'px';\n    }\n\n    if (isInline && !isScroll && !this.parent.allowPaging || frzCols || this.parent.frozenRows) {\n      gcontent.style.position = 'static';\n      var pos = calculateRelativeBasedPosition(input, div);\n      div.style.top = pos.top + inputClient.height + 9 + 'px';\n    }\n\n    if (validationForBottomRowPos) {\n      if (isScroll && !frzCols && this.parent.height !== 'auto' && !this.parent.frozenRows && !this.parent.enableVirtualization) {\n        var scrollWidth = gcontent.scrollWidth > gcontent.offsetWidth ? getScrollBarWidth() : 0;\n        div.style.bottom = this.parent.height - gcontent.querySelector('table').offsetHeight - scrollWidth + inputClient.height + 9 + 'px';\n      } else {\n        div.style.bottom = inputClient.height + 9 + 'px';\n      }\n\n      if (rows.length < viewPortRowCount && this.parent.editSettings.newRowPosition === 'Bottom' && this.editModule.args && this.editModule.args.requestType === 'add') {\n        var rowsCount = this.parent.frozenRows ? this.parent.frozenRows + (rows.length - 1) : rows.length - 1;\n        var rowsHeight = rowsCount * this.parent.getRowHeight();\n        var position = this.parent.getContent().clientHeight - rowsHeight;\n        div.style.bottom = position + 9 + 'px';\n      }\n\n      div.style.top = null;\n    }\n  };\n  /**\n   * @param {Column} col - specfies the column\n   * @returns {boolean} returns the whether column is grouped\n   * @hidden\n   */\n\n\n  Edit.prototype.checkColumnIsGrouped = function (col) {\n    return !col.visible && !(this.parent.groupSettings.columns.indexOf(col.field) > -1);\n  };\n  /**\n   * @param {object} editors -specfies the editors\n   * @returns {void}\n   * @hidden\n   */\n\n\n  Edit.AddEditors = function (editors) {\n    Edit.editCellType = extend(Edit.editCellType, editors);\n  };\n\n  Edit.editCellType = {\n    'dropdownedit': DropDownEditCell,\n    'numericedit': NumericEditCell,\n    'datepickeredit': DatePickerEditCell,\n    'datetimepickeredit': DatePickerEditCell,\n    'booleanedit': BooleanEditCell,\n    'defaultedit': DefaultEditCell,\n    'templateedit': TemplateEditCell\n  };\n  return Edit;\n}();\n/**\n * The `ColumnChooser` module is used to show or hide columns dynamically.\n */\n\n\nvar ColumnChooser =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid ColumnChooser module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the serviceLocator\n   * @hidden\n   */\n  function ColumnChooser(parent, serviceLocator) {\n    this.showColumn = [];\n    this.hideColumn = [];\n    this.changedColumns = [];\n    this.unchangedColumns = [];\n    this.isDlgOpen = false;\n    this.initialOpenDlg = true;\n    this.stateChangeColumns = [];\n    this.changedStateColumns = [];\n    this.isInitialOpen = false;\n    this.isCustomizeOpenCC = false;\n    this.searchOperator = 'startswith';\n    this.prevShowedCols = [];\n    this.hideDialogFunction = this.hideDialog.bind(this);\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n    this.cBoxTrue = createCheckBox(this.parent.createElement, true, {\n      checked: true,\n      label: ' '\n    });\n    this.cBoxFalse = createCheckBox(this.parent.createElement, true, {\n      checked: false,\n      label: ' '\n    });\n    this.cBoxTrue.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden e-cc e-cc-chbox',\n      attrs: {\n        type: 'checkbox'\n      }\n    }), this.cBoxTrue.firstChild);\n    this.cBoxFalse.insertBefore(this.parent.createElement('input', {\n      className: 'e-chk-hidden e-cc e-cc-chbox',\n      attrs: {\n        'type': 'checkbox'\n      }\n    }), this.cBoxFalse.firstChild);\n    this.cBoxFalse.querySelector('.e-frame').classList.add('e-uncheck');\n\n    if (this.parent.enableRtl) {\n      addClass([this.cBoxTrue, this.cBoxFalse], ['e-rtl']);\n    }\n\n    if (this.parent.cssClass) {\n      addClass([this.cBoxTrue, this.cBoxFalse], [this.parent.cssClass]);\n    }\n  }\n\n  ColumnChooser.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.removeEventListener();\n    this.unWireEvents();\n\n    if (!isNullOrUndefined(this.dlgObj) && this.dlgObj.element && !this.dlgObj.isDestroyed) {\n      this.dlgObj.destroy();\n    }\n  };\n\n  ColumnChooser.prototype.rtlUpdate = function () {\n    if (this.parent.enableRtl) {\n      addClass([].slice.call(this.innerDiv.getElementsByClassName('e-checkbox-wrapper')), ['e-rtl']);\n    } else {\n      removeClass([].slice.call(this.innerDiv.getElementsByClassName('e-checkbox-wrapper')), ['e-rtl']);\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnChooser.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.add(document, 'click', this.clickHandler, this);\n    this.parent.on(uiUpdate, this.enableAfterRenderEle, this);\n    this.parent.on(initialEnd, this.render, this);\n    this.parent.addEventListener(dataBound, this.hideDialogFunction);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(rtlUpdated, this.rtlUpdate, this);\n    this.parent.on(keyPressed, this.keyUpHandler, this);\n    this.parent.on(resetColumns, this.onResetColumns, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnChooser.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(document, 'click', this.clickHandler);\n    this.parent.off(initialEnd, this.render);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(uiUpdate, this.enableAfterRenderEle);\n    this.parent.off(rtlUpdated, this.rtlUpdate);\n    this.parent.on(keyPressed, this.keyUpHandler, this);\n    this.parent.off(resetColumns, this.onResetColumns);\n    this.parent.removeEventListener(dataBound, this.hideDialogFunction);\n  };\n\n  ColumnChooser.prototype.render = function () {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.renderDlgContent();\n    this.getShowHideService = this.serviceLocator.getService('showHideService');\n  };\n\n  ColumnChooser.prototype.clickHandler = function (e) {\n    var targetElement = e.target;\n\n    if (!this.isCustomizeOpenCC) {\n      if (!isNullOrUndefined(closest(targetElement, '.e-cc')) || !isNullOrUndefined(closest(targetElement, '.e-cc-toolbar'))) {\n        if (targetElement.classList.contains('e-columnchooser-btn') || targetElement.classList.contains('e-cc-toolbar')) {\n          if (this.initialOpenDlg && this.dlgObj.visible || !this.isDlgOpen) {\n            this.isDlgOpen = true;\n            return;\n          }\n        } else if (targetElement.classList.contains('e-cc-cancel')) {\n          targetElement.parentElement.querySelector('.e-ccsearch').value = '';\n          this.columnChooserSearch('');\n          this.removeCancelIcon();\n          this.refreshCheckboxButton();\n        }\n      } else {\n        if (!isNullOrUndefined(this.dlgObj) && this.dlgObj.visible && !targetElement.classList.contains('e-toolbar-items')) {\n          this.dlgObj.hide();\n          this.clearActions();\n          this.refreshCheckboxState(); // this.unWireEvents();\n\n          this.isDlgOpen = false;\n        }\n      }\n\n      if (this.parent.detailTemplate || this.parent.childGrid) {\n        this.targetdlg = e.target;\n      }\n    }\n\n    if (this.isCustomizeOpenCC && e.target.classList.contains('e-cc-cancel')) {\n      this.refreshCheckboxState();\n    }\n\n    this.rtlUpdate();\n  };\n\n  ColumnChooser.prototype.hideDialog = function () {\n    if (!isNullOrUndefined(this.dlgObj) && this.dlgObj.visible) {\n      this.dlgObj.hide(); // this.unWireEvents();\n\n      this.isDlgOpen = false;\n    }\n  };\n  /**\n   * To render columnChooser when showColumnChooser enabled.\n   *\n   * @param {number} x - specifies the position x\n   * @param {number} y - specifies the position y\n   * @param {Element} target - specifies the target\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnChooser.prototype.renderColumnChooser = function (x, y, target) {\n    if (!this.dlgObj.visible && (this.parent.detailTemplate || this.parent.childGrid)) {\n      this.hideOpenedDialog();\n    }\n\n    if (!this.dlgObj.visible) {\n      var args = this.beforeOpenColumnChooserEvent();\n\n      if (args.cancel) {\n        return;\n      }\n\n      if (target) {\n        this.targetdlg = target;\n      }\n\n      this.refreshCheckboxState();\n      this.dlgObj.dataBind();\n      this.dlgObj.element.style.maxHeight = '430px';\n      var elementVisible = this.dlgObj.element.style.display;\n      this.dlgObj.element.style.display = 'block';\n      var isSticky = this.parent.getHeaderContent().classList.contains('e-sticky');\n      var toolbarItem = closest(target, '.e-toolbar-item');\n      var newpos = void 0;\n\n      if (isSticky) {\n        newpos = toolbarItem.getBoundingClientRect();\n        this.dlgObj.element.classList.add('e-sticky');\n      } else {\n        this.dlgObj.element.classList.remove('e-sticky');\n        newpos = calculateRelativeBasedPosition(toolbarItem, this.dlgObj.element);\n      }\n\n      this.dlgObj.element.style.display = elementVisible;\n      this.dlgObj.element.style.top = newpos.top + closest(target, '.e-cc-toolbar').getBoundingClientRect().height + 'px';\n      var dlgWidth = 250;\n\n      if (!isNullOrUndefined(closest(target, '.e-bigger'))) {\n        this.dlgObj.width = 258;\n      }\n\n      if (Browser.isDevice) {\n        this.dlgObj.target = document.body;\n        this.dlgObj.position = {\n          X: 'center',\n          Y: 'center'\n        };\n        this.dlgObj.refreshPosition();\n        this.dlgObj.open = this.mOpenDlg.bind(this);\n      } else {\n        if (this.parent.enableRtl) {\n          this.dlgObj.element.style.left = target.offsetLeft + 'px';\n        } else {\n          this.dlgObj.element.style.left = newpos.left - dlgWidth + closest(target, '.e-cc-toolbar').clientWidth + 2 + 'px';\n        }\n      }\n\n      this.removeCancelIcon();\n      this.dlgObj.show();\n      this.parent.notify(columnChooserOpened, {\n        dialog: this.dlgObj\n      });\n    } else {\n      // this.unWireEvents();\n      this.hideDialog();\n      this.addcancelIcon();\n      this.clearActions();\n      this.refreshCheckboxState();\n    }\n\n    this.rtlUpdate();\n  };\n  /**\n   * Column chooser can be displayed on screen by given position(X and Y axis).\n   *\n   * @param  {number} X - Defines the X axis.\n   * @param  {number} Y - Defines the Y axis.\n   * @return {void}\n   */\n\n\n  ColumnChooser.prototype.openColumnChooser = function (X, Y) {\n    this.isCustomizeOpenCC = true;\n\n    if (this.dlgObj.visible) {\n      this.hideDialog();\n      return;\n    }\n\n    var args = this.beforeOpenColumnChooserEvent();\n\n    if (args.cancel) {\n      return;\n    }\n\n    if (!this.isInitialOpen) {\n      this.dlgObj.content = this.renderChooserList();\n      this.updateIntermediateBtn();\n    } else {\n      this.refreshCheckboxState();\n    }\n\n    this.dlgObj.dataBind();\n    this.dlgObj.position = {\n      X: 'center',\n      Y: 'center'\n    };\n\n    if (isNullOrUndefined(X)) {\n      this.dlgObj.position = {\n        X: 'center',\n        Y: 'center'\n      };\n      this.dlgObj.refreshPosition();\n    } else {\n      this.dlgObj.element.style.top = '';\n      this.dlgObj.element.style.left = '';\n      this.dlgObj.element.style.top = Y + 'px';\n      this.dlgObj.element.style.left = X + 'px';\n    }\n\n    this.dlgObj.beforeOpen = this.customDialogOpen.bind(this);\n    this.dlgObj.show();\n    this.isInitialOpen = true;\n    this.dlgObj.beforeClose = this.customDialogClose.bind(this);\n  };\n\n  ColumnChooser.prototype.enableAfterRenderEle = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.render();\n    }\n  };\n\n  ColumnChooser.prototype.keyUpHandler = function (e) {\n    if (e.action === 'escape') {\n      this.hideDialog();\n    }\n  };\n\n  ColumnChooser.prototype.customDialogOpen = function () {\n    var searchElement = this.dlgObj.content.querySelector('input.e-ccsearch');\n    EventHandler.add(searchElement, 'keyup', this.columnChooserManualSearch, this);\n  };\n\n  ColumnChooser.prototype.customDialogClose = function () {\n    var searchElement = this.dlgObj.content.querySelector('input.e-ccsearch');\n    EventHandler.remove(searchElement, 'keyup', this.columnChooserManualSearch);\n  };\n\n  ColumnChooser.prototype.getColumns = function () {\n    var columns = this.parent.getColumns().filter(function (column) {\n      return column.type !== 'checkbox' && column.showInColumnChooser === true || column.type === 'checkbox' && column.field !== undefined;\n    });\n    return columns;\n  };\n\n  ColumnChooser.prototype.renderDlgContent = function () {\n    this.dlgDiv = this.parent.createElement('div', {\n      className: 'e-ccdlg e-cc',\n      id: this.parent.element.id + '_ccdlg'\n    });\n    this.dlgDiv.setAttribute('aria-label', this.l10n.getConstant('ColumnChooserDialogARIA'));\n    this.parent.element.appendChild(this.dlgDiv);\n    this.dlgObj = new Dialog({\n      header: this.l10n.getConstant('ChooseColumns'),\n      showCloseIcon: false,\n      closeOnEscape: false,\n      locale: this.parent.locale,\n      visible: false,\n      enableRtl: this.parent.enableRtl,\n      target: document.getElementById(this.parent.element.id),\n      buttons: [{\n        click: this.confirmDlgBtnClick.bind(this),\n        buttonModel: {\n          content: this.l10n.getConstant('OKButton'),\n          isPrimary: true,\n          cssClass: this.parent.cssClass ? 'e-cc e-cc_okbtn' + ' ' + this.parent.cssClass : 'e-cc e-cc_okbtn'\n        }\n      }, {\n        click: this.clearBtnClick.bind(this),\n        buttonModel: {\n          cssClass: this.parent.cssClass ? 'e-flat e-cc e-cc-cnbtn' + ' ' + this.parent.cssClass : 'e-flat e-cc e-cc-cnbtn',\n          content: this.l10n.getConstant('CancelButton')\n        }\n      }],\n      content: this.renderChooserList(),\n      width: 250,\n      cssClass: this.parent.cssClass ? 'e-cc' + ' ' + this.parent.cssClass : 'e-cc',\n      animationSettings: {\n        effect: 'None'\n      }\n    });\n    var isStringTemplate = 'isStringTemplate';\n    this.dlgObj[isStringTemplate] = true;\n    this.dlgObj.appendTo(this.dlgDiv);\n    this.wireEvents();\n  };\n\n  ColumnChooser.prototype.renderChooserList = function () {\n    this.mainDiv = this.parent.createElement('div', {\n      className: 'e-main-div e-cc'\n    });\n    var searchDiv = this.parent.createElement('div', {\n      className: 'e-cc-searchdiv e-cc e-input-group'\n    });\n    var ccsearchele = this.parent.createElement('input', {\n      className: 'e-ccsearch e-cc e-input',\n      attrs: {\n        placeholder: this.l10n.getConstant('Search'),\n        cssClass: this.parent.cssClass\n      }\n    });\n    var ccsearchicon = this.parent.createElement('span', {\n      className: 'e-ccsearch-icon e-icons e-cc e-input-group-icon',\n      attrs: {\n        title: this.l10n.getConstant('Search')\n      }\n    });\n    var conDiv = this.parent.createElement('div', {\n      className: 'e-cc-contentdiv'\n    });\n    this.innerDiv = this.parent.createElement('div', {\n      className: 'e-innerdiv e-cc'\n    });\n    searchDiv.appendChild(ccsearchele);\n    searchDiv.appendChild(ccsearchicon);\n    this.searchBoxObj = new SearchBox(ccsearchele);\n    var innerDivContent = this.refreshCheckboxList(this.parent.getColumns());\n    this.innerDiv.appendChild(innerDivContent);\n    conDiv.appendChild(this.innerDiv);\n    this.mainDiv.appendChild(searchDiv);\n    this.mainDiv.appendChild(conDiv);\n    return this.mainDiv;\n  };\n\n  ColumnChooser.prototype.confirmDlgBtnClick = function (args) {\n    this.stateChangeColumns = [];\n    this.changedStateColumns = [];\n    this.changedColumns = this.changedColumns.length > 0 ? this.changedColumns : this.unchangedColumns;\n    this.changedColumnState(this.changedColumns);\n    var uncheckedLength = this.ulElement.querySelector('.e-uncheck') && this.ulElement.querySelectorAll('.e-uncheck:not(.e-selectall)').length;\n\n    if (!isNullOrUndefined(args)) {\n      if (uncheckedLength < this.parent.getColumns().length) {\n        if (this.hideColumn.length) {\n          this.columnStateChange(this.hideColumn, false);\n        }\n\n        if (this.showColumn.length) {\n          this.columnStateChange(this.showColumn, true);\n        }\n\n        this.getShowHideService.setVisible(this.stateChangeColumns, this.changedStateColumns);\n        this.clearActions();\n        this.parent.notify(tooltipDestroy, {\n          module: 'edit'\n        });\n\n        if (this.parent.getCurrentViewRecords().length === 0) {\n          var emptyRowCell = this.parent.element.querySelector('.e-emptyrow').querySelector('td');\n          emptyRowCell.setAttribute('colSpan', this.parent.getVisibleColumns().length.toString());\n        }\n      }\n    }\n  };\n\n  ColumnChooser.prototype.onResetColumns = function (e) {\n    if (e.requestType === 'columnstate') {\n      this.resetColumnState();\n      return;\n    }\n  };\n\n  ColumnChooser.prototype.resetColumnState = function () {\n    this.showColumn = [];\n    this.hideColumn = [];\n    this.hideDialog();\n  };\n\n  ColumnChooser.prototype.changedColumnState = function (changedColumns) {\n    for (var index = 0; index < changedColumns.length; index++) {\n      var colUid = changedColumns[index];\n      var currentCol = this.parent.getColumnByUid(colUid);\n      this.changedStateColumns.push(currentCol);\n    }\n  };\n\n  ColumnChooser.prototype.columnStateChange = function (stateColumns, state) {\n    for (var index = 0; index < stateColumns.length; index++) {\n      var colUid = stateColumns[index];\n      var currentCol = this.parent.getColumnByUid(colUid);\n\n      if (currentCol.type !== 'checkbox') {\n        currentCol.visible = state;\n      }\n\n      this.stateChangeColumns.push(currentCol);\n    }\n  };\n\n  ColumnChooser.prototype.clearActions = function () {\n    this.resetColumnState();\n    this.addcancelIcon();\n  };\n\n  ColumnChooser.prototype.clearBtnClick = function () {\n    this.clearActions();\n    this.parent.notify(columnChooserCancelBtnClick, {\n      dialog: this.dlgObj\n    });\n  };\n\n  ColumnChooser.prototype.checkstatecolumn = function (isChecked, coluid, selectAll$$1) {\n    if (selectAll$$1 === void 0) {\n      selectAll$$1 = false;\n    }\n\n    var currentCol = this.parent.getColumnByUid(coluid);\n\n    if (isChecked) {\n      if (this.hideColumn.indexOf(coluid) !== -1) {\n        this.hideColumn.splice(this.hideColumn.indexOf(coluid), 1);\n      }\n\n      if (this.showColumn.indexOf(coluid) === -1 && !(currentCol && currentCol.visible)) {\n        this.showColumn.push(coluid);\n      }\n    } else {\n      if (this.showColumn.indexOf(coluid) !== -1) {\n        this.showColumn.splice(this.showColumn.indexOf(coluid), 1);\n      }\n\n      if (this.hideColumn.indexOf(coluid) === -1 && currentCol && currentCol.visible) {\n        this.hideColumn.push(coluid);\n      }\n    }\n\n    if (selectAll$$1) {\n      if (!isChecked) {\n        this.changedColumns.push(coluid);\n      } else {\n        this.unchangedColumns.push(coluid);\n      }\n    } else if (this.changedColumns.indexOf(coluid) !== -1) {\n      this.changedColumns.splice(this.changedColumns.indexOf(coluid), 1);\n    } else {\n      this.changedColumns.push(coluid);\n    }\n  };\n\n  ColumnChooser.prototype.columnChooserSearch = function (searchVal) {\n    var clearSearch = false;\n    var fltrCol;\n    var okButton;\n    var buttonEle = this.dlgDiv.querySelector('.e-footer-content');\n    var selectedCbox = this.ulElement.querySelector('.e-check') && this.ulElement.querySelectorAll('.e-check:not(.e-selectall)').length;\n    this.isInitialOpen = true;\n\n    if (buttonEle) {\n      okButton = buttonEle.querySelector('.e-btn').ej2_instances[0];\n    }\n\n    if (searchVal === '') {\n      this.removeCancelIcon();\n      fltrCol = this.getColumns();\n      clearSearch = true;\n    } else {\n      fltrCol = new DataManager(this.getColumns()).executeLocal(new Query().where('headerText', this.searchOperator, searchVal, true, this.parent.columnChooserSettings.ignoreAccent));\n    }\n\n    if (fltrCol.length) {\n      this.innerDiv.innerHTML = ' ';\n      this.innerDiv.classList.remove('e-ccnmdiv');\n      this.innerDiv.appendChild(this.refreshCheckboxList(fltrCol));\n\n      if (!clearSearch) {\n        this.addcancelIcon();\n        this.refreshCheckboxButton();\n      } else {\n        if (okButton && selectedCbox) {\n          okButton.disabled = false;\n        }\n      }\n    } else {\n      var nMatchele = this.parent.createElement('span', {\n        className: 'e-cc e-nmatch'\n      });\n      nMatchele.innerHTML = this.l10n.getConstant('Matchs');\n      this.innerDiv.innerHTML = ' ';\n      this.innerDiv.appendChild(nMatchele);\n      this.innerDiv.classList.add('e-ccnmdiv');\n\n      if (okButton) {\n        okButton.disabled = true;\n      }\n    }\n\n    this.flag = true;\n    this.stopTimer();\n  };\n\n  ColumnChooser.prototype.wireEvents = function () {\n    EventHandler.add(this.dlgObj.element, 'click', this.checkBoxClickHandler, this);\n    EventHandler.add(this.searchBoxObj.searchBox, 'keyup', this.columnChooserManualSearch, this);\n    this.searchBoxObj.wireEvent();\n  };\n\n  ColumnChooser.prototype.unWireEvents = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (this.dlgObj.element) {\n      EventHandler.remove(this.dlgObj.element, 'click', this.checkBoxClickHandler);\n    }\n\n    EventHandler.remove(this.searchBoxObj.searchBox, 'keyup', this.columnChooserManualSearch);\n    this.searchBoxObj.unWireEvent();\n  };\n\n  ColumnChooser.prototype.checkBoxClickHandler = function (e) {\n    var checkstate;\n    var elem = parentsUntil(e.target, 'e-checkbox-wrapper');\n\n    if (elem) {\n      var selectAll$$1 = elem.querySelector('.e-selectall');\n\n      if (selectAll$$1) {\n        this.updateSelectAll(!elem.querySelector('.e-check'));\n      } else {\n        toogleCheckbox(elem.parentElement);\n      }\n\n      elem.querySelector('.e-chk-hidden').focus();\n\n      if (elem.querySelector('.e-check')) {\n        checkstate = true;\n      } else if (elem.querySelector('.e-uncheck')) {\n        checkstate = false;\n      } else {\n        return;\n      }\n\n      this.updateIntermediateBtn();\n      var columnUid = parentsUntil(elem, 'e-ccheck').getAttribute('uid');\n      var column = this.parent.getColumns();\n\n      if (columnUid === 'grid-selectAll') {\n        this.changedColumns = [];\n        this.unchangedColumns = [];\n\n        for (var i = 0; i < column.length; i++) {\n          if (column[i].showInColumnChooser) {\n            this.checkstatecolumn(checkstate, column[i].uid, true);\n          }\n        }\n      } else {\n        this.checkstatecolumn(checkstate, columnUid);\n      }\n\n      this.refreshCheckboxButton();\n    }\n  };\n\n  ColumnChooser.prototype.updateIntermediateBtn = function () {\n    var cnt = this.ulElement.children.length - 1;\n    var className = [];\n    var elem = this.ulElement.children[0].querySelector('.e-frame');\n    var selected = this.ulElement.querySelectorAll('.e-check:not(.e-selectall)').length;\n    var btn = this.dlgObj.btnObj[0];\n    btn.disabled = false;\n\n    if (cnt === selected) {\n      className = ['e-check'];\n    } else if (selected) {\n      className = ['e-stop'];\n    } else {\n      className = ['e-uncheck'];\n      btn.disabled = true;\n    }\n\n    btn.dataBind();\n    removeClass([elem], ['e-check', 'e-stop', 'e-uncheck']);\n    addClass([elem], className);\n  };\n\n  ColumnChooser.prototype.updateSelectAll = function (checked) {\n    var cBoxes = [].slice.call(this.ulElement.getElementsByClassName('e-frame'));\n\n    for (var _i = 0, cBoxes_1 = cBoxes; _i < cBoxes_1.length; _i++) {\n      var cBox = cBoxes_1[_i];\n      removeAddCboxClasses(cBox, checked);\n    }\n  };\n\n  ColumnChooser.prototype.refreshCheckboxButton = function () {\n    var visibleCols = this.parent.getVisibleColumns();\n\n    for (var i = 0; i < visibleCols.length; i++) {\n      var columnUID = visibleCols[i].uid;\n\n      if (this.prevShowedCols.indexOf(columnUID) === -1) {\n        this.prevShowedCols.push(columnUID);\n      }\n    }\n\n    for (var i = 0; i < this.hideColumn.length; i++) {\n      var index = this.prevShowedCols.indexOf(this.hideColumn[i]);\n\n      if (index !== -1) {\n        this.prevShowedCols.splice(index, 1);\n      }\n    }\n\n    var selected = this.showColumn.length !== 0 ? 1 : this.prevShowedCols.length;\n    var btn = this.dlgDiv.querySelector('.e-footer-content').querySelector('.e-btn').ej2_instances[0];\n    btn.disabled = false;\n    var srchShowCols = [];\n    var searchData = [].slice.call(this.parent.element.getElementsByClassName('e-cc-chbox'));\n\n    for (var i = 0, itemsLen = searchData.length; i < itemsLen; i++) {\n      var element = searchData[i];\n      var columnUID = parentsUntil(element, 'e-ccheck').getAttribute('uid');\n      srchShowCols.push(columnUID);\n    }\n\n    var hideCols = this.showColumn.filter(function (column) {\n      return srchShowCols.indexOf(column) !== -1;\n    });\n\n    if (selected === 0 && hideCols.length === 0) {\n      btn.disabled = true;\n    }\n\n    btn.dataBind();\n  };\n\n  ColumnChooser.prototype.refreshCheckboxList = function (gdCol) {\n    this.ulElement = this.parent.createElement('ul', {\n      className: 'e-ccul-ele e-cc'\n    });\n    var selectAllValue = this.l10n.getConstant('SelectAll');\n    var cclist = this.parent.createElement('li', {\n      className: 'e-cclist e-cc e-cc-selectall'\n    });\n    var selectAll$$1 = this.createCheckBox(selectAllValue, false, 'grid-selectAll');\n\n    if (gdCol.length) {\n      selectAll$$1.querySelector('.e-checkbox-wrapper').firstElementChild.classList.add('e-selectall');\n      selectAll$$1.querySelector('.e-frame').classList.add('e-selectall');\n      this.checkState(selectAll$$1.querySelector('.e-icons'), true);\n      cclist.appendChild(selectAll$$1);\n      this.ulElement.appendChild(cclist);\n    }\n\n    if (this.parent.cssClass) {\n      addClass([selectAll$$1], [this.parent.cssClass]);\n    }\n\n    for (var i = 0; i < gdCol.length; i++) {\n      var columns = gdCol[i];\n      this.renderCheckbox(columns);\n    }\n\n    return this.ulElement;\n  };\n\n  ColumnChooser.prototype.refreshCheckboxState = function () {\n    this.dlgObj.element.querySelector('.e-cc.e-input').value = '';\n    this.columnChooserSearch('');\n    var gridObject = this.parent;\n    var currentCheckBoxColls = this.dlgObj.element.querySelectorAll('.e-cc-chbox:not(.e-selectall)');\n\n    for (var i = 0, itemLen = currentCheckBoxColls.length; i < itemLen; i++) {\n      var element = currentCheckBoxColls[i];\n      var columnUID = void 0;\n\n      if (this.parent.childGrid || this.parent.detailTemplate) {\n        columnUID = parentsUntil(this.dlgObj.element.querySelectorAll('.e-cc-chbox:not(.e-selectall)')[i], 'e-ccheck').getAttribute('uid');\n      } else {\n        columnUID = parentsUntil(element, 'e-ccheck').getAttribute('uid');\n      }\n\n      var column = gridObject.getColumnByUid(columnUID);\n      var uncheck = [].slice.call(element.parentElement.getElementsByClassName('e-uncheck'));\n\n      if (column.visible && !uncheck.length) {\n        element.checked = true;\n        this.checkState(element.parentElement.querySelector('.e-icons'), true);\n      } else {\n        element.checked = false;\n        this.checkState(element.parentElement.querySelector('.e-icons'), false);\n      }\n    }\n  };\n\n  ColumnChooser.prototype.checkState = function (element, state) {\n    if (state) {\n      classList(element, ['e-check'], ['e-uncheck']);\n    } else {\n      classList(element, ['e-uncheck'], ['e-check']);\n    }\n  };\n\n  ColumnChooser.prototype.createCheckBox = function (label, checked, uid) {\n    var cbox = checked ? this.cBoxTrue.cloneNode(true) : this.cBoxFalse.cloneNode(true);\n    cbox.querySelector('.e-label').innerHTML = label;\n    return createCboxWithWrap(uid, cbox, 'e-ccheck');\n  };\n\n  ColumnChooser.prototype.renderCheckbox = function (column) {\n    var cclist;\n    var hideColState;\n    var showColState;\n\n    if (column.showInColumnChooser) {\n      cclist = this.parent.createElement('li', {\n        className: 'e-cclist e-cc',\n        styles: 'list-style:None',\n        id: 'e-ccli_' + column.uid\n      });\n      hideColState = this.hideColumn.indexOf(column.uid) === -1 ? false : true;\n      showColState = this.showColumn.indexOf(column.uid) === -1 ? false : true;\n      var cccheckboxlist = this.createCheckBox(column.headerText, column.visible && !hideColState || showColState, column.uid);\n      cclist.appendChild(cccheckboxlist);\n\n      if (this.parent.cssClass) {\n        addClass([cccheckboxlist], [this.parent.cssClass]);\n      }\n\n      this.ulElement.appendChild(cclist);\n    }\n\n    if (this.isInitialOpen) {\n      this.updateIntermediateBtn();\n    }\n  };\n\n  ColumnChooser.prototype.columnChooserManualSearch = function (e) {\n    this.addcancelIcon();\n    this.searchValue = e.target.value;\n    this.stopTimer();\n    this.startTimer(e);\n  };\n\n  ColumnChooser.prototype.startTimer = function (e) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    var proxy = this;\n    var interval = !proxy.flag && e.keyCode !== 13 ? 500 : 0;\n    this.timer = window.setInterval(function () {\n      proxy.columnChooserSearch(proxy.searchValue);\n    }, interval);\n  };\n\n  ColumnChooser.prototype.stopTimer = function () {\n    window.clearInterval(this.timer);\n  };\n\n  ColumnChooser.prototype.addcancelIcon = function () {\n    this.dlgDiv.querySelector('.e-cc.e-ccsearch-icon').classList.add('e-cc-cancel');\n  };\n\n  ColumnChooser.prototype.removeCancelIcon = function () {\n    this.dlgDiv.querySelector('.e-cc.e-ccsearch-icon').classList.remove('e-cc-cancel');\n  };\n\n  ColumnChooser.prototype.mOpenDlg = function () {\n    if (Browser.isDevice) {\n      this.dlgObj.element.querySelector('.e-cc-searchdiv').classList.remove('e-input-focus');\n      this.dlgObj.element.querySelectorAll('.e-cc-chbox')[0].focus();\n    }\n  }; // internally use\n\n\n  ColumnChooser.prototype.getModuleName = function () {\n    return 'columnChooser';\n  };\n\n  ColumnChooser.prototype.hideOpenedDialog = function () {\n    var openCC = [].slice.call(document.getElementsByClassName('e-ccdlg')).filter(function (dlgEle) {\n      return dlgEle.classList.contains('e-popup-open');\n    });\n\n    for (var i = 0, dlgLen = openCC.length; i < dlgLen; i++) {\n      if (openCC[i].classList.contains('e-dialog') || this.parent.element.id + '_ccdlg' !== openCC[i].id) {\n        openCC[i].ej2_instances[0].hide();\n      }\n    }\n  };\n\n  ColumnChooser.prototype.beforeOpenColumnChooserEvent = function () {\n    var args1 = {\n      requestType: 'beforeOpenColumnChooser',\n      element: this.parent.element,\n      columns: this.getColumns(),\n      cancel: false,\n      searchOperator: this.parent.columnChooserSettings.operator\n    };\n    this.parent.trigger(beforeOpenColumnChooser, args1);\n    this.searchOperator = args1.searchOperator;\n    return args1;\n  };\n\n  return ColumnChooser;\n}();\n/**\n * @hidden\n * `ExportHelper` for `PdfExport` & `ExcelExport`\n */\n\n\nvar ExportHelper =\n/** @__PURE__ @class */\nfunction () {\n  function ExportHelper(parent, foreignKeyData) {\n    this.hideColumnInclude = false;\n    this.foreignKeyData = {};\n    this.parent = parent;\n\n    if (!parent.parentDetails && foreignKeyData) {\n      this.foreignKeyData = foreignKeyData;\n    }\n  }\n\n  ExportHelper.getQuery = function (parent, data) {\n    var query = data.generateQuery(true).requiresCount();\n\n    if (data.isRemote()) {\n      if (parent.groupSettings.enableLazyLoading && parent.groupSettings.columns.length) {\n        query.lazyLoad = [];\n      } else {\n        query.take(parent.pageSettings.totalRecordsCount);\n      }\n    }\n\n    return query;\n  };\n\n  ExportHelper.prototype.getFData = function (value, column) {\n    var foreignKeyData = getForeignData(column, {}, value, this.foreignKeyData[column.field])[0];\n    return foreignKeyData;\n  };\n\n  ExportHelper.prototype.getGridRowModel = function (columns, dataSource, gObj, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n\n    var rows = [];\n    var length = dataSource.length;\n\n    if (length) {\n      for (var i = 0; i < length; i++, startIndex++) {\n        var options = {\n          isExpand: false\n        };\n        options.data = dataSource[i];\n        options.index = startIndex;\n\n        if (gObj.childGrid) {\n          if (gObj.hierarchyPrintMode === 'All') {\n            options.isExpand = true;\n          } else if (gObj.hierarchyPrintMode === 'Expanded' && this.parent.expandedRows && this.parent.expandedRows[startIndex]) {\n            options.isExpand = gObj.expandedRows[startIndex].isExpand;\n          }\n        }\n\n        var row = new Row(options);\n        row.cells = this.generateCells(columns, gObj);\n        rows.push(row);\n      }\n\n      this.processColumns(rows);\n    }\n\n    return rows;\n  };\n\n  ExportHelper.prototype.generateCells = function (columns, gObj) {\n    var cells = [];\n\n    if (gObj.childGridLevel) {\n      var len = gObj.childGridLevel;\n\n      for (var i = 0; len > i; i++) {\n        cells.push(this.generateCell({}, CellType.Indent));\n      }\n    }\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var col = columns_1[_i];\n      cells.push(this.generateCell(col, CellType.Data));\n    }\n\n    return cells;\n  };\n\n  ExportHelper.prototype.getColumnData = function (gridObj) {\n    var _this = this;\n\n    var columnPromise = [];\n    var promise;\n    var fColumns = gridObj.getForeignKeyColumns();\n\n    if (fColumns.length) {\n      for (var i = 0; i < fColumns.length; i++) {\n        var colData = 'result' in fColumns[i].dataSource ? new DataManager(fColumns[i].dataSource.result) : fColumns[i].dataSource;\n        columnPromise.push(colData.executeQuery(new Query()));\n      }\n\n      promise = Promise.all(columnPromise).then(function (e) {\n        for (var j = 0; j < fColumns.length; j++) {\n          _this.foreignKeyData[fColumns[j].field] = e[j].result;\n        } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      });\n    }\n\n    return promise;\n  };\n\n  ExportHelper.prototype.getHeaders = function (columns, isHideColumnInclude) {\n    if (isHideColumnInclude) {\n      this.hideColumnInclude = true;\n    } else {\n      this.hideColumnInclude = false;\n    }\n\n    this.colDepth = measureColumnDepth(columns);\n    var rows = [];\n\n    for (var i = 0; i < this.colDepth; i++) {\n      rows[i] = new Row({});\n      rows[i].cells = [];\n    }\n\n    rows = this.processColumns(rows);\n    rows = this.processHeaderCells(rows, columns);\n    return {\n      rows: rows,\n      columns: this.generateActualColumns(columns)\n    };\n  };\n\n  ExportHelper.prototype.getConvertedWidth = function (input) {\n    var value = parseFloat(input);\n    return input.indexOf('%') !== -1 ? this.parent.element.getBoundingClientRect().width * value / 100 : value;\n  };\n\n  ExportHelper.prototype.generateActualColumns = function (columns, actualColumns) {\n    if (actualColumns === void 0) {\n      actualColumns = [];\n    }\n\n    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n      var column = columns_2[_i];\n\n      if (column.commands) {\n        continue;\n      }\n\n      if (!column.columns) {\n        if (column.visible || this.hideColumnInclude) {\n          actualColumns.push(column);\n        }\n      } else {\n        if (column.visible || this.hideColumnInclude) {\n          var colSpan = this.getCellCount(column, 0);\n\n          if (colSpan !== 0) {\n            this.generateActualColumns(column.columns, actualColumns);\n          }\n        }\n      }\n    }\n\n    return actualColumns;\n  };\n\n  ExportHelper.prototype.processHeaderCells = function (rows, cols) {\n    var columns = cols;\n\n    for (var i = 0; i < columns.length; i++) {\n      if (!columns[i].commands) {\n        rows = this.appendGridCells(columns[i], rows, 0);\n      }\n    }\n\n    return rows;\n  };\n\n  ExportHelper.prototype.appendGridCells = function (cols, gridRows, index) {\n    if (!cols.columns && (cols.visible !== false || this.hideColumnInclude) && !cols.commands) {\n      gridRows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, index));\n    } else if (cols.columns) {\n      var colSpan = this.getCellCount(cols, 0);\n\n      if (colSpan) {\n        gridRows[index].cells.push(new Cell({\n          cellType: CellType.StackedHeader,\n          column: cols,\n          colSpan: colSpan\n        }));\n      }\n\n      var isIgnoreFirstCell = void 0;\n\n      for (var i = 0, len = cols.columns.length; i < len; i++) {\n        if (cols.columns[i].visible && !isIgnoreFirstCell) {\n          isIgnoreFirstCell = true;\n        }\n\n        gridRows = this.appendGridCells(cols.columns[i], gridRows, index + 1);\n      }\n    }\n\n    return gridRows;\n  };\n\n  ExportHelper.prototype.generateCell = function (gridColumn, cellType, rowSpan, rowIndex) {\n    var option = {\n      'visible': gridColumn.visible,\n      'isDataCell': cellType === CellType.Data,\n      'column': gridColumn,\n      'cellType': cellType,\n      'rowSpan': rowSpan,\n      'index': rowIndex\n    };\n\n    if (!option.rowSpan || option.rowSpan < 2) {\n      delete option.rowSpan;\n    }\n\n    return new Cell(option);\n  };\n\n  ExportHelper.prototype.processColumns = function (rows) {\n    //TODO: generate dummy column for group, detail, stacked row here; ensureColumns here\n    var gridObj = this.parent;\n    var columnIndexes = [];\n\n    if (gridObj.enableColumnVirtualization) {\n      columnIndexes = gridObj.getColumnIndexesInView();\n    }\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      if (gridObj.allowGrouping) {\n        for (var j = 0, len_1 = gridObj.groupSettings.columns.length - 1; j < len_1; j++) {\n          if (gridObj.enableColumnVirtualization && columnIndexes.indexOf(j) === -1) {\n            continue;\n          }\n\n          rows[i].cells.splice(0, 0, this.generateCell({}, CellType.HeaderIndent));\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  ExportHelper.prototype.getCellCount = function (column, count) {\n    if (column.columns) {\n      for (var i = 0; i < column.columns.length; i++) {\n        count = this.getCellCount(column.columns[i], count);\n      }\n    } else {\n      if (column.visible || this.hideColumnInclude) {\n        count++;\n      }\n    }\n\n    return count;\n  };\n\n  ExportHelper.prototype.checkAndExport = function (gridPool, globalResolve) {\n    var bool = Object.keys(gridPool).some(function (key) {\n      return !gridPool[key];\n    });\n\n    if (!bool) {\n      globalResolve();\n    }\n  };\n\n  ExportHelper.prototype.failureHandler = function (gridPool, childGridObj, resolve) {\n    var _this = this;\n\n    return function () {\n      gridPool[childGridObj.id] = true;\n\n      _this.checkAndExport(gridPool, resolve);\n    };\n  };\n\n  ExportHelper.prototype.createChildGrid = function (gObj, row, exportType, gridPool) {\n    var childGridObj = new Grid(this.parent.detailRowModule.getGridModel(gObj, row, exportType));\n    gObj.isPrinting = false;\n    var parent = 'parentDetails';\n    childGridObj[parent] = {\n      parentID: gObj.element.id,\n      parentPrimaryKeys: gObj.getPrimaryKeyFieldNames(),\n      parentKeyField: gObj.childGrid.queryString,\n      parentKeyFieldValue: getValue(childGridObj.queryString, row.data),\n      parentRowData: row.data\n    };\n    var exportId = getUid('child-grid');\n    var element = createElement('div', {\n      id: exportId,\n      styles: 'display: none'\n    });\n    document.body.appendChild(element);\n    childGridObj.id = exportId;\n    gridPool[exportId] = false;\n    childGridObj.isExportGrid = true;\n    return {\n      childGrid: childGridObj,\n      element: element\n    };\n  };\n\n  ExportHelper.prototype.getGridExportColumns = function (columns) {\n    var actualGridColumns = [];\n\n    for (var i = 0, gridColumns = columns; i < gridColumns.length; i++) {\n      if (gridColumns[i].type !== 'checkbox') {\n        actualGridColumns.push(gridColumns[i]);\n      }\n    }\n\n    return actualGridColumns;\n  };\n  /**\n   * Gets the foreignkey data.\n   *\n   * @returns {ForeignKeyFormat} returns the foreignkey data\n   * @hidden\n   */\n\n\n  ExportHelper.prototype.getForeignKeyData = function () {\n    return this.foreignKeyData;\n  };\n\n  return ExportHelper;\n}();\n/**\n * @hidden\n * `ExportValueFormatter` for `PdfExport` & `ExcelExport`\n */\n\n\nvar ExportValueFormatter =\n/** @__PURE__ @class */\nfunction () {\n  function ExportValueFormatter(culture) {\n    this.valueFormatter = new ValueFormatter(culture);\n    this.internationalization = new Internationalization(culture);\n  }\n\n  ExportValueFormatter.prototype.returnFormattedValue = function (args, customFormat) {\n    if (!isNullOrUndefined(args.value) && args.value) {\n      return this.valueFormatter.getFormatFunction(customFormat)(args.value);\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Used to format the exporting cell value\n   *\n   * @param  {ExportHelperArgs} args - Specifies cell details.\n   * @returns {string} returns formated value\n   * @hidden\n   */\n\n\n  ExportValueFormatter.prototype.formatCellValue = function (args) {\n    if (args.isForeignKey) {\n      args.value = getValue(args.column.foreignKeyValue, getForeignData(args.column, {}, args.value)[0]);\n    }\n\n    if (args.column.type === 'number' && args.column.format !== undefined && args.column.format !== '') {\n      if (typeof args.column.format === 'string') {\n        args.column.format = {\n          format: args.column.format\n        };\n      }\n\n      return args.value || args.value === 0 ? this.internationalization.getNumberFormat(args.column.format)(args.value) : '';\n    } else if (args.column.type === 'boolean' && args.value !== '') {\n      return args.value ? 'true' : 'false';\n      /* tslint:disable-next-line:max-line-length */\n    } else if ((args.column.type === 'date' || args.column.type === 'datetime' || args.column.type === 'time') && args.column.format !== undefined) {\n      if (typeof args.value === 'string') {\n        args.value = new Date(args.value);\n      }\n\n      if (typeof args.column.format === 'string') {\n        var format = void 0;\n        var cFormat = args.column.format;\n\n        if (args.column.type === 'date') {\n          format = {\n            type: 'date',\n            skeleton: cFormat\n          };\n        } else if (args.column.type === 'time') {\n          format = {\n            type: 'time',\n            skeleton: cFormat\n          };\n        } else {\n          format = {\n            type: 'dateTime',\n            skeleton: cFormat\n          };\n        }\n\n        return this.returnFormattedValue(args, format);\n      } else {\n        if (args.column.format instanceof Object && args.column.format.type === undefined) {\n          return args.value.toString();\n        } else {\n          var customFormat = void 0;\n\n          if (args.column.type === 'date') {\n            customFormat = {\n              type: args.column.format.type,\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          } else if (args.column.type === 'time') {\n            customFormat = {\n              type: 'time',\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          } else {\n            customFormat = {\n              type: 'dateTime',\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          }\n\n          return this.returnFormattedValue(args, customFormat);\n        }\n      }\n    } else {\n      if (!isNullOrUndefined(args.column.type) && !isNullOrUndefined(args.value) || !isNullOrUndefined(args.value)) {\n        return args.value.toString();\n      } else {\n        return '';\n      }\n    }\n  };\n\n  return ExportValueFormatter;\n}();\n/**\n * @hidden\n * `ExcelExport` module is used to handle the Excel export action.\n */\n\n\nvar ExcelExport =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid Excel Export module.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} locator - specifies the ServiceLocator\n   * @hidden\n   */\n  function ExcelExport(parent, locator) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.book = {};\n    this.workSheet = [];\n    this.rows = [];\n    this.columns = [];\n    this.styles = [];\n    this.rowLength = 1;\n    this.expType = 'AppendToSheet';\n    this.includeHiddenColumn = false;\n    this.isCsvExport = false;\n    this.isElementIdChanged = false;\n    this.gridPool = {};\n    this.sheet = {};\n    this.parent = parent;\n    this.helper = new ExportHelper(parent);\n    this.locator = locator;\n    this.l10n = this.locator.getService('localization');\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  ExcelExport.prototype.getModuleName = function () {\n    return 'ExcelExport';\n  };\n\n  ExcelExport.prototype.init = function (gObj) {\n    if (gObj.element !== null && gObj.element.id === '') {\n      gObj.element.id = new Date().toISOString();\n      this.isElementIdChanged = true;\n    }\n\n    this.parent = gObj;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.isExporting = undefined;\n    this.book = {};\n    this.workSheet = [];\n    this.rows = [];\n    this.columns = [];\n    this.styles = [];\n    this.rowLength = 1;\n    this.footer = undefined;\n    this.expType = 'AppendToSheet';\n    this.includeHiddenColumn = false;\n    this.exportValueFormatter = new ExportValueFormatter(gObj.locale);\n    gObj.id = getUid('main-grid');\n    this.gridPool[gObj.id] = false;\n  };\n  /**\n   * Export Grid to Excel file.\n   *\n   * @param {IGrid} grid - Defines the grid.\n   * @param  {exportProperties} exportProperties - Defines the export properties of the Grid.\n   * @param  {isMultipleExport} isMultipleExport - Defines is multiple Grid's are exported.\n   * @param  {Workbook} workbook - Defined the Workbook if multiple Grid is exported.\n   * @param  {boolean} isCsv - true if export to CSV.\n   * @param {boolean} isBlob - true if isBlob is enabled.\n   * @returns {Promise<any>} - Returns the map for export.\n   */\n  // eslint-disable-next-line\n\n\n  ExcelExport.prototype.Map = function (grid, exportProperties, isMultipleExport, workbook, isCsv, isBlob) {\n    var gObj = grid;\n    var cancel = 'cancel';\n    var isBlb = 'isBlob';\n    var csv = 'isCsv';\n    var workbk = 'workbook';\n    var isMultiEx = 'isMultipleExport';\n    this.gridPool = {};\n\n    if (grid.childGrid && !(!isNullOrUndefined(exportProperties) && exportProperties.hierarchyExportMode === 'None')) {\n      grid.expandedRows = getPrintGridModel(grid).expandedRows;\n    }\n\n    var args = {\n      requestType: 'beforeExcelExport',\n      gridObject: gObj,\n      cancel: false,\n      isMultipleExport: isMultipleExport,\n      workbook: workbook,\n      isCsv: isCsv,\n      isBlob: isBlob\n    };\n    gObj.trigger(beforeExcelExport, args);\n\n    if (args[cancel]) {\n      return new Promise(function (resolve) {\n        return resolve();\n      });\n    }\n\n    this.parent.log('exporting_begin', this.getModuleName());\n    this.data = new Data(gObj);\n    this.isExporting = true;\n    this.isBlob = args[isBlb];\n\n    if (args[csv]) {\n      this.isCsvExport = args[csv];\n    } else {\n      this.isCsvExport = false;\n    }\n\n    if (isExportColumns(exportProperties)) {\n      updateColumnTypeForExportColumns(exportProperties, gObj);\n    }\n\n    return this.processRecords(gObj, exportProperties, args[isMultiEx], args[workbk]);\n  };\n\n  ExcelExport.prototype.exportingSuccess = function (resolve) {\n    this.isExporting = false;\n    this.parent.trigger(excelExportComplete, this.isBlob ? {\n      promise: this.blobPromise\n    } : {});\n    this.parent.log('exporting_complete', this.getModuleName());\n    resolve(this.book);\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  ExcelExport.prototype.processRecords = function (gObj, exportProperties, isMultipleExport, workbook) {\n    var _this = this;\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.dataSource) && exportProperties.dataSource instanceof DataManager) {\n      var query_1 = exportProperties.query ? exportProperties.query : new Query();\n\n      if (isNullOrUndefined(query_1.isCountRequired) || gObj.aggregates) {\n        query_1.isCountRequired = true;\n      }\n\n      return new Promise(function (resolve) {\n        var dataManager = exportProperties.dataSource.executeQuery(query_1);\n        dataManager.then(function (r) {\n          _this.init(gObj);\n\n          _this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, r).then(function () {\n            _this.exportingSuccess(resolve);\n          });\n        });\n      });\n    } else if (!isNullOrUndefined(exportProperties) && exportProperties.exportType === 'CurrentPage') {\n      return new Promise(function (resolve) {\n        _this.init(gObj);\n\n        _this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, _this.parent.getCurrentViewRecords());\n\n        _this.exportingSuccess(resolve);\n      });\n    } else {\n      var allPromise_1 = [];\n      allPromise_1.push(this.data.getData({}, ExportHelper.getQuery(gObj, this.data)));\n      allPromise_1.push(this.helper.getColumnData(gObj));\n      return new Promise(function (resolve, reject) {\n        Promise.all(allPromise_1).then(function (e) {\n          _this.init(gObj);\n\n          _this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, e[0]).then(function () {\n            _this.exportingSuccess(resolve);\n          });\n        }).catch(function (e) {\n          reject(_this.book);\n\n          _this.parent.trigger(actionFailure, e);\n        });\n      });\n    }\n  };\n\n  ExcelExport.prototype.processInnerRecords = function (gObj, exportProperties, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isMultipleExport, workbook, r) {\n    var _this = this;\n\n    this.groupedColLength = gObj.groupSettings.columns.length;\n    var blankRows = 5;\n    var separator;\n    var rows = [];\n    var colDepth = measureColumnDepth(gObj.columns);\n    var isExportPropertiesPresent = !isNullOrUndefined(exportProperties);\n\n    if (isExportPropertiesPresent && !isNullOrUndefined(exportProperties.multipleExport)) {\n      this.expType = !isNullOrUndefined(exportProperties.multipleExport.type) ? exportProperties.multipleExport.type : 'AppendToSheet';\n\n      if (!isNullOrUndefined(exportProperties.multipleExport.blankRows)) {\n        blankRows = exportProperties.multipleExport.blankRows;\n      }\n    }\n\n    if (isNullOrUndefined(workbook)) {\n      this.workSheet = [];\n      this.rows = [];\n      this.columns = [];\n      this.styles = [];\n      this.sheet.images = [];\n    } else if (this.expType === 'NewSheet') {\n      this.workSheet = workbook.worksheets;\n      this.rows = [];\n      this.columns = [];\n      this.sheet.images = [];\n      this.styles = workbook.styles;\n    } else {\n      this.workSheet = [];\n      this.rows = workbook.worksheets[0].rows;\n      this.columns = workbook.worksheets[0].columns;\n      this.styles = workbook.styles;\n      this.sheet.images = workbook.worksheets[0].images;\n      this.rowLength = this.rows[this.rows.length - 1].index + blankRows;\n      this.rowLength++;\n    }\n\n    if (isExportPropertiesPresent) {\n      if (!isNullOrUndefined(isMultipleExport)) {\n        if (!isNullOrUndefined(exportProperties.header) && (isMultipleExport || this.expType === 'NewSheet')) {\n          this.processExcelHeader(JSON.parse(JSON.stringify(exportProperties.header)));\n        }\n\n        if (!isNullOrUndefined(exportProperties.footer)) {\n          if (this.expType === 'AppendToSheet') {\n            if (!isMultipleExport) {\n              this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n            }\n          } else {\n            this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n          }\n        }\n      } else {\n        if (!isNullOrUndefined(exportProperties.header)) {\n          this.processExcelHeader(JSON.parse(JSON.stringify(exportProperties.header)));\n        }\n\n        if (!isNullOrUndefined(exportProperties.footer)) {\n          this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n        }\n      }\n    }\n\n    this.includeHiddenColumn = isExportPropertiesPresent ? exportProperties.includeHiddenColumn : false; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    return new Promise(function (resolve, reject) {\n      gObj.childGridLevel = 0;\n      rows = _this.processGridExport(gObj, exportProperties, r);\n      _this.globalResolve = resolve;\n      _this.gridPool[gObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n    }).then(function () {\n      var organisedRows = [];\n\n      _this.organiseRows(rows, rows[0].index, organisedRows);\n\n      _this.rows = _this.rows.concat(organisedRows); //footer template add\n\n      if (!isNullOrUndefined(_this.footer)) {\n        if (_this.expType === 'AppendToSheet' && !isMultipleExport || _this.expType === 'NewSheet') {\n          _this.processExcelFooter(_this.footer);\n        }\n      }\n\n      if (_this.columns.length > 0) {\n        _this.sheet.columns = _this.columns;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      _this.sheet.rows = _this.rows;\n      _this.sheet.enableRtl = _this.parent.enableRtl;\n\n      if (_this.parent.allowFiltering && gObj.getVisibleColumns().length && isExportPropertiesPresent && exportProperties.enableFilter) {\n        var headerRowLen = exportProperties.header ? exportProperties.header.headerRows || exportProperties.header.rows.length : 0;\n        var autoFilters = {\n          row: colDepth + headerRowLen,\n          column: _this.groupedColLength ? _this.groupedColLength + 1 : _this.sheet.columns[0].index,\n          lastRow: _this.sheet.rows.length,\n          lastColumn: _this.sheet.columns.length\n        };\n        _this.sheet.autoFilters = autoFilters;\n      }\n\n      _this.workSheet.push(_this.sheet);\n\n      _this.book.worksheets = _this.workSheet;\n      _this.book.styles = _this.styles;\n      gObj.notify('finalPageSetup', _this.book);\n\n      if (!isMultipleExport) {\n        if (_this.isCsvExport) {\n          if (isExportPropertiesPresent && !isNullOrUndefined(exportProperties.separator) && exportProperties.separator !== ',') {\n            separator = exportProperties.separator;\n          }\n\n          var book = new Workbook(_this.book, 'csv', gObj.locale, gObj.currencyCode, separator);\n\n          if (!_this.isBlob) {\n            if (isExportPropertiesPresent && exportProperties.fileName) {\n              book.save(exportProperties.fileName);\n            } else {\n              book.save('Export.csv');\n            }\n          } else {\n            _this.blobPromise = book.saveAsBlob('text/csv');\n          }\n        } else {\n          var book = new Workbook(_this.book, 'xlsx', gObj.locale, gObj.currencyCode);\n\n          if (!_this.isBlob) {\n            if (isExportPropertiesPresent && exportProperties.fileName) {\n              book.save(exportProperties.fileName);\n            } else {\n              book.save('Export.xlsx');\n            }\n          } else {\n            _this.blobPromise = book.saveAsBlob('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n          }\n        }\n\n        if (_this.isElementIdChanged) {\n          gObj.element.id = '';\n        }\n\n        delete gObj.expandedRows;\n      }\n\n      return workbook;\n    });\n  };\n\n  ExcelExport.prototype.organiseRows = function (rows, initialIndex, organisedRows) {\n    if (!rows.length) {\n      return initialIndex;\n    }\n\n    for (var i = 0; i < rows.length; i++) {\n      var row = rows[i];\n      var childRows = row.childRows;\n\n      if (childRows) {\n        row.index = initialIndex++;\n        delete row.childRows;\n        organisedRows.push(row);\n        initialIndex = this.organiseRows(childRows, initialIndex, organisedRows);\n      } else {\n        row.index = initialIndex++;\n        organisedRows.push(row);\n      }\n    }\n\n    return initialIndex;\n  };\n\n  ExcelExport.prototype.processGridExport = function (gObj, exportProperties, r) {\n    var excelRows = [];\n    var isFrozen = this.parent.isFrozenGrid() && !this.parent.getFrozenColumns();\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.theme)) {\n      this.theme = exportProperties.theme;\n    }\n\n    if (gObj.childGrid && !isNullOrUndefined(exportProperties)) {\n      gObj.hierarchyPrintMode = exportProperties.hierarchyExportMode || 'Expanded';\n    }\n\n    var helper = new ExportHelper(gObj, this.helper.getForeignKeyData());\n    var gColumns = isExportColumns(exportProperties) ? prepareColumns(exportProperties.columns, gObj.enableColumnVirtualization) : helper.getGridExportColumns(isFrozen ? gObj.getColumns() : gObj.columns);\n    var headerRow = helper.getHeaders(gColumns, this.includeHiddenColumn);\n    var groupIndent = gObj.groupSettings.columns.length ? gObj.groupSettings.columns.length - 1 : 0;\n    excelRows = this.processHeaderContent(gObj, headerRow, groupIndent, excelRows); // eslint-disable-next-line max-len\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.dataSource) && !(exportProperties.dataSource instanceof DataManager)) {\n      // eslint-disable-next-line max-len\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, exportProperties.dataSource, excelRows, helper);\n    } else if (!isNullOrUndefined(exportProperties) && exportProperties.exportType === 'CurrentPage') {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, gObj.currentViewData, excelRows, helper);\n    } else {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, undefined, excelRows, helper);\n    }\n\n    gObj.notify(exportDataBound, {\n      excelRows: excelRows,\n      type: 'excel'\n    });\n    return excelRows;\n  };\n\n  ExcelExport.prototype.processRecordContent = function (gObj, returnType, headerRow, exportProperties, currentViewRecords, excelRow, helper) {\n    var record;\n\n    if (!isNullOrUndefined(currentViewRecords) && currentViewRecords.length) {\n      record = currentViewRecords;\n    } else {\n      record = returnType.result;\n    }\n\n    if (!isNullOrUndefined(record.level)) {\n      this.processGroupedRows(gObj, record, headerRow, record.level, 0, exportProperties, excelRow, helper);\n    } else {\n      this.processRecordRows(gObj, record, headerRow, 0, 0, exportProperties, excelRow, helper);\n    }\n\n    if (!isNullOrUndefined(returnType.aggregates)) {\n      if (!isNullOrUndefined(currentViewRecords)) {\n        this.processAggregates(gObj, returnType.result, excelRow, currentViewRecords);\n      } else {\n        var result = returnType.result.GroupGuid ? returnType.result.records : returnType.result;\n        this.processAggregates(gObj, result, excelRow);\n      }\n    }\n\n    return excelRow;\n  };\n\n  ExcelExport.prototype.processGroupedRows = function ( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  gObj, dataSource, headerRow, level, startIndex, excelExportProperties, excelRows, helper) {\n    for (var _i = 0, dataSource_1 = dataSource; _i < dataSource_1.length; _i++) {\n      var item = dataSource_1[_i];\n      var cells = [];\n      var index = 1; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var cell = {};\n      cell.index = index + level - 1;\n      var col = gObj.getColumnByField(item.field); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var args = {\n        value: item.key,\n        column: col,\n        style: undefined,\n        isForeignKey: col.isForeignColumn()\n      };\n      var value = gObj.getColumnByField(item.field).headerText + ': ' + (!col.enableGroupByFormat ? this.exportValueFormatter.formatCellValue(args) : item.key) + ' - ';\n\n      if (item.count > 1) {\n        value += item.count + ' items';\n      } else {\n        value += item.count + ' item';\n      }\n\n      var cArgs = {\n        captionText: value,\n        type: this.isCsvExport ? 'CSV' : 'Excel',\n        data: item\n      };\n      this.parent.trigger(exportGroupCaption, cArgs);\n      cell.value = cArgs.captionText;\n      cell.style = this.getCaptionThemeStyle(this.theme);\n\n      if (!isNullOrUndefined(cArgs.style)) {\n        cell.style = this.mergeOptions(cell.style, cArgs.style);\n      }\n\n      var captionModelGen = new CaptionSummaryModelGenerator(gObj);\n      var groupCaptionSummaryRows = captionModelGen.generateRows(item);\n      this.fillAggregates(gObj, groupCaptionSummaryRows, dataSource.level + dataSource.childLevels - 1, excelRows, this.rowLength);\n      cells.push(cell);\n\n      if (excelRows[excelRows.length - 1].cells.length > 0) {\n        var lIndex = dataSource.level + dataSource.childLevels + groupCaptionSummaryRows[0].cells.length;\n        var hIndex = 0;\n\n        for (var _a = 0, _b = excelRows[excelRows.length - 1].cells; _a < _b.length; _a++) {\n          var tCell = _b[_a];\n\n          if (tCell.index < lIndex) {\n            lIndex = tCell.index;\n          }\n\n          if (tCell.index > hIndex) {\n            hIndex = tCell.index;\n          }\n\n          if (cells[cells.length - 1].index !== tCell.index) {\n            cells.push(tCell);\n          }\n        }\n\n        if (lIndex - cell.index > 1) {\n          cell.colSpan = lIndex - cell.index;\n        }\n\n        while (hIndex < headerRow.columns.length + level + dataSource.childLevels) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          var sCell = {};\n          sCell.index = hIndex + 1;\n          sCell.style = this.getCaptionThemeStyle(this.theme);\n          cells.push(sCell);\n          hIndex++;\n        }\n      } else {\n        var span = 0; //Calculation for column span when group caption dont have aggregates\n\n        for (var _c = 0, _d = headerRow.columns; _c < _d.length; _c++) {\n          var col_1 = _d[_c];\n\n          if (col_1.visible) {\n            span++;\n          }\n        }\n\n        cell.colSpan = dataSource.childLevels + span;\n      }\n\n      excelRows[excelRows.length - 1].cells = cells;\n      this.rowLength++;\n\n      if (this.groupedColLength < 8 && level > 1) {\n        var grouping = {\n          outlineLevel: level - 1,\n          isCollapsed: true\n        };\n        excelRows[excelRows.length - 1].grouping = grouping;\n      }\n\n      if (!isNullOrUndefined(dataSource.childLevels) && dataSource.childLevels > 0) {\n        this.processGroupedRows(gObj, item.items, headerRow, item.items.level, startIndex, excelExportProperties, excelRows, helper);\n        this.processAggregates(gObj, item, excelRows, undefined, level - 1 + dataSource.childLevels, true);\n      } else {\n        startIndex = this.processRecordRows(gObj, item.items, headerRow, level - 1, startIndex, excelExportProperties, excelRows, helper);\n        this.processAggregates(gObj, item, excelRows, undefined, level - 1, true);\n      }\n    }\n  };\n\n  ExcelExport.prototype.processRecordRows = function (gObj, record, headerRow, level, startIndex, excelExportProperties, excelRows, helper) {\n    var index = 1;\n    var cells = [];\n    var columns = headerRow.columns;\n    var rows = helper.getGridRowModel(columns, record, gObj, startIndex);\n\n    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n      var row = rows_1[_i];\n      cells = [];\n      startIndex++;\n      index = 1;\n      var templateRowHeight = void 0;\n\n      for (var c = 0, len = row.cells.length; c < len; c++) {\n        var gCell = row.cells[c];\n\n        if (gCell.cellType !== CellType.Data) {\n          continue;\n        }\n\n        var column = gCell.column;\n        var field = column.field;\n        var cellValue = !isNullOrUndefined(field) ? column.valueAccessor(field, row.data, column) : '';\n        var value = !isNullOrUndefined(cellValue) ? cellValue : '';\n        var fkData = void 0;\n\n        if (column.isForeignColumn && column.isForeignColumn()) {\n          fkData = helper.getFData(value, column);\n          value = getValue(column.foreignKeyValue, fkData);\n        }\n\n        if (!isNullOrUndefined(value)) {\n          var cell = {};\n          var idx = index + level + gObj.childGridLevel; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          var excelCellArgs = {\n            data: row.data,\n            column: column,\n            foreignKeyData: fkData,\n            value: value,\n            style: undefined,\n            colSpan: 1,\n            cell: cell\n          };\n          gObj.trigger(excelQueryCellInfo, excelCellArgs);\n\n          if (!isNullOrUndefined(excelCellArgs.image) && !isNullOrUndefined(excelCellArgs.image.base64)) {\n            templateRowHeight = this.setImage(excelCellArgs, idx);\n\n            if (excelCellArgs.image.height && excelCellArgs.value !== '') {\n              templateRowHeight += 30;\n            }\n          }\n\n          if (!isNullOrUndefined(excelCellArgs.hyperLink)) {\n            excelCellArgs.cell.hyperlink = {\n              target: excelCellArgs.hyperLink.target\n            };\n            excelCellArgs.value = excelCellArgs.hyperLink.displayText || excelCellArgs.value;\n          }\n\n          cell = excelCellArgs.cell;\n          cell.index = idx;\n          cell.value = excelCellArgs.value;\n\n          if (excelCellArgs.data === '' && gObj.childGridLevel && index === 1) {\n            var style = {};\n            style.hAlign = 'left';\n            excelCellArgs = {\n              style: style\n            };\n            cell.colSpan = gObj.getVisibleColumns().length;\n            cell.value = this.l10n.getConstant('EmptyRecord');\n          }\n\n          if (excelCellArgs.colSpan > 1) {\n            cell.colSpan = excelCellArgs.colSpan;\n          }\n\n          if (!isNullOrUndefined(excelCellArgs.style)) {\n            var styleIndex = this.getColumnStyle(gObj, index + level);\n            cell.style = this.mergeOptions(this.styles[styleIndex], excelCellArgs.style);\n          } else {\n            cell.style = {\n              name: gObj.element.id + 'column' + (index + level)\n            };\n          }\n\n          cells.push(cell);\n        }\n\n        index++;\n      }\n\n      var excelRow = {\n        index: this.rowLength++,\n        cells: cells\n      };\n\n      if (!isNullOrUndefined(templateRowHeight)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        excelRow.height = templateRowHeight;\n      }\n\n      if (this.groupedColLength && this.groupedColLength < 8 && level + 1 > 0) {\n        excelRow.grouping = {\n          outlineLevel: level + 1,\n          isCollapsed: true\n        };\n        excelRows.push(excelRow);\n      } else {\n        excelRows.push(excelRow);\n      }\n\n      if (row.isExpand && !isNullOrUndefined(gObj.childGrid)) {\n        gObj.isPrinting = true;\n        var exportType = !isNullOrUndefined(excelExportProperties) && excelExportProperties.exportType ? excelExportProperties.exportType : 'AllPages';\n        var returnVal = this.helper.createChildGrid(gObj, row, exportType, this.gridPool);\n        var childGridObj = returnVal.childGrid;\n        var element = returnVal.element;\n        childGridObj.actionFailure = helper.failureHandler(this.gridPool, childGridObj, this.globalResolve);\n        childGridObj.childGridLevel = gObj.childGridLevel + 1;\n        var args = {\n          childGrid: childGridObj,\n          row: row,\n          exportProperties: excelExportProperties\n        };\n        this.parent.trigger(exportDetailDataBound, args);\n        childGridObj.beforeDataBound = this.childGridCell(excelRow, childGridObj, excelExportProperties, row);\n        childGridObj.appendTo(element);\n      }\n\n      gObj.notify(exportRowDataBound, {\n        rowObj: row,\n        type: 'excel',\n        excelRows: excelRows\n      });\n    }\n\n    return startIndex;\n  };\n\n  ExcelExport.prototype.setImage = function (args, idx) {\n    if (isNullOrUndefined(this.sheet.images)) {\n      this.sheet.images = [];\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var excelImage = {\n      image: args.image.base64,\n      row: this.rowLength,\n      column: idx,\n      lastRow: this.rowLength,\n      lastColumn: idx\n    };\n\n    if (args.image.width && args.image.height) {\n      excelImage.width = args.image.width;\n      excelImage.height = args.image.height;\n    }\n\n    this.sheet.images.push(excelImage);\n    this.columns[idx - 1].width = args.image.width || this.columns[idx - 1].width;\n    return args.image.height || 50;\n  };\n\n  ExcelExport.prototype.childGridCell = function (excelRow, childGridObj, excelExportProps, gRow) {\n    var _this = this;\n\n    return function (result) {\n      childGridObj.beforeDataBound = null;\n      result.cancel = true;\n\n      if (result.result.length === 0) {\n        result.result = [''];\n      }\n\n      excelRow.childRows = _this.processGridExport(childGridObj, excelExportProps, result);\n      var intent = _this.parent.groupSettings.columns.length;\n      var rows = excelRow.childRows;\n\n      for (var i = 0; i < rows.length; i++) {\n        rows[i].grouping = {\n          outlineLevel: intent + childGridObj.childGridLevel,\n          isCollapsed: !gRow.isExpand,\n          isHidden: !gRow.isExpand\n        };\n      }\n\n      childGridObj.destroy();\n      detach(childGridObj.element);\n      _this.gridPool[childGridObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n\n      return excelRow;\n    };\n  };\n\n  ExcelExport.prototype.processAggregates = function (gObj, rec, excelRows, currentViewRecords, indent, byGroup) {\n    var summaryModel = new SummaryModelGenerator(gObj);\n    var columns = summaryModel.getColumns();\n    columns = columns.filter(function (col) {\n      return isNullOrUndefined(col.commands) && col.type !== 'checkbox';\n    });\n\n    if (gObj.aggregates.length && this.parent !== gObj) {\n      gObj.aggregateModule.prepareSummaryInfo();\n    }\n\n    var data = undefined;\n\n    if (!isNullOrUndefined(currentViewRecords)) {\n      data = currentViewRecords;\n    } else {\n      data = rec;\n    }\n\n    if (indent === undefined) {\n      indent = 0;\n    }\n\n    if (gObj.groupSettings.columns.length > 0 && byGroup) {\n      var groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n      var groupSummaryRows = groupSummaryModel.generateRows(data, {\n        level: data.level\n      });\n\n      if (groupSummaryRows.length > 0) {\n        excelRows = this.fillAggregates(gObj, groupSummaryRows, indent, excelRows);\n      }\n    } else {\n      indent = gObj.groupSettings.columns.length > 0 && !byGroup ? gObj.groupSettings.columns.length : indent;\n      var sRows = summaryModel.generateRows(data, rec.aggregates, null, null, columns);\n\n      if (sRows.length > 0 && !byGroup) {\n        indent = gObj.groupSettings.columns.length ? indent - 1 : indent;\n        excelRows = this.fillAggregates(gObj, sRows, indent, excelRows);\n      }\n    }\n\n    return excelRows;\n  };\n\n  ExcelExport.prototype.fillAggregates = function (gObj, rows, indent, excelRows, customIndex) {\n    for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {\n      var row = rows_2[_i];\n      var cells = [];\n      var isEmpty = true;\n      var index = 0;\n\n      for (var _a = 0, _b = row.cells; _a < _b.length; _a++) {\n        var cell = _b[_a]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        var eCell = {};\n\n        if (cell.cellType === CellType.DetailFooterIntent) {\n          continue;\n        }\n\n        if (cell.visible || this.includeHiddenColumn) {\n          index++;\n\n          if (cell.isDataCell) {\n            isEmpty = false;\n            var footerTemplate = !isNullOrUndefined(cell.column.footerTemplate);\n            var groupFooterTemplate = !isNullOrUndefined(cell.column.groupFooterTemplate);\n            var groupCaptionTemplate = !isNullOrUndefined(cell.column.groupCaptionTemplate);\n            eCell.index = index + indent + gObj.childGridLevel;\n\n            if (footerTemplate) {\n              eCell.value = this.getAggreateValue(CellType.Summary, cell.column.footerTemplate, cell, row);\n            } else if (groupFooterTemplate) {\n              eCell.value = this.getAggreateValue(CellType.GroupSummary, cell.column.groupFooterTemplate, cell, row);\n            } else if (groupCaptionTemplate) {\n              eCell.value = this.getAggreateValue(CellType.CaptionSummary, cell.column.groupCaptionTemplate, cell, row);\n            } else {\n              for (var _c = 0, _d = Object.keys(row.data[cell.column.field]); _c < _d.length; _c++) {\n                var key = _d[_c];\n\n                if (key === cell.column.type) {\n                  if (!isNullOrUndefined(row.data[cell.column.field].Sum)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - sum\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Average)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - average\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Max)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - max\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Min)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - min\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Count)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - count\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].TrueCount)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - truecount\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].FalseCount)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - falsecount\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Custom)) {\n                    eCell.value = row.data[cell.column.field].Custom;\n                  }\n                }\n              }\n            }\n\n            eCell.style = this.getCaptionThemeStyle(this.theme); //{ name: gObj.element.id + 'column' + index };\n\n            this.aggregateStyle(cell.column, eCell.style, cell.column.field);\n            var gridCellStyle = cell.attributes.style;\n\n            if (gridCellStyle.textAlign) {\n              eCell.style.hAlign = gridCellStyle.textAlign.toLowerCase();\n            }\n\n            var args = {\n              row: row,\n              type: footerTemplate ? 'Footer' : groupFooterTemplate ? 'GroupFooter' : 'GroupCaption',\n              style: eCell\n            };\n            this.parent.trigger(excelAggregateQueryCellInfo, args);\n            cells.push(eCell);\n          } else {\n            if (customIndex === undefined) {\n              eCell.index = index + indent + gObj.childGridLevel;\n              eCell.style = this.getCaptionThemeStyle(this.theme); //{ name: gObj.element.id + 'column' + index };\n\n              cells.push(eCell);\n            }\n          }\n        }\n      }\n\n      if (!isNullOrUndefined(customIndex)) {\n        excelRows.push({\n          index: customIndex,\n          cells: cells\n        });\n      } else {\n        var row_1 = {};\n\n        if (this.groupedColLength < 8 && this.groupedColLength > 0) {\n          var dummyOutlineLevel = 'outlineLevel';\n          var dummyGrouping = 'grouping';\n          var level = excelRows[excelRows.length - 1][dummyGrouping][dummyOutlineLevel];\n          var grouping = {\n            outlineLevel: level,\n            isCollapsed: true\n          };\n          row_1 = {\n            index: this.rowLength++,\n            cells: cells,\n            grouping: grouping\n          };\n        } else {\n          row_1 = {\n            index: this.rowLength++,\n            cells: cells\n          };\n        }\n\n        if (!isEmpty) {\n          excelRows.push(row_1);\n        }\n      }\n    }\n\n    return excelRows;\n  };\n\n  ExcelExport.prototype.aggregateStyle = function (col, style, field) {\n    var column = this.parent.getColumnByField(field);\n\n    if (typeof col.format === 'object') {\n      var format = col.format;\n      style.numberFormat = !isNullOrUndefined(format.format) ? format.format : format.skeleton;\n\n      if (!isNullOrUndefined(format.type)) {\n        style.type = format.type.toLowerCase();\n      }\n    } else {\n      style.numberFormat = col.format;\n    }\n\n    if (!isNullOrUndefined(column) && isNullOrUndefined(style.type)) {\n      style.type = column.type.toLowerCase();\n    }\n  };\n\n  ExcelExport.prototype.getAggreateValue = function (cellType, template, cell, row) {\n    var templateFn = {};\n    templateFn[getEnumValue(CellType, cell.cellType)] = compile(template);\n    var txt;\n    var data = row.data[cell.column.field ? cell.column.field : cell.column.columnName];\n\n    if (this.parent.isReact || this.parent.isVue) {\n      txt = templateFn[getEnumValue(CellType, cell.cellType)](data, this.parent);\n\n      if (this.parent.isReact) {\n        this.parent.renderTemplates();\n      }\n    } else {\n      txt = templateFn[getEnumValue(CellType, cell.cellType)](data);\n    }\n\n    return txt[0].textContent;\n  };\n\n  ExcelExport.prototype.mergeOptions = function (JSON1, JSON2) {\n    var result = {};\n    var attrname = Object.keys(JSON1);\n\n    for (var index = 0; index < attrname.length; index++) {\n      if (attrname[index] !== 'name') {\n        result[attrname[index]] = JSON1[attrname[index]];\n      }\n    }\n\n    attrname = Object.keys(JSON2);\n\n    for (var index = 0; index < attrname.length; index++) {\n      if (attrname[index] !== 'name') {\n        result[attrname[index]] = JSON2[attrname[index]];\n      }\n    }\n\n    return result;\n  };\n\n  ExcelExport.prototype.getColumnStyle = function (gObj, columnIndex) {\n    var index = 0;\n\n    for (var _i = 0, _a = this.styles; _i < _a.length; _i++) {\n      var style = _a[_i];\n\n      if (style.name === gObj.element.id + 'column' + columnIndex) {\n        return index;\n      }\n\n      index++;\n    }\n\n    return undefined;\n  };\n\n  ExcelExport.prototype.headerRotation = function (args) {\n    var degree = args.style.rotation;\n\n    if (degree <= 90 && degree >= 0) {\n      args.style.hAlign = 'Left';\n    } else if (degree > 90 && degree <= 180) {\n      args.style.hAlign = 'Right';\n    } else {\n      degree = 180;\n      args.style.hAlign = 'Right';\n    }\n\n    args.style.rotation = degree;\n  };\n\n  ExcelExport.prototype.processHeaderContent = function (gObj, headerRow, indent, excelRows) {\n    var rowIndex = 1;\n    var gridRows = headerRow.rows; // Column collection with respect to the records in the grid\n\n    var gridColumns = headerRow.columns;\n    var spannedCells = [];\n\n    if (indent > 0) {\n      var index = 0;\n\n      while (index !== indent) {\n        this.columns.push({\n          index: index + 1,\n          width: 30\n        });\n        index++;\n      }\n    }\n\n    for (var col = 0; col < gridColumns.length; col++) {\n      this.parseStyles(gObj, gridColumns[col], this.getRecordThemeStyle(this.theme), indent + col + 1);\n    }\n\n    var templateRowHeight;\n\n    for (var row = 0; row < gridRows.length; row++) {\n      var currentCellIndex = 1 + indent;\n      var cells = [];\n\n      for (var column = 0; column < gridRows[row].cells.length; column++) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var style = {};\n        var cell = {};\n        var gridCell = gridRows[row].cells[column];\n\n        if (gridCell.cellType === CellType.HeaderIndent || gridCell.cellType === CellType.DetailHeader) {\n          continue;\n        }\n\n        var result = {\n          contains: true,\n          index: 1\n        };\n\n        while (result.contains) {\n          result = this.getIndex(spannedCells, rowIndex, currentCellIndex);\n          currentCellIndex = result.index;\n\n          if (!result.contains) {\n            cell.index = result.index + gObj.childGridLevel;\n            break;\n          }\n        }\n\n        if (!isNullOrUndefined(gridCell.rowSpan) && gridCell.rowSpan !== 1) {\n          cell.rowSpan = gridCell.rowSpan;\n\n          for (var i = rowIndex; i < gridCell.rowSpan + rowIndex; i++) {\n            var spannedCell = {\n              rowIndex: 0,\n              columnIndex: 0\n            };\n            spannedCell.rowIndex = i;\n            spannedCell.columnIndex = currentCellIndex;\n            spannedCells.push(spannedCell);\n          }\n        }\n\n        if (!isNullOrUndefined(gridCell.colSpan) && gridCell.colSpan !== 1) {\n          cell.colSpan = gridCell.colSpan;\n          currentCellIndex = currentCellIndex + cell.colSpan - 1;\n        }\n\n        cell.value = gridCell.column.headerText;\n        style = this.getHeaderThemeStyle(this.theme);\n\n        if (!isNullOrUndefined(gridCell.column.textAlign)) {\n          style.hAlign = gridCell.column.textAlign.toLowerCase();\n        }\n\n        if (!isNullOrUndefined(gridCell.column.headerTextAlign)) {\n          style.hAlign = gridCell.column.headerTextAlign.toLowerCase();\n        }\n\n        var excelHeaderCellArgs = {\n          cell: cell,\n          gridCell: gridCell,\n          style: style\n        };\n        gObj.trigger(excelHeaderQueryCellInfo, excelHeaderCellArgs);\n\n        if (excelHeaderCellArgs.style.rotation) {\n          this.headerRotation(excelHeaderCellArgs);\n        }\n\n        if (!isNullOrUndefined(excelHeaderCellArgs.image) && !isNullOrUndefined(excelHeaderCellArgs.image.base64)) {\n          templateRowHeight = this.setImage(excelHeaderCellArgs, currentCellIndex);\n        }\n\n        if (!isNullOrUndefined(excelHeaderCellArgs.hyperLink)) {\n          excelHeaderCellArgs.cell.hyperlink = {\n            target: excelHeaderCellArgs.hyperLink.target\n          };\n          cell.value = excelHeaderCellArgs.hyperLink.displayText || cell.value;\n        }\n\n        cell.style = excelHeaderCellArgs.style;\n        cells.push(cell);\n        currentCellIndex++;\n      }\n\n      var excelRow = {\n        index: this.rowLength++,\n        cells: cells\n      };\n\n      if (!isNullOrUndefined(templateRowHeight)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        excelRow.height = templateRowHeight;\n      }\n\n      excelRows.push(excelRow);\n    }\n\n    return excelRows;\n  };\n\n  ExcelExport.prototype.getHeaderThemeStyle = function (theme) {\n    var style = {};\n    style.fontSize = 12;\n    style.borders = {\n      color: '#E0E0E0'\n    };\n    style.bold = true;\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.header)) {\n      style = this.updateThemeStyle(theme.header, style);\n    }\n\n    return style;\n  };\n\n  ExcelExport.prototype.updateThemeStyle = function (themestyle, style) {\n    return extend(style, themestyle);\n  };\n\n  ExcelExport.prototype.getCaptionThemeStyle = function (theme) {\n    var style = {};\n    style.fontSize = 13;\n    style.backColor = '#F6F6F6';\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.caption)) {\n      style = this.updateThemeStyle(theme.caption, style);\n    }\n\n    return style;\n  };\n\n  ExcelExport.prototype.getRecordThemeStyle = function (theme) {\n    var style = {};\n    style.fontSize = 13;\n    style.borders = {\n      color: '#E0E0E0'\n    };\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.record)) {\n      style = this.updateThemeStyle(theme.record, style);\n    }\n\n    return style;\n  };\n\n  ExcelExport.prototype.processExcelHeader = function (header) {\n    if (!isNullOrUndefined(header.rows) && (this.expType === 'NewSheet' || this.rowLength === 1)) {\n      var noRows = void 0;\n\n      if (header.headerRows === undefined) {\n        this.rowLength = header.rows.length;\n      } else {\n        this.rowLength = header.headerRows;\n      }\n\n      if (this.rowLength < header.rows.length) {\n        noRows = this.rowLength;\n      } else {\n        noRows = header.rows.length;\n      }\n\n      this.rowLength++;\n\n      for (var row = 0; row < noRows; row++) {\n        var json = header.rows[row]; //Row index\n\n        if (!(json.index !== null && !isNullOrUndefined(json.index))) {\n          json.index = row + 1;\n        }\n\n        this.updatedCellIndex(json);\n      }\n    }\n  };\n\n  ExcelExport.prototype.updatedCellIndex = function (json) {\n    var cellsLength = json.cells.length;\n\n    for (var cellId = 0; cellId < cellsLength; cellId++) {\n      var jsonCell = json.cells[cellId]; //cell index\n\n      if (!(jsonCell.index !== null && !isNullOrUndefined(jsonCell.index))) {\n        jsonCell.index = cellId + 1;\n      }\n    }\n\n    this.rows.push(json);\n  };\n\n  ExcelExport.prototype.processExcelFooter = function (footer) {\n    if (!isNullOrUndefined(footer.rows)) {\n      var noRows = void 0;\n\n      if (footer.footerRows === undefined) {\n        this.rowLength += footer.rows.length;\n      } else {\n        if (footer.footerRows > footer.rows.length) {\n          this.rowLength += footer.footerRows - footer.rows.length;\n          noRows = footer.rows.length;\n        } else {\n          noRows = footer.footerRows;\n        }\n      }\n\n      for (var row = 0; row < noRows; row++) {\n        var json = footer.rows[row]; //Row index\n\n        if (json.index === null || json.index === undefined) {\n          json.index = this.rowLength++;\n        } else {\n          json.index += this.rowLength;\n        }\n\n        this.updatedCellIndex(json);\n      }\n    }\n  };\n\n  ExcelExport.prototype.getIndex = function (spannedCells, rowIndex, columnIndex) {\n    for (var _i = 0, spannedCells_1 = spannedCells; _i < spannedCells_1.length; _i++) {\n      var spannedCell = spannedCells_1[_i];\n\n      if (spannedCell.rowIndex === rowIndex && spannedCell.columnIndex === columnIndex) {\n        columnIndex = columnIndex + 1;\n        return {\n          contains: true,\n          index: columnIndex\n        };\n      }\n    }\n\n    return {\n      contains: false,\n      index: columnIndex\n    };\n  };\n\n  ExcelExport.prototype.parseStyles = function (gObj, col, style, index) {\n    if (!isNullOrUndefined(col.format)) {\n      if (typeof col.format === 'object') {\n        var format = col.format;\n        style.numberFormat = !isNullOrUndefined(format.format) ? format.format : format.skeleton;\n\n        if (!isNullOrUndefined(format.type)) {\n          style.type = format.type.toLowerCase();\n        }\n      } else {\n        style.numberFormat = col.format;\n        style.type = col.type;\n      }\n    }\n\n    if (!isNullOrUndefined(col.textAlign)) {\n      style.hAlign = col.textAlign.toLowerCase();\n    }\n\n    if (Object.keys(style).length > 0) {\n      style.name = gObj.element.id + 'column' + index;\n      this.styles.push(style);\n    }\n\n    if (!isNullOrUndefined(col.width) && col.width !== 'auto') {\n      this.columns.push({\n        index: index + gObj.childGridLevel,\n        width: typeof col.width === 'number' ? col.width : this.helper.getConvertedWidth(col.width)\n      });\n    }\n  };\n\n  ExcelExport.prototype.destroy = function () {//destroy for exporting\n  };\n\n  return ExcelExport;\n}();\n/**\n * `PDF Export` module is used to handle the exportToPDF action.\n *\n * @hidden\n */\n\n\nvar PdfExport =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid PDF Export module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @hidden\n   */\n  function PdfExport(parent) {\n    this.hideColumnInclude = false;\n    this.currentViewData = false;\n    this.customDataSource = false;\n    this.isGrouping = false;\n    this.headerOnPages = [];\n    this.drawPosition = {\n      xPosition: 0,\n      yPosition: 0\n    };\n    this.parent = parent;\n    this.helper = new ExportHelper(parent);\n    this.gridPool = {};\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  PdfExport.prototype.getModuleName = function () {\n    return 'PdfExport';\n  };\n\n  PdfExport.prototype.init = function (parent) {\n    this.exportValueFormatter = new ExportValueFormatter(parent.locale);\n    this.pdfDocument = undefined;\n    this.hideColumnInclude = false;\n    this.currentViewData = false;\n    this.parent = parent;\n    this.isGrouping = false;\n    this.isExporting = true;\n    parent.id = getUid('main-grid');\n    this.gridPool[parent.id] = false;\n    this.pdfPageSettings = new PdfPageSettings();\n  };\n\n  PdfExport.prototype.exportWithData = function (parent, pdfDoc, resolve, returnType, pdfExportProperties, isMultipleExport, reject) {\n    var _this = this;\n\n    this.init(parent);\n\n    if (!isNullOrUndefined(pdfDoc)) {\n      this.pdfDocument = pdfDoc;\n    } else {\n      this.pdfDocument = new PdfDocument();\n    }\n\n    this.processExport(parent, returnType, pdfExportProperties, isMultipleExport).then(function () {\n      _this.isExporting = false;\n      parent.trigger(pdfExportComplete, _this.isBlob ? {\n        promise: _this.blobPromise\n      } : {});\n\n      _this.parent.log('exporting_complete', _this.getModuleName());\n\n      resolve(_this.pdfDocument);\n    }).catch(function (e) {\n      reject(_this.pdfDocument);\n\n      _this.parent.trigger(actionFailure, e);\n    });\n  };\n  /**\n   * Used to map the input data\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {PdfExportProperties} pdfExportProperties - specifies the PdfExportProperties\n   * @param {boolean} isMultipleExport - specifies the isMultipleExport\n   * @param {Object} pdfDoc - specifies the pdfDoc\n   * @param {boolean} isBlob - speciies whether it is Blob or not\n   * @returns {void}\n   */\n\n\n  PdfExport.prototype.Map = function (parent, pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {\n    var _this = this;\n\n    this.data = new Data(this.parent);\n    this.isBlob = isBlob;\n    this.gridPool = {};\n    var query = new Query();\n\n    if (parent.childGrid && !(!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.hierarchyExportMode === 'None')) {\n      parent.expandedRows = getPrintGridModel(parent).expandedRows;\n    }\n\n    var args = {\n      requestType: 'beforePdfExport',\n      cancel: false,\n      headerPageNumbers: [],\n      gridDrawPosition: {\n        xPosition: 0,\n        yPosition: 0\n      },\n      generateQuery: false\n    };\n    var gridObject = 'gridObject';\n    args[gridObject] = parent;\n    var can = 'cancel';\n    var generateQuery$$1 = 'generateQuery';\n    var header = 'headerPageNumbers';\n    var drawPos = 'gridDrawPosition';\n    parent.trigger(beforePdfExport, args);\n\n    if (args[can] === true) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      return new Promise(function (resolve, reject) {\n        return resolve();\n      });\n    }\n\n    if (isExportColumns(pdfExportProperties)) {\n      updateColumnTypeForExportColumns(pdfExportProperties, parent);\n    }\n\n    if (args[generateQuery$$1]) {\n      query = ExportHelper.getQuery(parent, this.data);\n    }\n\n    this.headerOnPages = args[header];\n    this.drawPosition = args[drawPos];\n    this.parent.log('exporting_begin', this.getModuleName());\n\n    if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.dataSource) && pdfExportProperties.dataSource instanceof DataManager) {\n      return new Promise(function (resolve, reject) {\n        pdfExportProperties.dataSource.executeQuery(query).then(function (returnType) {\n          _this.exportWithData(parent, pdfDoc, resolve, returnType, pdfExportProperties, isMultipleExport, reject);\n        });\n      });\n    } else if (!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.exportType === 'CurrentPage') {\n      return new Promise(function (resolve, reject) {\n        _this.exportWithData(parent, pdfDoc, resolve, _this.parent.getCurrentViewRecords(), pdfExportProperties, isMultipleExport, reject);\n      });\n    } else {\n      var allPromise_1 = [];\n      allPromise_1.push(this.data.getData({}, ExportHelper.getQuery(parent, this.data)));\n      allPromise_1.push(this.helper.getColumnData(parent));\n      return new Promise(function (resolve, reject) {\n        Promise.all(allPromise_1).then(function (e) {\n          _this.init(parent);\n\n          if (!isNullOrUndefined(pdfDoc)) {\n            _this.pdfDocument = pdfDoc;\n          } else {\n            _this.pdfDocument = new PdfDocument();\n          }\n\n          _this.processExport(parent, e[0], pdfExportProperties, isMultipleExport).then(function () {\n            _this.isExporting = false;\n            parent.trigger(pdfExportComplete, _this.isBlob ? {\n              promise: _this.blobPromise\n            } : {});\n\n            _this.parent.log('exporting_complete', _this.getModuleName());\n\n            resolve(_this.pdfDocument);\n          }).catch(function (e) {\n            reject(_this.pdfDocument);\n\n            _this.parent.trigger(actionFailure, e);\n          });\n        });\n      });\n    }\n  };\n\n  PdfExport.prototype.processExport = function (gObj, returnType, pdfExportProperties, isMultipleExport) {\n    var _this = this;\n\n    var section = this.pdfDocument.sections.add();\n    var pdfGrid;\n    this.processSectionExportProperties(section, pdfExportProperties);\n    var pdfPage = section.pages.add(); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    return new Promise(function (resolve, reject) {\n      pdfGrid = _this.processGridExport(gObj, returnType, pdfExportProperties);\n      _this.globalResolve = resolve;\n      _this.gridPool[gObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n    }).then(function () {\n      // draw the grid\n      var xPosition = 'xPosition';\n      var yPosition = 'yPosition';\n      pdfGrid.draw(pdfPage, _this.drawPosition[xPosition], _this.drawPosition[yPosition]);\n\n      _this.drawHeader(pdfExportProperties);\n\n      if (!isMultipleExport) {\n        // save the PDF\n        if (!_this.isBlob) {\n          if (!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.fileName) {\n            _this.pdfDocument.save(pdfExportProperties.fileName);\n          } else {\n            _this.pdfDocument.save('Export.pdf');\n          }\n        } else {\n          _this.blobPromise = _this.pdfDocument.save();\n        }\n\n        _this.pdfDocument.destroy();\n\n        delete gObj.expandedRows;\n      }\n\n      return _this.pdfDocument;\n    });\n  };\n\n  PdfExport.prototype.processSectionExportProperties = function (section, pdfExportProperties) {\n    if (!isNullOrUndefined(pdfExportProperties) && (!isNullOrUndefined(pdfExportProperties.pageOrientation) || !isNullOrUndefined(pdfExportProperties.pageSize))) {\n      this.pdfPageSettings.orientation = pdfExportProperties.pageOrientation === 'Landscape' ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;\n      this.pdfPageSettings.size = this.getPageSize(pdfExportProperties.pageSize);\n      section.setPageSettings(this.pdfPageSettings);\n    }\n\n    return section;\n  };\n\n  PdfExport.prototype.processGridExport = function (gObj, returnType, pdfExportProperties) {\n    var allowHorizontalOverflow = true;\n    var isFrozen = this.parent.isFrozenGrid() && !this.parent.getFrozenColumns();\n\n    if (!isNullOrUndefined(pdfExportProperties)) {\n      this.gridTheme = pdfExportProperties.theme;\n      allowHorizontalOverflow = isNullOrUndefined(pdfExportProperties.allowHorizontalOverflow) ? true : pdfExportProperties.allowHorizontalOverflow;\n    }\n\n    var helper = new ExportHelper(gObj, this.helper.getForeignKeyData());\n    var dataSource = this.processExportProperties(pdfExportProperties, returnType.result);\n    var columns = isExportColumns(pdfExportProperties) ? prepareColumns(pdfExportProperties.columns, gObj.enableColumnVirtualization) : helper.getGridExportColumns(isFrozen ? gObj.getColumns() : gObj.columns);\n    columns = columns.filter(function (columns) {\n      return isNullOrUndefined(columns.commands);\n    });\n    var isGrouping = false;\n\n    if (gObj.groupSettings.columns.length) {\n      isGrouping = true;\n    }\n\n    if (gObj.childGrid && !isNullOrUndefined(pdfExportProperties)) {\n      gObj.hierarchyPrintMode = pdfExportProperties.hierarchyExportMode || 'Expanded';\n    } // create a grid\n\n\n    var pdfGrid = new PdfGrid(); // get header theme style\n\n    var headerThemeStyle = this.getHeaderThemeStyle();\n    var border = headerThemeStyle.border;\n    var headerFont = headerThemeStyle.font;\n    var headerBrush = headerThemeStyle.brush;\n    var returnValue = helper.getHeaders(columns, this.hideColumnInclude); // Column collection with respect to the records in the grid\n\n    var gridColumns = returnValue.columns; // process grid header content\n\n    pdfGrid = this.processGridHeaders(gObj.groupSettings.columns.length, pdfGrid, returnValue.rows, gridColumns, border, headerFont, headerBrush, gObj, allowHorizontalOverflow, columns); // set alignment, width and type of the values of the column\n\n    this.setColumnProperties(gridColumns, pdfGrid, helper, gObj, allowHorizontalOverflow);\n    var captionThemeStyle = this.getSummaryCaptionThemeStyle();\n\n    if (!isNullOrUndefined(dataSource) && dataSource.length) {\n      if (isGrouping) {\n        if (!isNullOrUndefined(captionThemeStyle.border)) {\n          border = captionThemeStyle.border;\n        }\n\n        this.processGroupedRecords(pdfGrid, dataSource, gridColumns, gObj, border, 0, captionThemeStyle.font, captionThemeStyle.brush, captionThemeStyle.backgroundBrush, returnType, pdfExportProperties, helper, 0);\n      } else {\n        this.processRecord(border, gridColumns, gObj, dataSource, pdfGrid, 0, pdfExportProperties, helper, 0);\n      }\n\n      if (!isNullOrUndefined(returnType.aggregates)) {\n        var summaryModel = new SummaryModelGenerator(gObj);\n        var sRows = void 0;\n        var column = summaryModel.getColumns();\n        column = column.filter(function (col) {\n          return isNullOrUndefined(col.commands) && col.type !== 'checkbox';\n        });\n\n        if (gObj.aggregates.length && this.parent !== gObj) {\n          gObj.aggregateModule.prepareSummaryInfo();\n        }\n\n        if (this.customDataSource) {\n          sRows = summaryModel.generateRows(dataSource, returnType.aggregates);\n        } else if (this.currentViewData) {\n          sRows = summaryModel.generateRows(this.parent.getCurrentViewRecords(), returnType.aggregates);\n        } else if (isGrouping) {\n          sRows = summaryModel.generateRows(dataSource.records, returnType.aggregates);\n        } else {\n          sRows = summaryModel.generateRows(returnType.result, returnType.aggregates, null, null, column);\n        }\n\n        this.processAggregates(sRows, pdfGrid, border, captionThemeStyle.font, captionThemeStyle.brush, captionThemeStyle.backgroundBrush, false, null, null, null, isGrouping ? false : true);\n      }\n    } else {\n      var row = pdfGrid.rows.addRow();\n      row.style.setBorder(border);\n    }\n\n    return pdfGrid;\n  };\n\n  PdfExport.prototype.getSummaryCaptionThemeStyle = function () {\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.caption)) {\n      var fontSize = !isNullOrUndefined(this.gridTheme.caption.fontSize) ? this.gridTheme.caption.fontSize : 9.75;\n      var fontFamily = !isNullOrUndefined(this.gridTheme.caption.fontName) ? this.getFontFamily(this.gridTheme.caption.fontName) : PdfFontFamily.Helvetica;\n      var fontStyle = this.getFontStyle(this.gridTheme.caption);\n      var pdfColor = new PdfColor(0, 0, 0);\n\n      if (!isNullOrUndefined(this.gridTheme.caption.fontColor)) {\n        var penBrushColor = this.hexToRgb(this.gridTheme.caption.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      var borderCaption = this.gridTheme.caption.border ? this.getBorderStyle(this.gridTheme.caption.border) : null;\n      var font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.caption.font)) {\n        font = this.gridTheme.caption.font;\n      }\n\n      return {\n        font: font,\n        brush: new PdfSolidBrush(pdfColor),\n        backgroundBrush: new PdfSolidBrush(new PdfColor(246, 246, 246)),\n        border: borderCaption\n      };\n    } else {\n      //Material theme\n      return {\n        font: new PdfStandardFont(PdfFontFamily.Helvetica, 9.75),\n        brush: new PdfSolidBrush(new PdfColor(0, 0, 0)),\n        backgroundBrush: new PdfSolidBrush(new PdfColor(246, 246, 246))\n      };\n    }\n  };\n\n  PdfExport.prototype.getGridPdfFont = function (args) {\n    var fontFamily = 'fontFamily';\n    var fontSize = 'fontSize';\n    var fontStyle = 'fontStyle';\n    var isTrueType = 'isTrueType';\n    var style = 0;\n\n    if (args.header && args.header.font) {\n      var headerFont = args.header.font[fontFamily];\n      var headerSize = args.header.font[fontSize];\n      var headerStyle = args.header.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[headerStyle]) ? 0 : PdfFontStyle[headerStyle];\n\n      if (args.header.font[isTrueType]) {\n        args.header.font = new PdfTrueTypeFont(headerFont, headerSize, style);\n      } else {\n        var fontFamily_1 = !isNullOrUndefined(headerFont) ? this.getFontFamily(headerFont) : PdfFontFamily.Helvetica;\n        args.header.font = new PdfStandardFont(fontFamily_1, headerSize, style);\n      }\n    }\n\n    if (args.caption && args.caption.font) {\n      var captionFont = args.caption.font[fontFamily];\n      var captionSize = args.caption.font[fontSize];\n      var captionStyle = args.caption.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[captionStyle]) ? 0 : PdfFontStyle[captionStyle];\n\n      if (args.caption.font[isTrueType]) {\n        args.caption.font = new PdfTrueTypeFont(captionFont, captionSize, style);\n      } else {\n        var fontFamily_2 = !isNullOrUndefined(captionFont) ? this.getFontFamily(captionFont) : PdfFontFamily.Helvetica;\n        args.caption.font = new PdfStandardFont(fontFamily_2, captionSize, style);\n      }\n    }\n\n    if (args.record && args.record.font) {\n      var recordFont = args.record.font[fontFamily];\n      var recordSize = args.record.font[fontSize];\n      var recordStyle = args.record.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[recordStyle]) ? 0 : PdfFontStyle[recordStyle];\n\n      if (args.record.font[isTrueType]) {\n        args.record.font = new PdfTrueTypeFont(recordFont, recordSize, style);\n      } else {\n        var fontFamily_3 = !isNullOrUndefined(recordFont) ? this.getFontFamily(recordFont) : PdfFontFamily.Helvetica;\n        args.record.font = new PdfStandardFont(fontFamily_3, recordSize, style);\n      }\n    }\n  };\n\n  PdfExport.prototype.getHeaderThemeStyle = function () {\n    var border = new PdfBorders();\n\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.header)) {\n      var fontFamily = !isNullOrUndefined(this.gridTheme.header.fontName) ? this.getFontFamily(this.gridTheme.header.fontName) : PdfFontFamily.Helvetica;\n      var fontStyle = this.getFontStyle(this.gridTheme.header);\n      var fontSize = !isNullOrUndefined(this.gridTheme.header.fontSize) ? this.gridTheme.header.fontSize : 10.5;\n      var pdfColor = new PdfColor();\n\n      if (!isNullOrUndefined(this.gridTheme.header.fontColor)) {\n        var penBrushColor = this.hexToRgb(this.gridTheme.header.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      var font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.header.font)) {\n        font = this.gridTheme.header.font;\n      }\n\n      return {\n        border: this.getBorderStyle(this.gridTheme.header.border),\n        font: font,\n        brush: new PdfSolidBrush(pdfColor)\n      };\n    } else {\n      //Material theme\n      border.all = new PdfPen(new PdfColor(234, 234, 234));\n      return {\n        border: border,\n        font: new PdfStandardFont(PdfFontFamily.Helvetica, 10.5),\n        brush: new PdfSolidBrush(new PdfColor(102, 102, 102))\n      };\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.processGroupedRecords = function (pdfGrid, dataSource, gridColumns, gObj, border, level, font, brush, backgroundBrush, returnType, pdfExportProperties, helper, index) {\n    var _this = this;\n\n    var groupIndex = level;\n\n    var _loop_1 = function (dataSourceItems) {\n      var row = pdfGrid.rows.addRow();\n      var col = gObj.getColumnByField(dataSourceItems.field); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var args = {\n        value: dataSourceItems.key,\n        column: col,\n        style: undefined,\n        isForeignKey: col.isForeignColumn()\n      };\n      var value = this_1.parent.getColumnByField(dataSourceItems.field).headerText + ': ' + (!col.enableGroupByFormat ? this_1.exportValueFormatter.formatCellValue(args) : dataSourceItems.key) + ' - ' + dataSourceItems.count + (dataSource.count > 1 ? ' items' : ' item');\n      var cArgs = {\n        captionText: value,\n        type: 'PDF',\n        data: dataSourceItems,\n        style: undefined\n      };\n      this_1.parent.trigger(exportGroupCaption, cArgs, function (cArgs) {\n        row.cells.getCell(groupIndex).value = cArgs.captionText;\n        row.cells.getCell(groupIndex).style.stringFormat = new PdfStringFormat(PdfTextAlignment.Left);\n        row.style.setBorder(border);\n        row.style.setFont(font);\n        row.style.setTextBrush(brush);\n        row.style.setBackgroundBrush(backgroundBrush);\n\n        if (!isNullOrUndefined(cArgs.style)) {\n          _this.processCellStyle(row.cells.getCell(groupIndex), cArgs);\n        }\n\n        var sRows;\n        var captionSummaryModel = new CaptionSummaryModelGenerator(gObj);\n\n        if (!isNullOrUndefined(dataSourceItems.items.records)) {\n          sRows = captionSummaryModel.generateRows(dataSourceItems.items.records, dataSourceItems);\n        } else {\n          sRows = captionSummaryModel.generateRows(dataSourceItems.items, dataSourceItems);\n        }\n\n        if (!isNullOrUndefined(sRows) && sRows.length === 0) {\n          row.cells.getCell(groupIndex + 1).columnSpan = pdfGrid.columns.count - (groupIndex + 1);\n        }\n\n        if (!isNullOrUndefined(dataSource.childLevels) && dataSource.childLevels > 0) {\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, true, row, groupIndex);\n\n          _this.processGroupedRecords(pdfGrid, dataSourceItems.items, gridColumns, gObj, border, groupIndex + 1, font, brush, backgroundBrush, returnType, pdfExportProperties, helper, index);\n\n          var groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n          sRows = groupSummaryModel.generateRows(dataSourceItems.items.records, dataSourceItems);\n\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, false);\n        } else {\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, true, row, groupIndex);\n\n          index = _this.processRecord(border, gridColumns, gObj, dataSourceItems.items, pdfGrid, groupIndex + 1, pdfExportProperties, helper, index);\n          var groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n          sRows = groupSummaryModel.generateRows(dataSourceItems.items, dataSourceItems);\n          var isGroupedFooter = true;\n\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, false, null, null, isGroupedFooter);\n        }\n      });\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, dataSource_1 = dataSource; _i < dataSource_1.length; _i++) {\n      var dataSourceItems = dataSource_1[_i];\n\n      _loop_1(dataSourceItems);\n    }\n  };\n\n  PdfExport.prototype.processGridHeaders = function (childLevels, pdfGrid, rows, gridColumn, border, headerFont, headerBrush, grid, allowHorizontalOverflow, eCols) {\n    var _this = this;\n\n    var columnCount = gridColumn.length + childLevels;\n    var depth = measureColumnDepth(eCols);\n    var cols = eCols;\n    var index = 0;\n    var rowNumber = [];\n\n    for (var i = 0; i < rows.length; i++) {\n      rowNumber[i] = 0;\n    }\n\n    if (this.parent.groupSettings.columns.length) {\n      index = this.parent.groupSettings.columns.length - 1;\n      columnCount = columnCount - 1;\n    }\n\n    pdfGrid.columns.add(columnCount);\n    pdfGrid.headers.add(rows.length);\n\n    var applyTextAndSpan = function (rowIdx, colIdx, col, rowSpan, colSpan) {\n      var gridHeader = pdfGrid.headers.getHeader(rowIdx);\n      var pdfCell = gridHeader.cells.getCell(colIdx);\n      var cell = rows[rowIdx].cells[_this.parent.groupSettings.columns.length ? colIdx : rowNumber[rowIdx]];\n      rowNumber[rowIdx] = rowNumber[rowIdx] + 1;\n\n      if (!isNullOrUndefined(col.headerTextAlign)) {\n        pdfCell.style.stringFormat = _this.getHorizontalAlignment(col.headerTextAlign);\n      }\n\n      if (rowSpan > 0) {\n        pdfCell.rowSpan = rowSpan;\n        pdfCell.style.stringFormat = _this.getVerticalAlignment('Bottom', pdfCell.style.stringFormat, col.textAlign);\n      }\n\n      if (colSpan > 0) {\n        pdfCell.columnSpan = colSpan;\n      }\n\n      gridHeader.style.setBorder(border);\n      gridHeader.style.setFont(headerFont);\n      gridHeader.style.setTextBrush(headerBrush);\n      pdfCell.value = col.headerText;\n\n      if (!isNullOrUndefined(cell) && (cell.cellType === CellType.HeaderIndent || cell.cellType === CellType.DetailHeader)) {\n        pdfCell.value = '';\n        pdfCell.width = 20;\n      }\n\n      var args = {\n        cell: pdfCell,\n        gridCell: cell,\n        style: pdfCell.style\n      };\n\n      _this.parent.trigger(pdfHeaderQueryCellInfo, args);\n\n      var evtArgs = args;\n      var setCellBorder = args.style.borders;\n      var setCellFont = args.style.font;\n      var setHeaderBrush = args.style.textBrush;\n\n      if (!isNullOrUndefined(setCellBorder)) {\n        gridHeader.style.setBorder(setCellBorder);\n      }\n\n      if (!isNullOrUndefined(setCellFont)) {\n        gridHeader.style.setFont(setCellFont);\n      }\n\n      if (!isNullOrUndefined(setHeaderBrush)) {\n        gridHeader.style.setTextBrush(setHeaderBrush);\n      }\n\n      if (!isNullOrUndefined(evtArgs.style.verticalAlignment)) {\n        pdfCell.style.stringFormat = _this.getVerticalAlignment(evtArgs.style.verticalAlignment, pdfCell.style.stringFormat);\n      }\n\n      if (!isNullOrUndefined(evtArgs.image)) {\n        pdfCell.value = new PdfBitmap(evtArgs.image.base64);\n      }\n\n      if (!isNullOrUndefined(evtArgs.hyperLink)) {\n        pdfCell.value = _this.setHyperLink(evtArgs);\n      }\n    };\n\n    var recuHeader = function (cols, depth, spanCnt, colIndex, rowIndex, isRoot) {\n      var cidx = 0;\n\n      for (var i = 0; i < cols.length; i++) {\n        if (isRoot) {\n          cidx = cidx + spanCnt + (i === 0 ? 0 : -1);\n          colIndex = cidx;\n          spanCnt = 0;\n        }\n\n        if (!isRoot && !cols[i].visible) {\n          colIndex = colIndex - 1;\n        }\n\n        if (cols[i].columns && cols[i].columns.length) {\n          var newSpanCnt = recuHeader(cols[i].columns, depth - 1, 0, i + colIndex, rowIndex + 1, false);\n          applyTextAndSpan(rowIndex, i + colIndex + index, cols[i], 0, newSpanCnt);\n          spanCnt = spanCnt + newSpanCnt;\n          colIndex = colIndex + newSpanCnt - 1;\n        } else if (cols[i].visible || _this.hideColumnInclude) {\n          spanCnt++;\n          applyTextAndSpan(rowIndex, i + colIndex + index, cols[i], depth, 0);\n        }\n      }\n\n      return spanCnt;\n    };\n\n    recuHeader(cols, depth, 0, 0, 0, true);\n\n    if (pdfGrid.columns.count >= 6 && allowHorizontalOverflow) {\n      pdfGrid.style.allowHorizontalOverflow = true;\n    }\n\n    return pdfGrid;\n  };\n\n  PdfExport.prototype.processExportProperties = function (pdfExportProperties, dataSource) {\n    if (!isNullOrUndefined(pdfExportProperties)) {\n      if (!isNullOrUndefined(pdfExportProperties.theme)) {\n        this.gridTheme = pdfExportProperties.theme;\n      }\n\n      var clientSize = this.pdfPageSettings.size;\n      this.drawHeader(pdfExportProperties);\n\n      if (!isNullOrUndefined(pdfExportProperties.footer)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var footer = pdfExportProperties.footer;\n        var position = new PointF(0, clientSize.width - 80 - footer.fromBottom * 0.75);\n        var size = new SizeF(clientSize.width - 80, footer.height * 0.75);\n        var bounds = new RectangleF(position, size);\n        this.pdfDocument.template.bottom = this.drawPageTemplate(new PdfPageTemplateElement(bounds), footer);\n      }\n\n      if (!isNullOrUndefined(pdfExportProperties.includeHiddenColumn) && !this.isGrouping) {\n        this.hideColumnInclude = pdfExportProperties.includeHiddenColumn;\n      }\n\n      if (!isNullOrUndefined(pdfExportProperties.dataSource)) {\n        if (!(pdfExportProperties.dataSource instanceof DataManager)) {\n          dataSource = pdfExportProperties.dataSource;\n        }\n\n        this.customDataSource = true;\n        this.currentViewData = false;\n      } else if (!isNullOrUndefined(pdfExportProperties.exportType)) {\n        if (pdfExportProperties.exportType === 'CurrentPage') {\n          dataSource = this.parent.currentViewData;\n          this.currentViewData = true;\n          this.customDataSource = false;\n        } else {\n          this.currentViewData = false;\n          this.customDataSource = false;\n        }\n      } else {\n        this.currentViewData = false;\n        this.customDataSource = false;\n      }\n    } else {\n      this.currentViewData = false;\n      this.customDataSource = false;\n    }\n\n    return dataSource;\n  };\n\n  PdfExport.prototype.drawHeader = function (pdfExportProperties) {\n    var _this = this;\n\n    var clientSize = this.pdfPageSettings.size;\n\n    if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.header)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var header = pdfExportProperties.header;\n      var position = new PointF(0, header.fromTop);\n      var size = new SizeF(clientSize.width - 80, header.height * 0.75);\n      var bounds = new RectangleF(position, size);\n\n      if (!this.headerOnPages.length) {\n        this.pdfDocument.template.top = this.drawPageTemplate(new PdfPageTemplateElement(bounds), header);\n      } else {\n        var headerTemplate_1 = this.drawPageTemplate(new PdfPageTemplateElement(bounds), header);\n        this.headerOnPages.filter(function (index) {\n          if (index - 1 >= 0 && index - 1 <= _this.pdfDocument.pages.count - 1) {\n            _this.pdfDocument.pages.getPageByIndex(index - 1).graphics.drawPdfTemplate(headerTemplate_1.template, new PointF(0, 0));\n          }\n        });\n      }\n    }\n  };\n\n  PdfExport.prototype.drawPageTemplate = function (template, element) {\n    for (var _i = 0, _a = element.contents; _i < _a.length; _i++) {\n      var content = _a[_i];\n      this.processContentValidation(content);\n\n      switch (content.type) {\n        case 'Text':\n          if (content.value === '' || content.value === undefined || content.value === null || typeof content.value !== 'string') {\n            throw new Error('please enter the valid input value in text content...');\n          }\n\n          this.drawText(template, content);\n          break;\n\n        case 'PageNumber':\n          this.drawPageNumber(template, content);\n          break;\n\n        case 'Image':\n          if (content.src === undefined || content.src === null || content.src === '') {\n            throw new Error('please enter the valid base64 string in image content...');\n          }\n\n          this.drawImage(template, content);\n          break;\n\n        case 'Line':\n          this.drawLine(template, content);\n          break;\n\n        default:\n          throw new Error('Please set valid content type...');\n      }\n    }\n\n    return template;\n  };\n\n  PdfExport.prototype.processContentValidation = function (content) {\n    if (content.type === undefined || content.type === null) {\n      throw new Error('please set valid content type...');\n    } else {\n      if (content.type === 'Line') {\n        if (content.points === undefined || content.points === null) {\n          throw new Error('please enter valid points in ' + content.type + ' content...');\n        } else {\n          if (content.points.x1 === undefined || content.points.x1 === null || typeof content.points.x1 !== 'number') {\n            throw new Error('please enter valid x1 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.y1 === undefined || content.points.y1 === null || typeof content.points.y1 !== 'number') {\n            throw new Error('please enter valid y1 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.x2 === undefined || content.points.x2 === null || typeof content.points.x2 !== 'number') {\n            throw new Error('please enter valid x2 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.y2 === undefined || content.points.y2 === null || typeof content.points.y2 !== 'number') {\n            throw new Error('please enter valid y2 co-ordinate in ' + content.type + ' points...');\n          }\n        }\n      } else {\n        if (content.position === undefined || content.position === null) {\n          throw new Error('please enter valid position in ' + content.type + ' content...');\n        } else {\n          if (content.position.x === undefined || content.position.x === null || typeof content.position.x !== 'number') {\n            throw new Error('please enter valid x co-ordinate in ' + content.type + ' position...');\n          }\n\n          if (content.position.y === undefined || content.position.y === null || typeof content.position.y !== 'number') {\n            throw new Error('please enter valid y co-ordinate in ' + content.type + ' position...');\n          }\n        }\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.drawText = function (pageTemplate, content) {\n    var font = this.getFont(content);\n    var brush = this.getBrushFromContent(content);\n    var pen = null;\n\n    if (!isNullOrUndefined(content.style.textPenColor)) {\n      var penColor = this.hexToRgb(content.style.textPenColor);\n      pen = new PdfPen(new PdfColor(penColor.r, penColor.g, penColor.b));\n    }\n\n    if (brush == null && pen == null) {\n      brush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    var value = content.value.toString();\n    var x = content.position.x * 0.75;\n    var y = content.position.y * 0.75;\n    var format = new PdfStringFormat();\n\n    if (!isNullOrUndefined(content.style.stringFormat)) {\n      format.alignment = content.style.stringFormat.alignment;\n    }\n\n    var result = this.setContentFormat(content, format);\n\n    if (result !== null && !isNullOrUndefined(result.format) && !isNullOrUndefined(result.size)) {\n      pageTemplate.graphics.drawString(value, font, pen, brush, x, y, result.size.width, result.size.height, result.format);\n    } else {\n      pageTemplate.graphics.drawString(value, font, pen, brush, x, y, format);\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.drawPageNumber = function (documentHeader, content) {\n    var font = this.getFont(content);\n    var brush = null;\n\n    if (!isNullOrUndefined(content.style.textBrushColor)) {\n      var brushColor = this.hexToRgb(content.style.textBrushColor);\n      brush = new PdfSolidBrush(new PdfColor(brushColor.r, brushColor.g, brushColor.b));\n    } else {\n      brush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    var pageNumber = new PdfPageNumberField(font, brush);\n    pageNumber.numberStyle = this.getPageNumberStyle(content.pageNumberType);\n    var compositeField;\n    var format;\n\n    if (!isNullOrUndefined(content.format)) {\n      var total = '$total';\n      var current = '$current';\n\n      if (content.format.indexOf(total) !== -1 && content.format.indexOf(current) !== -1) {\n        var pageCount = new PdfPageCountField(font);\n        pageCount.numberStyle = this.getPageNumberStyle(content.pageNumberType);\n\n        if (content.format.indexOf(total) > content.format.indexOf(current)) {\n          format = content.format.replace(current, '0');\n          format = format.replace(total, '1');\n        } else {\n          format = content.format.replace(current, '1');\n          format = format.replace(total, '0');\n        }\n\n        compositeField = new PdfCompositeField(font, brush, format, pageNumber, pageCount);\n      } else if (content.format.indexOf(current) !== -1 && content.format.indexOf(total) === -1) {\n        format = content.format.replace(current, '0');\n        compositeField = new PdfCompositeField(font, brush, format, pageNumber);\n      } else {\n        var pageCount = new PdfPageCountField(font);\n        format = content.format.replace(total, '0');\n        compositeField = new PdfCompositeField(font, brush, format, pageCount);\n      }\n    } else {\n      format = '{0}';\n      compositeField = new PdfCompositeField(font, brush, format, pageNumber);\n    }\n\n    var x = content.position.x * 0.75;\n    var y = content.position.y * 0.75;\n    var result = this.setContentFormat(content, compositeField.stringFormat);\n\n    if (result !== null && !isNullOrUndefined(result.format) && !isNullOrUndefined(result.size)) {\n      compositeField.stringFormat = result.format;\n      compositeField.bounds = new RectangleF(x, y, result.size.width, result.size.height);\n    }\n\n    compositeField.draw(documentHeader.graphics, x, y);\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.drawImage = function (documentHeader, content) {\n    var x = content.position.x * 0.75;\n    var y = content.position.y * 0.75;\n    var width = !isNullOrUndefined(content.size) ? content.size.width * 0.75 : undefined;\n    var height = !isNullOrUndefined(content.size) ? content.size.height * 0.75 : undefined;\n    var image = new PdfBitmap(content.src);\n\n    if (!isNullOrUndefined(width)) {\n      documentHeader.graphics.drawImage(image, x, y, width, height);\n    } else {\n      documentHeader.graphics.drawImage(image, x, y);\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.drawLine = function (documentHeader, content) {\n    var x1 = content.points.x1 * 0.75;\n    var y1 = content.points.y1 * 0.75;\n    var x2 = content.points.x2 * 0.75;\n    var y2 = content.points.y2 * 0.75;\n    var pen = this.getPenFromContent(content);\n\n    if (!isNullOrUndefined(content.style) && content.style !== null) {\n      if (!isNullOrUndefined(content.style.penSize) && content.style.penSize !== null && typeof content.style.penSize === 'number') {\n        pen.width = content.style.penSize * 0.75;\n      }\n\n      pen.dashStyle = this.getDashStyle(content.style.dashStyle);\n    }\n\n    documentHeader.graphics.drawLine(pen, x1, y1, x2, y2);\n  };\n\n  PdfExport.prototype.processAggregates = function (sRows, pdfGrid, border, font, brush, backgroundBrush, isCaption, captionRow, groupIndex, isGroupedFooter, isAggregate) {\n    for (var _i = 0, sRows_1 = sRows; _i < sRows_1.length; _i++) {\n      var row = sRows_1[_i];\n      var leastCaptionSummaryIndex = -1;\n      var index = 0;\n      var isEmpty = true; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var value = [];\n      var aggIdx = isAggregate ? 0 : 1;\n\n      for (var i = 0; i < pdfGrid.columns.count + aggIdx; i++) {\n        var cell = row.cells[index];\n\n        if (cell.cellType === CellType.DetailFooterIntent) {\n          i--;\n          index++;\n          continue;\n        }\n\n        if (!this.hideColumnInclude) {\n          while (cell.visible === undefined) {\n            if (cell.cellType === CellType.DetailFooterIntent) {\n              continue;\n            }\n\n            if (!isNullOrUndefined(captionRow)) {\n              if (!isNullOrUndefined(captionRow.cells.getCell(i).value)) {\n                var args = {\n                  row: row,\n                  type: 'GroupCaption',\n                  style: captionRow.cells\n                };\n                this.parent.trigger(pdfAggregateQueryCellInfo, args);\n                value.push(captionRow.cells.getCell(i).value);\n                isEmpty = false;\n\n                if (!isCaption) {\n                  i += 1;\n                }\n              } else {\n                value.push('');\n              }\n            } else {\n              value.push('');\n            }\n\n            i += 1;\n            index = index + 1;\n            cell = row.cells[index];\n          }\n\n          while (!isNullOrUndefined(cell.visible) && !cell.visible) {\n            index = index + 1;\n            cell = row.cells[index];\n          }\n        }\n\n        if (cell.isDataCell) {\n          var templateFn = {};\n\n          if (!isNullOrUndefined(cell.column.footerTemplate) || !isNullOrUndefined(cell.column.groupCaptionTemplate) || !isNullOrUndefined(cell.column.groupFooterTemplate)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var result = this.getTemplateFunction(templateFn, i, leastCaptionSummaryIndex, cell);\n            templateFn = result.templateFunction;\n            leastCaptionSummaryIndex = result.leastCaptionSummaryIndex;\n            var txt = void 0;\n            var data = row.data[cell.column.field ? cell.column.field : cell.column.columnName];\n\n            if (this.parent.isReact || this.parent.isVue) {\n              txt = templateFn[getEnumValue(CellType, cell.cellType)](data, this.parent);\n\n              if (this.parent.isReact) {\n                this.parent.renderTemplates();\n              }\n            } else {\n              txt = templateFn[getEnumValue(CellType, cell.cellType)](data);\n            }\n\n            value.push(txt[0].textContent);\n            isEmpty = false;\n          } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var result = this.getSummaryWithoutTemplate(row.data[cell.column.field]);\n\n            if (!isNullOrUndefined(result)) {\n              value.push(result);\n            }\n          }\n        } else {\n          value.push('');\n        }\n\n        if (isEmpty && value[i] !== '' && !isNullOrUndefined(value[i]) && value[i] !== null) {\n          isEmpty = false;\n        }\n\n        index += 1;\n      }\n\n      if (!isAggregate) {\n        if (!isCaption) {\n          value.splice(0, 1);\n        } else {\n          for (var i = this.parent.groupSettings.columns.length; i < value.length - 1; i++) {\n            value[i] = value[i + 1];\n            value[i + 1] = value[i + 2] ? value[i + 2] : '';\n          }\n        }\n      }\n\n      if (!isEmpty) {\n        if (!isCaption) {\n          var gridRow = pdfGrid.rows.addRow();\n          gridRow.style.setBorder(border);\n          gridRow.style.setFont(font);\n          gridRow.style.setTextBrush(brush);\n          gridRow.style.setBackgroundBrush(backgroundBrush);\n          var args = {\n            row: row,\n            type: isGroupedFooter ? 'GroupFooter' : 'Footer',\n            style: gridRow.cells\n          };\n          this.parent.trigger(pdfAggregateQueryCellInfo, args);\n\n          for (var i = 0; i < pdfGrid.columns.count; i++) {\n            gridRow.cells.getCell(i).value = value[i].toString();\n          }\n        } else {\n          for (var i = 0; i < pdfGrid.columns.count; i++) {\n            captionRow.cells.getCell(i).value = value[i].toString();\n\n            if (i === groupIndex && leastCaptionSummaryIndex !== -1 && leastCaptionSummaryIndex !== 1) {\n              captionRow.cells.getCell(i).columnSpan = leastCaptionSummaryIndex - 1 - groupIndex;\n            } else if (i === groupIndex && leastCaptionSummaryIndex === -1) {\n              captionRow.cells.getCell(i).columnSpan = pdfGrid.columns.count - groupIndex;\n            }\n          }\n        }\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.getTemplateFunction = function (templateFn, index, leastCaptionSummaryIndex, cell) {\n    if (!isNullOrUndefined(cell.column.footerTemplate) && cell.cellType === CellType.Summary) {\n      templateFn[getEnumValue(CellType, CellType.Summary)] = compile(cell.column.footerTemplate);\n    } else if (!isNullOrUndefined(cell.column.groupCaptionTemplate)) {\n      if (leastCaptionSummaryIndex === -1) {\n        leastCaptionSummaryIndex = index;\n      }\n\n      templateFn[getEnumValue(CellType, CellType.CaptionSummary)] = compile(cell.column.groupCaptionTemplate);\n    } else {\n      templateFn[getEnumValue(CellType, CellType.GroupSummary)] = compile(cell.column.groupFooterTemplate);\n    }\n\n    return {\n      templateFunction: templateFn,\n      leastCaptionSummaryIndex: leastCaptionSummaryIndex\n    };\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.getSummaryWithoutTemplate = function (data) {\n    if (!isNullOrUndefined(data.Sum)) {\n      return data.Sum;\n    } else if (!isNullOrUndefined(data.Average)) {\n      return data.Average;\n    } else if (!isNullOrUndefined(data.Max)) {\n      return data.Max;\n    } else if (!isNullOrUndefined(data.Min)) {\n      return data.Min;\n    } else if (!isNullOrUndefined(data.Count)) {\n      return data.Count;\n    } else if (!isNullOrUndefined(data.TrueCount)) {\n      return data.TrueCount;\n    } else if (!isNullOrUndefined(data.FalseCount)) {\n      return data.FalseCount;\n    } else if (!isNullOrUndefined(data.Custom)) {\n      return data.Custom;\n    }\n  };\n  /**\n   * Set alignment, width and type of the values of the column\n   *\n   * @param {Column[]} gridColumns - specifies the grid column\n   * @param {PdfGrid} pdfGrid - specifies the pdfGrid\n   * @param {ExportHelper} helper - specifies the helper\n   * @param {IGrid} gObj - specifies the IGrid\n   * @param {boolean} allowHorizontalOverflow - specifies the allowHorizontalOverflow\n   * @returns {void}\n   */\n\n\n  PdfExport.prototype.setColumnProperties = function (gridColumns, pdfGrid, helper, gObj, allowHorizontalOverflow) {\n    var startIndex = gObj.groupSettings.columns.length ? gObj.groupSettings.columns.length - 1 : 0;\n\n    for (var i = 0; i < startIndex; i++) {\n      pdfGrid.columns.getColumn(i).width = 20;\n    }\n\n    for (var i = 0; i < gridColumns.length; i++) {\n      if (!isNullOrUndefined(gridColumns[i].textAlign)) {\n        pdfGrid.columns.getColumn(i + startIndex).format = this.getHorizontalAlignment(gridColumns[i].textAlign);\n      } // Need to add width consideration with % value\n\n\n      if (pdfGrid.style.allowHorizontalOverflow && !isNullOrUndefined(gridColumns[i].width) && allowHorizontalOverflow) {\n        pdfGrid.columns.getColumn(i + startIndex).width = typeof gridColumns[i].width === 'number' ? gridColumns[i].width * 0.75 : helper.getConvertedWidth(gridColumns[i].width) * 0.75;\n      }\n    }\n  };\n  /**\n   * set default style properties of each rows in exporting grid\n   *\n   * @param {PdfGridRow} row - specifies the PdfGridRow\n   * @param {PdfBorders} border - specifies the PdfBorders\n   * @returns {PdfGrid} returns the pdfgrid\n   * @private\n   */\n\n\n  PdfExport.prototype.setRecordThemeStyle = function (row, border) {\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.record)) {\n      var fontFamily = !isNullOrUndefined(this.gridTheme.record.fontName) ? this.getFontFamily(this.gridTheme.record.fontName) : PdfFontFamily.Helvetica;\n      var fontSize = !isNullOrUndefined(this.gridTheme.record.fontSize) ? this.gridTheme.record.fontSize : 9.75;\n      var fontStyle = this.getFontStyle(this.gridTheme.record);\n      var font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.record.font)) {\n        font = this.gridTheme.record.font;\n      }\n\n      row.style.setFont(font);\n      var pdfColor = new PdfColor();\n\n      if (!isNullOrUndefined(this.gridTheme.record.fontColor)) {\n        var penBrushColor = this.hexToRgb(this.gridTheme.record.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      row.style.setTextBrush(new PdfSolidBrush(pdfColor));\n    } else {\n      row.style.setTextBrush(new PdfSolidBrush(new PdfColor(0, 0, 0)));\n    }\n\n    var borderRecord = this.gridTheme && this.gridTheme.record && this.gridTheme.record.border ? this.getBorderStyle(this.gridTheme.record.border) : border;\n    row.style.setBorder(borderRecord);\n    return row;\n  };\n  /**\n   * generate the formatted cell values\n   *\n   * @param {PdfBorders} border - specifies the border\n   * @param {Column[]} columns - specifies the columns\n   * @param {IGrid} gObj - specifies the IGrid\n   * @param {Object[]} dataSource - specifies the datasource\n   * @param {PdfGrid} pdfGrid - specifies the pdfGrid\n   * @param {number} startIndex - specifies the startindex\n   * @param {PdfExportProperties} pdfExportProperties - specifies the pdfExportProperties\n   * @param {ExportHelper} helper - specifies the helper\n   * @param {number} rowIndex - specifies the rowIndex\n   * @returns {number} returns the number of records\n   * @private\n   */\n\n\n  PdfExport.prototype.processRecord = function (border, columns, gObj, dataSource, pdfGrid, startIndex, pdfExportProperties, helper, rowIndex) {\n    var rows = helper.getGridRowModel(columns, dataSource, gObj, rowIndex);\n\n    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n      var row = rows_1[_i];\n      rowIndex++; // create a new row and set default style properties\n\n      var gridRow = this.setRecordThemeStyle(pdfGrid.rows.addRow(), border);\n      var cellLength = row.cells.length;\n\n      for (var j = 0; j < cellLength; j++) {\n        var gridCell = row.cells[j];\n\n        if (gridCell.cellType !== CellType.Data) {\n          continue;\n        }\n\n        var column = gridCell.column;\n        var field = column.field;\n        var cellValue = !isNullOrUndefined(field) ? column.valueAccessor(field, row.data, column) : '';\n        var value = !isNullOrUndefined(cellValue) ? cellValue : '';\n        var foreignKeyData$$1 = void 0;\n\n        if (column.isForeignColumn && column.isForeignColumn()) {\n          foreignKeyData$$1 = helper.getFData(value, column);\n          value = getValue(column.foreignKeyValue, foreignKeyData$$1);\n        }\n\n        var data = row.data;\n        var cell = gridRow.cells.getCell(j);\n        var args = {\n          data: data,\n          value: value,\n          column: column,\n          style: undefined,\n          colSpan: 1,\n          cell: cell\n        };\n        args.value = args.column.type === 'boolean' && typeof args.value === 'string' ? args.value : this.exportValueFormatter.formatCellValue(args);\n        this.parent.trigger(pdfQueryCellInfo, args);\n\n        if (!isNullOrUndefined(args.image)) {\n          args.value = new PdfBitmap(args.image.base64);\n          args.value.height = args.image.height || args.value.height;\n          args.value.width = args.image.width || args.value.width;\n        }\n\n        cell.value = args.value;\n\n        if (!isNullOrUndefined(args.hyperLink)) {\n          cell.value = this.setHyperLink(args);\n        }\n\n        if (!isNullOrUndefined(args.style)) {\n          this.processCellStyle(cell, args);\n        }\n\n        if (args.colSpan > 1) {\n          if (j + 1 + args.colSpan > gridRow.cells.count) {\n            args.colSpan = gridRow.cells.count - (j + 1);\n          }\n\n          cell.columnSpan = args.colSpan;\n\n          for (var i = 1; i < cell.columnSpan; i++) {\n            var spanCell = gridRow.cells.getCell(j + i);\n            spanCell.value = '';\n          }\n\n          j += args.colSpan - 1;\n        }\n      }\n\n      if (row.isExpand) {\n        var gridRow_1 = this.setRecordThemeStyle(pdfGrid.rows.addRow(), border);\n        var cell = gridRow_1.cells.getCell(startIndex);\n        cell.columnSpan = gridRow_1.cells.count - startIndex;\n        cell.style.cellPadding = new PdfPaddings(10, 10, 10, 10);\n        gObj.isPrinting = true;\n        var exportType = !isNullOrUndefined(pdfExportProperties) && pdfExportProperties.exportType ? pdfExportProperties.exportType : 'AllPages';\n        var returnValue = this.helper.createChildGrid(gObj, row, exportType, this.gridPool);\n        var childGridObj = returnValue.childGrid;\n        var element = returnValue.element;\n        childGridObj.actionFailure = helper.failureHandler(this.gridPool, childGridObj, this.globalResolve);\n        var args = {\n          childGrid: childGridObj,\n          row: row,\n          cell: cell,\n          exportProperties: pdfExportProperties\n        };\n        this.parent.trigger(exportDetailDataBound, args);\n        childGridObj.beforeDataBound = this.childGridCell(cell, childGridObj, pdfExportProperties);\n        childGridObj.appendTo(element);\n      }\n\n      this.parent.notify(exportRowDataBound, {\n        type: 'pdf',\n        rowObj: row\n      });\n    }\n\n    return rowIndex;\n  };\n\n  PdfExport.prototype.setHyperLink = function (args) {\n    // create the Text Web Link\n    var textLink = new PdfTextWebLink(); // set the hyperlink\n\n    textLink.url = args.hyperLink.target; // set the link text\n\n    textLink.text = args.hyperLink.displayText || args.hyperLink.target; // set the font\n\n    textLink.font = new PdfStandardFont(PdfFontFamily.Helvetica, 9.75); // set the brush and pen for the text color\n\n    textLink.brush = new PdfSolidBrush(new PdfColor(51, 102, 187));\n    return textLink;\n  };\n\n  PdfExport.prototype.childGridCell = function (cell, childGridObj, pdfExportProperties) {\n    var _this = this;\n\n    return function (result) {\n      childGridObj.beforeDataBound = null;\n      result.cancel = true;\n      cell.value = _this.processGridExport(childGridObj, result, pdfExportProperties);\n      childGridObj.destroy();\n      detach(childGridObj.element);\n      _this.gridPool[childGridObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n\n      return cell;\n    };\n  };\n\n  PdfExport.prototype.processCellStyle = function (cell, args) {\n    if (!isNullOrUndefined(args.style.backgroundColor)) {\n      var backColor = this.hexToRgb(args.style.backgroundColor);\n      cell.style.backgroundBrush = new PdfSolidBrush(new PdfColor(backColor.r, backColor.g, backColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.textAlignment)) {\n      cell.style.stringFormat = this.getHorizontalAlignment(args.style.textAlignment);\n    }\n\n    if (!isNullOrUndefined(args.style.cellPadding)) {\n      cell.style.cellPadding = args.style.cellPadding;\n    }\n\n    if (!isNullOrUndefined(args.style.verticalAlignment)) {\n      cell.style.stringFormat = this.getVerticalAlignment(args.style.verticalAlignment, cell.style.stringFormat);\n    }\n\n    if (!isNullOrUndefined(args.style.textBrushColor)) {\n      var textBrushColor = this.hexToRgb(args.style.textBrushColor);\n      cell.style.textBrush = new PdfSolidBrush(new PdfColor(textBrushColor.r, textBrushColor.g, textBrushColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.textPenColor)) {\n      var textPenColor = this.hexToRgb(args.style.textPenColor);\n      cell.style.textPen = new PdfPen(new PdfColor(textPenColor.r, textPenColor.g, textPenColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.fontFamily) || !isNullOrUndefined(args.style.fontSize) || !isNullOrUndefined(args.style.bold) || !isNullOrUndefined(args.style.italic) || !isNullOrUndefined(args.style.underline) || !isNullOrUndefined(args.style.strikeout)) {\n      cell.style.font = this.getFont(args);\n    }\n\n    if (!isNullOrUndefined(args.style.border)) {\n      var border = new PdfBorders();\n      var borderWidth = args.style.border.width; // set border width\n\n      var width = !isNullOrUndefined(borderWidth) && typeof borderWidth === 'number' ? borderWidth * 0.75 : undefined; // set border color\n\n      var color = new PdfColor(196, 196, 196);\n\n      if (!isNullOrUndefined(args.style.border.color)) {\n        var borderColor = this.hexToRgb(args.style.border.color);\n        color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);\n      }\n\n      var pen = new PdfPen(color, width); // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'\n\n      if (!isNullOrUndefined(args.style.border.dashStyle)) {\n        pen.dashStyle = this.getDashStyle(args.style.border.dashStyle);\n      }\n\n      border.all = pen;\n      cell.style.borders = border;\n    }\n\n    if (!isNullOrUndefined(args.style.paragraphIndent)) {\n      cell.style.stringFormat = new PdfStringFormat();\n      cell.style.stringFormat.paragraphIndent = args.style.paragraphIndent;\n    }\n  };\n  /**\n   * set text alignment of each columns in exporting grid\n   *\n   * @param {string} textAlign - specifies the textAlign\n   * @param {PdfStringFormat} format - specifies the PdfStringFormat\n   * @returns {PdfStringFormat} returns the PdfStringFormat\n   * @private\n   */\n\n\n  PdfExport.prototype.getHorizontalAlignment = function (textAlign, format) {\n    if (format === undefined) {\n      format = new PdfStringFormat();\n    }\n\n    switch (textAlign) {\n      case 'Right':\n        format.alignment = PdfTextAlignment.Right;\n        break;\n\n      case 'Center':\n        format.alignment = PdfTextAlignment.Center;\n        break;\n\n      case 'Justify':\n        format.alignment = PdfTextAlignment.Justify;\n        break;\n\n      case 'Left':\n        format.alignment = PdfTextAlignment.Left;\n        break;\n    }\n\n    return format;\n  };\n  /**\n   * set vertical alignment of each columns in exporting grid\n   *\n   * @param {string} verticalAlign - specifies the verticalAlign\n   * @param {PdfStringFormat} format - specifies the PdfStringFormat\n   * @param {string} textAlign - specifies the text align\n   * @returns {PdfStringFormat} returns the PdfStringFormat\n   * @private\n   */\n\n\n  PdfExport.prototype.getVerticalAlignment = function (verticalAlign, format, textAlign) {\n    if (format === undefined) {\n      format = new PdfStringFormat();\n      format = this.getHorizontalAlignment(textAlign, format);\n    }\n\n    switch (verticalAlign) {\n      case 'Bottom':\n        format.lineAlignment = PdfVerticalAlignment.Bottom;\n        break;\n\n      case 'Middle':\n        format.lineAlignment = PdfVerticalAlignment.Middle;\n        break;\n\n      case 'Top':\n        format.lineAlignment = PdfVerticalAlignment.Top;\n        break;\n    }\n\n    return format;\n  };\n\n  PdfExport.prototype.getFontFamily = function (fontFamily) {\n    switch (fontFamily) {\n      case 'TimesRoman':\n        return 2;\n\n      case 'Courier':\n        return 1;\n\n      case 'Symbol':\n        return 3;\n\n      case 'ZapfDingbats':\n        return 4;\n\n      default:\n        return 0;\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  PdfExport.prototype.getFont = function (content) {\n    if (content.font) {\n      return content.font;\n    }\n\n    var fontSize = !isNullOrUndefined(content.style.fontSize) ? content.style.fontSize * 0.75 : 9.75;\n    var fontFamily = !isNullOrUndefined(content.style.fontFamily) ? this.getFontFamily(content.style.fontFamily) : PdfFontFamily.TimesRoman;\n    var fontStyle = PdfFontStyle.Regular;\n\n    if (!isNullOrUndefined(content.style.bold) && content.style.bold) {\n      fontStyle |= PdfFontStyle.Bold;\n    }\n\n    if (!isNullOrUndefined(content.style.italic) && content.style.italic) {\n      fontStyle |= PdfFontStyle.Italic;\n    }\n\n    if (!isNullOrUndefined(content.style.underline) && content.style.underline) {\n      fontStyle |= PdfFontStyle.Underline;\n    }\n\n    if (!isNullOrUndefined(content.style.strikeout) && content.style.strikeout) {\n      fontStyle |= PdfFontStyle.Strikeout;\n    }\n\n    return new PdfStandardFont(fontFamily, fontSize, fontStyle);\n  };\n\n  PdfExport.prototype.getPageNumberStyle = function (pageNumberType) {\n    switch (pageNumberType) {\n      case 'LowerLatin':\n        return 2;\n\n      case 'LowerRoman':\n        return 3;\n\n      case 'UpperLatin':\n        return 4;\n\n      case 'UpperRoman':\n        return 5;\n\n      default:\n        return 1;\n    }\n  };\n\n  PdfExport.prototype.setContentFormat = function (content, format) {\n    if (!isNullOrUndefined(content.size)) {\n      var width = content.size.width * 0.75;\n      var height = content.size.height * 0.75;\n      format = new PdfStringFormat(PdfTextAlignment.Left, PdfVerticalAlignment.Middle);\n\n      if (!isNullOrUndefined(content.style.hAlign)) {\n        switch (content.style.hAlign) {\n          case 'Right':\n            format.alignment = PdfTextAlignment.Right;\n            break;\n\n          case 'Center':\n            format.alignment = PdfTextAlignment.Center;\n            break;\n\n          case 'Justify':\n            format.alignment = PdfTextAlignment.Justify;\n            break;\n\n          default:\n            format.alignment = PdfTextAlignment.Left;\n        }\n      }\n\n      if (!isNullOrUndefined(content.style.vAlign)) {\n        format = this.getVerticalAlignment(content.style.vAlign, format);\n      }\n\n      return {\n        format: format,\n        size: new SizeF(width, height)\n      };\n    }\n\n    return null;\n  };\n\n  PdfExport.prototype.getPageSize = function (pageSize) {\n    switch (pageSize) {\n      case 'Letter':\n        return new SizeF(612, 792);\n\n      case 'Note':\n        return new SizeF(540, 720);\n\n      case 'Legal':\n        return new SizeF(612, 1008);\n\n      case 'A0':\n        return new SizeF(2380, 3368);\n\n      case 'A1':\n        return new SizeF(1684, 2380);\n\n      case 'A2':\n        return new SizeF(1190, 1684);\n\n      case 'A3':\n        return new SizeF(842, 1190);\n\n      case 'A5':\n        return new SizeF(421, 595);\n\n      case 'A6':\n        return new SizeF(297, 421);\n\n      case 'A7':\n        return new SizeF(210, 297);\n\n      case 'A8':\n        return new SizeF(148, 210);\n\n      case 'A9':\n        return new SizeF(105, 148);\n      // case 'A10':\n      // return new SizeF(74, 105);\n\n      case 'B0':\n        return new SizeF(2836, 4008);\n\n      case 'B1':\n        return new SizeF(2004, 2836);\n\n      case 'B2':\n        return new SizeF(1418, 2004);\n\n      case 'B3':\n        return new SizeF(1002, 1418);\n\n      case 'B4':\n        return new SizeF(709, 1002);\n\n      case 'B5':\n        return new SizeF(501, 709);\n\n      case 'Archa':\n        return new SizeF(648, 864);\n\n      case 'Archb':\n        return new SizeF(864, 1296);\n\n      case 'Archc':\n        return new SizeF(1296, 1728);\n\n      case 'Archd':\n        return new SizeF(1728, 2592);\n\n      case 'Arche':\n        return new SizeF(2592, 3456);\n\n      case 'Flsa':\n        return new SizeF(612, 936);\n\n      case 'HalfLetter':\n        return new SizeF(396, 612);\n\n      case 'Letter11x17':\n        return new SizeF(792, 1224);\n\n      case 'Ledger':\n        return new SizeF(1224, 792);\n\n      default:\n        return new SizeF(595, 842);\n    }\n  };\n\n  PdfExport.prototype.getDashStyle = function (dashStyle) {\n    switch (dashStyle) {\n      case 'Dash':\n        return 1;\n\n      case 'Dot':\n        return 2;\n\n      case 'DashDot':\n        return 3;\n\n      case 'DashDotDot':\n        return 4;\n\n      default:\n        return 0;\n    }\n  };\n\n  PdfExport.prototype.getPenFromContent = function (content) {\n    var pen = new PdfPen(new PdfColor(0, 0, 0));\n\n    if (!isNullOrUndefined(content.style) && content.style !== null && !isNullOrUndefined(content.style.penColor)) {\n      var penColor = this.hexToRgb(content.style.penColor);\n      pen = new PdfPen(new PdfColor(penColor.r, penColor.g, penColor.b));\n    }\n\n    return pen;\n  };\n\n  PdfExport.prototype.getBrushFromContent = function (content) {\n    var brush = null;\n\n    if (!isNullOrUndefined(content.style.textBrushColor)) {\n      /* tslint:disable-next-line:max-line-length */\n      var brushColor = this.hexToRgb(content.style.textBrushColor);\n      brush = new PdfSolidBrush(new PdfColor(brushColor.r, brushColor.g, brushColor.b));\n    }\n\n    return brush;\n  };\n\n  PdfExport.prototype.hexToRgb = function (hex) {\n    if (hex === null || hex === '' || hex.length !== 7) {\n      throw new Error('please set valid hex value for color...');\n    }\n\n    hex = hex.substring(1);\n    var bigint = parseInt(hex, 16);\n    var r = bigint >> 16 & 255;\n    var g = bigint >> 8 & 255;\n    var b = bigint & 255;\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  };\n\n  PdfExport.prototype.getFontStyle = function (theme) {\n    var fontStyle = PdfFontStyle.Regular;\n\n    if (!isNullOrUndefined(theme) && theme.bold) {\n      fontStyle |= PdfFontStyle.Bold;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.italic) {\n      fontStyle |= PdfFontStyle.Italic;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.underline) {\n      fontStyle |= PdfFontStyle.Underline;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.strikeout) {\n      fontStyle |= PdfFontStyle.Strikeout;\n    }\n\n    return fontStyle;\n  };\n\n  PdfExport.prototype.getBorderStyle = function (border) {\n    var borders = new PdfBorders();\n\n    if (!isNullOrUndefined(border)) {\n      var borderWidth = border.width; // set border width\n\n      var width = !isNullOrUndefined(borderWidth) && typeof borderWidth === 'number' ? borderWidth * 0.75 : undefined; // set border color\n\n      var color = new PdfColor(196, 196, 196);\n\n      if (!isNullOrUndefined(border.color)) {\n        var borderColor = this.hexToRgb(border.color);\n        color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);\n      }\n\n      var pen = new PdfPen(color, width); // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'\n\n      if (!isNullOrUndefined(border.dashStyle)) {\n        pen.dashStyle = this.getDashStyle(border.dashStyle);\n      }\n\n      borders.all = pen;\n    } else {\n      borders.all = new PdfPen(new PdfColor(234, 234, 234));\n    }\n\n    return borders;\n  };\n\n  PdfExport.prototype.destroy = function () {//destroy for exporting\n  };\n\n  return PdfExport;\n}();\n\nvar __extends$31 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `CommandColumn` used to render command column in grid\n *\n * @hidden\n */\n\n\nvar CommandColumnRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$31(CommandColumnRenderer, _super);\n\n  function CommandColumnRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.buttonElement = _this.parent.createElement('button', {});\n    _this.unbounDiv = _this.parent.createElement('div', {\n      className: 'e-unboundcelldiv',\n      styles: 'display: inline-block'\n    });\n    _this.childRefs = [];\n    _this.element = _this.parent.createElement('TD', {\n      className: 'e-rowcell e-unboundcell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n\n    _this.parent.on(destroy, _this.destroyButtons, _this);\n\n    _this.parent.on(commandColumnDestroy, _this.destroyButtons, _this);\n\n    return _this;\n  }\n\n  CommandColumnRenderer.prototype.destroyButtons = function (args) {\n    for (var i = 0; i < this.childRefs.length; i++) {\n      if (this.childRefs[i] && !this.childRefs[i].isDestroyed) {\n        this.childRefs[i].destroy();\n\n        if (this.childRefs[i].element) {\n          this.childRefs[i].element.innerHTML = '';\n        }\n      }\n    }\n\n    if (args.type === 'refreshCommandColumn') {\n      var elem = this.parent.element.querySelectorAll('.e-unboundcell');\n\n      if (elem.length) {\n        for (var i = 0; i < elem.length; i++) {\n          if (elem[i]) {\n            if (elem[i].querySelector('.e-unboundcelldiv')) {\n              elem[i].querySelector('.e-unboundcelldiv').innerHTML = '';\n            }\n\n            elem[i].innerHTML = '';\n          }\n        }\n\n        elem = null;\n      }\n    } else {\n      this.parent.off(destroy, this.destroyButtons);\n      this.parent.off(commandColumnDestroy, this.destroyButtons);\n    }\n  };\n  /**\n   * Function to render the cell content based on Column object.\n   *\n   * @param {cell<Column>} cell - specifies the cell\n   * @param {Object} data - specifies the data\n   * @param {Object} attributes - specifies the attributes\n   * @param {boolean} isVirtualEdit - specifies virtual scroll editing\n   * @returns {Element} returns the element\n   */\n\n\n  CommandColumnRenderer.prototype.render = function (cell, data, attributes$$1, isVirtualEdit) {\n    var node = this.element.cloneNode();\n    var uid = 'uid';\n    node.appendChild(this.unbounDiv.cloneNode());\n    node.setAttribute('aria-label', this.localizer.getConstant('CommandColumnAria') + cell.column.headerText);\n\n    if (cell.column.commandsTemplate) {\n      if (this.parent.isReact && typeof cell.column.commandsTemplate !== 'string') {\n        var tempID = this.parent + 'commandsTemplate';\n        cell.column.getColumnTemplate()(data, this.parent, 'commandsTemplate', tempID, null, null, node.firstElementChild);\n        this.parent.renderTemplates();\n      } else {\n        appendChildren(node.firstElementChild, cell.column.getColumnTemplate()(data));\n      }\n    } else {\n      for (var _i = 0, _a = cell.commands; _i < _a.length; _i++) {\n        var command = _a[_i];\n        node = this.renderButton(node, command, attributes$$1.index, command[uid]);\n      }\n    }\n\n    this.setAttributes(node, cell, attributes$$1);\n\n    if (!this.parent.enableVirtualization && this.parent.isEdit || isVirtualEdit) {\n      addClass([].slice.call(node.getElementsByClassName('e-edit-delete')), 'e-hide');\n      removeClass([].slice.call(node.getElementsByClassName('e-save-cancel')), 'e-hide');\n    } else {\n      addClass([].slice.call(node.getElementsByClassName('e-save-cancel')), 'e-hide');\n      removeClass([].slice.call(node.getElementsByClassName('e-edit-delete')), 'e-hide');\n    }\n\n    return node;\n  };\n\n  CommandColumnRenderer.prototype.renderButton = function (node, buttonOption, index, uid) {\n    var button = this.buttonElement.cloneNode();\n    attributes(button, {\n      'id': this.parent.element.id + (buttonOption.type || '') + '_' + index + '_' + uid,\n      'type': 'button',\n      title: !isNullOrUndefined(buttonOption.title) ? buttonOption.title : buttonOption.buttonOption.content || this.localizer.getConstant(buttonOption.type) || buttonOption.type,\n      'data-uid': uid\n    });\n    button.onclick = buttonOption.buttonOption.click;\n    buttonOption.buttonOption.cssClass = this.parent.cssClass ? buttonOption.buttonOption.cssClass + ' ' + this.parent.cssClass : buttonOption.buttonOption.cssClass;\n    var buttonObj = new Button(buttonOption.buttonOption, button);\n    this.childRefs.push(buttonObj);\n    buttonObj.commandType = buttonOption.type;\n    node.firstElementChild.appendChild(buttonObj.element);\n\n    switch (buttonOption.type) {\n      case 'Edit':\n      case 'Delete':\n        addClass([button], ['e-edit-delete', 'e-' + buttonOption.type.toLowerCase() + 'button']);\n        break;\n\n      case 'Cancel':\n      case 'Save':\n        addClass([button], ['e-save-cancel', 'e-' + buttonOption.type.toLowerCase() + 'button']);\n        break;\n    }\n\n    return node;\n  };\n\n  return CommandColumnRenderer;\n}(CellRenderer);\n/**\n * `CommandColumn` used to handle the command column actions.\n *\n * @hidden\n */\n\n\nvar CommandColumn =\n/** @__PURE__ @class */\nfunction () {\n  function CommandColumn(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.initiateRender();\n    this.addEventListener();\n  }\n\n  CommandColumn.prototype.initiateRender = function () {\n    var cellFac = this.locator.getService('cellRendererFactory');\n    cellFac.addCellRenderer(CellType.CommandColumn, new CommandColumnRenderer(this.parent, this.locator));\n  };\n\n  CommandColumn.prototype.commandClickHandler = function (e) {\n    var gObj = this.parent;\n    var target = closest(e.target, 'button');\n\n    if (!target || !closest(e.target, '.e-unboundcell')) {\n      return;\n    }\n\n    var buttonObj = target.ej2_instances[0];\n    var type = buttonObj.commandType;\n    var uid = target.getAttribute('data-uid');\n    var commandColumn;\n    var row$$1 = gObj.getRowObjectFromUID(closest(target, '.' + row).getAttribute('data-uid'));\n    var cols = this.parent.columnModel;\n\n    for (var i = 0; i < cols.length; i++) {\n      if (cols[i].commands) {\n        var commandCols = cols[i].commands;\n\n        for (var j = 0; j < commandCols.length; j++) {\n          var idInString = 'uid';\n          var typeInString = 'type';\n\n          if (commandCols[j][idInString] === uid && commandCols[j][typeInString] === type) {\n            commandColumn = commandCols[j];\n          } else {\n            var buttons = [].slice.call(closest(target, '.e-unboundcell').querySelectorAll('button'));\n            var index = buttons.findIndex(function (ele) {\n              return ele === target;\n            });\n\n            if (index < commandCols.length && commandCols[index][typeInString] === type) {\n              commandColumn = commandCols[index];\n            }\n          }\n        }\n      }\n    }\n\n    var args = {\n      cancel: false,\n      target: target,\n      commandColumn: commandColumn,\n      rowData: isNullOrUndefined(row$$1) ? undefined : row$$1.data\n    };\n    this.parent.trigger(commandClick, args, function (commandclickargs) {\n      if (buttonObj.disabled || !gObj.editModule || commandclickargs.cancel) {\n        return;\n      }\n\n      switch (type) {\n        case 'Edit':\n          gObj.editModule.endEdit();\n          gObj.editModule.startEdit(closest(target, 'tr'));\n          break;\n\n        case 'Cancel':\n          gObj.editModule.closeEdit();\n          break;\n\n        case 'Save':\n          gObj.editModule.endEdit();\n          break;\n\n        case 'Delete':\n          if (gObj.editSettings.mode !== 'Batch') {\n            gObj.editModule.endEdit();\n          }\n\n          gObj.commandDelIndex = parseInt(closest(target, 'tr').getAttribute(dataRowIndex), 10);\n          gObj.clearSelection(); //for toogle issue when dbl click\n\n          gObj.selectRow(gObj.commandDelIndex, false);\n          gObj.editModule.deleteRecord();\n          gObj.commandDelIndex = undefined;\n          break;\n      }\n    });\n  };\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   */\n\n\n  CommandColumn.prototype.getModuleName = function () {\n    return 'commandColumn';\n  };\n  /**\n   * To destroy CommandColumn.\n   *\n   * @function destroy\n   * @returns {void}\n   */\n\n\n  CommandColumn.prototype.destroy = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.removeEventListener();\n  };\n\n  CommandColumn.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(click, this.commandClickHandler);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(initialEnd, this.load);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  CommandColumn.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(click, this.commandClickHandler, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(initialEnd, this.load, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n\n  CommandColumn.prototype.keyPressHandler = function (e) {\n    if (e.action === 'enter' && closest(e.target, '.e-unboundcelldiv')) {\n      this.commandClickHandler(e);\n      e.preventDefault();\n    }\n  };\n\n  CommandColumn.prototype.load = function () {\n    var uid = 'uid';\n    var col = this.parent.columnModel;\n\n    for (var i = 0; i < col.length; i++) {\n      if (col[i].commands) {\n        var commandCol = col[i].commands;\n\n        for (var j = 0; j < commandCol.length; j++) {\n          commandCol[j][uid] = getUid('gridcommand');\n        }\n      }\n    }\n  };\n\n  return CommandColumn;\n}();\n\nvar menuClass = {\n  header: '.' + gridHeader,\n  content: '.' + gridContent,\n  edit: '.e-inline-edit',\n  batchEdit: '.e-editedbatchcell',\n  editIcon: 'e-edit',\n  pager: '.e-gridpager',\n  delete: 'e-delete',\n  save: 'e-save',\n  cancel: 'e-cancel',\n  copy: 'e-copy',\n  pdf: 'e-pdfexport',\n  group: 'e-icon-group',\n  ungroup: 'e-icon-ungroup',\n  csv: 'e-csvexport',\n  excel: 'e-excelexport',\n  fPage: 'e-icon-first',\n  nPage: 'e-icon-next',\n  lPage: 'e-icon-last',\n  pPage: 'e-icon-prev',\n  ascending: 'e-icon-ascending',\n  descending: 'e-icon-descending',\n  groupHeader: 'e-groupdroparea',\n  touchPop: 'e-gridpopup'\n};\n/**\n * The `ContextMenu` module is used to handle context menu actions.\n */\n\nvar ContextMenu$1 =\n/** @__PURE__ @class */\nfunction () {\n  function ContextMenu$$1(parent, serviceLocator) {\n    this.defaultItems = {};\n    this.disableItems = [];\n    this.hiddenItems = [];\n    this.localeText = this.setLocaleKey();\n    this.parent = parent;\n    this.gridID = parent.element.id;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ContextMenu$$1.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(uiUpdate, this.enableAfterRenderMenu, this);\n    this.parent.on(initialLoad, this.render, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ContextMenu$$1.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.render);\n    this.parent.off(uiUpdate, this.enableAfterRenderMenu);\n    this.parent.off(destroy, this.destroy);\n    EventHandler.remove(this.element, 'keydown', this.keyDownHandler.bind(this));\n  };\n\n  ContextMenu$$1.prototype.keyDownHandler = function (e) {\n    if (e.code === 'Tab' || e.which === 9) {\n      this.contextMenu.close();\n    }\n\n    if (e.code === 'Escape') {\n      this.contextMenu.close();\n      this.parent.notify(restoreFocus, {});\n    }\n  };\n\n  ContextMenu$$1.prototype.render = function () {\n    this.parent.element.classList.add('e-noselect');\n    this.l10n = this.serviceLocator.getService('localization');\n    this.element = this.parent.createElement('ul', {\n      id: this.gridID + '_cmenu'\n    });\n    EventHandler.add(this.element, 'keydown', this.keyDownHandler.bind(this));\n    this.parent.element.appendChild(this.element);\n    var target = '#' + this.gridID;\n    this.contextMenu = new ContextMenu({\n      items: this.getMenuItems(),\n      enableRtl: this.parent.enableRtl,\n      enablePersistence: this.parent.enablePersistence,\n      locale: this.parent.locale,\n      target: target,\n      select: this.contextMenuItemClick.bind(this),\n      beforeOpen: this.contextMenuBeforeOpen.bind(this),\n      onOpen: this.contextMenuOpen.bind(this),\n      onClose: this.contextMenuOnClose.bind(this),\n      cssClass: this.parent.cssClass ? 'e-grid-menu' + ' ' + this.parent.cssClass : 'e-grid-menu'\n    });\n    this.contextMenu.appendTo(this.element);\n  };\n\n  ContextMenu$$1.prototype.enableAfterRenderMenu = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      if (this.contextMenu) {\n        this.contextMenu.destroy();\n        remove(this.element);\n        this.parent.element.classList.remove('e-noselect');\n      }\n\n      this.render();\n    }\n  };\n\n  ContextMenu$$1.prototype.getMenuItems = function () {\n    var menuItems = [];\n    var exportItems = [];\n\n    for (var _i = 0, _a = this.parent.contextMenuItems; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (typeof item === 'string' && this.getDefaultItems().indexOf(item) !== -1) {\n        if (item.toLocaleLowerCase().indexOf('export') !== -1) {\n          exportItems.push(this.buildDefaultItems(item));\n        } else {\n          menuItems.push(this.buildDefaultItems(item));\n        }\n      } else if (typeof item !== 'string') {\n        menuItems.push(item);\n      }\n    }\n\n    if (exportItems.length > 0) {\n      var exportGroup = this.buildDefaultItems('export');\n      exportGroup.items = exportItems;\n      menuItems.push(exportGroup);\n    }\n\n    return menuItems;\n  };\n\n  ContextMenu$$1.prototype.getLastPage = function () {\n    var totalpage = Math.floor(this.parent.pageSettings.totalRecordsCount / this.parent.pageSettings.pageSize);\n\n    if (this.parent.pageSettings.totalRecordsCount % this.parent.pageSettings.pageSize) {\n      totalpage += 1;\n    }\n\n    return totalpage;\n  };\n\n  ContextMenu$$1.prototype.contextMenuOpen = function () {\n    this.isOpen = true;\n  };\n  /**\n   * @param {ContextMenuClickEventArgs} args - specifies the ContextMenuClickEventArgs argument type\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ContextMenu$$1.prototype.contextMenuItemClick = function (args) {\n    var item = this.getKeyFromId(args.item.id);\n\n    switch (item) {\n      case 'AutoFitAll':\n        this.parent.autoFitColumns([]);\n        break;\n\n      case 'AutoFit':\n        this.parent.autoFitColumns(this.targetColumn.field);\n        break;\n\n      case 'Group':\n        this.parent.groupColumn(this.targetColumn.field);\n        break;\n\n      case 'Ungroup':\n        this.parent.ungroupColumn(this.targetColumn.field);\n        break;\n\n      case 'Edit':\n        if (this.parent.editModule) {\n          if (this.parent.editSettings.mode === 'Batch') {\n            if (this.row && this.cell && !isNaN(parseInt(this.cell.getAttribute(dataColIndex), 10))) {\n              this.parent.editModule.editCell(parseInt(this.row.getAttribute(dataRowIndex), 10), // eslint-disable-next-line\n              this.parent.getColumns()[parseInt(this.cell.getAttribute(dataColIndex), 10)].field);\n            }\n          } else {\n            this.parent.editModule.endEdit();\n            this.parent.editModule.startEdit(this.row);\n          }\n        }\n\n        break;\n\n      case 'Delete':\n        if (this.parent.editModule) {\n          if (this.parent.editSettings.mode !== 'Batch') {\n            this.parent.editModule.endEdit();\n          }\n\n          if (this.parent.getSelectedRecords().length === 1) {\n            this.parent.editModule.deleteRow(this.row);\n          } else {\n            this.parent.deleteRecord();\n          }\n        }\n\n        break;\n\n      case 'Save':\n        if (this.parent.editModule) {\n          this.parent.editModule.endEdit();\n        }\n\n        break;\n\n      case 'Cancel':\n        if (this.parent.editModule) {\n          this.parent.editModule.closeEdit();\n        }\n\n        break;\n\n      case 'Copy':\n        this.parent.copy();\n        break;\n\n      case 'PdfExport':\n        this.parent.pdfExport();\n        break;\n\n      case 'ExcelExport':\n        this.parent.excelExport();\n        break;\n\n      case 'CsvExport':\n        this.parent.csvExport();\n        break;\n\n      case 'SortAscending':\n        this.isOpen = false;\n        this.parent.sortColumn(this.targetColumn.field, 'Ascending');\n        break;\n\n      case 'SortDescending':\n        this.isOpen = false;\n        this.parent.sortColumn(this.targetColumn.field, 'Descending');\n        break;\n\n      case 'FirstPage':\n        this.parent.goToPage(1);\n        break;\n\n      case 'PrevPage':\n        this.parent.goToPage(this.parent.pageSettings.currentPage - 1);\n        break;\n\n      case 'LastPage':\n        this.parent.goToPage(this.getLastPage());\n        break;\n\n      case 'NextPage':\n        this.parent.goToPage(this.parent.pageSettings.currentPage + 1);\n        break;\n    }\n\n    args.column = this.targetColumn;\n    args.rowInfo = this.targetRowdata;\n    this.parent.trigger(contextMenuClick, args);\n  };\n\n  ContextMenu$$1.prototype.contextMenuOnClose = function (args) {\n    var parent = 'parentObj';\n\n    if (args.items.length > 0 && args.items[0][parent] instanceof ContextMenu) {\n      this.updateItemStatus();\n    }\n\n    this.parent.notify(selectRowOnContextOpen, {\n      isOpen: false\n    });\n  };\n\n  ContextMenu$$1.prototype.getLocaleText = function (item) {\n    return this.l10n.getConstant(this.localeText[item]);\n  };\n\n  ContextMenu$$1.prototype.updateItemStatus = function () {\n    this.contextMenu.showItems(this.hiddenItems);\n    this.contextMenu.enableItems(this.disableItems);\n    this.hiddenItems = [];\n    this.disableItems = [];\n    this.isOpen = false;\n  };\n\n  ContextMenu$$1.prototype.contextMenuBeforeOpen = function (args) {\n    var closestGrid = closest(args.event.target, '.e-grid');\n\n    if (args.event && closestGrid && closestGrid !== this.parent.element) {\n      args.cancel = true;\n    } else if (args.event && (closest(args.event.target, '.' + menuClass.groupHeader) || closest(args.event.target, '.' + menuClass.touchPop) || closest(args.event.target, '.e-summarycell') || closest(args.event.target, '.e-groupcaption') || closest(args.event.target, '.e-filterbarcell'))) {\n      args.cancel = true;\n    } else {\n      this.targetColumn = this.getColumn(args.event);\n\n      if (parentsUntil(args.event.target, 'e-grid')) {\n        this.targetRowdata = this.parent.getRowInfo(args.event.target);\n      }\n\n      if (isNullOrUndefined(args.parentItem) && this.targetColumn) {\n        if (this.targetRowdata.cell) {\n          this.parent.notify(selectRowOnContextOpen, {\n            isOpen: true\n          });\n          this.selectRow(args.event, this.targetRowdata.cell.classList.contains('e-selectionbackground') && this.parent.selectionSettings.type === 'Multiple' ? false : true);\n        }\n      }\n\n      var hideSepItems = [];\n      var showSepItems = [];\n\n      for (var _i = 0, _a = args.items; _i < _a.length; _i++) {\n        var item = _a[_i];\n        var key = this.getKeyFromId(item.id);\n        var dItem = this.defaultItems[key];\n\n        if (this.getDefaultItems().indexOf(key) !== -1) {\n          if (this.ensureDisabledStatus(key)) {\n            this.disableItems.push(item.text);\n          }\n\n          if (args.event && (this.ensureTarget(args.event.target, menuClass.edit) || this.ensureTarget(args.event.target, menuClass.batchEdit))) {\n            if (key !== 'Save' && key !== 'Cancel') {\n              this.hiddenItems.push(item.text);\n            }\n          } else if (this.parent.editModule && this.parent.editSettings.mode === 'Batch' && (closest(args.event.target, '.e-gridform') || this.parent.editModule.getBatchChanges()[changedRecords].length || this.parent.editModule.getBatchChanges()[addedRecords].length || this.parent.editModule.getBatchChanges()[deletedRecords].length) && (key === 'Save' || key === 'Cancel')) {\n            continue;\n          } else if (isNullOrUndefined(args.parentItem) && args.event && !this.ensureTarget(args.event.target, dItem.target)) {\n            this.hiddenItems.push(item.text);\n          }\n        } else if (item.target && args.event && !this.ensureTarget(args.event.target, item.target)) {\n          if (item.separator) {\n            hideSepItems.push(item.id);\n          } else {\n            this.hiddenItems.push(item.text);\n          }\n        } else if (this.ensureTarget(args.event.target, item.target) && item.separator) {\n          showSepItems.push(item.id);\n        }\n      }\n\n      if (showSepItems.length > 0) {\n        this.contextMenu.showItems(showSepItems, true);\n      }\n\n      this.contextMenu.enableItems(this.disableItems, false);\n      this.contextMenu.hideItems(this.hiddenItems);\n\n      if (hideSepItems.length > 0) {\n        this.contextMenu.hideItems(hideSepItems, true);\n      }\n\n      this.eventArgs = args.event;\n      args.column = this.targetColumn;\n      args.rowInfo = this.targetRowdata;\n      this.parent.trigger(contextMenuOpen, args);\n\n      if (args.cancel || this.hiddenItems.length === args.items.length && !args.parentItem) {\n        this.updateItemStatus();\n        args.cancel = true;\n      }\n    }\n\n    applyBiggerTheme(this.parent.element, this.contextMenu.element.parentElement);\n  };\n\n  ContextMenu$$1.prototype.ensureTarget = function (targetElement, selector) {\n    var target = targetElement;\n\n    if (this.ensureFrozenHeader(targetElement) && (selector === menuClass.header || selector === menuClass.content)) {\n      target = closest(targetElement, selector === menuClass.header ? 'thead' : tbody);\n    } else if (selector === menuClass.content || selector === menuClass.header) {\n      target = parentsUntil(closest(targetElement, '.' + table), selector.substr(1, selector.length));\n    } else {\n      target = closest(targetElement, selector);\n    }\n\n    return target && parentsUntil(target, 'e-grid') === this.parent.element;\n  };\n\n  ContextMenu$$1.prototype.ensureFrozenHeader = function (targetElement) {\n    return (this.parent.isFrozenGrid() || this.parent.frozenRows) && closest(targetElement, menuClass.header) ? true : false;\n  };\n\n  ContextMenu$$1.prototype.ensureDisabledStatus = function (item) {\n    var status = false;\n\n    switch (item) {\n      case 'AutoFitAll':\n      case 'AutoFit':\n        status = !(this.parent.ensureModuleInjected(Resize) && !this.parent.isEdit) || this.targetColumn && !this.targetColumn.field && item === 'AutoFit';\n        break;\n\n      case 'Group':\n        if (!this.parent.allowGrouping || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) >= 0 || this.targetColumn && !this.targetColumn.field) {\n          status = true;\n        }\n\n        break;\n\n      case 'Ungroup':\n        if (!this.parent.allowGrouping || !this.parent.ensureModuleInjected(Group) || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) < 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'Edit':\n      case 'Delete':\n      case 'Save':\n      case 'Cancel':\n        if (!this.parent.editModule || this.parent.getDataRows().length === 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'Copy':\n        if (this.parent.getSelectedRowIndexes().length === 0 && this.parent.getSelectedRowCellIndexes().length === 0 || this.parent.getCurrentViewRecords().length === 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'export':\n        if (!this.parent.allowExcelExport || !this.parent.excelExport || !this.parent.ensureModuleInjected(PdfExport) && !this.parent.ensureModuleInjected(ExcelExport)) {\n          status = true;\n        }\n\n        break;\n\n      case 'PdfExport':\n        if (!this.parent.allowPdfExport || !this.parent.ensureModuleInjected(PdfExport)) {\n          status = true;\n        }\n\n        break;\n\n      case 'ExcelExport':\n      case 'CsvExport':\n        if (!this.parent.allowExcelExport || !this.parent.ensureModuleInjected(ExcelExport)) {\n          status = true;\n        }\n\n        break;\n\n      case 'SortAscending':\n      case 'SortDescending':\n        if (!this.parent.allowSorting || !this.parent.ensureModuleInjected(Sort) || this.targetColumn && !this.targetColumn.field) {\n          status = true;\n        } else if (this.parent.ensureModuleInjected(Sort) && this.parent.sortSettings.columns.length > 0 && this.targetColumn) {\n          var sortColumns = this.parent.sortSettings.columns;\n\n          for (var i = 0; i < sortColumns.length; i++) {\n            if (sortColumns[i].field === this.targetColumn.field && sortColumns[i].direction.toLowerCase() === item.toLowerCase().replace('sort', '').toLocaleLowerCase()) {\n              status = true;\n            }\n          }\n        }\n\n        break;\n\n      case 'FirstPage':\n      case 'PrevPage':\n        if (!this.parent.allowPaging || !this.parent.ensureModuleInjected(Page) || this.parent.getCurrentViewRecords().length === 0 || this.parent.ensureModuleInjected(Page) && this.parent.pageSettings.currentPage === 1) {\n          status = true;\n        }\n\n        break;\n\n      case 'LastPage':\n      case 'NextPage':\n        if (!this.parent.allowPaging || !this.parent.ensureModuleInjected(Page) || this.parent.getCurrentViewRecords().length === 0 || this.parent.ensureModuleInjected(Page) && this.parent.pageSettings.currentPage === this.getLastPage()) {\n          status = true;\n        }\n\n        break;\n    }\n\n    return status;\n  };\n  /**\n   * Gets the context menu element from the Grid.\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ContextMenu$$1.prototype.getContextMenu = function () {\n    return this.element;\n  };\n  /**\n   * Destroys the context menu component in the Grid.\n   *\n   * @function destroy\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ContextMenu$$1.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.contextMenu.destroy();\n\n    if (this.element.parentNode) {\n      remove(this.element);\n    }\n\n    this.removeEventListener();\n    this.parent.element.classList.remove('e-noselect');\n  };\n\n  ContextMenu$$1.prototype.getModuleName = function () {\n    return 'contextMenu';\n  };\n\n  ContextMenu$$1.prototype.generateID = function (item) {\n    return this.gridID + '_cmenu_' + item;\n  };\n\n  ContextMenu$$1.prototype.getKeyFromId = function (id) {\n    return id.replace(this.gridID + '_cmenu_', '');\n  };\n\n  ContextMenu$$1.prototype.buildDefaultItems = function (item) {\n    var menuItem;\n\n    switch (item) {\n      case 'AutoFitAll':\n      case 'AutoFit':\n        menuItem = {\n          target: menuClass.header\n        };\n        break;\n\n      case 'Group':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.group\n        };\n        break;\n\n      case 'Ungroup':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.ungroup\n        };\n        break;\n\n      case 'Edit':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.editIcon\n        };\n        break;\n\n      case 'Delete':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.delete\n        };\n        break;\n\n      case 'Save':\n        menuItem = {\n          target: menuClass.edit,\n          iconCss: menuClass.save\n        };\n        break;\n\n      case 'Cancel':\n        menuItem = {\n          target: menuClass.edit,\n          iconCss: menuClass.cancel\n        };\n        break;\n\n      case 'Copy':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.copy\n        };\n        break;\n\n      case 'export':\n        menuItem = {\n          target: menuClass.content\n        };\n        break;\n\n      case 'PdfExport':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.pdf\n        };\n        break;\n\n      case 'ExcelExport':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.excel\n        };\n        break;\n\n      case 'CsvExport':\n        menuItem = {\n          target: menuClass.content,\n          iconCss: menuClass.csv\n        };\n        break;\n\n      case 'SortAscending':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.ascending\n        };\n        break;\n\n      case 'SortDescending':\n        menuItem = {\n          target: menuClass.header,\n          iconCss: menuClass.descending\n        };\n        break;\n\n      case 'FirstPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.fPage\n        };\n        break;\n\n      case 'PrevPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.pPage\n        };\n        break;\n\n      case 'LastPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.lPage\n        };\n        break;\n\n      case 'NextPage':\n        menuItem = {\n          target: menuClass.pager,\n          iconCss: menuClass.nPage\n        };\n        break;\n    }\n\n    this.defaultItems[item] = {\n      text: this.getLocaleText(item),\n      id: this.generateID(item),\n      target: menuItem.target,\n      iconCss: menuItem.iconCss ? 'e-icons ' + menuItem.iconCss : ''\n    };\n    return this.defaultItems[item];\n  };\n\n  ContextMenu$$1.prototype.getDefaultItems = function () {\n    return ['AutoFitAll', 'AutoFit', 'Group', 'Ungroup', 'Edit', 'Delete', 'Save', 'Cancel', 'Copy', 'export', 'PdfExport', 'ExcelExport', 'CsvExport', 'SortAscending', 'SortDescending', 'FirstPage', 'PrevPage', 'LastPage', 'NextPage'];\n  };\n\n  ContextMenu$$1.prototype.setLocaleKey = function () {\n    var localeKeys = {\n      'AutoFitAll': 'autoFitAll',\n      'AutoFit': 'autoFit',\n      'Copy': 'Copy',\n      'Group': 'Group',\n      'Ungroup': 'Ungroup',\n      'Edit': 'EditRecord',\n      'Delete': 'DeleteRecord',\n      'Save': 'Save',\n      'Cancel': 'CancelButton',\n      'PdfExport': 'Pdfexport',\n      'ExcelExport': 'Excelexport',\n      'CsvExport': 'Csvexport',\n      'export': 'Export',\n      'SortAscending': 'SortAscending',\n      'SortDescending': 'SortDescending',\n      'FirstPage': 'FirstPage',\n      'LastPage': 'LastPage',\n      'PrevPage': 'PreviousPage',\n      'NextPage': 'NextPage'\n    };\n    return localeKeys;\n  };\n\n  ContextMenu$$1.prototype.getColumn = function (e) {\n    var cell = closest(e.target, 'th.e-headercell');\n\n    if (cell) {\n      var uid = cell.querySelector('.e-headercelldiv, .e-stackedheadercelldiv').getAttribute('e-mappinguid');\n      return this.parent.getColumnByUid(uid);\n    } else {\n      var ele = this.parent.getRowInfo(e.target).column;\n      return ele || null;\n    }\n  };\n\n  ContextMenu$$1.prototype.selectRow = function (e, isSelectable) {\n    this.cell = e.target;\n    this.row = closest(e.target, 'tr.e-row') || this.row;\n\n    if (this.row && isSelectable && !parentsUntil(e.target, 'e-gridpager')) {\n      this.parent.selectRow(parseInt(this.row.getAttribute(dataRowIndex), 10));\n    }\n  };\n\n  return ContextMenu$$1;\n}();\n/**\n * FreezeRowModelGenerator is used to generate grid data rows with freeze row and column.\n *\n * @hidden\n */\n\n\nvar FreezeRowModelGenerator =\n/** @__PURE__ @class */\nfunction () {\n  function FreezeRowModelGenerator(parent) {\n    this.parent = parent;\n    this.rowModelGenerator = new RowModelGenerator(this.parent);\n  }\n\n  FreezeRowModelGenerator.prototype.generateRows = function (data, notifyArgs, virtualRows) {\n    var tableName;\n\n    if (notifyArgs.renderFrozenRightContent || notifyArgs.renderMovableContent && !this.parent.enableVirtualization) {\n      tableName = 'frozen-right';\n    } else if (notifyArgs.renderMovableContent || notifyArgs.isFrozen) {\n      tableName = 'movable';\n    } else {\n      tableName = this.parent.getFrozenLeftCount() ? 'frozen-left' : 'frozen-right';\n    }\n\n    if (notifyArgs.requestType === 'virtualscroll' && notifyArgs.virtualInfo.sentinelInfo.axis === 'X') {\n      if (tableName !== 'movable') {\n        return null;\n      }\n    }\n\n    var row = this.parent.enableVirtualization && !notifyArgs.isFrozenRowsRender ? virtualRows : this.rowModelGenerator.generateRows(data, notifyArgs);\n\n    for (var i = 0, len = row.length; i < len; i++) {\n      row[i].cells = splitFrozenRowObjectCells(this.parent, row[i].cells, tableName);\n    }\n\n    return row;\n  };\n\n  return FreezeRowModelGenerator;\n}();\n\nvar __extends$32 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Freeze module is used to render grid content with frozen rows and columns\n *\n * @hidden\n */\n\n\nvar FreezeContentRender =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$32(FreezeContentRender, _super);\n\n  function FreezeContentRender(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.isInitialRender = true;\n    _this.widthService = locator.getService('widthService');\n\n    _this.addEventListener();\n\n    return _this;\n  }\n\n  FreezeContentRender.prototype.addEventListener = function () {\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent.addEventListener(batchAdd, this.batchAdd.bind(this));\n    this.parent.on(batchCancel, this.batchAdd.bind(this));\n    this.parent.addEventListener(batchDelete, this.batchAdd.bind(this));\n    this.parent.on(setHeightToFrozenElement, this.refreshScrollOffset);\n    this.parent.on(columnVisibilityChanged, this.widthService.refreshFrozenScrollbar, this);\n  };\n\n  FreezeContentRender.prototype.batchAdd = function (args) {\n    var isAdd = args.name !== 'batchCancel' && !(this.parent.frozenRows && this.parent.editSettings.newRowPosition === 'Top');\n\n    if (this.parent.height !== 'auto' && (isAdd || args.name === 'batchCancel' || args.name === 'batchDelete')) {\n      this.refreshScrollOffset();\n      var height = this.getTable().offsetHeight;\n\n      if (args.name === 'add' && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.parent.getContent().firstChild.scroll(0, height);\n      }\n    }\n  };\n\n  FreezeContentRender.prototype.setHeightToContent = function (height) {\n    this.getFrozenContent().style.height = height.toString() + 'px';\n    this.getMovableContent().style.height = height.toString() + 'px';\n  };\n\n  FreezeContentRender.prototype.actionComplete = function (args) {\n    if (this.parent.editSettings.mode !== 'Dialog' && (args.requestType === 'add' || args.requestType === 'cancel' && args.row.classList.contains(addedRow)) && (!this.parent.frozenRows || this.parent.editSettings.newRowPosition === 'Bottom') && this.parent.height !== 'auto') {\n      this.refreshScrollOffset();\n      var height = this.getTable().offsetHeight;\n\n      if (args.requestType === 'add' && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.parent.getContent().firstChild.scroll(0, height);\n      }\n    }\n  };\n\n  FreezeContentRender.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.removeEventListener(actionComplete, this.actionComplete);\n    this.parent.removeEventListener(batchAdd, this.batchAdd);\n    this.parent.off(columnVisibilityChanged, this.widthService.refreshFrozenScrollbar);\n  };\n\n  FreezeContentRender.prototype.renderPanel = function () {\n    _super.prototype.renderPanel.call(this);\n\n    var fDiv = this.parent.element.querySelector('.' + frozenContent);\n    var mDiv = this.parent.element.querySelector('.' + movableContent);\n\n    if (isNullOrUndefined(fDiv)) {\n      fDiv = this.parent.createElement('div', {\n        className: 'e-frozencontent e-frozen-left-content'\n      });\n      mDiv = this.parent.createElement('div', {\n        className: movableContent\n      });\n      this.getPanel().querySelector('.' + content).appendChild(fDiv);\n      this.getPanel().querySelector('.' + content).appendChild(mDiv);\n      mDiv.style.scrollbarWidth = 'none';\n    }\n\n    this.setFrozenContent(fDiv);\n    this.setMovableContent(mDiv);\n\n    if (Browser.userAgent.indexOf('Mac OS') > -1 && Browser.info.name === 'safari' && !this.parent.enableVirtualization) {\n      this.getPanel().firstElementChild.classList.add('e-mac-safari');\n    }\n  };\n\n  FreezeContentRender.prototype.renderFrozenRigthPanel = function () {\n    _super.prototype.renderPanel.call(this);\n  };\n\n  FreezeContentRender.prototype.renderEmpty = function (tbody$$1) {\n    _super.prototype.renderEmpty.call(this, tbody$$1);\n\n    this.getMovableContent().querySelector(tbody).innerHTML = '<tr><td></td></tr>';\n    addClass([this.getMovableContent().querySelector(tbody).querySelector('tr')], ['e-emptyrow']);\n    this.getFrozenContent().querySelector('.e-emptyrow').querySelector('td').colSpan = this.parent.getVisibleFrozenColumns();\n    this.getFrozenContent().style.borderRightWidth = '0px';\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody).innerHTML = '';\n      this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody).innerHTML = '';\n    }\n  };\n\n  FreezeContentRender.prototype.renderFrozenRightEmpty = function (tbody$$1) {\n    _super.prototype.renderEmpty.call(this, tbody$$1);\n  };\n\n  FreezeContentRender.prototype.setFrozenContent = function (ele) {\n    this.frozenContent = ele;\n  };\n  /**\n   * @param {Element} ele - specifies the element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  FreezeContentRender.prototype.setMovableContent = function (ele) {\n    this.movableContent = ele;\n  };\n\n  FreezeContentRender.prototype.getFrozenContent = function () {\n    return this.frozenContent;\n  };\n\n  FreezeContentRender.prototype.getMovableContent = function () {\n    return this.movableContent;\n  };\n\n  FreezeContentRender.prototype.getModelGenerator = function () {\n    return new FreezeRowModelGenerator(this.parent);\n  };\n\n  FreezeContentRender.prototype.renderFrozenRightTable = function () {\n    _super.prototype.renderTable.call(this);\n  };\n\n  FreezeContentRender.prototype.renderTable = function () {\n    var mTbl;\n\n    if (this.getFrozenContent().querySelector('.' + table) == null) {\n      _super.prototype.renderTable.call(this);\n\n      this.getFrozenContent().appendChild(this.getTable());\n      mTbl = this.getTable().cloneNode(true);\n      this.getMovableContent().appendChild(mTbl);\n    } else {\n      this.setTable(this.getFrozenContent().querySelector('.' + table));\n      this.setColGroup(this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true));\n      this.getFrozenContent().querySelector('.' + table).appendChild(this.getColGroup());\n      mTbl = this.getMovableContent().querySelector('.' + table);\n\n      if (this.parent.frozenRows) {\n        this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n      }\n    }\n\n    if (this.getMovableContent().querySelector(colGroup)) {\n      remove(this.getMovableContent().querySelector(colGroup));\n    }\n\n    var colGroup$$1 = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n    mTbl.insertBefore(colGroup$$1, mTbl.querySelector(tbody));\n    var style = this.parent.enableVirtualization ? '' : 'flex';\n    this.getPanel().firstChild.style.display = style;\n    this.renderHorizontalScrollbar('e-frozenscrollbar e-frozen-left-scrollbar', this.getScrollbarDisplay());\n  };\n\n  FreezeContentRender.prototype.getScrollbarDisplay = function () {\n    var frozenDisplay = '';\n\n    if (this.parent.getFrozenColumns() && !this.parent.getVisibleFrozenColumns() || this.parent.getFrozenLeftColumnsCount() && !this.parent.getVisibleFrozenLeftCount()) {\n      frozenDisplay = 'none';\n    }\n\n    return frozenDisplay;\n  };\n\n  FreezeContentRender.prototype.renderHorizontalScrollbar = function (className, display, isRight) {\n    var left = this.parent.createElement('div', {\n      className: className,\n      styles: 'display:' + display\n    });\n    var movable = this.parent.createElement('div', {\n      className: 'e-movablescrollbar'\n    });\n    var child = this.parent.createElement('div', {\n      className: 'e-movablechild'\n    });\n    var scrollbarHeight = getScrollBarWidth().toString();\n    this.setScrollbarHeight(movable, scrollbarHeight);\n    this.setScrollbarHeight(child, scrollbarHeight);\n    movable.appendChild(child);\n    this.appendScrollbar(left, movable, isRight);\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  FreezeContentRender.prototype.appendScrollbar = function (frozen, movable, isRight) {\n    var parent = this.parent.createElement('div', {\n      className: 'e-scrollbar',\n      styles: 'display: flex'\n    });\n    parent.appendChild(frozen);\n    parent.appendChild(movable);\n    this.parent.getContent().appendChild(parent);\n  };\n\n  FreezeContentRender.prototype.setScrollbarHeight = function (ele, height) {\n    ele.style.minHeight = height + 'px';\n    ele.style.maxHeight = height + 'px';\n  };\n  /**\n   * @param {NotifyArgs} args - specifies the NotifyArgs\n   * @param {freezeTable} tableName - specifies the Freeze Table\n   * @returns {void}\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  FreezeContentRender.prototype.setIsFrozen = function (args, tableName) {\n    args.isFrozen = !args.isFrozen;\n  };\n  /**\n   * @param {Row<Column>[]} modelData - specifies the modeldata\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {freezeTable} returns the freeze table\n   * @hidden\n   */\n\n\n  FreezeContentRender.prototype.setTbody = function (modelData, args) {\n    var tableName;\n\n    if (isNullOrUndefined(modelData[0].cells[0])) {\n      this.getMovableContent().querySelector(tbody).innerHTML = '';\n    }\n\n    var cell = modelData[0].cells[0];\n    var idx = cell.index;\n\n    if (isUndefined(idx) && this.parent.isRowDragable()) {\n      cell = modelData[0].cells[1];\n      idx = cell.index;\n    }\n\n    if (idx === 0) {\n      this.getPanel().firstChild.style.overflowX = 'hidden';\n\n      if (this.parent.enableColumnVirtualization) {\n        this.getMovableContent().style.overflowX = 'hidden';\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization && args.renderMovableContent && args.requestType === 'virtualscroll' && this.getMovableContent().scrollLeft > 0 && args.virtualInfo.columnIndexes[0] !== 0) {\n      idx = this.parent.getFrozenColumns();\n    }\n\n    if (cell && cell.column) {\n      tableName = cell.column.getFreezeTableName();\n    }\n\n    this.setIdx(idx);\n    args.tableName = tableName;\n    return tableName;\n  };\n  /**\n   * @param {string} tableName - specifies the table name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  FreezeContentRender.prototype.splitRows = function (tableName) {\n    if (tableName === frozenLeft) {\n      this.freezeRows = this.rows;\n      this.freezeRowElements = this.rowElements;\n    } else {\n      this.movableRows = this.rows;\n    }\n  };\n  /**\n   * @param {NotifyArgs} args - specifies the notifyargs\n   * @param {string} tableName - specifies the tableName\n   * @returns {void}\n   * @hidden\n   */\n\n\n  FreezeContentRender.prototype.renderNextFrozentPart = function (args, tableName) {\n    var isVFTable = this.parent.enableVirtualization;\n\n    if (tableName === frozenLeft) {\n      if (isVFTable) {\n        args.renderMovableContent = true;\n      }\n\n      this.refreshContentRows(extend({}, args));\n    }\n  };\n\n  FreezeContentRender.prototype.appendContent = function (tbody$$1, frag, args, tableName) {\n    if (this.parent.isReact && !isNullOrUndefined(this.parent.rowTemplate)) {\n      tbody$$1 = frag;\n    } else {\n      tbody$$1.appendChild(frag);\n    }\n\n    if (tableName === frozenLeft) {\n      this.isLoaded = false;\n      this.getFrozenContent().querySelector('table').appendChild(tbody$$1);\n    } else {\n      this.refreshTbody(tbody$$1);\n      this.isLoaded = true;\n      this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n      this.refreshHeight();\n      this.refreshScrollOffset();\n      this.widthService.refreshFrozenScrollbar();\n    }\n\n    if (this.isInitialRender) {\n      this.parent.scrollModule.setHeight();\n      this.isInitialRender = false;\n    }\n  };\n\n  FreezeContentRender.prototype.refreshScrollOffset = function () {\n    if (this.parent.height !== 'auto') {\n      var height = this.getTable().offsetHeight + 1;\n      this.setHeightToContent(height);\n    }\n\n    this.parent.notify(refreshFrozenHeight, {});\n  };\n  /**\n   * @param {string} tableName - specifies the table name\n   * @returns {HTMLElement} returns the Html element\n   * @hidden\n   */\n\n\n  FreezeContentRender.prototype.getFrozenHeader = function (tableName) {\n    if (tableName === frozenLeft) {\n      return this.parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody);\n    } else {\n      return this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody);\n    }\n  };\n\n  FreezeContentRender.prototype.refreshTbody = function (tbody$$1) {\n    if (tbody$$1.childElementCount < 1) {\n      tbody$$1.appendChild(this.parent.createElement('tr', {\n        attrs: {\n          role: 'row'\n        }\n      }).appendChild(this.parent.createElement('td')));\n    }\n  };\n\n  FreezeContentRender.prototype.refreshHeight = function () {\n    if (!this.parent.allowTextWrap) {\n      this.parent.notify(freezeRender, {\n        case: 'refreshHeight'\n      });\n    }\n\n    this.getFrozenContent().style.borderRightWidth = '1px';\n  };\n\n  FreezeContentRender.prototype.setIdx = function (idx) {\n    this.idx = idx;\n  };\n\n  FreezeContentRender.prototype.getIdx = function () {\n    return this.idx;\n  };\n  /**\n   * @param {freezeTable} tableName - specifies the table name\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  FreezeContentRender.prototype.getTbody = function (tableName) {\n    if (tableName === frozenLeft) {\n      return this.getTable().querySelector(tbody);\n    } else {\n      return this.getMovableContent().querySelector(tbody);\n    }\n  };\n\n  return FreezeContentRender;\n}(ContentRender);\n\nvar FreezeRender =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$32(FreezeRender, _super);\n\n  function FreezeRender(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n\n  FreezeRender.prototype.addEventListener = function () {\n    this.eventHandler = [{\n      event: freezeRender,\n      handler: this.refreshFreeze\n    }, {\n      event: frozenHeight,\n      handler: this.setFrozenHeight\n    }, {\n      event: uiUpdate,\n      handler: this.enableAfterRender\n    }];\n    addRemoveEventListener(this.parent, this.eventHandler, true, this);\n  };\n\n  FreezeRender.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.eventHandler, false);\n  };\n\n  FreezeRender.prototype.renderTable = function () {\n    _super.prototype.renderTable.call(this);\n\n    this.rfshMovable();\n    this.updateColgroup();\n    this.initializeHeaderDrag();\n    this.initializeHeaderDrop();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  };\n\n  FreezeRender.prototype.renderPanel = function () {\n    var fDiv = this.parent.element.querySelector('.' + frozenHeader);\n    var mDiv = this.parent.element.querySelector('.' + movableHeader);\n\n    _super.prototype.renderPanel.call(this);\n\n    if (isNullOrUndefined(fDiv)) {\n      fDiv = this.parent.createElement('div', {\n        className: 'e-frozenheader e-frozen-left-header'\n      });\n      mDiv = this.parent.createElement('div', {\n        className: movableHeader\n      });\n      this.getPanel().querySelector('.' + headerContent).appendChild(fDiv);\n      this.getPanel().querySelector('.' + headerContent).appendChild(mDiv);\n    }\n\n    this.setFrozenHeader(fDiv);\n    this.setMovableHeader(mDiv);\n  };\n\n  FreezeRender.prototype.renderFrozenRightPanel = function () {\n    _super.prototype.renderPanel.call(this);\n  };\n\n  FreezeRender.prototype.renderFrozenRightTable = function () {\n    _super.prototype.renderTable.call(this);\n  };\n\n  FreezeRender.prototype.refreshUI = function () {\n    var tbody$$1 = this.getMovableHeader().querySelector(tbody);\n    remove(this.getMovableHeader().querySelector('table'));\n\n    _super.prototype.refreshUI.call(this);\n\n    this.rfshMovable();\n    this.getMovableHeader().querySelector(tbody).innerHTML = tbody$$1.innerHTML;\n    this.updateColgroup();\n    this.widthService.setWidthToColumns();\n\n    if (!this.parent.enableVirtualization && !this.parent.isFrozenGrid()) {\n      this.widthService.setWidthToTable();\n    }\n\n    if (this.parent.allowTextWrap && this.parent.textWrapSettings.wrapMode === 'Header') {\n      wrap([].slice.call(this.movableHeader.querySelectorAll('tr.e-columnheader')), true);\n    }\n\n    this.parent.updateDefaultCursor();\n    renderMovable(this.parent.getContentTable().querySelector(colGroup), this.parent.getFrozenColumns(), this.parent);\n    this.widthService.refreshFrozenScrollbar();\n    this.initializeHeaderDrag();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  };\n\n  FreezeRender.prototype.refreshFrozenLeftUI = function () {\n    _super.prototype.refreshUI.call(this);\n  };\n\n  FreezeRender.prototype.rfshMovable = function () {\n    this.getFrozenHeader().appendChild(this.getTable());\n    this.getMovableHeader().appendChild(this.createHeader(undefined, 'movable'));\n    this.refreshStackedHdrHgt();\n    this.addMovableFirstCls();\n  };\n\n  FreezeRender.prototype.addMovableFirstCls = function () {\n    if (this.parent.getVisibleFrozenColumns()) {\n      var movablefirstcell = [].slice.call(this.parent.element.querySelector('.' + movableHeader).querySelector('thead').getElementsByClassName('e-columnheader'));\n      var len = movablefirstcell.length;\n\n      for (var i = 0; i < len; i++) {\n        var cells = 'cells';\n        var element = movablefirstcell[i][cells][0];\n\n        if (element) {\n          addClass([element], ['e-movablefirst']);\n\n          if (movablefirstcell[i][cells][0].rowSpan > 1) {\n            i = i + (movablefirstcell[i][cells][0].rowSpan - 1);\n          }\n        }\n      }\n    }\n  };\n\n  FreezeRender.prototype.refreshFreeze = function (obj) {\n    if (obj.case === 'filter') {\n      var filterRow = this.getTable().querySelector('.e-filterbar');\n\n      if (this.parent.allowFiltering && filterRow && this.getMovableHeader().querySelector('thead')) {\n        this.getMovableHeader().querySelector('thead:not(.e-masked-thead)').appendChild(this.filterRenderer(filterRow, this.parent.getFrozenColumns()));\n        var elements = [].slice.call(this.getMovableHeader().querySelectorAll('thead .e-filterbarcell .e-input'));\n\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n          var elem = elements_1[_i];\n          var args = {\n            element: elem,\n            floatLabelType: 'Never',\n            properties: {\n              enableRtl: this.parent.enableRtl,\n              showClearButton: true\n            }\n          };\n          Input.bindInitialEvent(args);\n        }\n      }\n    } else if (obj.case === 'textwrap' || obj.case === 'refreshHeight') {\n      this.refreshHeight(obj);\n      this.parent.contentModule.refreshScrollOffset();\n    }\n  };\n\n  FreezeRender.prototype.refreshHeight = function (obj) {\n    var fRows;\n    var mRows;\n    var fHdr = this.getFrozenHeader();\n    var mHdr = this.getMovableHeader();\n    var cont = this.parent.getContent();\n    var wrapMode = this.parent.textWrapSettings.wrapMode;\n    var hdrClassList = this.parent.getHeaderContent().querySelector('.' + headerContent).classList;\n\n    if (obj.case === 'textwrap') {\n      if (wrapMode !== 'Header' || obj.isModeChg) {\n        fRows = cont.querySelector('.' + frozenContent).querySelectorAll('tr');\n        mRows = cont.querySelector('.' + movableContent).querySelectorAll('tr');\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, true);\n      }\n\n      if (wrapMode === 'Content' && this.parent.allowTextWrap) {\n        hdrClassList.add('e-wrap');\n      } else {\n        hdrClassList.remove('e-wrap');\n      }\n\n      if (wrapMode === 'Both' || obj.isModeChg) {\n        fRows = fHdr.querySelectorAll('tr');\n        mRows = mHdr.querySelectorAll('tr');\n      } else {\n        mRows = mHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n        fRows = fHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n      }\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, false, this.colDepth > 1);\n      }\n\n      this.refreshStackedHdrHgt();\n    } else if (obj.case === 'refreshHeight') {\n      this.setWrapHeight(cont.querySelector('.' + frozenContent).querySelectorAll('tr'), cont.querySelector('.' + movableContent).querySelectorAll('tr'), obj.isModeChg);\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        this.setWrapHeight(fHdr.querySelectorAll('tr'), mHdr.querySelectorAll('tr'), obj.isModeChg);\n      }\n    }\n  };\n\n  FreezeRender.prototype.enableAfterRender = function (e) {\n    if (e.module === 'scroll') {\n      this.setFrozenHeight();\n    }\n  };\n\n  FreezeRender.prototype.updateResizeHandler = function () {\n    var elements = [].slice.call(this.parent.getHeaderContent().getElementsByClassName('e-rhandler'));\n\n    for (var i = 0; i < elements.length; i++) {\n      elements[i].style.height = elements[i].parentElement.offsetHeight + 'px';\n    }\n  };\n\n  FreezeRender.prototype.setWrapHeight = function (fRows, mRows, isModeChg, isContReset, isStackedHdr) {\n    var fRowHgt;\n    var mRowHgt;\n    var isWrap = this.parent.allowTextWrap;\n    var wrapMode = this.parent.textWrapSettings.wrapMode;\n    var tHead = this.parent.getHeaderContent().querySelector('thead');\n    var tBody = this.parent.getHeaderContent().querySelector(tbody);\n    var height = [];\n    var width = [];\n\n    for (var i = 0, len = fRows.length; i < len; i++) {\n      if (isModeChg && (!this.parent.rowHeight && tBody.className === 'e-hide' || wrapMode === 'Header' && isContReset || wrapMode === 'Content' && tHead.contains(fRows[i]) || wrapMode === 'Header' && tBody.contains(fRows[i])) || isStackedHdr) {\n        fRows[i].style.height = null;\n        mRows[i].style.height = null;\n      }\n\n      if (!isNullOrUndefined(fRows[i]) && !isNullOrUndefined(mRows[i])) {\n        height[i] = fRows[i].getBoundingClientRect().height; //https://pagebuildersandwich.com/increased-plugins-performance-200/\n\n        width[i] = mRows[i].getBoundingClientRect().height;\n      }\n\n      fRowHgt = height[i];\n      mRowHgt = width[i];\n\n      if (!isNullOrUndefined(fRows[i]) && fRows[i].childElementCount && (isWrap && fRowHgt < mRowHgt || !isWrap && fRowHgt < mRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === false)) {\n        fRows[i].style.height = mRowHgt + 'px';\n      }\n\n      if (mRows && !isNullOrUndefined(mRows[i]) && mRows[i].childElementCount && (isWrap && fRowHgt > mRowHgt || !isWrap && fRowHgt > mRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === true)) {\n        mRows[i].style.height = fRowHgt + 'px';\n      }\n    }\n\n    if (isWrap && this.parent.height !== 'auto') {\n      this.setFrozenHeight();\n    }\n  };\n\n  FreezeRender.prototype.setFrozenHeight = function (height) {\n    if (height === void 0) {\n      height = getScrollBarWidth();\n    }\n\n    var movableContentHeight = this.parent.element.querySelector('.' + movableContent).getBoundingClientRect().height;\n    var movableContent$$1 = this.parent.element.querySelector('.' + movableContent);\n    var frozenContent$$1 = this.parent.element.querySelector('.' + frozenContent);\n    var contentScrollWidth = this.parent.getContent().scrollWidth;\n    var contentTableScrollWidth = this.parent.element.querySelector('.e-movablecontent table').scrollWidth + this.parent.getContentTable().scrollWidth;\n\n    if (movableContent$$1.scrollWidth - movableContent$$1.clientWidth) {\n      frozenContent$$1.style.height = movableContentHeight - height + 'px';\n      frozenContent$$1.style.borderBottom = '';\n    } else {\n      frozenContent$$1.style.height = movableContentHeight + 'px';\n\n      if ((frozenContent$$1.scrollHeight <= frozenContent$$1.clientHeight || movableContent$$1.scrollHeight <= movableContent$$1.clientHeight) && contentScrollWidth === contentTableScrollWidth) {\n        this.parent.scrollModule.removePadding();\n      }\n\n      frozenContent$$1.style.borderBottom = '0px';\n    }\n  };\n\n  FreezeRender.prototype.refreshStackedHdrHgt = function () {\n    var fRowSpan;\n    var mRowSpan;\n    var fTr = [].slice.call(this.getFrozenHeader().getElementsByClassName('e-columnheader'));\n    var mTr = [].slice.call(this.getMovableHeader().getElementsByClassName('e-columnheader'));\n\n    for (var i = 0, len = fTr.length; i < len; i++) {\n      fRowSpan = this.getRowSpan(fTr[i]);\n      mRowSpan = this.getRowSpan(mTr[i]);\n\n      if (fRowSpan.min > 1) {\n        this.updateStackedHdrRowHgt(i, fRowSpan.max, fTr[i], mTr);\n      } else if (mRowSpan.min > 1) {\n        this.updateStackedHdrRowHgt(i, mRowSpan.max, mTr[i], fTr);\n      }\n    }\n\n    if (this.parent.allowResizing) {\n      this.updateResizeHandler();\n    }\n  };\n\n  FreezeRender.prototype.getRowSpan = function (row$$1) {\n    var rSpan;\n    var minRowSpan;\n    var maxRowSpan;\n\n    for (var i = 0, len = row$$1.childElementCount; i < len; i++) {\n      if (i === 0) {\n        minRowSpan = row$$1.children[0].rowSpan;\n      }\n\n      rSpan = row$$1.children[i].rowSpan;\n      minRowSpan = Math.min(rSpan, minRowSpan);\n      maxRowSpan = Math.max(rSpan, minRowSpan);\n    }\n\n    return {\n      min: minRowSpan,\n      max: maxRowSpan\n    };\n  };\n\n  FreezeRender.prototype.updateStackedHdrRowHgt = function (idx, maxRowSpan, row$$1, rows) {\n    var height = 0;\n\n    for (var i = 0; i < maxRowSpan; i++) {\n      height += rows[idx + i].style.height ? parseInt(rows[idx + i].style.height, 10) : rows[idx + i].offsetHeight;\n    }\n\n    row$$1.style.height = height + 'px';\n  };\n\n  FreezeRender.prototype.setFrozenHeader = function (ele) {\n    this.frozenHeader = ele;\n  };\n  /**\n   * @param {Element} ele - specifies the element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  FreezeRender.prototype.setMovableHeader = function (ele) {\n    this.movableHeader = ele;\n  };\n\n  FreezeRender.prototype.getFrozenHeader = function () {\n    return this.frozenHeader;\n  };\n\n  FreezeRender.prototype.getMovableHeader = function () {\n    return this.movableHeader;\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  FreezeRender.prototype.updateColgroup = function () {\n    var mTable = this.getMovableHeader().querySelector('table');\n    remove(this.getMovableHeader().querySelector(colGroup));\n    mTable.insertBefore(renderMovable(this.getFrozenHeader().querySelector(colGroup), this.parent.getFrozenColumns(), this.parent), mTable.querySelector('thead'));\n  };\n\n  FreezeRender.prototype.filterRenderer = function (ele, frozenColumn, total) {\n    var clone = ele.cloneNode(true);\n    clone.innerHTML = '';\n    var end = total ? total : this.parent.getColumns().length;\n\n    if (this.parent.allowRowDragAndDrop && this.parent.getFrozenColumns()) {\n      end += 1;\n      frozenColumn += 1;\n    }\n\n    for (var i = frozenColumn; i < end; i++) {\n      clone.appendChild(ele.removeChild(ele.children[frozenColumn]));\n    }\n\n    return clone;\n  };\n\n  return FreezeRender;\n}(HeaderRender);\n\nvar __extends$34 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * ColumnFreezeHeaderRenderer is used to freeze the columns header at right and left\n *\n * @hidden\n */\n\n\nvar ColumnFreezeHeaderRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$34(ColumnFreezeHeaderRenderer, _super);\n\n  function ColumnFreezeHeaderRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n\n  ColumnFreezeHeaderRenderer.prototype.addEventListener = function () {\n    this.evtHandlers = [{\n      event: freezeRender,\n      handler: this.refreshFreeze\n    }, {\n      event: refreshFrozenColumns,\n      handler: this.refreshFrozenColumns\n    }, {\n      event: setReorderDestinationElement,\n      handler: this.setReorderElement\n    }, {\n      event: columnVisibilityChanged,\n      handler: this.setVisible\n    }];\n    addRemoveEventListener(this.parent, this.evtHandlers, true, this);\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    addRemoveEventListener(this.parent, this.evtHandlers, false);\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.setReorderElement = function (args) {\n    this.destEle = args.ele;\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.refreshFrozenColumns = function (args) {\n    if (!args.parent) {\n      this.parent.setProperties({\n        columns: args.columns\n      }, true);\n    }\n\n    var isFrozenLeft = parentsUntil(this.destEle, 'e-frozen-left-header');\n    var isFrozenRight = parentsUntil(this.destEle, 'e-frozen-right-header');\n    var left = this.parent.getFrozenLeftColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n    args.column.freeze = null;\n\n    if (isFrozenLeft) {\n      args.column.freeze = 'Left';\n    } else if (isFrozenRight) {\n      args.column.freeze = 'Right';\n    }\n\n    this.parent.setFrozenCount();\n    args.cancel = left !== this.parent.getFrozenLeftColumnsCount() || right !== this.parent.getFrozenRightColumnsCount();\n\n    if (args.cancel) {\n      this.parent.refreshColumns();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.setWrapHeight = function (fRows, mRows, isModeChg, isContReset, isStackedHdr, frRows) {\n    var fRowHgt;\n    var mRowHgt;\n    var frRowHgt;\n    var isWrap = this.parent.allowTextWrap;\n    var tBody = this.parent.getHeaderContent().querySelector(tbody);\n    var wrapMode = this.parent.textWrapSettings.wrapMode;\n    var tHead = this.parent.getHeaderContent().querySelector('thead');\n    var height = [];\n    var width = [];\n    var rightHeight = [];\n\n    for (var i = 0, len = fRows.length; i < len; i++) {\n      //separate loop for performance issue\n      if (!isNullOrUndefined(fRows[i]) && !isNullOrUndefined(mRows[i])) {\n        if (frRows) {\n          rightHeight[i] = frRows[i].getBoundingClientRect().height;\n        }\n\n        width[i] = mRows[i].getBoundingClientRect().height;\n        height[i] = fRows[i].getBoundingClientRect().height; //https://pagebuildersandwich.com/increased-plugins-performance-200/\n      }\n    }\n\n    for (var i = 0, len = fRows.length; i < len; i++) {\n      if (isModeChg && (wrapMode === 'Content' && tHead.contains(fRows[i]) || wrapMode === 'Header' && tBody.contains(fRows[i]) || wrapMode === 'Header' && isContReset) || isStackedHdr) {\n        if (frRows[i]) {\n          frRows[i].style.height = null;\n        }\n\n        fRows[i].style.height = null;\n        mRows[i].style.height = null;\n      }\n\n      fRowHgt = height[i];\n      mRowHgt = width[i];\n      frRowHgt = rightHeight[i] ? rightHeight[i] : 0;\n      var maxHeight = Math.max(fRowHgt, mRowHgt, frRowHgt);\n\n      if (!isNullOrUndefined(fRows[i]) && fRows[i].childElementCount && (isWrap && fRowHgt < maxHeight || !isWrap && fRowHgt < maxHeight || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === false)) {\n        fRows[i].style.height = maxHeight + 'px';\n      }\n\n      if (mRows && !isNullOrUndefined(mRows[i]) && mRows[i].childElementCount && (isWrap && maxHeight > mRowHgt || !isWrap && maxHeight > mRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === true)) {\n        mRows[i].style.height = maxHeight + 'px';\n      }\n\n      if (frRows && !isNullOrUndefined(frRows[i]) && frRows[i].childElementCount && (isWrap && maxHeight > frRowHgt || !isWrap && maxHeight > frRowHgt || this.parent.allowResizing && this.parent.resizeModule && this.parent.resizeModule.isFrozenColResized === true)) {\n        frRows[i].style.height = maxHeight + 'px';\n      }\n    }\n\n    if (isWrap) {\n      this.setFrozenHeight();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.refreshHeight = function (obj) {\n    var isLeftRight = this.parent.getFrozenMode() === leftRight;\n    var fRows;\n    var frRows;\n    var mRows;\n    var frHdr = this.getFrozenRightHeader();\n    var fHdr = this.parent.getHeaderContent().querySelector('.' + frozenHeader);\n    var cont = this.parent.getContent();\n    var mHdr = this.getMovableHeader();\n    var hdrClassList = this.parent.getHeaderContent().querySelector('.' + headerContent).classList;\n    var wrapMode = this.parent.textWrapSettings.wrapMode;\n\n    if (obj.case === 'textwrap') {\n      if (wrapMode !== 'Header' || obj.isModeChg) {\n        if (isLeftRight) {\n          frRows = cont.querySelector('.e-frozen-right-content').querySelectorAll('tr');\n        }\n\n        mRows = cont.querySelector('.' + movableContent).querySelectorAll('tr');\n        fRows = cont.querySelector('.' + frozenContent).querySelectorAll('tr');\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, true, false, frRows);\n      }\n\n      if (wrapMode === 'Content' && this.parent.allowTextWrap) {\n        hdrClassList.add('e-wrap');\n      } else {\n        hdrClassList.remove('e-wrap');\n      }\n\n      if (wrapMode === 'Both' || obj.isModeChg) {\n        if (isLeftRight) {\n          frRows = frHdr.querySelectorAll('tr');\n        }\n\n        fRows = fHdr.querySelectorAll('tr');\n        mRows = mHdr.querySelectorAll('tr');\n      } else {\n        if (isLeftRight) {\n          frRows = frHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n        }\n\n        fRows = fHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n        mRows = mHdr.querySelector(wrapMode === 'Content' ? tbody : 'thead').querySelectorAll('tr');\n      }\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, false, this.colDepth > 1, frRows);\n      }\n\n      this.refreshStackedHdrHgt();\n    } else if (obj.case === 'refreshHeight') {\n      mRows = cont.querySelector('.' + movableContent).querySelectorAll('tr');\n      fRows = cont.querySelector('.' + frozenContent).querySelectorAll('tr');\n\n      if (isLeftRight) {\n        frRows = cont.querySelector('.e-frozen-right-content').querySelectorAll('tr');\n      }\n\n      this.setWrapHeight(fRows, mRows, obj.isModeChg, false, false, frRows);\n\n      if (!this.parent.getHeaderContent().getElementsByClassName('e-stackedheadercell').length) {\n        if (isLeftRight) {\n          frRows = frHdr.querySelectorAll('tr');\n        }\n\n        fRows = fHdr.querySelectorAll('tr');\n        mRows = mHdr.querySelectorAll('tr');\n        this.setWrapHeight(fRows, mRows, obj.isModeChg, false, false, frRows);\n      }\n    }\n  };\n  /**\n   * Function to hide header table column based on visible property\n   *\n   * @param {Column[]} columns - specifies the column[]\n   * @returns {void}\n   */\n\n\n  ColumnFreezeHeaderRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var displayVal;\n    var idx;\n    var left = this.parent.getFrozenLeftColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n    var movable = this.parent.getMovableColumnsCount();\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n\n      if (column.freeze === 'Left' || column.freeze === 'Right') {\n        if (left && !right) {\n          var leftColGrp = gObj.getHeaderContent().querySelector('.e-frozen-left-header').querySelector(colGroup);\n          setStyleAttribute(leftColGrp.children[idx], {\n            'display': displayVal\n          });\n        } else if (!left && right) {\n          var rightColGrp = gObj.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup);\n          setStyleAttribute(rightColGrp.children[idx - movable], {\n            'display': displayVal\n          });\n        }\n      } else {\n        var mTblColGrp = gObj.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup);\n        setStyleAttribute(mTblColGrp.children[idx - left], {\n          'display': displayVal\n        });\n      }\n    }\n\n    this.refreshUI();\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.filterRenderer = function (ele, frozenColumn, total) {\n    return _super.prototype.filterRenderer.call(this, ele, frozenColumn, total);\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.refreshUI = function () {\n    var frTbody;\n    var tbody$$1 = this.getMovableHeader().querySelector(tbody);\n    remove(this.getMovableHeader().querySelector('table'));\n\n    if (this.parent.getFrozenMode() === leftRight) {\n      frTbody = this.getFrozenRightHeader().querySelector(tbody);\n      remove(this.getFrozenRightHeader().querySelector('table'));\n    }\n\n    _super.prototype.refreshFrozenLeftUI.call(this);\n\n    this.rfshMovable();\n    this.getMovableHeader().querySelector(tbody).innerHTML = tbody$$1.innerHTML;\n\n    if (frTbody) {\n      this.getFrozenRightHeader().querySelector(tbody).innerHTML = frTbody.innerHTML;\n    }\n\n    this.updateColgroup();\n    this.widthService.setWidthToColumns();\n    this.parent.notify(colGroupRefresh, {});\n\n    if (this.parent.allowTextWrap && this.parent.textWrapSettings.wrapMode === 'Header') {\n      wrap([].slice.call(this.getMovableHeader().querySelectorAll('tr.e-columnheader')), true);\n    }\n\n    this.parent.updateDefaultCursor();\n    var mTbl = this.parent.getContent().querySelector('.' + movableContent).querySelector('.' + table);\n    remove(mTbl.querySelector(colGroup));\n    var mColGroup = this.getMovableHeader().querySelector(colGroup).cloneNode(true);\n    mTbl.insertBefore(mColGroup, mTbl.querySelector(tbody));\n\n    if (frTbody) {\n      var frtbl = this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.' + table);\n      remove(frtbl.querySelector(colGroup));\n      var frtblColGroup = this.getFrozenRightHeader().querySelector(colGroup).cloneNode(true);\n      frtbl.insertBefore(frtblColGroup, frtbl.querySelector(tbody));\n    }\n\n    this.widthService.refreshFrozenScrollbar();\n    this.initializeHeaderDrag();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.refreshFreeze = function (obj) {\n    var left = this.parent.getFrozenLeftColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n    var movable = this.parent.getMovableColumnsCount();\n\n    if (obj.case === 'filter') {\n      var filterRow = this.getTable().querySelector('.e-filterbar');\n\n      if (this.parent.allowFiltering && filterRow && this.getMovableHeader().querySelector('thead')) {\n        var isDraggable = this.parent.isRowDragable();\n        var index = left ? isDraggable ? left + 1 : left : 0;\n        var total = left + movable + (left && isDraggable ? 1 : 0);\n        this.getMovableHeader().querySelector('thead').appendChild(this.filterRenderer(filterRow, index, total));\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          var ele = [].slice.call(this.getMovableHeader().querySelectorAll('thead .e-filterbarcell .e-input'));\n          this.getFrozenRightHeader().querySelector('thead').appendChild(this.filterRenderer(filterRow, index, index + right));\n          this.adjudtFilterBarCell(ele);\n        }\n\n        var elements = [].slice.call(this.getMovableHeader().querySelectorAll('thead .e-filterbarcell .e-input'));\n        this.adjudtFilterBarCell(elements);\n      }\n    } else if (obj.case === 'textwrap' || obj.case === 'refreshHeight') {\n      this.refreshHeight(obj);\n      this.parent.contentModule.refreshScrollOffset();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.updateFrozenColGroup = function (cols, colGroup$$1) {\n    if (cols && cols.visible === false) {\n      setStyleAttribute(colGroup$$1, {\n        'display': 'none'\n      });\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.adjudtFilterBarCell = function (elements) {\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var elem = elements_1[_i];\n      var args = {\n        element: elem,\n        floatLabelType: 'Never',\n        properties: {\n          enableRtl: this.parent.enableRtl,\n          showClearButton: true\n        }\n      };\n      Input.bindInitialEvent(args);\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.renderPanel = function () {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.renderPanel.call(this);\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderLeftWithRightFrozenPanel();\n      }\n    } else {\n      this.renderRightFrozenPanelAlone();\n    }\n\n    this.getPanel().firstChild.style.display = 'flex';\n    this.getMovableHeader().style.flex = '1';\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.renderTable = function () {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.renderTable.call(this);\n    } else {\n      this.renderFrozenRightTableAlone();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.rfshMovable = function () {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.rfshMovable.call(this);\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        var rows = this.rows;\n        this.getFrozenRightHeader().appendChild(this.createHeader(undefined, 'frozen-right'));\n        this.refreshStackedHdrHgt();\n        this.parent.notify(headerRefreshed, {\n          rows: this.rows,\n          args: {\n            renderFrozenRightContent: true\n          }\n        });\n        this.rows = rows;\n      }\n    } else {\n      this.getFrozenRightHeader().appendChild(this.getTable());\n      this.getMovableHeader().appendChild(this.createHeader(undefined, 'movable'));\n      this.refreshStackedHdrHgt();\n      this.addMovableFirstCls();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.refreshStackedHdrHgt = function () {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.refreshStackedHdrHgt.call(this);\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.refreshFrozenRightStackedHdrHgt();\n      }\n    } else {\n      this.refreshFrozenRightStackedHdrHgt();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.refreshFrozenRightStackedHdrHgt = function () {\n    var fRowSpan;\n    var frTr = [].slice.call(this.getFrozenRightHeader().getElementsByClassName('e-columnheader'));\n    var mTr = [].slice.call(this.getMovableHeader().getElementsByClassName('e-columnheader'));\n\n    for (var i = 0, len = frTr.length; i < len; i++) {\n      fRowSpan = this.getRowSpan(frTr[i]);\n\n      if (fRowSpan.min > 1) {\n        this.updateStackedHdrRowHgt(i, fRowSpan.max, frTr[i], mTr);\n      }\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnFreezeHeaderRenderer.prototype.updateColgroup = function () {\n    this.updateMovableColGroup();\n\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      this.updateFrozenLeftColGroup();\n    }\n\n    if (this.parent.getFrozenRightColumnsCount()) {\n      this.updateFrozenRightColGroup();\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.renderRightFrozenPanelAlone = function () {\n    var mDiv = this.parent.element.querySelector('.' + movableHeader);\n    var fRightDiv = this.parent.element.querySelector('.e-frozen-right-header');\n\n    _super.prototype.renderFrozenRightPanel.call(this);\n\n    if (isNullOrUndefined(fRightDiv)) {\n      mDiv = this.parent.createElement('div', {\n        className: movableHeader\n      });\n      fRightDiv = this.parent.createElement('div', {\n        className: 'e-frozenheader e-frozen-right-header'\n      });\n      this.getPanel().querySelector('.' + headerContent).appendChild(mDiv);\n      this.getPanel().querySelector('.' + headerContent).appendChild(fRightDiv);\n    }\n\n    _super.prototype.setMovableHeader.call(this, mDiv);\n\n    this.setFrozenRightHeader(fRightDiv);\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.renderLeftWithRightFrozenPanel = function () {\n    var fRightDiv = this.parent.element.querySelector('.e-frozen-right-header');\n\n    _super.prototype.renderFrozenRightPanel.call(this);\n\n    if (isNullOrUndefined(fRightDiv)) {\n      fRightDiv = this.parent.createElement('div', {\n        className: 'e-frozenheader e-frozen-right-header'\n      });\n      this.getPanel().querySelector('.' + headerContent).appendChild(fRightDiv);\n    }\n\n    this.setFrozenRightHeader(fRightDiv);\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.renderFrozenRightTableAlone = function () {\n    _super.prototype.renderFrozenRightTable.call(this);\n\n    this.rfshMovable();\n    this.updateColgroup();\n    this.initializeHeaderDrag();\n    this.initializeHeaderDrop();\n    this.parent.notify(headerRefreshed, {\n      rows: this.rows,\n      args: {\n        isFrozen: false\n      }\n    });\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.updateFrozenLeftColGroup = function () {\n    var leftColGroup = this.getFrozenHeader().querySelector(colGroup).children;\n    var start = this.parent.isRowDragable() ? 1 : 0;\n    var count = this.parent.isRowDragable() ? this.parent.getFrozenLeftColumnsCount() + 1 : this.parent.getFrozenLeftColumnsCount();\n\n    for (var i = start; i < leftColGroup.length; i++) {\n      if (i >= count) {\n        remove(leftColGroup[i]);\n        i--;\n      }\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.updateMovableColGroup = function () {\n    var movableColGroup = this.getMovableHeader().querySelector(colGroup).children;\n\n    if (this.parent.isRowDragable()) {\n      remove(movableColGroup[0]);\n    }\n\n    var length = movableColGroup.length;\n    var left = this.parent.getFrozenLeftColumnsCount();\n    var movable = this.parent.getMovableColumnsCount();\n    var k = 0;\n\n    for (var i = 0; i < length; i++, k++) {\n      if (i < left || i >= left + movable) {\n        remove(movableColGroup[k]);\n        k--;\n      }\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.updateFrozenRightColGroup = function () {\n    var isDraggable = this.parent.isRowDragable();\n    var rightColumns = this.parent.getFrozenRightColumns();\n    var rightColGroup = this.getFrozenRightHeader().querySelector(colGroup).children;\n\n    if (this.parent.getFrozenMode() === leftRight && isDraggable) {\n      remove(rightColGroup[0]);\n    }\n\n    var length = rightColGroup.length;\n    var left = this.parent.getFrozenLeftColumnsCount();\n    var movable = this.parent.getMovableColumnsCount();\n    var k = 0;\n\n    for (var i = 0; i < length; i++) {\n      if (i < left + movable) {\n        remove(rightColGroup[0]);\n      } else {\n        this.updateFrozenColGroup(rightColumns[k], rightColGroup[k]);\n        k++;\n      }\n    }\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.setFrozenRightHeader = function (ele) {\n    this.frozenRightHeader = ele;\n  };\n\n  ColumnFreezeHeaderRenderer.prototype.getFrozenRightHeader = function () {\n    return this.frozenRightHeader;\n  };\n\n  return ColumnFreezeHeaderRenderer;\n}(FreezeRender);\n/**\n * ColumnFreezeContentRenderer is used to freeze the columns content at right and left\n *\n * @hidden\n */\n\n\nvar ColumnFreezeContentRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$34(ColumnFreezeContentRenderer, _super);\n\n  function ColumnFreezeContentRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.frzCount = 0;\n    _this.isColGroupRefresh = false;\n    _this.widthService = locator.getService('widthService');\n    return _this;\n  }\n\n  ColumnFreezeContentRenderer.prototype.renderPanel = function () {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.renderPanel.call(this);\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderFrozenLeftWithRightPanel();\n      }\n    } else {\n      this.renderFrozenRightPanelAlone();\n    }\n\n    var display = this.parent.enableVirtualization ? '' : 'flex';\n    this.getPanel().firstChild.style.display = display;\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderTable = function () {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.renderTable.call(this);\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderFrozenLeftWithRightTable();\n        var display = !this.parent.getVisibleFrozenRightCount() ? 'none' : '';\n        this.renderHorizontalScrollbar('e-frozenscrollbar e-frozen-right-scrollbar', display, true);\n      }\n    } else {\n      this.renderFrozenRightTableAlone();\n      var display = !this.parent.getVisibleFrozenRightCount() ? 'none' : '';\n      this.renderHorizontalScrollbar('e-frozenscrollbar e-frozen-right-scrollbar', display);\n    }\n\n    this.getMovableContent().style.flex = '1';\n  };\n\n  ColumnFreezeContentRenderer.prototype.appendScrollbar = function (frozen, movable, isRight) {\n    var parent = this.parent.createElement('div', {\n      className: 'e-scrollbar',\n      styles: 'display: flex'\n    });\n\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      if (!isRight) {\n        parent.appendChild(frozen);\n        parent.appendChild(movable);\n      } else {\n        this.parent.getContent().querySelector('.e-scrollbar').appendChild(frozen);\n        return;\n      }\n    } else {\n      parent.appendChild(movable);\n      parent.appendChild(frozen);\n    }\n\n    this.parent.getContent().appendChild(parent);\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderFrozenRightPanelAlone = function () {\n    this.renderFrozenRigthPanel();\n    var mDiv = this.parent.element.querySelector('.' + movableContent);\n    var fRightContent = this.parent.element.querySelector('.e-frozen-right-content');\n\n    if (isNullOrUndefined(fRightContent)) {\n      mDiv = this.parent.createElement('div', {\n        className: movableContent\n      });\n      fRightContent = this.parent.createElement('div', {\n        className: 'e-frozencontent e-frozen-right-content'\n      });\n      this.getPanel().querySelector('.' + content).appendChild(mDiv);\n      this.getPanel().querySelector('.' + content).appendChild(fRightContent);\n    }\n\n    _super.prototype.setMovableContent.call(this, mDiv);\n\n    this.setFrozenRightContent(fRightContent);\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderFrozenLeftWithRightPanel = function () {\n    this.renderFrozenRigthPanel();\n    var fRightContent = this.parent.element.querySelector('.e-frozen-right-content');\n\n    if (isNullOrUndefined(fRightContent)) {\n      fRightContent = this.parent.createElement('div', {\n        className: 'e-frozencontent e-frozen-right-content'\n      });\n      this.getPanel().querySelector('.' + content).appendChild(fRightContent);\n    }\n\n    this.setFrozenRightContent(fRightContent);\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderFrozenRightTableAlone = function () {\n    var mTbl;\n\n    if (this.getFrozenRightContent().querySelector('.' + table) == null) {\n      _super.prototype.renderFrozenRightTable.call(this);\n\n      this.getFrozenRightContent().appendChild(this.getTable());\n      mTbl = this.getTable().cloneNode(true);\n      this.getMovableContent().appendChild(mTbl);\n    } else {\n      if (this.parent.frozenRows) {\n        this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n      }\n\n      this.setTable(this.getFrozenRightContent().querySelector('.' + table));\n      this.setColGroup(this.getFrozenRightHeaderColGroup());\n      mTbl = this.getMovableContent().querySelector('.' + table);\n      this.getFrozenRightContent().querySelector('.' + table).appendChild(this.getColGroup());\n    }\n\n    if (this.getMovableContent().querySelector(colGroup)) {\n      remove(this.getMovableContent().querySelector(colGroup));\n    }\n\n    var colgroup = this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(colGroup).cloneNode(true);\n    mTbl.insertBefore(colgroup, mTbl.querySelector(tbody));\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderFrozenLeftWithRightTable = function () {\n    var frozenRight$$1 = this.getTable().cloneNode(true);\n    this.getFrozenRightContent().appendChild(frozenRight$$1);\n    var oldColGroup = this.getFrozenRightContent().querySelector(colGroup);\n\n    if (oldColGroup) {\n      remove(oldColGroup);\n    }\n\n    var rightTable = this.getFrozenRightContent().querySelector('.' + table);\n    rightTable.insertBefore(this.getFrozenRightHeaderColGroup(), rightTable.querySelector(tbody));\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderFrozenRightEmptyRowAlone = function (tbody$$1) {\n    _super.prototype.renderFrozenRightEmpty.call(this, tbody$$1);\n\n    this.getMovableContent().querySelector(tbody).innerHTML = '<tr><td></td></tr>';\n    addClass([this.parent.getMovableContentTbody().querySelector('tr')], ['e-emptyrow']);\n    this.getFrozenRightContent().querySelector('.e-emptyrow').querySelector('td').colSpan = this.parent.getVisibleFrozenRightCount();\n\n    if (this.parent.frozenRows) {\n      this.parent.getFrozenRightHeaderTbody().innerHTML = '';\n      this.parent.getMovableHeaderTbody().innerHTML = '';\n    }\n  };\n  /**\n   * @param {string} tableName - specfies the table name\n   * @returns {HTMLElement} returns the element\n   * @hidden\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getFrozenHeader = function (tableName) {\n    if (tableName === frozenLeft) {\n      return this.parent.getHeaderContent().querySelector('.e-frozen-left-header').querySelector(tbody);\n    } else if (tableName === 'movable') {\n      return this.parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody);\n    } else {\n      return this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody);\n    }\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderFrozenLeftWithRightEmptyRow = function () {\n    this.getFrozenRightContent().querySelector(tbody).innerHTML = '<tr><td></td></tr>';\n    addClass([this.getFrozenRightContent().querySelector(tbody).querySelector('tr')], ['e-emptyrow']);\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody).innerHTML = '';\n    }\n  };\n\n  ColumnFreezeContentRenderer.prototype.setFrozenRightContent = function (ele) {\n    this.frozenRigthContent = ele;\n  };\n\n  ColumnFreezeContentRenderer.prototype.getFrozenRightContent = function () {\n    return this.frozenRigthContent;\n  };\n\n  ColumnFreezeContentRenderer.prototype.getHeaderColGroup = function () {\n    var colGroup$$1 = this.parent.element.querySelector('.' + gridHeader).querySelector(colGroup).cloneNode(true);\n\n    if (!this.parent.getFrozenLeftColumnsCount()) {\n      var right = this.getFrozenRightHeaderColGroup();\n      colGroup$$1 = right && this.frzCount ? right.cloneNode(true) : colGroup$$1;\n      this.frzCount++;\n      this.isColGroupRefresh = true;\n    }\n\n    return colGroup$$1;\n  };\n\n  ColumnFreezeContentRenderer.prototype.getFrozenRightHeaderColGroup = function () {\n    var col = this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(colGroup);\n\n    if (!col) {\n      col = this.parent.getHeaderContent().querySelector(colGroup);\n    }\n\n    return col.cloneNode(true);\n  };\n\n  ColumnFreezeContentRenderer.prototype.setColGroup = function (colGroup$$1) {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      return _super.prototype.setColGroup.call(this, colGroup$$1);\n    } else {\n      colGroup$$1 = !this.isColGroupRefresh ? this.getFrozenRightHeaderColGroup() : colGroup$$1;\n\n      if (!isNullOrUndefined(colGroup$$1)) {\n        colGroup$$1.id = 'content-' + colGroup$$1.id;\n      }\n\n      this.isColGroupRefresh = false;\n\n      if (this.frzCount === 2) {\n        this.frzCount = 0;\n      }\n\n      return this.colgroup = colGroup$$1;\n    }\n  };\n\n  ColumnFreezeContentRenderer.prototype.renderEmpty = function (tbody$$1) {\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      _super.prototype.renderEmpty.call(this, tbody$$1);\n\n      this.getFrozenContent().querySelector('.e-emptyrow').querySelector('td').colSpan = this.parent.getVisibleFrozenLeftCount();\n\n      if (this.parent.getFrozenRightColumnsCount()) {\n        this.renderFrozenLeftWithRightEmptyRow();\n      }\n    } else {\n      this.renderFrozenRightEmptyRowAlone(tbody$$1);\n    }\n\n    this.parent.notify(freezeRender, {\n      case: 'refreshHeight'\n    });\n  };\n\n  ColumnFreezeContentRenderer.prototype.setHeightToContent = function (height) {\n    if (this.parent.getFrozenRightColumnsCount()) {\n      this.getFrozenRightContent().style.height = height.toString() + 'px';\n    }\n\n    if (this.parent.getFrozenLeftColumnsCount()) {\n      this.getFrozenContent().style.height = height.toString() + 'px';\n    }\n\n    this.getMovableContent().style.height = height.toString() + 'px';\n  };\n\n  ColumnFreezeContentRenderer.prototype.actionComplete = function (args) {\n    _super.prototype.actionComplete.call(this, args);\n  };\n\n  ColumnFreezeContentRenderer.prototype.batchAdd = function (args) {\n    _super.prototype.batchAdd.call(this, args);\n  };\n  /**\n   * @param {freezeTable} tableName - specfies the table name\n   * @returns {Element} - returns the element\n   * @hidden\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getTbody = function (tableName) {\n    var tbody$$1;\n\n    if (tableName === frozenLeft) {\n      tbody$$1 = this.parent.getFrozenLeftContentTbody();\n    } else if (tableName === 'movable') {\n      tbody$$1 = this.parent.getMovableContentTbody();\n    } else if (tableName === frozenRight) {\n      tbody$$1 = this.parent.getFrozenRightContentTbody();\n    }\n\n    return tbody$$1;\n  };\n  /**\n   * @param {NotifyArgs} args - specfies the args\n   * @param {freezeTable} tableName - specfies the freeze table\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.setIsFrozen = function (args, tableName) {\n    args.isFrozen = tableName === frozenLeft || this.parent.getFrozenMode() === 'Right' && tableName === frozenRight;\n    args.renderFrozenRightContent = this.parent.getFrozenMode() === leftRight && tableName === frozenRight;\n    args.renderMovableContent = tableName === 'movable';\n  };\n  /**\n   * @param {Element} tbody - specfies the element\n   * @param {DocumentFragment | HTMLElement} frag - specfies the frag\n   * @param {NotifyArgs} args - specfies the args\n   * @param {freezeTable} tableName - specfies the tableName\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.appendContent = function (tbody$$1, frag, args, tableName) {\n    if (!isNullOrUndefined(this.parent.rowTemplate) && this.parent.isReact) {\n      tbody$$1 = frag;\n    } else {\n      tbody$$1.appendChild(frag);\n    }\n\n    if (this.parent.getFrozenMode() === 'Left') {\n      if (tableName === frozenLeft) {\n        this.isLoaded = false;\n        this.getFrozenContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      } else {\n        this.refreshTbody(tbody$$1);\n        this.isLoaded = true;\n        this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshHeight();\n        this.refreshScrollOffset();\n      }\n    } else if (this.parent.getFrozenMode() === 'Right') {\n      if (tableName === 'movable') {\n        this.refreshTbody(tbody$$1);\n        this.isLoaded = true;\n        this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshHeight();\n        this.refreshScrollOffset();\n      } else {\n        this.isLoaded = false;\n        this.getFrozenRightContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      }\n    } else if (this.parent.getFrozenMode() === leftRight) {\n      if (tableName === frozenLeft) {\n        this.isLoaded = false;\n        this.getFrozenContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      } else if (tableName === 'movable') {\n        this.refreshTbody(tbody$$1);\n        this.isLoaded = false;\n        this.getMovableContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshContentRows(extend({}, args));\n      } else {\n        this.isLoaded = true;\n        this.getFrozenRightContent().querySelector('table').appendChild(tbody$$1);\n        this.refreshHeight();\n        this.refreshScrollOffset();\n      }\n    }\n\n    if (this.isInitialRender) {\n      this.parent.scrollModule.setHeight();\n      this.isInitialRender = false;\n    }\n\n    this.widthService.refreshFrozenScrollbar();\n  };\n\n  ColumnFreezeContentRenderer.prototype.refreshHeight = function () {\n    if (!this.parent.allowTextWrap) {\n      this.parent.notify(freezeRender, {\n        case: 'refreshHeight'\n      });\n    }\n  };\n  /**\n   * @param {freezeTable} tableName - specifies the table\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.splitRows = function (tableName) {\n    var left = this.parent.getFrozenLeftColumnsCount();\n    var right = this.parent.getFrozenRightColumnsCount();\n\n    if (left && !right) {\n      if (tableName === frozenLeft) {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      } else {\n        this.movableRows = this.rows;\n      }\n    } else if (!left && right) {\n      if (tableName === 'movable') {\n        this.movableRows = this.rows;\n      } else {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      }\n    } else if (left && right) {\n      if (tableName === frozenLeft) {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      } else if (tableName === 'movable') {\n        this.movableRows = this.rows;\n        this.movableRowElements = this.rowElements;\n      } else {\n        this.frozenRightRows = this.rows;\n        this.frozenRightRowElements = this.rowElements;\n      }\n    }\n  };\n  /**\n   * Get the Freeze pane movable content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getMovableRowElements = function () {\n    if (this.parent.getFrozenMode() !== leftRight) {\n      return this.rowElements;\n    } else {\n      return this.movableRowElements;\n    }\n  };\n  /**\n   * Get the Freeze pane frozen right content table data row elements\n   *\n   * @returns {Element} returns the Element\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getFrozenRightRowElements = function () {\n    if (this.parent.getFrozenMode() !== leftRight) {\n      return this.freezeRowElements;\n    } else {\n      return this.frozenRightRowElements;\n    }\n  };\n  /**\n   * Get the frozen right row collection in the Freeze pane Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row object\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getFrozenRightRows = function () {\n    if (this.parent.getFrozenMode() === leftRight) {\n      if (this.parent.enableInfiniteScrolling) {\n        return this.rightFreezeRows;\n      }\n\n      return this.frozenRightRows;\n    } else {\n      return this.getRows();\n    }\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getFrozenRightRowByIndex = function (index) {\n    return this.parent.getFrozenRightDataRows()[index];\n  };\n  /**\n   * Get the Row collection in the Grid.\n   *\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>} returns the row object\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getRows = function () {\n    var infiniteRows = this.getInfiniteRows();\n    return infiniteRows.length ? infiniteRows : this.freezeRows;\n  };\n  /**\n   * Get the content table data row elements\n   *\n   * @returns {Element} returns the element\n   */\n\n\n  ColumnFreezeContentRenderer.prototype.getRowElements = function () {\n    return this.freezeRowElements;\n  };\n\n  return ColumnFreezeContentRenderer;\n}(FreezeContentRender);\n\nvar __extends$33 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * VirtualFreezeRenderer is used to render the virtual table within the frozen and movable content table\n *\n * @hidden\n */\n\n\nvar VirtualFreezeRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$33(VirtualFreezeRenderer, _super);\n\n  function VirtualFreezeRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n    /** @hidden */\n\n\n    _this.frzRows = [];\n    /** @hidden */\n\n    _this.mvblRows = [];\n    /** @hidden */\n\n    _this.frRows = [];\n    _this.serviceLoc = locator;\n\n    _this.eventListener('on');\n\n    _this.rowModelGenerator = new RowModelGenerator(_this.parent);\n    return _this;\n  }\n\n  VirtualFreezeRenderer.prototype.eventListener = function (action) {\n    this.parent[action](getVirtualData, this.getVirtualData, this);\n    this.parent[action](setFreezeSelection, this.setFreezeSelection, this);\n    this.parent[action](refreshVirtualFrozenRows, this.refreshVirtualFrozenRows, this);\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n  };\n\n  VirtualFreezeRenderer.prototype.actionComplete = function (args) {\n    if (args.requestType === 'delete' && this.parent.frozenRows) {\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        setCache(this, i);\n      }\n    }\n  };\n\n  VirtualFreezeRenderer.prototype.refreshVirtualFrozenRows = function (args) {\n    var _this = this;\n\n    var gObj = this.parent;\n\n    if (args.requestType === 'delete' && gObj.frozenRows) {\n      args.isFrozenRowsRender = true;\n      var query = gObj.renderModule.data.generateQuery(true).clone();\n      query.page(1, gObj.pageSettings.pageSize);\n      gObj.renderModule.data.getData({}, query).then(function (e) {\n        renderFrozenRows(args, e.result, gObj.getSelectedRowIndexes(), gObj, _this.rowModelGenerator, _this.serviceLoc, _this.virtualRenderer, _this);\n      });\n    }\n  };\n\n  VirtualFreezeRenderer.prototype.getVirtualData = function (data) {\n    this.virtualRenderer.getVirtualData(data);\n  };\n\n  VirtualFreezeRenderer.prototype.setFreezeSelection = function (args) {\n    setFreezeSelectionAction(args, this.virtualRenderer);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.renderTable = function () {\n    this.freezeRowGenerator = new FreezeRowModelGenerator(this.parent);\n    this.virtualRenderer = new VirtualContentRenderer(this.parent, this.serviceLoc);\n    this.virtualRenderer.header = this.serviceLoc.getService('rendererFactory').getRenderer(RenderType.Header).virtualHdrRenderer;\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualRenderer.setPanel(this.parent.getContent());\n    this.scrollbar = this.parent.getContent().querySelector('.e-movablescrollbar');\n    var movableCont = this.getMovableContent();\n    var minHeight = this.parent.height;\n    this.virtualRenderer.virtualEle.content = this.virtualRenderer.content = this.getPanel().querySelector('.' + content);\n    this.virtualRenderer.virtualEle.content.style.overflowX = 'hidden';\n    this.virtualRenderer.virtualEle.renderFrozenWrapper(minHeight);\n    this.virtualRenderer.virtualEle.renderFrozenPlaceHolder();\n\n    if (this.parent.enableColumnVirtualization) {\n      this.virtualRenderer.virtualEle.movableContent = this.virtualRenderer.movableContent = this.getPanel().querySelector('.' + movableContent);\n      this.virtualRenderer.virtualEle.renderMovableWrapper(minHeight);\n      this.virtualRenderer.virtualEle.renderMovablePlaceHolder();\n      var tbl = movableCont.querySelector('table');\n      this.virtualRenderer.virtualEle.movableTable = tbl;\n      this.virtualRenderer.virtualEle.movableWrapper.appendChild(tbl);\n      movableCont.appendChild(this.virtualRenderer.virtualEle.movableWrapper);\n      movableCont.appendChild(this.virtualRenderer.virtualEle.movablePlaceholder);\n    }\n\n    this.virtualRenderer.virtualEle.wrapper.appendChild(this.getFrozenContent());\n    this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n    this.virtualRenderer.virtualEle.table = this.getTable();\n    setDebounce(this.parent, this.virtualRenderer, this.scrollbar, this.getMovableContent());\n  };\n  /**\n   * @param {HTMLElement} target - specifies the target\n   * @param {DocumentFragment} newChild - specifies the newChild\n   * @param {NotifyArgs} e - specifies the notifyargs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.appendContent = function (target, newChild, e) {\n    appendContent(this.virtualRenderer, this.widthService, target, newChild, e);\n  };\n  /**\n   * @param {Object[]} data - specifies the data\n   * @param {NotifyArgs} notifyArgs - specifies the notifyargs\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.generateRows = function (data, notifyArgs) {\n    if (!this.firstPageRecords) {\n      this.firstPageRecords = data;\n    }\n\n    return generateRows(this.virtualRenderer, data, notifyArgs, this.freezeRowGenerator, this.parent);\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getRowByIndex = function (index) {\n    return this.virtualRenderer.getRowByIndex(index);\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getMovableRowByIndex = function (index) {\n    return this.virtualRenderer.getMovableVirtualRowByIndex(index);\n  };\n\n  VirtualFreezeRenderer.prototype.collectRows = function (tableName) {\n    return collectRows(tableName, this.virtualRenderer, this.parent);\n  };\n  /**\n   * @returns {HTMLCollection} returns the Htmlcollection\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getMovableRows = function () {\n    return this.collectRows('movable');\n  };\n  /**\n   * @returns {HTMLCollectionOf<HTMLTableRowElement>} returns the html collection\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getRows = function () {\n    return this.collectRows('frozen-left');\n  };\n  /**\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getColGroup = function () {\n    var mCol = this.parent.getMovableVirtualContent();\n    return this.isXaxis() ? mCol.querySelector(colGroup + ':not(.e-masked-colgroup)') : this.colgroup;\n  };\n  /**\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getReorderedFrozenRows = function (args) {\n    return getReorderedFrozenRows(args, this.virtualRenderer, this.parent, this.freezeRowGenerator, this.firstPageRecords);\n  };\n\n  VirtualFreezeRenderer.prototype.isXaxis = function () {\n    return isXaxis(this.virtualRenderer);\n  };\n\n  VirtualFreezeRenderer.prototype.getHeaderCells = function () {\n    return getHeaderCells(this.virtualRenderer, this.parent);\n  };\n\n  VirtualFreezeRenderer.prototype.getVirtualFreezeHeader = function () {\n    return getVirtualFreezeHeader(this.virtualRenderer, this.parent);\n  };\n\n  VirtualFreezeRenderer.prototype.ensureFrozenCols = function (columns) {\n    return ensureFrozenCols(columns, this.parent);\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {object} returns the object\n   * @hidden\n   */\n\n\n  VirtualFreezeRenderer.prototype.getRowObjectByIndex = function (index) {\n    return this.virtualRenderer.getRowObjectByIndex(index);\n  };\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} returns the element\n   */\n\n\n  VirtualFreezeRenderer.prototype.setColGroup = function (colGroup$$1) {\n    return setColGroup(colGroup$$1, this.virtualRenderer, this);\n  };\n\n  return VirtualFreezeRenderer;\n}(FreezeContentRender);\n/**\n * VirtualFreezeHdrRenderer is used to render the virtual table within the frozen and movable header table\n *\n * @hidden\n */\n\n\nvar VirtualFreezeHdrRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$33(VirtualFreezeHdrRenderer, _super);\n\n  function VirtualFreezeHdrRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.serviceLoc = locator;\n    return _this;\n  }\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  VirtualFreezeHdrRenderer.prototype.renderTable = function () {\n    this.virtualHdrRenderer = new VirtualHeaderRenderer(this.parent, this.serviceLoc);\n    this.virtualHdrRenderer.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.virtualHdrRenderer.gen.getColumnIndexes(this.getPanel().querySelector('.' + headerContent)));\n    this.virtualHdrRenderer.virtualEle.content = this.getPanel().querySelector('.' + headerContent);\n    this.virtualHdrRenderer.virtualEle.renderFrozenWrapper();\n    this.virtualHdrRenderer.virtualEle.renderFrozenPlaceHolder();\n\n    if (this.parent.enableColumnVirtualization) {\n      this.virtualHdrRenderer.virtualEle.movableContent = this.getPanel().querySelector('.' + movableHeader);\n      this.virtualHdrRenderer.virtualEle.renderMovableWrapper();\n      this.virtualHdrRenderer.virtualEle.renderMovablePlaceHolder();\n    }\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualHdrRenderer.setPanel(this.parent.getHeaderContent());\n  };\n\n  VirtualFreezeHdrRenderer.prototype.rfshMovable = function () {\n    this.getFrozenHeader().appendChild(this.getTable());\n    this.virtualHdrRenderer.virtualEle.wrapper.appendChild(this.getFrozenHeader());\n\n    if (this.parent.enableColumnVirtualization) {\n      this.virtualHdrRenderer.virtualEle.movableWrapper.appendChild(this.createHeader(undefined, 'movable'));\n    } else {\n      this.getMovableHeader().appendChild(this.createTable());\n    }\n\n    this.virtualHdrRenderer.virtualEle.wrapper.appendChild(this.getMovableHeader());\n  };\n\n  return VirtualFreezeHdrRenderer;\n}(FreezeRender);\n/**\n * @param {NotifyArgs} args - specifies the args\n * @param {Object[]} data - specifies the data\n * @param {number[]}selectedIdx - specifies the selected index\n * @param {IGrid} parent - specifies the IGrid\n * @param {IModelGenerator} rowModelGenerator - specifies the rowModeGenerator\n * @param {ServiceLocator} locator - specifies the locator\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {VirtualFreezeRenderer} instance - specifies the instance\n * @returns {void}\n * @hidden\n */\n\n\nfunction renderFrozenRows(args, data, selectedIdx, parent, rowModelGenerator, locator, virtualRenderer, instance) {\n  parent.clearSelection();\n  args.startIndex = 0;\n  var rowRenderer = new RowRenderer(locator, null, parent);\n  var rows = rowModelGenerator.generateRows(data, args);\n\n  if (args.renderMovableContent) {\n    virtualRenderer.vgenerator.movableCache[1] = rows;\n    rows = parent.getMovableRowsObject();\n  } else if (!args.renderFrozenRightContent && !args.renderMovableContent) {\n    virtualRenderer.vgenerator.cache[1] = rows;\n    rows = parent.getRowsObject();\n  } else if (args.renderFrozenRightContent) {\n    virtualRenderer.vgenerator.frozenRightCache[1] = rows;\n    rows = parent.getFrozenRightRowsObject();\n  }\n\n  var hdr = !args.renderMovableContent && !args.renderFrozenRightContent ? parent.getHeaderContent().querySelector('.' + frozenHeader).querySelector(tbody) : args.renderMovableContent ? parent.getHeaderContent().querySelector('.' + movableHeader).querySelector(tbody) : parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector(tbody);\n  hdr.innerHTML = '';\n\n  for (var i = 0; i < parent.frozenRows; i++) {\n    hdr.appendChild(rowRenderer.render(rows[i], parent.getColumns()));\n\n    if (selectedIdx.indexOf(i) > -1) {\n      rows[i].isSelected = true;\n\n      for (var k = 0; k < rows[i].cells.length; k++) {\n        rows[i].cells[k].isSelected = true;\n      }\n    }\n  }\n\n  if (args.renderMovableContent) {\n    instance.mvblRows = virtualRenderer.vgenerator.movableCache[1];\n  } else if (!args.renderMovableContent && !args.renderFrozenRightContent) {\n    instance.frzRows = virtualRenderer.vgenerator.cache[1];\n  } else if (args.renderFrozenRightContent) {\n    instance.frRows = virtualRenderer.vgenerator.frozenRightCache[1];\n  }\n\n  args.renderMovableContent = !args.renderMovableContent && !args.renderFrozenRightContent;\n  args.renderFrozenRightContent = parent.getFrozenMode() === leftRight && !args.renderMovableContent && !args.renderFrozenRightContent;\n\n  if (args.renderMovableContent || args.renderFrozenRightContent) {\n    renderFrozenRows(args, data, selectedIdx, parent, rowModelGenerator, locator, virtualRenderer, instance);\n\n    if (!args.renderMovableContent && !args.renderFrozenRightContent) {\n      args.isFrozenRowsRender = false;\n    }\n  }\n}\n/**\n * @param {Row<Column>[]} data - specifies the data\n * @param {freezeTable} tableName -specifies the table\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction splitCells(data, tableName, parent) {\n  var rows = [];\n\n  for (var i = 0; i < data.length; i++) {\n    rows.push(extend({}, data[i]));\n    rows[i].cells = splitFrozenRowObjectCells(parent, rows[i].cells, tableName);\n  }\n\n  return rows;\n}\n/**\n * @param {freezeTable} tableName - specifies the freeze tabel\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction collectRows(tableName, virtualRenderer, parent) {\n  var rows = [];\n  var cache;\n\n  if (tableName === frozenLeft) {\n    cache = virtualRenderer.vgenerator.cache;\n  } else if (tableName === 'movable') {\n    cache = virtualRenderer.vgenerator.movableCache;\n  } else if (tableName === frozenRight) {\n    cache = parent.getFrozenMode() === 'Right' ? virtualRenderer.vgenerator.cache : virtualRenderer.vgenerator.frozenRightCache;\n  }\n\n  var keys = Object.keys(cache);\n\n  for (var i = 0; i < keys.length; i++) {\n    rows = rows.concat(splitCells(cache[keys[i]], tableName, parent));\n  }\n\n  return rows;\n}\n/**\n * @param {object} args - specifies the args\n * @param {string} args.uid - specifirs the uid\n * @param {boolean} args.set - specifies the set\n * @param {boolean} args.clearAll - specifies the boolean to clearall\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @returns {void}\n * @hidden\n */\n\n\nfunction setFreezeSelectionAction(args, virtualRenderer) {\n  var leftKeys = Object.keys(virtualRenderer.vgenerator.cache);\n  var movableKeys = Object.keys(virtualRenderer.vgenerator.movableCache);\n  var rightKeys = Object.keys(virtualRenderer.vgenerator.frozenRightCache);\n\n  for (var i = 0; i < leftKeys.length; i++) {\n    selectFreezeRows(args, virtualRenderer.vgenerator.cache[leftKeys[i]]);\n  }\n\n  for (var i = 0; i < movableKeys.length; i++) {\n    selectFreezeRows(args, virtualRenderer.vgenerator.movableCache[movableKeys[i]]);\n  }\n\n  for (var i = 0; i < rightKeys.length; i++) {\n    selectFreezeRows(args, virtualRenderer.vgenerator.frozenRightCache[rightKeys[i]]);\n  }\n}\n/**\n * @param {Object} args - specifies the args\n * @param {string} args.uid - specifirs the uid\n * @param {boolean} args.set - specifies the set\n * @param {boolean} args.clearAll - specifies the boolean to clearall\n * @param {Row<Column>[]} cache - specifies the cache\n * @returns {void}\n * @hidden\n */\n\n\nfunction selectFreezeRows(args, cache) {\n  var rows = cache.filter(function (row$$1) {\n    return args.clearAll || args.uid === row$$1.uid;\n  });\n\n  for (var j = 0; j < rows.length; j++) {\n    rows[j].isSelected = args.set;\n    var cells = rows[j].cells;\n\n    for (var k = 0; k < cells.length; k++) {\n      cells[k].isSelected = args.set;\n    }\n  }\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {ColumnWidthService} widthService - specifies the width service\n * @param {HTMLElement} target - specifies the target\n * @param {DocumentFragment} newChild - specifies the newchild\n * @param {NotifyArgs} e - specifies the notifyargs\n * @returns {void}\n * @hidden\n */\n\n\nfunction appendContent(virtualRenderer, widthService, target, newChild, e) {\n  virtualRenderer.appendContent(target, newChild, e);\n  widthService.refreshFrozenScrollbar();\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {object[]} data - specifies the data\n * @param {NotifyArgs} notifyArgs - specifies the notifyargs\n * @param {FreezeRowModelGenerator} freezeRowGenerator - specifies the freeze row generator\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction generateRows(virtualRenderer, data, notifyArgs, freezeRowGenerator, parent) {\n  var virtualRows = virtualRenderer.vgenerator.generateRows(data, notifyArgs);\n  var arr = [];\n  arr = virtualRows.map(function (row$$1) {\n    return extend({}, row$$1);\n  });\n  var rows = freezeRowGenerator.generateRows(data, notifyArgs, arr);\n\n  if (parent.frozenRows && notifyArgs.requestType === 'delete' && parent.pageSettings.currentPage === 1) {\n    rows = rows.slice(parent.frozenRows);\n  }\n\n  return rows;\n}\n/**\n * @param {NotifyArgs} args -specifies the args\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {IGrid} parent - specifies the IGrid\n * @param {FreezeRowModelGenerator} freezeRowGenerator - specifies the freezeRowGenerator\n * @param {Object[]} firstPageRecords - specifies the first page records\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction getReorderedFrozenRows(args, virtualRenderer, parent, freezeRowGenerator, firstPageRecords) {\n  var bIndex = args.virtualInfo.blockIndexes;\n  var colIndex = args.virtualInfo.columnIndexes;\n  var page = args.virtualInfo.page;\n  args.virtualInfo.blockIndexes = [1, 2];\n  args.virtualInfo.page = 1;\n\n  if (!args.renderMovableContent) {\n    args.virtualInfo.columnIndexes = [];\n  }\n\n  var firstRecordslength = parent.getCurrentViewRecords().length;\n  firstPageRecords = parent.renderModule.data.dataManager.dataSource.json.slice(0, firstRecordslength);\n  var virtualRows = virtualRenderer.vgenerator.generateRows(firstPageRecords, args);\n  var rows = splitReorderedRows(virtualRows, parent, args, freezeRowGenerator);\n  args.virtualInfo.blockIndexes = bIndex;\n  args.virtualInfo.columnIndexes = colIndex;\n  args.virtualInfo.page = page;\n  return rows.splice(0, parent.frozenRows);\n}\n/**\n * @param {Row<Column>[]} rows - specifies the row\n * @param {IGrid} parent - specifies the IGrid\n * @param {NotifyArgs} args - specifies the notify arguments\n * @param {FreezeRowModelGenerator} freezeRowGenerator - specifies the freezerowgenerator\n * @returns {Row<Column>[]} returns the row\n * @hidden\n */\n\n\nfunction splitReorderedRows( // eslint-disable-next-line @typescript-eslint/no-unused-vars\nrows, parent, args, freezeRowGenerator) {\n  var tableName;\n\n  if (args.renderMovableContent) {\n    tableName = 'movable';\n  } else if (args.renderFrozenRightContent) {\n    tableName = 'frozen-right';\n  } else {\n    tableName = 'frozen-left';\n  }\n\n  for (var i = 0, len = rows.length; i < len; i++) {\n    rows[i].cells = splitFrozenRowObjectCells(parent, rows[i].cells, tableName);\n  }\n\n  return rows;\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the VirtualRenderer\n * @returns {boolean} returns the isXaxis\n * @hidden\n */\n\n\nfunction isXaxis(virtualRenderer) {\n  var value = false;\n\n  if (virtualRenderer) {\n    value = virtualRenderer.requestType === 'virtualscroll' && virtualRenderer.currentInfo.sentinelInfo.axis === 'X';\n  }\n\n  return value;\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtualrenderer\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Element[]} returns the element\n * @hidden\n */\n\n\nfunction getHeaderCells(virtualRenderer, parent) {\n  var content$$1 = isXaxis(virtualRenderer) ? parent.getMovableVirtualHeader() : parent.getHeaderContent();\n  return content$$1 ? [].slice.call(content$$1.querySelectorAll('.e-headercell:not(.e-stackedheadercell)')) : [];\n}\n/**\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual Renderer\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Element} returns the element\n * @hidden\n */\n\n\nfunction getVirtualFreezeHeader(virtualRenderer, parent) {\n  var headerTable;\n\n  if (isXaxis(virtualRenderer)) {\n    headerTable = parent.getMovableVirtualHeader().querySelector('.' + table + ':not(.e-masked-table)');\n  } else {\n    headerTable = parent.getFrozenVirtualHeader().querySelector('.' + table);\n  }\n\n  return headerTable;\n}\n/**\n * @param {Column[]} columns - specifies the columns\n * @param {IGrid} parent - specifies the IGrid\n * @returns {Column[]} returns the column[]\n * @hidden\n */\n\n\nfunction ensureFrozenCols(columns, parent) {\n  var frozenCols = parent.columns.slice(0, parent.getFrozenColumns());\n  columns = frozenCols.concat(columns);\n  return columns;\n}\n/**\n * @param {Element} colGroup - specifies the colGroup\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtual renderer\n * @param {ColumnVirtualFreezeRenderer} instance - specifies the instances\n * @returns {Element} returns the element\n * @hidden\n */\n\n\nfunction setColGroup(colGroup$$1, virtualRenderer, instance) {\n  if (!isXaxis(virtualRenderer)) {\n    if (!isNullOrUndefined(colGroup$$1)) {\n      colGroup$$1.id = 'content-' + colGroup$$1.id;\n    }\n\n    instance.colgroup = colGroup$$1;\n  }\n\n  return instance.colgroup;\n}\n/**\n * @param {VirtualFreezeRenderer} instance - specifies the instance\n * @param {number} index - specifies the index\n * @returns {void}\n * @hidden\n */\n\n\nfunction setCache(instance, index) {\n  if (instance.virtualRenderer.vgenerator.cache[1]) {\n    instance.virtualRenderer.vgenerator.cache[1][index] = instance.frzRows[index];\n  } else {\n    instance.virtualRenderer.vgenerator.cache[1] = instance.frzRows;\n  }\n\n  if (instance.virtualRenderer.vgenerator.movableCache[1]) {\n    instance.virtualRenderer.vgenerator.movableCache[1][index] = instance.mvblRows[index];\n  } else {\n    instance.virtualRenderer.vgenerator.movableCache[1] = instance.mvblRows;\n  }\n}\n/**\n * @param {IGrid} parent - specifies the IGrid\n * @param {VirtualContentRenderer} virtualRenderer - specifies the virtualRenderer\n * @param {Element} scrollbar - specifies the scrollbr\n * @param {Element} mCont - specifies the mCont\n * @returns {void}\n * @hidden\n */\n\n\nfunction setDebounce(parent, virtualRenderer, scrollbar, mCont) {\n  var debounceEvent = parent.dataSource instanceof DataManager && !parent.dataSource.dataSource.offline;\n  var opt = {\n    container: virtualRenderer.content,\n    pageHeight: virtualRenderer.getBlockHeight() * 2,\n    debounceEvent: debounceEvent,\n    axes: parent.enableColumnVirtualization ? ['X', 'Y'] : ['Y'],\n    scrollbar: scrollbar,\n    movableContainer: mCont\n  };\n  virtualRenderer.observer = new InterSectionObserver(virtualRenderer.virtualEle.wrapper, opt, virtualRenderer.virtualEle.movableWrapper);\n}\n/**\n * ColumnVirtualFreezeRenderer is used to render the virtual table within the frozen and movable content table\n *\n * @hidden\n */\n\n\nvar ColumnVirtualFreezeRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$33(ColumnVirtualFreezeRenderer, _super);\n\n  function ColumnVirtualFreezeRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n    /** @hidden */\n\n\n    _this.frRows = [];\n    /** @hidden */\n\n    _this.frzRows = [];\n    /** @hidden */\n\n    _this.mvblRows = [];\n    _this.serviceLoc = locator;\n\n    _this.eventListener('on');\n\n    _this.rowModelGenerator = new RowModelGenerator(_this.parent);\n    return _this;\n  }\n\n  ColumnVirtualFreezeRenderer.prototype.actionComplete = function (args) {\n    if (args.requestType === 'delete' && this.parent.frozenRows) {\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        if (this.virtualRenderer.vgenerator.frozenRightCache[1]) {\n          this.virtualRenderer.vgenerator.frozenRightCache[1][i] = this.frRows.length ? this.frRows[i] : this.frzRows[i];\n        } else {\n          this.virtualRenderer.vgenerator.frozenRightCache[1] = this.frRows.length ? this.frRows : this.frzRows;\n          break;\n        }\n\n        setCache(this, i);\n      }\n    }\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.eventListener = function (action) {\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent[action](refreshVirtualFrozenRows, this.refreshVirtualFrozenRows, this);\n    this.parent[action](getVirtualData, this.getVirtualData, this);\n    this.parent[action](setFreezeSelection, this.setFreezeSelection, this);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.refreshVirtualFrozenRows = function (args) {\n    var _this = this;\n\n    if (args.requestType === 'delete' && this.parent.frozenRows) {\n      args.isFrozenRowsRender = true;\n      var query = this.parent.renderModule.data.generateQuery(true).clone();\n      query.page(1, this.parent.pageSettings.pageSize);\n      var selectedIdx_1 = this.parent.getSelectedRowIndexes();\n      this.parent.renderModule.data.getData({}, query).then(function (e) {\n        renderFrozenRows(args, e.result, selectedIdx_1, _this.parent, _this.rowModelGenerator, _this.serviceLoc, _this.virtualRenderer, _this);\n      });\n    }\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.setFreezeSelection = function (args) {\n    setFreezeSelectionAction(args, this.virtualRenderer);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.getVirtualData = function (data) {\n    this.virtualRenderer.getVirtualData(data);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.renderNextFrozentPart = function (e, tableName) {\n    e.renderMovableContent = this.parent.getFrozenLeftCount() ? tableName === frozenLeft : tableName === frozenRight;\n    e.renderFrozenRightContent = this.parent.getFrozenMode() === leftRight && tableName === 'movable';\n\n    if (e.renderMovableContent || e.renderFrozenRightContent) {\n      this.refreshContentRows(extend({}, e));\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.renderTable = function () {\n    this.virtualRenderer = new VirtualContentRenderer(this.parent, this.serviceLoc);\n    this.virtualRenderer.header = this.serviceLoc.getService('rendererFactory').getRenderer(RenderType.Header).virtualHdrRenderer;\n    this.freezeRowGenerator = new FreezeRowModelGenerator(this.parent);\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualRenderer.setPanel(this.parent.getContent());\n    this.scrollbar = this.parent.getContent().querySelector('.e-movablescrollbar');\n    var frozenRightCont = this.getFrozenRightContent();\n    var frzCont = this.getFrozenContent();\n    var movableCont = this.getMovableContent();\n\n    if (this.parent.getFrozenMode() === 'Right') {\n      frzCont = frozenRightCont;\n    }\n\n    this.virtualRenderer.virtualEle.content = this.virtualRenderer.content = this.getPanel().querySelector('.' + content);\n    this.virtualRenderer.virtualEle.content.style.overflowX = 'hidden';\n    var minHeight = this.parent.height;\n    this.virtualRenderer.virtualEle.renderFrozenWrapper(minHeight);\n    this.virtualRenderer.virtualEle.renderFrozenPlaceHolder();\n    this.renderVirtualFrozenLeft(frzCont, movableCont);\n    this.renderVirtualFrozenRight(frzCont, movableCont);\n    this.renderVirtualFrozenLeftRight(frzCont, movableCont, frozenRightCont);\n    this.virtualRenderer.virtualEle.table = this.getTable();\n    setDebounce(this.parent, this.virtualRenderer, this.scrollbar, this.getMovableContent());\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.renderVirtualFrozenLeft = function (frzCont, movableCont) {\n    if (this.parent.getFrozenMode() === 'Left') {\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frzCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n    }\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.renderVirtualFrozenRight = function (frzCont, movableCont) {\n    if (this.parent.getFrozenMode() === 'Right') {\n      this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frzCont);\n    }\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.renderVirtualFrozenLeftRight = function (frzCont, movableCont, frozenRightCont) {\n    if (this.parent.getFrozenMode() === leftRight) {\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frzCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(movableCont);\n      this.virtualRenderer.virtualEle.wrapper.appendChild(frozenRightCont);\n    }\n  };\n  /**\n   * @param {HTMLElement} target - specifies the target\n   * @param {DocumentFragment} newChild - specifies the newchild\n   * @param {NotifyArgs} e - specifies the NotifyArgs\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.appendContent = function (target, newChild, e) {\n    appendContent(this.virtualRenderer, this.widthService, target, newChild, e);\n    this.refreshScrollOffset();\n  };\n  /**\n   * @param {Object[]} data - specifies the data\n   * @param {NotifyArgs} e - specifies the notifyargs\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.generateRows = function (data, e) {\n    if (!this.firstPageRecords) {\n      this.firstPageRecords = data;\n    }\n\n    return generateRows(this.virtualRenderer, data, e, this.freezeRowGenerator, this.parent);\n  };\n  /**\n   * @param {number} index - specifies the number\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getRowByIndex = function (index) {\n    return this.virtualRenderer.getRowByIndex(index);\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} - returns the element\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getFrozenRightRowByIndex = function (index) {\n    return this.virtualRenderer.getFrozenRightVirtualRowByIndex(index);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.collectRows = function (tableName) {\n    return collectRows(tableName, this.virtualRenderer, this.parent);\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getMovableRowByIndex = function (index) {\n    return this.virtualRenderer.getMovableVirtualRowByIndex(index);\n  };\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getFrozenRightRows = function () {\n    return this.collectRows('frozen-right');\n  };\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getMovableRows = function () {\n    return this.collectRows('movable');\n  };\n  /**\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getColGroup = function () {\n    var mCol = this.parent.getMovableVirtualContent();\n    return isXaxis(this.virtualRenderer) ? mCol.querySelector(colGroup) : this.colgroup;\n  };\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getRows = function () {\n    return this.collectRows(this.parent.getFrozenMode() === 'Right' ? 'frozen-right' : 'frozen-left');\n  };\n  /**\n   * @param {NotifyArgs} args - specifies the args\n   * @returns {Row<Column>[]} returns the row object\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getReorderedFrozenRows = function (args) {\n    return getReorderedFrozenRows(args, this.virtualRenderer, this.parent, this.freezeRowGenerator, this.firstPageRecords);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.getHeaderCells = function () {\n    return getHeaderCells(this.virtualRenderer, this.parent);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.isXaxis = function () {\n    return isXaxis(this.virtualRenderer);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.getVirtualFreezeHeader = function () {\n    return getVirtualFreezeHeader(this.virtualRenderer, this.parent);\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {object} - returns the object\n   * @hidden\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.getRowObjectByIndex = function (index) {\n    return this.virtualRenderer.getRowObjectByIndex(index);\n  };\n\n  ColumnVirtualFreezeRenderer.prototype.ensureFrozenCols = function (columns) {\n    return ensureFrozenCols(columns, this.parent);\n  };\n  /**\n   * Set the header colgroup element\n   *\n   * @param {Element} colGroup - specifies the colgroup\n   * @returns {Element} - returns the element\n   */\n\n\n  ColumnVirtualFreezeRenderer.prototype.setColGroup = function (colGroup$$1) {\n    return setColGroup(colGroup$$1, this.virtualRenderer, this);\n  };\n\n  return ColumnVirtualFreezeRenderer;\n}(ColumnFreezeContentRenderer);\n/**\n * `Freeze` module is used to handle Frozen rows and columns.\n *\n * @hidden\n */\n\n\nvar Freeze =\n/** @__PURE__ @class */\nfunction () {\n  function Freeze(parent, locator) {\n    this.parent = parent;\n    this.locator = locator;\n    this.addEventListener();\n  }\n\n  Freeze.prototype.getModuleName = function () {\n    return 'freeze';\n  };\n\n  Freeze.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n\n  Freeze.prototype.instantiateRenderer = function () {\n    this.parent.log('limitation', this.getModuleName());\n    var renderer = this.locator.getService('rendererFactory');\n\n    if (this.parent.getFrozenColumns()) {\n      if (this.parent.enableColumnVirtualization) {\n        renderer.addRenderer(RenderType.Header, new VirtualFreezeHdrRenderer(this.parent, this.locator));\n      } else {\n        renderer.addRenderer(RenderType.Header, new FreezeRender(this.parent, this.locator));\n      }\n\n      if (this.parent.enableVirtualization) {\n        renderer.addRenderer(RenderType.Content, new VirtualFreezeRenderer(this.parent, this.locator));\n      } else {\n        renderer.addRenderer(RenderType.Content, new FreezeContentRender(this.parent, this.locator));\n      }\n    }\n\n    if (this.parent.getFrozenLeftColumnsCount() || this.parent.getFrozenRightColumnsCount()) {\n      renderer.addRenderer(RenderType.Header, new ColumnFreezeHeaderRenderer(this.parent, this.locator));\n\n      if (this.parent.enableVirtualization) {\n        renderer.addRenderer(RenderType.Content, new ColumnVirtualFreezeRenderer(this.parent, this.locator));\n      } else {\n        renderer.addRenderer(RenderType.Content, new ColumnFreezeContentRenderer(this.parent, this.locator));\n      }\n    }\n  };\n\n  Freeze.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.instantiateRenderer);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  Freeze.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  return Freeze;\n}();\n/**\n * 'column menu module used to handle column menu actions'\n *\n * @hidden\n */\n\n\nvar ColumnMenu =\n/** @__PURE__ @class */\nfunction () {\n  function ColumnMenu(parent, serviceLocator) {\n    this.defaultItems = {};\n    this.localeText = this.setLocaleKey();\n    this.disableItems = [];\n    this.hiddenItems = [];\n    this.isOpen = false; // default class names\n\n    this.GROUP = 'e-icon-group';\n    this.UNGROUP = 'e-icon-ungroup';\n    this.ASCENDING = 'e-icon-ascending';\n    this.DESCENDING = 'e-icon-descending';\n    this.ROOT = 'e-columnmenu';\n    this.FILTER = 'e-icon-filter';\n    this.POP = 'e-filter-popup';\n    this.WRAP = 'e-col-menu';\n    this.CHOOSER = '_chooser_';\n    this.parent = parent;\n    this.gridID = parent.element.id;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n\n  ColumnMenu.prototype.wireEvents = function () {\n    var elements = this.getColumnMenuHandlers();\n\n    for (var i = 0; i < elements.length; i++) {\n      EventHandler.add(elements[i], 'mousedown', this.columnMenuHandlerDown, this);\n    }\n  };\n\n  ColumnMenu.prototype.unwireEvents = function () {\n    var elements = this.getColumnMenuHandlers();\n\n    for (var i = 0; i < elements.length; i++) {\n      EventHandler.remove(elements[i], 'mousedown', this.columnMenuHandlerDown);\n    }\n  };\n  /**\n   * To destroy the resize\n   *\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnMenu.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement || !gridElement.querySelector('.' + gridHeader) && !gridElement.querySelector('.' + gridContent)) {\n      return;\n    }\n\n    this.columnMenu.destroy();\n    this.removeEventListener();\n    this.unwireFilterEvents();\n    this.unwireEvents();\n\n    if (this.element.parentNode) {\n      remove(this.element);\n    }\n  };\n\n  ColumnMenu.prototype.columnMenuHandlerClick = function (e) {\n    if (e.target.classList.contains('e-columnmenu')) {\n      this.columnMenu.items = this.getItems();\n      this.columnMenu.dataBind();\n\n      if (this.isOpen && this.headerCell !== this.getHeaderCell(e) || document.querySelector('.e-grid-menu .e-menu-parent.e-ul')) {\n        this.columnMenu.close();\n        this.openColumnMenu(e);\n      } else if (!this.isOpen) {\n        this.openColumnMenu(e);\n      } else {\n        this.columnMenu.close();\n      }\n    }\n  };\n  /**\n   * @param {string} field - specifies the field name\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnMenu.prototype.openColumnMenuByField = function (field) {\n    this.openColumnMenu({\n      target: this.parent.getColumnHeaderByField(field).querySelector('.e-columnmenu')\n    });\n  };\n\n  ColumnMenu.prototype.afterFilterColumnMenuClose = function () {\n    if (this.columnMenu) {\n      this.columnMenu.items = this.getItems();\n      this.columnMenu.dataBind();\n      this.columnMenu.close();\n    }\n  };\n\n  ColumnMenu.prototype.openColumnMenu = function (e) {\n    var pos = {\n      top: 0,\n      left: 0\n    };\n    this.element.style.cssText = 'display:block;visibility:hidden';\n    var elePos = this.element.getBoundingClientRect();\n    var gClient = this.parent.element.getBoundingClientRect();\n    this.element.style.cssText = 'display:none;visibility:visible';\n    this.headerCell = this.getHeaderCell(e);\n\n    if (Browser.isDevice) {\n      pos.top = window.innerHeight / 2 - elePos.height / 2;\n      pos.left = window.innerWidth / 2 - elePos.width / 2;\n    } else {\n      if (this.parent.enableRtl) {\n        pos = calculatePosition(this.headerCell, 'left', 'bottom');\n      } else {\n        pos = calculatePosition(this.headerCell, 'right', 'bottom');\n        pos.left -= elePos.width;\n\n        if (pos.left + elePos.width + 1 >= gClient.right) {\n          pos.left -= 35;\n        }\n      }\n    }\n\n    this.columnMenu.open(pos.top, pos.left);\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n    applyBiggerTheme(this.parent.element, this.columnMenu.element.parentElement);\n  };\n\n  ColumnMenu.prototype.columnMenuHandlerDown = function () {\n    this.isOpen = !(this.element.style.display === 'none' || this.element.style.display === '');\n  };\n\n  ColumnMenu.prototype.getColumnMenuHandlers = function () {\n    return [].slice.call(this.parent.getHeaderTable().getElementsByClassName(this.ROOT));\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnMenu.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(headerRefreshed, this.wireEvents, this);\n    this.parent.on(uiUpdate, this.enableAfterRenderMenu, this);\n    this.parent.on(initialEnd, this.render, this);\n\n    if (this.isFilterItemAdded()) {\n      this.parent.on(filterDialogCreated, this.filterPosition, this);\n    }\n\n    this.parent.on(click, this.columnMenuHandlerClick, this);\n    this.parent.on(afterFilterColumnMenuClose, this.afterFilterColumnMenuClose, this);\n    this.parent.on(keyPressed, this.keyPressHandler, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  ColumnMenu.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(headerRefreshed, this.unwireEvents);\n    this.parent.off(uiUpdate, this.enableAfterRenderMenu);\n    this.parent.off(initialEnd, this.render);\n\n    if (this.isFilterItemAdded()) {\n      this.parent.off(filterDialogCreated, this.filterPosition);\n    }\n\n    this.parent.off(click, this.columnMenuHandlerClick);\n    this.parent.on(afterFilterColumnMenuClose, this.afterFilterColumnMenuClose);\n    this.parent.off(keyPressed, this.keyPressHandler);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  ColumnMenu.prototype.keyPressHandler = function (e) {\n    var gObj = this.parent;\n\n    if (e.action === 'altDownArrow') {\n      var element = gObj.focusModule.currentInfo.element;\n\n      if (element && element.classList.contains('e-headercell')) {\n        var column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n        this.openColumnMenuByField(column.field);\n      }\n    }\n  };\n\n  ColumnMenu.prototype.enableAfterRenderMenu = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      if (this.columnMenu) {\n        this.columnMenu.destroy();\n        remove(this.element);\n      }\n\n      this.render();\n    }\n  };\n\n  ColumnMenu.prototype.render = function () {\n    this.l10n = this.serviceLocator.getService('localization');\n    this.element = this.parent.createElement('ul', {\n      id: this.gridID + '_columnmenu',\n      className: 'e-colmenu'\n    });\n    this.element.setAttribute('aria-label', this.l10n.getConstant('ColumnMenuDialogARIA'));\n    this.parent.element.appendChild(this.element);\n    this.columnMenu = new ContextMenu({\n      cssClass: this.parent.cssClass ? 'e-grid-menu' + ' ' + this.parent.cssClass : 'e-grid-menu',\n      enableRtl: this.parent.enableRtl,\n      enablePersistence: this.parent.enablePersistence,\n      locale: this.parent.locale,\n      items: this.getItems(),\n      select: this.columnMenuItemClick.bind(this),\n      beforeOpen: this.columnMenuBeforeOpen.bind(this),\n      onOpen: this.columnMenuOnOpen.bind(this),\n      onClose: this.columnMenuOnClose.bind(this),\n      beforeItemRender: this.beforeMenuItemRender.bind(this),\n      beforeClose: this.columnMenuBeforeClose.bind(this)\n    });\n    this.columnMenu.appendTo(this.element);\n    this.wireFilterEvents();\n  };\n\n  ColumnMenu.prototype.wireFilterEvents = function () {\n    if (!Browser.isDevice && this.isFilterItemAdded()) {\n      EventHandler.add(this.element, 'mouseover', this.appendFilter, this);\n    }\n  };\n\n  ColumnMenu.prototype.unwireFilterEvents = function () {\n    if (!Browser.isDevice && this.isFilterItemAdded()) {\n      EventHandler.remove(this.element, 'mouseover', this.appendFilter);\n    }\n  };\n\n  ColumnMenu.prototype.beforeMenuItemRender = function (args) {\n    if (this.isChooserItem(args.item)) {\n      var field_1 = this.getKeyFromId(args.item.id, this.CHOOSER);\n      var column = this.parent.columnModel.filter(function (col) {\n        return col.field === field_1;\n      });\n      var check = createCheckBox(this.parent.createElement, false, {\n        label: args.item.text,\n        checked: column[0].visible\n      });\n\n      if (this.parent.enableRtl) {\n        check.classList.add('e-rtl');\n      }\n\n      if (this.parent.cssClass) {\n        check.classList.add(this.parent.cssClass);\n      }\n\n      args.element.innerHTML = '';\n      args.element.appendChild(check);\n    } else if (args.item.id && this.getKeyFromId(args.item.id) === 'Filter') {\n      args.element.appendChild(this.parent.createElement('span', {\n        className: 'e-icons e-caret'\n      }));\n      args.element.className += 'e-filter-item e-menu-caret-icon';\n    }\n  };\n\n  ColumnMenu.prototype.columnMenuBeforeClose = function (args) {\n    var colChooser = args.event ? closest(args.event.target, '.e-menu-item') : null;\n\n    if (!isNullOrUndefined(args.parentItem) && this.getKeyFromId(args.parentItem.id) === 'ColumnChooser' && colChooser && this.isChooserItem(colChooser)) {\n      args.cancel = true;\n    } else if (args.event && (closest(args.event.target, '.' + this.POP) || args.event.currentTarget && args.event.currentTarget.activeElement && parentsUntil(args.event.currentTarget.activeElement, 'e-filter-popup') || parentsUntil(args.event.target, 'e-popup') || parentsUntil(args.event.target, 'e-popup-wrapper')) && !Browser.isDevice) {\n      args.cancel = true;\n    }\n  };\n\n  ColumnMenu.prototype.isChooserItem = function (item) {\n    return item.id && item.id.indexOf('_colmenu_') >= 0 && this.getKeyFromId(item.id, this.CHOOSER).indexOf('_colmenu_') === -1;\n  };\n\n  ColumnMenu.prototype.columnMenuBeforeOpen = function (args) {\n    args.column = this.targetColumn = this.getColumn();\n    this.parent.trigger(columnMenuOpen, args);\n\n    for (var _i = 0, _a = args.items; _i < _a.length; _i++) {\n      var item = _a[_i];\n      var key = this.getKeyFromId(item.id);\n      var dItem = this.defaultItems[key];\n\n      if (this.getDefaultItems().indexOf(key) !== -1 && this.ensureDisabledStatus(key) && !dItem.hide) {\n        this.disableItems.push(item.text);\n      }\n\n      if (item.hide) {\n        this.hiddenItems.push(item.text);\n      }\n    }\n\n    this.columnMenu.enableItems(this.disableItems, false);\n    this.columnMenu.hideItems(this.hiddenItems);\n  };\n\n  ColumnMenu.prototype.columnMenuOnOpen = function (args) {\n    if (args.element.className === 'e-menu-parent e-ul ') {\n      if (args.element.offsetHeight > window.innerHeight || this.parent.element.offsetHeight > window.innerHeight) {\n        args.element.style.maxHeight = window.innerHeight * 0.8 + 'px';\n        args.element.style.overflowY = 'auto';\n      }\n    }\n  };\n\n  ColumnMenu.prototype.ensureDisabledStatus = function (item) {\n    var status = false;\n\n    switch (item) {\n      case 'Group':\n        if (!this.parent.allowGrouping || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) >= 0 || this.targetColumn && !this.targetColumn.allowGrouping) {\n          status = true;\n        }\n\n        break;\n\n      case 'AutoFitAll':\n      case 'AutoFit':\n        status = !this.parent.ensureModuleInjected(Resize);\n        break;\n\n      case 'Ungroup':\n        if (!this.parent.ensureModuleInjected(Group) || this.parent.ensureModuleInjected(Group) && this.targetColumn && this.parent.groupSettings.columns.indexOf(this.targetColumn.field) < 0) {\n          status = true;\n        }\n\n        break;\n\n      case 'SortDescending':\n      case 'SortAscending':\n        if (this.parent.allowSorting && this.parent.ensureModuleInjected(Sort) && this.parent.sortSettings.columns.length > 0 && this.targetColumn && this.targetColumn.allowSorting) {\n          var sortColumns = this.parent.sortSettings.columns;\n\n          for (var i = 0; i < sortColumns.length; i++) {\n            if (sortColumns[i].field === this.targetColumn.field && sortColumns[i].direction.toLocaleLowerCase() === item.toLocaleLowerCase().replace('sort', '')) {\n              status = true;\n            }\n          }\n        } else if (!this.parent.allowSorting || !this.parent.ensureModuleInjected(Sort) || this.parent.allowSorting && this.targetColumn && !this.targetColumn.allowSorting) {\n          status = true;\n        }\n\n        break;\n\n      case 'Filter':\n        if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar' && this.parent.ensureModuleInjected(Filter) && this.targetColumn && this.targetColumn.allowFiltering) {\n          status = false;\n        } else if (this.parent.ensureModuleInjected(Filter) && this.parent.allowFiltering && this.targetColumn && (!this.targetColumn.allowFiltering || this.parent.filterSettings.type === 'FilterBar')) {\n          status = true;\n        }\n\n    }\n\n    return status;\n  };\n\n  ColumnMenu.prototype.columnMenuItemClick = function (args) {\n    var item = this.isChooserItem(args.item) ? 'ColumnChooser' : this.getKeyFromId(args.item.id);\n\n    switch (item) {\n      case 'AutoFit':\n        this.parent.autoFitColumns(this.targetColumn.field);\n        break;\n\n      case 'AutoFitAll':\n        this.parent.autoFitColumns([]);\n        break;\n\n      case 'Ungroup':\n        this.parent.ungroupColumn(this.targetColumn.field);\n        break;\n\n      case 'Group':\n        this.parent.groupColumn(this.targetColumn.field);\n        break;\n\n      case 'SortAscending':\n        this.parent.sortColumn(this.targetColumn.field, 'Ascending');\n        break;\n\n      case 'SortDescending':\n        this.parent.sortColumn(this.targetColumn.field, 'Descending');\n        break;\n\n      case 'ColumnChooser':\n        // eslint-disable-next-line no-case-declarations\n        var key = this.getKeyFromId(args.item.id, this.CHOOSER); // eslint-disable-next-line no-case-declarations\n\n        var checkbox = args.element.querySelector('.e-checkbox-wrapper .e-frame');\n\n        if (checkbox && checkbox.classList.contains('e-check')) {\n          checkbox.classList.remove('e-check');\n          this.parent.hideColumns(key, 'field');\n        } else if (checkbox) {\n          this.parent.showColumns(key, 'field');\n          checkbox.classList.add('e-check');\n        }\n\n        break;\n\n      case 'Filter':\n        this.getFilter(args.element, args.item.id);\n        break;\n    }\n\n    args.column = this.targetColumn;\n    this.parent.trigger(columnMenuClick, args);\n  };\n\n  ColumnMenu.prototype.columnMenuOnClose = function (args) {\n    var parent = 'parentObj';\n\n    if (args.items.length > 0 && args.items[0][parent] instanceof ContextMenu) {\n      this.columnMenu.enableItems(this.disableItems, false);\n      this.disableItems = [];\n      this.columnMenu.showItems(this.hiddenItems);\n      this.hiddenItems = [];\n\n      if (this.isFilterPopupOpen()) {\n        this.getFilter(args.element, args.element.id, true);\n      }\n    }\n\n    if (!this.parent.isFrozenGrid()) {\n      this.parent.notify(restoreFocus, {});\n    }\n  };\n\n  ColumnMenu.prototype.getDefaultItems = function () {\n    return ['AutoFitAll', 'AutoFit', 'SortAscending', 'SortDescending', 'Group', 'Ungroup', 'ColumnChooser', 'Filter'];\n  };\n\n  ColumnMenu.prototype.getItems = function () {\n    var items = [];\n    var defultItems = this.parent.columnMenuItems ? this.parent.columnMenuItems : this.getDefault();\n\n    for (var _i = 0, defultItems_1 = defultItems; _i < defultItems_1.length; _i++) {\n      var item = defultItems_1[_i];\n\n      if (typeof item === 'string') {\n        if (item === 'ColumnChooser') {\n          var col = this.getDefaultItem(item);\n          col.items = this.createChooserItems();\n          items.push(col);\n        } else {\n          items.push(this.getDefaultItem(item));\n        }\n      } else {\n        items.push(item);\n      }\n    }\n\n    return items;\n  };\n\n  ColumnMenu.prototype.getDefaultItem = function (item) {\n    var menuItem = {};\n\n    switch (item) {\n      case 'SortAscending':\n        menuItem = {\n          iconCss: this.ASCENDING\n        };\n        break;\n\n      case 'SortDescending':\n        menuItem = {\n          iconCss: this.DESCENDING\n        };\n        break;\n\n      case 'Group':\n        menuItem = {\n          iconCss: this.GROUP\n        };\n        break;\n\n      case 'Ungroup':\n        menuItem = {\n          iconCss: this.UNGROUP\n        };\n        break;\n\n      case 'Filter':\n        menuItem = {\n          iconCss: this.FILTER\n        };\n        break;\n    }\n\n    this.defaultItems[item] = {\n      text: this.getLocaleText(item),\n      id: this.generateID(item),\n      iconCss: menuItem.iconCss ? 'e-icons ' + menuItem.iconCss : null\n    };\n    return this.defaultItems[item];\n  };\n\n  ColumnMenu.prototype.getLocaleText = function (item) {\n    return this.l10n.getConstant(this.localeText[item]);\n  };\n\n  ColumnMenu.prototype.generateID = function (item, append$$1) {\n    return this.gridID + '_colmenu_' + (append$$1 ? append$$1 + item : item);\n  };\n\n  ColumnMenu.prototype.getKeyFromId = function (id, append$$1) {\n    return id.indexOf('_colmenu_') > 0 && id.replace(this.gridID + '_colmenu_' + (append$$1 ? append$$1 : ''), '');\n  };\n  /**\n   * @returns {HTMLElement} returns the HTMLElement\n   * @hidden\n   */\n\n\n  ColumnMenu.prototype.getColumnMenu = function () {\n    return this.element;\n  };\n\n  ColumnMenu.prototype.getModuleName = function () {\n    return 'columnMenu';\n  };\n\n  ColumnMenu.prototype.setLocaleKey = function () {\n    var localeKeys = {\n      'AutoFitAll': 'autoFitAll',\n      'AutoFit': 'autoFit',\n      'Group': 'Group',\n      'Ungroup': 'Ungroup',\n      'SortAscending': 'SortAscending',\n      'SortDescending': 'SortDescending',\n      'ColumnChooser': 'Columnchooser',\n      'Filter': 'FilterMenu'\n    };\n    return localeKeys;\n  };\n\n  ColumnMenu.prototype.getHeaderCell = function (e) {\n    return closest(e.target, 'th.e-headercell');\n  };\n\n  ColumnMenu.prototype.getColumn = function () {\n    if (this.headerCell) {\n      var uid = this.headerCell.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n      return this.parent.getColumnByUid(uid);\n    }\n\n    return null;\n  };\n\n  ColumnMenu.prototype.createChooserItems = function () {\n    var items = [];\n\n    for (var _i = 0, _a = this.parent.columnModel; _i < _a.length; _i++) {\n      var col = _a[_i];\n\n      if (col.showInColumnChooser && col.field) {\n        items.push({\n          id: this.generateID(col.field, this.CHOOSER),\n          text: col.headerText ? col.headerText : col.field\n        });\n      }\n    }\n\n    return items;\n  };\n\n  ColumnMenu.prototype.appendFilter = function (e) {\n    var filter = 'Filter';\n\n    if (!this.defaultItems[filter]) {\n      return;\n    } else {\n      var key = this.defaultItems[filter].id;\n\n      if (closest(e.target, '#' + key) && !this.isFilterPopupOpen()) {\n        this.getFilter(e.target, key);\n      } else if (!closest(e.target, '#' + key) && this.isFilterPopupOpen()) {\n        this.getFilter(e.target, key, true);\n      }\n    }\n  };\n\n  ColumnMenu.prototype.getFilter = function (target, id, isClose) {\n    var filterPopup = this.getFilterPop();\n\n    if (filterPopup) {\n      filterPopup.style.display = !Browser.isDevice && isClose ? 'none' : 'block';\n    } else {\n      this.parent.notify(filterOpen, {\n        col: this.targetColumn,\n        target: target,\n        isClose: isClose,\n        id: id\n      });\n    }\n  };\n\n  ColumnMenu.prototype.setPosition = function (li, ul) {\n    var gridPos = this.parent.element.getBoundingClientRect();\n    var liPos = li.getBoundingClientRect();\n    var left = liPos.left - gridPos.left;\n    var top = liPos.top - gridPos.top;\n\n    if (gridPos.height < top) {\n      top = top - ul.offsetHeight + liPos.height;\n    } else if (gridPos.height < top + ul.offsetHeight) {\n      top = gridPos.height - ul.offsetHeight;\n    }\n\n    if (window.innerHeight < ul.offsetHeight + top + gridPos.top) {\n      top = window.innerHeight - ul.offsetHeight - gridPos.top;\n    }\n\n    if (top + gridPos.top < 0) {\n      top = 0;\n    }\n\n    left += this.parent.enableRtl ? -ul.offsetWidth : liPos.width;\n\n    if (gridPos.width <= left + ul.offsetWidth) {\n      left -= liPos.width + ul.offsetWidth;\n\n      if (liPos.left < ul.offsetWidth) {\n        left = liPos.left + ul.offsetWidth / 2;\n      }\n    } else if (left < 0) {\n      left += ul.offsetWidth + liPos.width;\n    }\n\n    ul.style.top = top + 'px';\n    ul.style.left = left + 'px';\n  };\n\n  ColumnMenu.prototype.filterPosition = function () {\n    var filterPopup = this.getFilterPop();\n    filterPopup.classList.add(this.WRAP);\n\n    if (!Browser.isDevice) {\n      var disp = filterPopup.style.display;\n      filterPopup.style.cssText += 'display:block;visibility:hidden';\n      var li = this.element.querySelector('.' + this.FILTER);\n\n      if (li) {\n        this.setPosition(li.parentElement, filterPopup);\n        filterPopup.style.cssText += 'display:' + disp + ';visibility:visible';\n      }\n    }\n  };\n\n  ColumnMenu.prototype.getDefault = function () {\n    var items = [];\n\n    if (this.parent.ensureModuleInjected(Resize)) {\n      items.push('AutoFitAll');\n      items.push('AutoFit');\n    }\n\n    if (this.parent.allowGrouping && this.parent.ensureModuleInjected(Group)) {\n      items.push('Group');\n      items.push('Ungroup');\n    }\n\n    if (this.parent.allowSorting && this.parent.ensureModuleInjected(Sort)) {\n      items.push('SortAscending');\n      items.push('SortDescending');\n    }\n\n    items.push('ColumnChooser');\n\n    if (this.parent.allowFiltering && this.parent.filterSettings.type !== 'FilterBar' && this.parent.ensureModuleInjected(Filter)) {\n      items.push('Filter');\n    }\n\n    return items;\n  };\n\n  ColumnMenu.prototype.isFilterPopupOpen = function () {\n    var filterPopup = this.getFilterPop();\n    return filterPopup && filterPopup.style.display !== 'none';\n  };\n\n  ColumnMenu.prototype.getFilterPop = function () {\n    if (Browser.isDevice && this.targetColumn !== null && this.parent.filterSettings.type === 'Menu') {\n      return document.getElementById(this.targetColumn.uid + '-flmdlg');\n    }\n\n    return this.parent.element.querySelector('.' + this.POP);\n  };\n\n  ColumnMenu.prototype.isFilterItemAdded = function () {\n    return this.parent.columnMenuItems && this.parent.columnMenuItems.indexOf('Filter') >= 0 || !this.parent.columnMenuItems;\n  };\n\n  return ColumnMenu;\n}();\n\nvar __extends$35 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `ForeignKey` module is used to handle foreign key column's actions.\n */\n\n\nvar ForeignKey =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$35(ForeignKey, _super);\n\n  function ForeignKey(parent, serviceLocator) {\n    var _this = _super.call(this, parent, serviceLocator) || this;\n\n    _this.parent = parent;\n    _this.serviceLocator = serviceLocator;\n\n    _this.initEvent();\n\n    return _this;\n  }\n\n  ForeignKey.prototype.initEvent = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initForeignKeyColumn, this.initForeignKeyColumns, this);\n    this.parent.on(getForeignKeyData, this.getForeignKeyData, this);\n    this.parent.on(generateQuery, this.generateQueryFormData, this);\n  };\n\n  ForeignKey.prototype.initForeignKeyColumns = function (columns) {\n    for (var i = 0; i < columns.length; i++) {\n      columns[i].dataSource = columns[i].dataSource instanceof DataManager ? columns[i].dataSource : isNullOrUndefined(columns[i].dataSource) ? new DataManager() : 'result' in columns[i].dataSource ? columns[i].dataSource : new DataManager(columns[i].dataSource);\n    }\n  };\n\n  ForeignKey.prototype.eventfPromise = function (args, query, key, column) {\n    var state = this.getStateEventArgument(query);\n    var def = new Deferred();\n    var deff = new Deferred();\n    state.action = args.action;\n    var dataModule = this.parent.getDataModule();\n\n    if (!isNullOrUndefined(args.action) && args.action.requestType && dataModule.foreignKeyDataState.isDataChanged !== false) {\n      dataModule.setForeignKeyDataState({\n        isPending: true,\n        resolver: deff.resolve\n      });\n      deff.promise.then(function () {\n        def.resolve(column.dataSource);\n      });\n      state.setColumnData = this.parent.setForeignKeyData.bind(this.parent);\n      this.parent.trigger(columnDataStateChange, state);\n    } else {\n      dataModule.setForeignKeyDataState({});\n      def.resolve(key);\n    }\n\n    return def;\n  };\n\n  ForeignKey.prototype.getForeignKeyData = function (args) {\n    var _this = this;\n\n    var foreignColumns = args.column ? [args.column] : this.parent.getForeignKeyColumns();\n    var allPromise = [];\n\n    var _loop_1 = function (i) {\n      var promise = void 0;\n      var query = args.isComplex ? this_1.genarateColumnQuery(foreignColumns[i]) : this_1.genarateQuery(foreignColumns[i], args.result.result, false, true);\n      query.params = this_1.parent.query.params;\n      var dataSource = foreignColumns[i].dataSource;\n\n      if (dataSource && 'result' in dataSource) {\n        var def = this_1.eventfPromise(args, query, dataSource, foreignColumns[i]);\n        promise = def.promise;\n      } else if (!dataSource.ready || dataSource.dataSource.offline) {\n        promise = dataSource.executeQuery(query);\n      } else {\n        promise = dataSource.ready.then(function () {\n          return dataSource.executeQuery(query);\n        });\n      }\n\n      allPromise.push(promise);\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < foreignColumns.length; i++) {\n      _loop_1(i);\n    }\n\n    Promise.all(allPromise).then(function (responses) {\n      for (var i = 0; i < responses.length; i++) {\n        foreignColumns[i].columnData = responses[i].result;\n\n        if (foreignColumns[i].editType === 'dropdownedit' && 'result' in foreignColumns[i].dataSource) {\n          foreignColumns[i].edit.params = extend(foreignColumns[i].edit.params, {\n            dataSource: responses[i].result,\n            query: new Query(),\n            fields: {\n              value: foreignColumns[i].foreignKeyField || foreignColumns[i].field,\n              text: foreignColumns[i].foreignKeyValue\n            }\n          });\n        }\n      }\n\n      args.promise.resolve(args.result);\n    }).catch(function (e) {\n      _this.parent.log(['actionfailure', 'foreign_key_failure']);\n\n      if (args.promise && args.promise.reject) {\n        args.promise.reject(e);\n      }\n\n      return e;\n    });\n  };\n\n  ForeignKey.prototype.generateQueryFormData = function (args) {\n    args.predicate.predicate = this.genarateQuery(args.column, args.column.columnData, true);\n  };\n\n  ForeignKey.prototype.genarateQuery = function (column, e, fromData, needQuery) {\n    var gObj = this.parent;\n    var predicates = [];\n    var query = new Query();\n    var field = fromData ? column.foreignKeyField : column.field;\n\n    if (gObj.allowPaging || gObj.enableVirtualization || fromData) {\n      e = new DataManager(gObj.allowGrouping && gObj.groupSettings.columns.length && !fromData ? e.records : e).executeLocal(new Query().select(field));\n      var filteredValue = DataUtil.distinct(e, field, false);\n      field = fromData ? column.field : column.foreignKeyField;\n\n      for (var i = 0; i < filteredValue.length; i++) {\n        if (filteredValue[i] && filteredValue[i].getDay) {\n          predicates.push(getDatePredicate({\n            field: field,\n            operator: 'equal',\n            value: filteredValue[i],\n            matchCase: false\n          }));\n        } else {\n          predicates.push(new Predicate(field, 'equal', filteredValue[i], false));\n        }\n      }\n    }\n\n    if (needQuery) {\n      return predicates.length ? query.where(Predicate.or(predicates)) : query;\n    }\n\n    return predicates.length ? Predicate.or(predicates) : {\n      predicates: []\n    };\n  };\n\n  ForeignKey.prototype.genarateColumnQuery = function (column) {\n    var gObj = this.parent;\n    var query = new Query();\n    var queryColumn = this.isFiltered(column);\n\n    if (queryColumn.isTrue) {\n      query = this.filterQuery(query, queryColumn.column, true);\n    }\n\n    if (gObj.searchSettings.key.length) {\n      var sSettings = gObj.searchSettings;\n\n      if (column.dataSource instanceof DataManager && column.dataSource.adaptor.getModuleName && column.dataSource.adaptor.getModuleName() === 'ODataV4Adaptor') {\n        query = this.searchQuery(query, column, true);\n      } else {\n        query.search(sSettings.key, column.foreignKeyValue, sSettings.operator, sSettings.ignoreCase);\n      }\n    }\n\n    return query;\n  };\n\n  ForeignKey.prototype.isFiltered = function (column) {\n    var filterColumn = this.parent.filterSettings.columns.filter(function (fColumn) {\n      return fColumn.field === column.foreignKeyValue && fColumn.uid === column.uid;\n    });\n    return {\n      column: filterColumn,\n      isTrue: !!filterColumn.length\n    };\n  };\n\n  ForeignKey.prototype.getModuleName = function () {\n    return 'foreignKey';\n  };\n\n  ForeignKey.prototype.destroy = function () {\n    this.destroyEvent();\n  };\n\n  ForeignKey.prototype.destroyEvent = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initForeignKeyColumn, this.initForeignKeyColumns);\n    this.parent.off(getForeignKeyData, this.getForeignKeyData);\n    this.parent.off(generateQuery, this.generateQueryFormData);\n  };\n\n  return ForeignKey;\n}(Data);\n/**\n *\n * `Logger` class\n */\n\n\nvar BASE_DOC_URL = 'https://ej2.syncfusion.com/documentation/grid';\nvar DOC_URL = 'https://ej2.syncfusion.com/documentation/';\nvar WARNING = '[EJ2Grid.Warning]';\nvar ERROR = '[EJ2Grid.Error]';\nvar INFO = '[EJ2Grid.Info]';\n\nvar Logger =\n/** @__PURE__ @class */\nfunction () {\n  function Logger(parent) {\n    this.parent = parent;\n    this.parent.on('initial-end', this.patchadaptor, this);\n  }\n\n  Logger.prototype.getModuleName = function () {\n    return 'logger';\n  };\n\n  Logger.prototype.log = function (types, args) {\n    if (!(types instanceof Array)) {\n      types = [types];\n    }\n\n    var type = types;\n\n    for (var i = 0; i < type.length; i++) {\n      var item = detailLists[type[i]];\n      var cOp = item.check(args, this.parent);\n\n      if (cOp.success) {\n        // eslint-disable-next-line no-console\n        console[item.logType](item.generateMessage(args, this.parent, cOp.options));\n      }\n    }\n  };\n\n  Logger.prototype.patchadaptor = function () {\n    var adaptor = this.parent.getDataModule().dataManager.adaptor;\n    var original = adaptor.beforeSend;\n\n    if (original) {\n      adaptor.beforeSend = function (dm, request, settings) {\n        original.call(adaptor, dm, request, settings);\n      };\n    }\n  };\n\n  Logger.prototype.destroy = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off('initial-end', this.patchadaptor);\n  };\n\n  return Logger;\n}();\n\nvar detailLists = {\n  // eslint-disable-next-line camelcase\n  module_missing: {\n    type: 'module_missing',\n    logType: 'warn',\n    check: function (args, parent) {\n      var injected = parent.getInjectedModules().map(function (m) {\n        return m.prototype.getModuleName();\n      }); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var modules = parent.requiredModules().map(function (m) {\n        return m.member;\n      }).filter(function (name) {\n        return injected.indexOf(name) === -1;\n      });\n      return {\n        success: modules.filter(function (m) {\n          return m !== 'resize';\n        }).length > 0,\n        options: modules\n      };\n    },\n    generateMessage: function (args, parent, modules) {\n      modules = modules.filter(function (m) {\n        return m !== 'resize';\n      }).reduce(function (prev, cur) {\n        return prev + (\"* \" + cur + \"\\n\");\n      }, '');\n      return WARNING + ': MODULES MISSING\\n' + 'The following modules are not injected:.\\n' + (\"\" + modules) + (\"Refer to \" + BASE_DOC_URL + \"/module.html for documentation on importing feature modules.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  promise_enabled: {\n    type: 'promise_enabled',\n    logType: 'error',\n    check: function () {\n      return {\n        success: typeof Promise === 'undefined'\n      };\n    },\n    generateMessage: function () {\n      return ERROR + ': PROMISE UNDEFINED\\n' + 'Promise object is not present in the global environment,' + 'please use polyfil to support Promise object in your environment.\\n' + (\"Refer to \" + DOC_URL + \"/base/browser.html?#required-polyfills for more information.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  primary_column_missing: {\n    type: 'primary_column_missing',\n    logType: 'warn',\n    check: function (args, parent) {\n      return {\n        success: parent.getColumns().filter(function (column) {\n          return column.isPrimaryKey;\n        }).length === 0\n      };\n    },\n    generateMessage: function () {\n      return WARNING + ': PRIMARY KEY MISSING\\n' + 'Editing is enabled but primary key column is not specified.\\n' + (\"Refer to \" + BASE_DOC_URL + \"/api-column.html?#isprimarykey for documentation on providing primary key columns.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  selection_key_missing: {\n    type: 'selection_key_missing',\n    logType: 'warn',\n    check: function (args, parent) {\n      return {\n        success: parent.selectionSettings.persistSelection && parent.getColumns().filter(function (column) {\n          return column.isPrimaryKey;\n        }).length === 0\n      };\n    },\n    generateMessage: function () {\n      return WARNING + ': PRIMARY KEY MISSING\\n' + 'selectionSettings.persistSelection property is enabled. It requires one primary key column to persist selection.\\n' + (\"Refer to \" + BASE_DOC_URL + \"/api-column.html?#isprimarykey for documentation on providing primary key columns.\");\n    }\n  },\n  actionfailure: {\n    type: 'actionfailure',\n    logType: 'error',\n    check: function () {\n      return {\n        success: true\n      };\n    },\n    generateMessage: function (args, parent) {\n      var message = '';\n      var formatError = formatErrorHandler(args, parent);\n      var ajaxError = ajaxErrorHandler(args, parent);\n\n      if (ajaxError !== '') {\n        message = ajaxError;\n      } else if (formatError !== '') {\n        message = formatError;\n      } else {\n        message = args.error;\n      }\n\n      return WARNING + ': ' + message;\n    }\n  },\n  // eslint-disable-next-line camelcase\n  locale_missing: {\n    type: 'locale_missing',\n    logType: 'warn',\n    check: function (args, parent) {\n      var lObj = DataUtil.getObject(\"locale.\" + parent.locale + \".grid\", L10n);\n      return {\n        success: parent.locale !== 'en-US' && isNullOrUndefined(lObj)\n      };\n    },\n    generateMessage: function (args, parent) {\n      return WARNING + ': LOCALE CONFIG MISSING\\n' + (\"Locale configuration for '\" + parent.locale + \"' is not provided.\\n\") + (\"Refer to \" + BASE_DOC_URL + \"/globalization-and-localization.html?#localization \\n             for documentation on setting locale configuration.\");\n    }\n  },\n  limitation: {\n    type: 'limitation',\n    logType: 'warn',\n    check: function (args, parent) {\n      var name = args;\n      var opt;\n\n      switch (name) {\n        case 'freeze':\n          opt = {\n            success: parent.allowGrouping || !isUndefined(parent.detailTemplate) || !isUndefined(parent.childGrid) || !isUndefined(parent.rowTemplate) || parent.enableVirtualization,\n            options: {\n              name: 'freeze'\n            }\n          };\n          break;\n\n        case 'virtualization':\n          opt = {\n            success: !isUndefined(parent.detailTemplate) || !isUndefined(parent.childGrid) || parent.frozenRows !== 0 || parent.frozenColumns !== 0,\n            options: {\n              name: 'virtualization'\n            }\n          };\n          break;\n\n        default:\n          opt = {\n            success: false\n          };\n          break;\n      }\n\n      return opt;\n    },\n    generateMessage: function (args, parent, options) {\n      var name = options.name;\n      var opt;\n\n      switch (name) {\n        case 'freeze':\n          opt = 'Frozen rows and columns do not support the following features:\\n' + '* Virtualization\\n' + '* Row Template\\n' + '* Details Template\\n' + '* Hierarchy Grid\\n' + '* Grouping';\n          break;\n\n        case 'virtualization':\n          opt = 'Virtualization does not support the following features.\\n' + '* Freeze rows and columns.\\n' + '* Details Template.\\n' + '* Hierarchy Grid.\\n';\n          break;\n\n        default:\n          opt = '';\n          break;\n      }\n\n      return WARNING + (\": \" + name.toUpperCase() + \" LIMITATIONS\\n\") + opt;\n    }\n  },\n  // eslint-disable-next-line camelcase\n  check_datasource_columns: {\n    type: 'check_datasource_columns',\n    logType: 'warn',\n    check: function (args, parent) {\n      return {\n        success: !(parent.columns.length || parent.dataSource instanceof DataManager || parent.dataSource.length)\n      };\n    },\n    generateMessage: function () {\n      return WARNING + ': GRID CONFIG MISSING\\n' + 'dataSource and columns are not provided in the grid. ' + 'At least one of either must be provided for grid configuration.\\n' + (\"Refer to \" + BASE_DOC_URL + \"/columns.html for documentation on configuring the grid data and columns.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  virtual_height: {\n    type: 'virtual_height',\n    logType: 'error',\n    check: function (args, parent) {\n      return {\n        success: isNullOrUndefined(parent.height) || parent.height === 'auto'\n      };\n    },\n    generateMessage: function () {\n      return ERROR + ': GRID HEIGHT MISSING \\n' + 'height property is required to use virtualization.\\n' + (\"Refer to \" + BASE_DOC_URL + \"/virtual.html for documentation on configuring the virtual grid.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  grid_remote_edit: {\n    type: 'grid_remote_edit',\n    logType: 'error',\n    check: function (args) {\n      return {\n        success: Array.isArray(args) || Array.isArray(args.result)\n      };\n    },\n    generateMessage: function () {\n      return ERROR + ': RETRUN VALUE MISSING  \\n' + 'Remote service returns invalid data. \\n' + (\"Refer to \" + BASE_DOC_URL + \"/edit.html for documentation on configuring editing with remote data.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  grid_sort_comparer: {\n    type: 'grid_sort_comparer',\n    logType: 'warn',\n    check: function (args, parent) {\n      return {\n        success: parent.getDataModule().isRemote()\n      };\n    },\n    generateMessage: function () {\n      return WARNING + ': SORT COMPARER NOT WORKING  \\n' + 'Sort comparer will not work with remote data.' + (\"Refer to \" + BASE_DOC_URL + \"/sorting/#custom-sort-comparer for documentation on using the sort comparer.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  resize_min_max: {\n    type: 'resize_min_max',\n    logType: 'info',\n    check: function (args) {\n      return {\n        success: args.column.minWidth && args.column.minWidth >= args.width || args.column.maxWidth && args.column.maxWidth <= args.width\n      };\n    },\n    generateMessage: function () {\n      return INFO + ': RESIZING COLUMN REACHED MIN OR MAX  \\n' + 'The column resizing width is at its min or max.';\n    }\n  },\n  // eslint-disable-next-line camelcase\n  action_disabled_column: {\n    type: 'action_disabled_column',\n    logType: 'info',\n    check: function (args) {\n      var success = true;\n      var fn;\n\n      switch (args.moduleName) {\n        case 'reorder':\n          if (isNullOrUndefined(args.destColumn)) {\n            fn = \"reordering action is disabled for the \" + args.column.headerText + \" column\";\n          } else {\n            fn = \"reordering action is disabled for the \" + (args.column.allowReordering ? args.destColumn.headerText : args.column.headerText) + \" column\";\n          }\n\n          break;\n\n        case 'group':\n          fn = \"grouping action is disabled for the \" + args.columnName + \" column.\";\n          break;\n\n        case 'filter':\n          fn = \"filtering action is disabled for the \" + args.columnName + \" column.\";\n          break;\n\n        case 'sort':\n          fn = \"sorting action is disabled for the \" + args.columnName + \" column.\";\n          break;\n      }\n\n      return {\n        success: success,\n        options: {\n          fn: fn\n        }\n      };\n    },\n    generateMessage: function (args, parent, options) {\n      return INFO + (\": ACTION DISABLED \\n \" + options.fn);\n    }\n  },\n  // eslint-disable-next-line camelcase\n  exporting_begin: {\n    type: 'exporting_begin',\n    logType: 'info',\n    check: function (args) {\n      return {\n        success: true,\n        options: {\n          args: args\n        }\n      };\n    },\n    generateMessage: function (args, parent, options) {\n      return INFO + (\": EXPORTNIG INPROGRESS \\n Grid \" + options.args + \"ing is in progress\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  exporting_complete: {\n    type: 'exporting_complete',\n    logType: 'info',\n    check: function (args) {\n      return {\n        success: true,\n        options: {\n          args: args\n        }\n      };\n    },\n    generateMessage: function (args, parent, options) {\n      return INFO + (\": EXPORTNIG COMPLETED \\n Grid \" + options.args + \"ing is complete\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  foreign_key_failure: {\n    type: 'foreign_key_failure',\n    logType: 'error',\n    check: function () {\n      return {\n        success: true\n      };\n    },\n    generateMessage: function () {\n      return ERROR + ': FOREIGNKEY CONFIG \\n  Grid foreign key column needs a valid data source/service.' + (\"Refer to \" + BASE_DOC_URL + \"/columns/#foreign-key-column for documentation on configuring foreign key columns.\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  initial_action: {\n    type: 'initial_action',\n    logType: 'error',\n    check: function (args) {\n      var success = true;\n      var fn;\n\n      switch (args.moduleName) {\n        case 'group':\n          fn = \"The \" + args.columnName + \" column is not available in the grid's column model.\" + 'Please provide a valid field name to group the column';\n          break;\n\n        case 'filter':\n          fn = \"The \" + args.columnName + \" column is not available in the grid's column model.\" + 'Please provide a valid field name to filter the column.';\n          break;\n\n        case 'sort':\n          fn = \"The \" + args.columnName + \" column is not available in the grid's column model.\" + 'Please provide a valid field name to sort the column.';\n          break;\n      }\n\n      return {\n        success: success,\n        options: {\n          fn: fn\n        }\n      };\n    },\n    generateMessage: function (args, parent, options) {\n      return ERROR + (\": INITIAL ACTION FAILURE \\n \" + options.fn);\n    }\n  },\n  // eslint-disable-next-line camelcase\n  frozen_rows_columns: {\n    type: 'frozen_rows_columns',\n    logType: 'error',\n    check: function (args, parent) {\n      return {\n        success: parent.getColumns().length <= parent.frozenColumns || parent.frozenRows >= parent.currentViewData.length\n      };\n    },\n    generateMessage: function (args, parent) {\n      return ERROR + (\": OUT OF RANGE ERROR-\\n \" + (parent.getColumns().length <= parent.frozenColumns ? 'FROZEN COLUMNS,' : '')) + ((parent.frozenRows >= parent.currentViewData.length ? 'FROZEN ROWS' : '') + \" invalid\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  column_type_missing: {\n    type: 'column_type_missing',\n    logType: 'error',\n    check: function (args) {\n      return {\n        success: isNullOrUndefined(args.column.type),\n        options: args.column.headerText\n      };\n    },\n    generateMessage: function (args, parent, options) {\n      return ERROR + (\": COLUMN TYPE MISSING-\\n  \" + options + \" column type was invalid or not defined.\") + (\"Please go through below help link: \" + DOC_URL + \"/grid/columns/#column-type\");\n    }\n  },\n  // eslint-disable-next-line camelcase\n  datasource_syntax_mismatch: {\n    type: 'datasource_syntax_mismatch',\n    logType: 'warn',\n    check: function (args) {\n      return {\n        success: args.dataState.dataSource && !(args.dataState.dataSource instanceof DataManager || 'result' in args.dataState.dataSource || args.dataState.dataSource instanceof Array) && !isNullOrUndefined(args.dataState.dataStateChange)\n      };\n    },\n    generateMessage: function () {\n      return WARNING + ': DATASOURCE SYNTAX WARNING\\n' + 'DataSource should be in the form of {result: Object[], count: number}' + 'when dataStateChangeEvent used';\n    }\n  }\n};\n\nvar formatErrorHandler = function (args) {\n  var error = args.error;\n\n  if (error.indexOf && error.indexOf('Format options') !== 0) {\n    return '';\n  }\n\n  return 'INVALID FORMAT\\n' + 'For more information, refer to the following documentation links:\\n' + (\"Number format: \" + DOC_URL + \"/base/intl.html?#supported-format-string.\\n\") + (\"Date format: \" + DOC_URL + \"/base/intl.html?#manipulating-datetime.\\n\") + (\"Message: \" + error);\n};\n\nvar ajaxErrorHandler = function (args) {\n  var error = DataUtil.getObject('error.error', args);\n\n  if (isNullOrUndefined(error)) {\n    return '';\n  }\n\n  var jsonResult = '';\n\n  try {\n    jsonResult = JSON.parse(error.responseText);\n  } catch (_a) {\n    jsonResult = '';\n  }\n\n  return 'XMLHTTPREQUEST FAILED\\n' + (\"Url: \" + error.responseURL + \"\\n\") + (\"Status: \" + error.status + \" - \" + error.statusText + \"\\n\") + (\"\" + (jsonResult !== '' ? 'Message: ' + jsonResult : ''));\n};\n/**\n * Infinite Scrolling class\n *\n * @hidden\n */\n\n\nvar InfiniteScroll =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for the Grid infinite scrolling.\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the ServiceLocator\n   * @hidden\n   */\n  function InfiniteScroll(parent, serviceLocator) {\n    this.infiniteCache = {};\n    this.infiniteCurrentViewData = {};\n    this.infiniteFrozenCache = {};\n    this.isDownScroll = false;\n    this.isUpScroll = false;\n    this.isScroll = true;\n    this.enableContinuousScroll = false;\n    this.initialRender = true;\n    this.isRemove = false;\n    this.isInitialCollapse = false;\n    this.prevScrollTop = 0;\n    this.actions = ['filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'sorting', 'refresh'];\n    this.keys = [downArrow, upArrow, enter, shiftEnter];\n    this.rowTop = 0;\n    this.isInitialMovableRender = true;\n    this.virtualInfiniteData = {};\n    this.isCancel = false;\n    this.emptyRowData = {};\n    this.isNormaledit = false;\n    this.isInfiniteScroll = false;\n    this.isLastPage = false;\n    this.isInitialRender = true;\n    this.isFocusScroll = false;\n    this.isGroupCollapse = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.isNormaledit = this.parent.editSettings.mode === 'Normal';\n    this.addEventListener();\n    this.widthService = serviceLocator.getService('widthService');\n    this.rowModelGenerator = this.parent.isFrozenGrid() ? new FreezeRowModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  InfiniteScroll.prototype.getModuleName = function () {\n    return 'infiniteScroll';\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  InfiniteScroll.prototype.addEventListener = function () {\n    this.parent.on(dataReady, this.onDataReady, this);\n    this.parent.on(dataSourceModified, this.dataSourceModified, this);\n    this.parent.on(infinitePageQuery, this.infinitePageQuery, this);\n    this.parent.on(infiniteScrollHandler, this.infiniteScrollHandler, this);\n    this.parent.on(beforeCellFocused, this.infiniteCellFocus, this);\n    this.parent.on(appendInfiniteContent, this.appendInfiniteRows, this);\n    this.parent.on(removeInfiniteRows, this.removeInfiniteCacheRows, this);\n    this.parent.on(resetInfiniteBlocks, this.resetInfiniteBlocks, this);\n    this.parent.on(setInfiniteCache, this.setCache, this);\n    this.parent.on(initialCollapse, this.ensureIntialCollapse, this);\n    this.parent.on(keyPressed, this.infiniteCellFocus, this);\n    this.parent.on(infiniteShowHide, this.setDisplayNone, this);\n    this.parent.on(virtualScrollEditActionBegin, this.editActionBegin, this);\n    this.parent.on(getVirtualData, this.getVirtualInfiniteData, this);\n    this.parent.on(editReset, this.resetInfiniteEdit, this);\n    this.parent.on(virtualScrollEditSuccess, this.infiniteEditSuccess, this);\n    this.parent.on(refreshVirtualCache, this.refreshInfiniteCache, this);\n    this.parent.on(refreshInfiniteEditrowindex, this.refreshInfiniteEditrowindex, this);\n    this.parent.on(infiniteEditHandler, this.infiniteEditHandler, this);\n    this.parent.on(virtualScrollAddActionBegin, this.infiniteAddActionBegin, this);\n    this.parent.on(modelChanged, this.modelChanged, this);\n    this.parent.on(refreshInfiniteCurrentViewData, this.refreshInfiniteCurrentViewData, this);\n    this.parent.on(destroy, this.destroy, this);\n    this.parent.on(contentReady, this.selectNewRow, this);\n    this.parent.on(captionActionComplete, this.captionActionComplete, this);\n    this.parent.on(setVirtualPageQuery, this.setGroupCollapsePageQuery, this);\n    this.actionBeginFunction = this.actionBegin.bind(this);\n    this.actionCompleteFunction = this.actionComplete.bind(this);\n    this.dataBoundFunction = this.dataBound.bind(this);\n    this.parent.on(deleteComplete, this.deleteComplate, this);\n    this.parent.addEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.addEventListener(actionComplete, this.actionCompleteFunction);\n    this.parent.addEventListener(dataBound, this.dataBoundFunction);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  InfiniteScroll.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(dataReady, this.onDataReady);\n    this.parent.off(dataSourceModified, this.dataSourceModified);\n    this.parent.off(infinitePageQuery, this.infinitePageQuery);\n    this.parent.off(infiniteScrollHandler, this.infiniteScrollHandler);\n    this.parent.off(beforeCellFocused, this.infiniteCellFocus);\n    this.parent.off(appendInfiniteContent, this.appendInfiniteRows);\n    this.parent.off(removeInfiniteRows, this.removeInfiniteCacheRows);\n    this.parent.off(resetInfiniteBlocks, this.resetInfiniteBlocks);\n    this.parent.off(setInfiniteCache, this.setCache);\n    this.parent.off(initialCollapse, this.ensureIntialCollapse);\n    this.parent.off(keyPressed, this.infiniteCellFocus);\n    this.parent.off(infiniteShowHide, this.setDisplayNone);\n    this.parent.off(virtualScrollEditActionBegin, this.editActionBegin);\n    this.parent.off(getVirtualData, this.getVirtualInfiniteData);\n    this.parent.off(editReset, this.resetInfiniteEdit);\n    this.parent.off(virtualScrollEditSuccess, this.infiniteEditSuccess);\n    this.parent.off(refreshVirtualCache, this.refreshInfiniteCache);\n    this.parent.on(refreshInfiniteEditrowindex, this.refreshInfiniteEditrowindex);\n    this.parent.off(infiniteEditHandler, this.infiniteEditHandler);\n    this.parent.off(virtualScrollAddActionBegin, this.infiniteAddActionBegin);\n    this.parent.off(modelChanged, this.modelChanged);\n    this.parent.off(refreshInfiniteCurrentViewData, this.refreshInfiniteCurrentViewData);\n    this.parent.off(destroy, this.destroy);\n    this.parent.off(contentReady, this.selectNewRow);\n    this.parent.off(captionActionComplete, this.captionActionComplete);\n    this.parent.off(setVirtualPageQuery, this.setGroupCollapsePageQuery);\n    this.parent.removeEventListener(actionBegin, this.actionBeginFunction);\n    this.parent.removeEventListener(actionComplete, this.actionCompleteFunction);\n    this.parent.removeEventListener(dataBound, this.dataBoundFunction);\n  };\n\n  InfiniteScroll.prototype.dataBound = function () {\n    if (this.groupCaptionAction === 'collapse') {\n      this.groupCaptionAction = 'refresh';\n      this.makeGroupCollapseRequest();\n    } else if (this.groupCaptionAction === 'refresh') {\n      this.parent.hideSpinner();\n      this.groupCaptionAction = this.empty;\n    }\n  };\n\n  InfiniteScroll.prototype.setGroupCollapsePageQuery = function (args) {\n    var gObj = this.parent;\n\n    if (!gObj.infiniteScrollSettings.enableCache && this.isGroupCollapse) {\n      args.skipPage = true;\n      this.isGroupCollapse = false;\n\n      if (this.groupCaptionAction === 'collapse') {\n        var captionRow = gObj.getRowObjectFromUID(this.parentCapUid);\n        var rowObjs = gObj.getRowsObject();\n        var childCount = 0;\n\n        for (var i = rowObjs.length - 1; i >= 0; i--) {\n          if (rowObjs[i].indent === captionRow.indent) {\n            break;\n          }\n\n          if (rowObjs[i].isDataRow) {\n            childCount++;\n          }\n        }\n\n        var key = getGroupKeysAndFields(rowObjs.indexOf(captionRow), rowObjs);\n        var pred = generateExpandPredicates(key.fields, key.keys, this);\n        var predicateList = getPredicates(pred);\n        pred = predicateList[predicateList.length - 1];\n\n        for (var i = predicateList.length - 2; i >= 0; i--) {\n          pred = pred.and(predicateList[i]);\n        }\n\n        args.query.where(pred);\n        args.query.skip(childCount);\n        this.parentCapUid = this.empty;\n      } else {\n        var rows = gObj.getRows();\n        var size = gObj.pageSettings.pageSize;\n        var skip = getRowIndexFromElement(rows[rows.length - 1]) + 1;\n        var additionalCnt = skip - skip % size + size - skip;\n\n        if (skip % size === 0) {\n          additionalCnt = 0;\n        }\n\n        args.query.skip(skip);\n        args.query.take(gObj.infiniteScrollSettings.initialBlocks * gObj.pageSettings.pageSize + additionalCnt);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.captionActionComplete = function (args) {\n    var gObj = this.parent;\n\n    if (!gObj.infiniteScrollSettings.enableCache && args.isCollapse) {\n      var contetRect = gObj.getContent().firstElementChild.getBoundingClientRect();\n      var tableReact = gObj.contentModule.getTable().getBoundingClientRect();\n\n      if (Math.round(tableReact.bottom - gObj.getRowHeight()) <= Math.round(contetRect.bottom)) {\n        this.parentCapUid = args.parentUid;\n        this.groupCaptionAction = 'collapse';\n        gObj.showSpinner();\n        var caption = gObj.getRowObjectFromUID(args.parentUid);\n        var childCount = this.getCaptionChildCount(caption);\n\n        if (!childCount) {\n          this.groupCaptionAction = 'refresh';\n          this.makeGroupCollapseRequest();\n        } else {\n          this.makeGroupCollapseRequest(args.parentUid);\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.makeGroupCollapseRequest = function (parentUid) {\n    var gObj = this.parent;\n    var captionRows = [].slice.call(gObj.getContentTable().querySelectorAll('tr'));\n    var rows = gObj.groupSettings.enableLazyLoading ? captionRows : gObj.getRows();\n    var index = !gObj.groupSettings.enableLazyLoading ? getRowIndexFromElement(rows[rows.length - 1]) : gObj.contentModule['visibleRows'].length - 1;\n    var prevPage = this.parent.pageSettings.currentPage;\n\n    if (prevPage >= this.maxPage) {\n      gObj.hideSpinner();\n      return;\n    }\n\n    this.parent.pageSettings.currentPage = Math.ceil(index / this.parent.pageSettings.pageSize) + 1;\n    var scrollArg = {\n      requestType: 'infiniteScroll',\n      currentPage: this.parent.pageSettings.currentPage,\n      prevPage: prevPage,\n      startIndex: index + 1,\n      direction: 'down',\n      isCaptionCollapse: true,\n      parentUid: parentUid\n    };\n    this.isGroupCollapse = true;\n    this.parent.notify('model-changed', scrollArg);\n  };\n\n  InfiniteScroll.prototype.getCaptionChildCount = function (caption) {\n    var rowObj = this.parent.getRowsObject();\n    var index = rowObj.indexOf(caption);\n    var make = false;\n\n    for (var i = index; i < rowObj.length; i++) {\n      if ((rowObj[i].indent === caption.indent || rowObj[i].indent < caption.indent) && rowObj[i].data.key !== caption.data.key) {\n        break;\n      }\n\n      if (rowObj[i].isCaptionRow && !this.childCheck(rowObj, rowObj[i], i)) {\n        make = true;\n        break;\n      }\n    }\n\n    return make;\n  };\n\n  InfiniteScroll.prototype.childCheck = function (rowObj, row$$1, index) {\n    var childCount = 0;\n\n    for (var i = index + 1; i < rowObj.length; i++) {\n      if (rowObj[i].indent === row$$1.indent) {\n        break;\n      }\n\n      if (rowObj[i].indent === row$$1.indent + 1 && rowObj[i].parentUid === row$$1.uid) {\n        childCount++;\n      }\n    }\n\n    return row$$1.data.count === childCount;\n  };\n\n  InfiniteScroll.prototype.updateCurrentViewData = function () {\n    var gObj = this.parent;\n\n    if (gObj.groupSettings.columns.length) {\n      return;\n    }\n\n    var keys = Object.keys(this.infiniteCurrentViewData);\n    gObj.currentViewData = [];\n    var page = gObj.pageSettings.currentPage;\n    var isCache = gObj.infiniteScrollSettings.enableCache;\n    var blocks = gObj.infiniteScrollSettings.maxBlocks;\n    var isMiddlePage = isCache && (page > blocks || this.isUpScroll && page > 1);\n    var start = isMiddlePage ? this.isUpScroll ? page : page - blocks + 1 : 1;\n    var end = isMiddlePage ? start + blocks - 1 : isCache ? blocks : keys.length;\n\n    for (var i = start; i <= end; i++) {\n      if (this.infiniteCurrentViewData[i]) {\n        gObj.currentViewData = gObj.currentViewData.concat(this.infiniteCurrentViewData[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.refreshInfiniteCurrentViewData = function (e) {\n    var page = this.parent.pageSettings.currentPage;\n    var size = this.parent.pageSettings.pageSize;\n    var blocks = this.parent.infiniteScrollSettings.initialBlocks;\n    var keys = Object.keys(this.infiniteCurrentViewData);\n    var cache = this.parent.infiniteScrollSettings.enableCache;\n\n    if (!this.parent.groupSettings.columns.length) {\n      var isAdd = e.args.requestType === 'save' && !(this.parent.sortSettings.columns.length || this.parent.filterSettings.columns.length || this.parent.groupSettings.columns.length || this.parent.searchSettings.key);\n      var isDelete = e.args.requestType === 'delete';\n\n      if (!cache && (isAdd || isDelete)) {\n        if (isAdd) {\n          var indexCount = 0;\n\n          for (var i = 1; i <= keys.length; i++) {\n            indexCount += this.infiniteCurrentViewData[i].length - 1;\n\n            if (e.args.index <= indexCount) {\n              this.resetCurrentViewData(i);\n              this.infiniteCurrentViewData[i].splice(e.args.index, 0, e.args.data);\n              break;\n            }\n          }\n        } else {\n          this.infiniteCurrentViewData[keys[keys.length - 1]].push(e.data[0]);\n        }\n      } else {\n        if (blocks > 1 && e.data.length === blocks * size) {\n          this.setInitialCache(e.data.slice(), {}, cache && e.args.requestType === 'delete', true);\n        } else {\n          this.infiniteCurrentViewData[page] = e.data.slice();\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.resetCurrentViewData = function (startIndex) {\n    var keys = Object.keys(this.infiniteCurrentViewData);\n\n    for (var i = startIndex; i <= keys.length; i++) {\n      var lastViewData = this.infiniteCurrentViewData[i][this.infiniteCurrentViewData[i].length - 1];\n\n      if (this.infiniteCurrentViewData[i + 1]) {\n        this.infiniteCurrentViewData[i + 1].splice(0, 0, lastViewData);\n      }\n\n      this.infiniteCurrentViewData[i].pop();\n    }\n  };\n\n  InfiniteScroll.prototype.deleteComplate = function () {\n    if (this.parent.isFrozenGrid() && !this.parent.infiniteScrollSettings.enableCache) {\n      this.parent.contentModule.refreshScrollOffset();\n    }\n  };\n\n  InfiniteScroll.prototype.modelChanged = function (args) {\n    var rows = this.parent.getRows();\n\n    if (args.requestType === 'save' && args.index && args.data) {\n      this.addRowIndex = args.index;\n    }\n\n    if (rows && rows.length && args.requestType !== 'infiniteScroll' && (args.requestType === 'delete' || this.requestType === 'add')) {\n      this.firstIndex = getRowIndexFromElement(rows[0]);\n      this.firstBlock = Math.ceil((this.firstIndex + 1) / this.parent.pageSettings.pageSize);\n      this.lastIndex = getRowIndexFromElement(rows[rows.length - 1]);\n\n      if (args.requestType === 'delete') {\n        var rowObj = this.parent.getRowsObject();\n        args.startIndex = this.parent.infiniteScrollSettings.enableCache ? (this.firstBlock - 1) * this.parent.pageSettings.pageSize : rowObj[rowObj.length - 1].index;\n      } else {\n        args.startIndex = this.firstIndex;\n      }\n\n      if (!this.parent.infiniteScrollSettings.enableCache && this.parent.pageSettings.currentPage === this.maxPage && args.requestType === 'delete') {\n        this.isLastPage = true;\n        this.lastIndex = this.lastIndex - 1;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.infiniteAddActionBegin = function (args) {\n    if (this.isNormaledit) {\n      this.isAdd = true;\n\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        if (!Object.keys(this.emptyRowData).length) {\n          this.createEmptyRowdata();\n        }\n\n        if (this.parent.pageSettings.currentPage > 1) {\n          args.startEdit = false;\n          this.resetInfiniteBlocks({}, true);\n          this.makeRequest({\n            currentPage: 1\n          });\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.infiniteEditHandler = function (args) {\n    if (!this.parent.infiniteScrollSettings.enableCache && (args.e.requestType === 'delete' || args.e.requestType === 'save' && this.requestType === 'add')) {\n      var frozenCols = this.parent.isFrozenGrid();\n      var rowElms = this.parent.getRows();\n      var rows = this.parent.getRowsObject();\n\n      if (this.ensureRowAvailability(rows, args.result[0])) {\n        if (rowElms.length && !(this.addRowIndex && this.addRowIndex >= rowElms.length)) {\n          this.resetRowIndex(rows, args.e, rowElms, this.requestType === 'add', true);\n\n          if (frozenCols) {\n            var rows_1 = this.parent.getMovableRowsObject();\n            this.resetRowIndex(rows_1, args.e, this.parent.getMovableDataRows(), this.requestType === 'add');\n\n            if (this.parent.getFrozenMode() === leftRight) {\n              var frRows = this.parent.getFrozenRightRowsObject();\n              this.resetRowIndex(frRows, args.e, this.parent.getFrozenRightRows(), this.requestType === 'add');\n            }\n          }\n        }\n\n        if (!this.isLastPage) {\n          this.createRow(rows, args);\n        } else {\n          this.isLastPage = false;\n          this.parent.pageSettings.currentPage = this.maxPage;\n\n          if (this.parent.selectionModule.index < this.parent.frozenRows) {\n            remove(rowElms[this.parent.frozenRows - 1]);\n            this.createRow([rows[this.parent.frozenRows - 1]], args, false, true);\n\n            if (frozenCols) {\n              var movableRows = this.parent.getMovableDataRows();\n              remove(movableRows[this.parent.frozenRows]);\n              this.createRow([this.parent.getMovableRowsObject()[this.parent.frozenRows - 1]], args, true, true);\n\n              if (this.parent.getFrozenMode() === leftRight) {\n                var rightRows = this.parent.getFrozenRightDataRows();\n                remove(rightRows[this.parent.frozenRows]);\n                this.createRow([this.parent.getFrozenRightRowsObject()[this.parent.frozenRows - 1]], args, false, true, true);\n              }\n            }\n\n            setRowElements(this.parent);\n          }\n        }\n      }\n\n      this.parent.hideSpinner();\n      this.parent.notify(refreshInfinitePersistSelection, {});\n\n      if (this.requestType === 'delete') {\n        this.parent.notify(deleteComplete, args.e);\n      } else {\n        this.parent.notify(saveComplete, args.e);\n      }\n    }\n\n    this.parent.notify(freezeRender, {\n      case: 'refreshHeight'\n    });\n  };\n\n  InfiniteScroll.prototype.createRow = function (rows, args, isMovable, isFrozenRows, isFrozenRight) {\n    var row$$1 = !isFrozenRows ? this.generateRows(args.result, args.e) : rows;\n    var rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n    this.parent.removeMaskRow();\n\n    if (args.e.requestType === 'save' && args.e.index && args.e.data) {\n      row$$1[0].index = this.addRowIndex;\n      this.addRowIndex = null;\n\n      if (row$$1[0].index >= rows.length) {\n        return;\n      }\n    }\n\n    var tbody$$1;\n\n    if (isFrozenRight) {\n      tbody$$1 = this.parent.element.querySelector('.e-frozen-right-content').querySelector(tbody);\n    } else {\n      tbody$$1 = !this.parent.isFrozenGrid() ? this.parent.getContent().querySelector(tbody) : isMovable ? this.parent.getMovableVirtualContent().querySelector(tbody) : this.parent.getFrozenVirtualContent().querySelector(tbody);\n    }\n\n    if (this.parent.frozenRows) {\n      tbody$$1 = isFrozenRows && this.requestType !== 'add' || !isFrozenRows && this.requestType === 'add' ? !this.parent.isFrozenGrid() ? this.parent.getHeaderContent().querySelector(tbody) : isMovable ? this.parent.getMovableVirtualHeader().querySelector(tbody) : isFrozenRight ? this.parent.element.querySelector('.e-frozen-right-header').querySelector(tbody) : this.parent.getFrozenVirtualHeader().querySelector(tbody) : tbody$$1;\n    }\n\n    var notifyArgs = {\n      rows: rows,\n      cancel: false,\n      args: args,\n      isMovable: isMovable,\n      isFrozenRows: isFrozenRows,\n      isFrozenRight: isFrozenRows,\n      row: row$$1\n    };\n    this.parent.notify(infiniteCrudCancel, notifyArgs);\n\n    if (!notifyArgs.cancel) {\n      for (var i = row$$1.length - 1; i >= 0; i--) {\n        if (this.requestType === 'delete') {\n          tbody$$1.appendChild(rowRenderer.render(row$$1[i], this.parent.getColumns()));\n        } else {\n          tbody$$1.insertBefore(rowRenderer.render(row$$1[i], this.parent.getColumns()), tbody$$1.rows[args.e.index]);\n        }\n      }\n    }\n\n    if (!isFrozenRows && this.parent.frozenRows && (this.parent.selectionModule.index < this.parent.frozenRows || this.requestType === 'add')) {\n      var rowElems = isMovable ? this.parent.getMovableDataRows() : isFrozenRight ? this.parent.getFrozenRightDataRows() : this.parent.getRows();\n      var index = (isMovable || isFrozenRight) && this.requestType === 'add' ? this.parent.frozenRows : this.parent.frozenRows - 1;\n      remove(rowElems[index]);\n      this.createRow([rows[this.parent.frozenRows - 1]], args, isMovable, true, isFrozenRight);\n    }\n\n    if (!this.parent.infiniteScrollSettings.enableCache && !isFrozenRows) {\n      if (isFrozenRight) {\n        setRowElements(this.parent);\n        this.parent.contentModule.rightFreezeRows = this.requestType === 'add' ? row$$1.concat(rows) : rows.concat(row$$1);\n      } else if (!this.parent.isFrozenGrid() || isMovable) {\n        setRowElements(this.parent);\n        this.parent.contentModule.visibleRows = this.requestType === 'add' ? row$$1.concat(rows) : rows.concat(row$$1);\n\n        if (this.parent.getFrozenMode() === leftRight) {\n          args.e.renderMovableContent = true;\n          this.createRow(this.parent.getFrozenRightRowsObject(), args, false, false, true);\n        }\n      } else {\n        this.parent.contentModule.visibleFrozenRows = this.requestType === 'add' ? row$$1.concat(rows) : rows.concat(row$$1);\n        args.e.isFrozen = true;\n        this.createRow(this.parent.getMovableRowsObject(), args, true);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.ensureRowAvailability = function (rows, data) {\n    var resume = true;\n\n    if (this.parent.frozenRows && !this.parent.infiniteScrollSettings.enableCache && this.parent.sortSettings.columns && this.requestType === 'add') {\n      var key = this.parent.getPrimaryKeyFieldNames()[0];\n\n      for (var i = 0; i < rows.length; i++) {\n        if (rows[i].data[key] === data[key]) {\n          resume = false;\n          break;\n        }\n      }\n    }\n\n    return resume;\n  };\n\n  InfiniteScroll.prototype.generateRows = function (data, args) {\n    return this.rowModelGenerator.generateRows(data, args);\n  };\n\n  InfiniteScroll.prototype.resetRowIndex = function (rows, args, rowElms, isAdd, isFrozen) {\n    var _this = this;\n\n    var keyField = this.parent.getPrimaryKeyFieldNames()[0];\n    var isRemove = !(rowElms.length % this.parent.pageSettings.pageSize);\n\n    if (isAdd) {\n      if (isRemove) {\n        if (isFrozen && !this.parent.groupSettings.columns.length) {\n          this.swapCurrentViewData(1, true);\n        }\n\n        remove(rowElms[rows.length - 1]);\n        rowElms.splice(rows.length - 1, 1);\n        rows.splice(rows.length - 1, 1);\n      }\n    } else {\n      rows.filter(function (e, index) {\n        if (e.data[keyField] === args.data[0][keyField]) {\n          if (isFrozen && !_this.parent.groupSettings.columns.length) {\n            var page = Math.ceil((index + 1) / _this.parent.pageSettings.pageSize);\n\n            _this.resetInfiniteCurrentViewData(page, index);\n          }\n\n          rows.splice(index, 1);\n          remove(rowElms[index]);\n          rowElms.splice(index, 1);\n        }\n      });\n    }\n\n    var startIndex = isAdd ? this.addRowIndex ? this.addRowIndex + 1 : 1 : 0;\n    resetRowIndex(this.parent, rows, rowElms, startIndex, this.addRowIndex ? this.addRowIndex : 0);\n  };\n\n  InfiniteScroll.prototype.resetInfiniteCurrentViewData = function (page, index) {\n    index = index - (page - 1) * this.parent.pageSettings.pageSize;\n    this.infiniteCurrentViewData[page].splice(index, 1);\n    this.swapCurrentViewData(page, false);\n  };\n\n  InfiniteScroll.prototype.swapCurrentViewData = function (page, isAdd) {\n    var keys = Object.keys(this.infiniteCurrentViewData);\n    var end = isAdd ? keys.length + 1 : keys.length;\n\n    for (var i = page; i < end; i++) {\n      if (this.infiniteCurrentViewData[i + 1]) {\n        var pageIndex = isAdd ? i : i + 1;\n        var index = isAdd ? this.infiniteCurrentViewData[i].length - 1 : 0;\n        var data = this.infiniteCurrentViewData[pageIndex].splice(index, 1);\n\n        if (isAdd) {\n          this.infiniteCurrentViewData[i + 1] = data.concat(this.infiniteCurrentViewData[i + 1]);\n\n          if (i + 1 === end - 1) {\n            this.infiniteCurrentViewData[i + 1].splice(this.infiniteCurrentViewData[i + 1].length - 1, 1);\n          }\n        } else {\n          this.infiniteCurrentViewData[i].push(data[0]);\n        }\n      }\n    }\n\n    this.updateCurrentViewData();\n  };\n\n  InfiniteScroll.prototype.setDisplayNone = function (args) {\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      var frozenCols = this.parent.isFrozenGrid();\n      var keys = frozenCols ? Object.keys(this.infiniteFrozenCache) : Object.keys(this.infiniteCache);\n\n      for (var i = 1; i <= keys.length; i++) {\n        var cache = frozenCols ? args.isFreeze ? this.infiniteFrozenCache[i][0] : this.infiniteFrozenCache[i][1] : this.infiniteCache[i];\n        cache.filter(function (e) {\n          e.cells[args.index].visible = args.visible === '';\n        });\n      }\n\n      this.resetContentModuleCache(frozenCols ? this.infiniteFrozenCache : this.infiniteCache);\n    }\n  };\n\n  InfiniteScroll.prototype.refreshInfiniteCache = function (args) {\n    this.getEditedRowObject().data = args.data;\n  };\n\n  InfiniteScroll.prototype.refreshInfiniteCacheRowVisibleLength = function (args, currentPage) {\n    var cPageRowArray = args[currentPage];\n\n    if (this.parent.enableInfiniteScrolling && this.parent.infiniteScrollSettings.enableCache) {\n      var length_1 = 0;\n      var vRowLen = 0;\n      var hRowLen = 0;\n\n      for (var i = 0; i < cPageRowArray.length; i++) {\n        if (cPageRowArray[i].visible || isNullOrUndefined(cPageRowArray[i].visible)) {\n          vRowLen++;\n        } else {\n          hRowLen++;\n        }\n      }\n\n      if (hRowLen > vRowLen) {\n        length_1 = hRowLen - vRowLen;\n\n        if (length_1 > vRowLen) {\n          length_1 = vRowLen;\n        }\n      } else {\n        length_1 = vRowLen - hRowLen;\n\n        if (length_1 > hRowLen) {\n          length_1 = hRowLen;\n        }\n      }\n\n      if (length_1 === 0) {\n        length_1 = 1;\n      }\n\n      return length_1;\n    } else {\n      return cPageRowArray.length;\n    }\n  };\n\n  InfiniteScroll.prototype.refreshInfiniteEditrowindex = function (args) {\n    this.editRowIndex = args.index;\n  };\n\n  InfiniteScroll.prototype.getEditedRowObject = function () {\n    var rowObjects = this.parent.getRowsObject();\n    var editedrow;\n\n    for (var i = 0; i < rowObjects.length; i++) {\n      if (rowObjects[i].index === this.editRowIndex) {\n        editedrow = rowObjects[i];\n      }\n    }\n\n    return editedrow;\n  };\n\n  InfiniteScroll.prototype.infiniteEditSuccess = function (args) {\n    if (this.isNormaledit) {\n      if (!this.isAdd && args.data) {\n        this.updateCurrentViewRecords(args.data);\n      }\n\n      this.isAdd = false;\n    }\n  };\n\n  InfiniteScroll.prototype.updateCurrentViewRecords = function (data) {\n    var index = getEditedDataIndex(this.parent, data);\n\n    if (!isNullOrUndefined(index)) {\n      this.parent.getCurrentViewRecords()[index] = data;\n    }\n  };\n\n  InfiniteScroll.prototype.actionBegin = function (args) {\n    if (args.requestType === 'add' || args.requestType === 'delete') {\n      this.requestType = args.requestType;\n    } else if (args.action === 'add' && args.requestType === 'save') {\n      this.requestType = args.action;\n    }\n\n    if (this.parent.isFrozenGrid() && !args.cancel && args.requestType === 'searching' || args.requestType === 'sorting' || args.requestType === 'filtering') {\n      this.isInitialRender = true;\n    }\n  };\n\n  InfiniteScroll.prototype.actionComplete = function (args) {\n    if (args.requestType === 'delete' || args.requestType === 'save' || args.requestType === 'cancel') {\n      this.requestType = this.empty;\n      this.isCancel = args.requestType === 'cancel' || args.requestType === 'save';\n      this.isAdd = this.isEdit = false;\n\n      if (this.isNormaledit) {\n        this.editRowIndex = this.empty;\n        this.virtualInfiniteData = {};\n        this.parent.editModule.previousVirtualData = {};\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.resetInfiniteEdit = function () {\n    if (this.parent.enableInfiniteScrolling && this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && this.isEdit || this.parent.editSettings.allowAdding && this.isAdd) {\n        this.parent.isEdit = true;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.getVirtualInfiniteData = function (data) {\n    this.getVirtualInfiniteEditedData();\n    data.virtualData = this.virtualInfiniteData;\n    data.isAdd = this.isAdd;\n    data.isCancel = this.isCancel;\n  };\n\n  InfiniteScroll.prototype.editActionBegin = function (e) {\n    this.isEdit = true;\n    this.editRowIndex = e.index;\n    var rowObject = extend({}, this.getEditedRowObject().data);\n    e.data = Object.keys(this.virtualInfiniteData).length ? this.virtualInfiniteData : rowObject;\n  };\n\n  InfiniteScroll.prototype.dataSourceModified = function () {\n    this.resetInfiniteBlocks({\n      requestType: this.empty\n    }, true);\n  };\n\n  InfiniteScroll.prototype.onDataReady = function (e) {\n    if (!isNullOrUndefined(e.count) && e.requestType !== 'infiniteScroll') {\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n  };\n\n  InfiniteScroll.prototype.ensureIntialCollapse = function (isExpand) {\n    this.isInitialCollapse = !isExpand;\n  };\n\n  InfiniteScroll.prototype.infiniteScrollHandler = function (e) {\n    this.restoreInfiniteEdit();\n    this.restoreInfiniteAdd();\n    var targetEle = e.target;\n    var isInfinite = targetEle.classList.contains(content);\n\n    if (isInfinite && this.parent.enableInfiniteScrolling && !e.isLeft) {\n      var scrollEle = this.parent.getContent().firstElementChild;\n      var captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n      this.prevScrollTop = scrollEle.scrollTop;\n      var rows = this.parent.groupSettings.enableLazyLoading ? captionRows : this.parent.getRows();\n\n      if (!rows.length) {\n        return;\n      }\n\n      var index = getRowIndexFromElement(rows[rows.length - 1]) + 1;\n      var prevPage = this.parent.pageSettings.currentPage;\n      var args = void 0;\n      var offset = targetEle.scrollHeight - targetEle.scrollTop;\n      var round = Math.round(targetEle.scrollHeight - targetEle.scrollTop);\n      var floor = offset < targetEle.clientHeight ? Math.ceil(offset) : Math.floor(offset);\n\n      if (floor > targetEle.clientHeight) {\n        floor = floor - 1;\n      }\n\n      var isBottom = floor === targetEle.clientHeight || round === targetEle.clientHeight;\n\n      if (!isNullOrUndefined(this.groupCaptionAction)) {\n        return;\n      }\n\n      if (this.isScroll && isBottom && (this.parent.pageSettings.currentPage <= this.maxPage - 1 || this.enableContinuousScroll)) {\n        if (this.parent.infiniteScrollSettings.enableCache) {\n          this.isUpScroll = false;\n          this.isDownScroll = true;\n        }\n\n        var rows_2 = [].slice.call(scrollEle.querySelectorAll('.e-row:not(.e-addedrow)'));\n        var row$$1 = rows_2[rows_2.length - 1];\n        var rowIndex = !this.parent.groupSettings.enableLazyLoading ? getRowIndexFromElement(row$$1) : this.parent.contentModule['visibleRows'].length - 1;\n        this.parent.pageSettings.currentPage = Math.ceil(rowIndex / this.parent.pageSettings.pageSize) + 1;\n        args = {\n          requestType: 'infiniteScroll',\n          currentPage: this.parent.pageSettings.currentPage,\n          prevPage: prevPage,\n          startIndex: index,\n          direction: 'down'\n        };\n        this.makeRequest(args);\n      }\n\n      if (this.isScroll && this.parent.infiniteScrollSettings.enableCache && targetEle.scrollTop === 0 && this.parent.pageSettings.currentPage !== 1) {\n        if (this.parent.infiniteScrollSettings.enableCache) {\n          this.isDownScroll = false;\n          this.isUpScroll = true;\n        }\n\n        var row$$1 = [].slice.call(scrollEle.getElementsByClassName(row));\n        var rowIndex = getRowIndexFromElement(row$$1[this.parent.pageSettings.pageSize - 1]);\n        var startIndex = getRowIndexFromElement(row$$1[0]) - this.parent.pageSettings.pageSize;\n        this.parent.pageSettings.currentPage = Math.ceil(rowIndex / this.parent.pageSettings.pageSize) - 1;\n\n        if (this.parent.pageSettings.currentPage) {\n          args = {\n            requestType: 'infiniteScroll',\n            currentPage: this.parent.pageSettings.currentPage,\n            prevPage: prevPage,\n            startIndex: startIndex,\n            direction: 'up'\n          };\n          this.makeRequest(args);\n        }\n      }\n\n      if (this.parent.infiniteScrollSettings.enableCache && !this.isScroll && isNullOrUndefined(args)) {\n        if (this.isDownScroll || this.isUpScroll) {\n          scrollEle.scrollTop = this.top;\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.makeRequest = function (args) {\n    var _this = this;\n\n    if (this.parent.pageSettings.currentPage !== args.prevPage) {\n      var initBlocks = this.parent.infiniteScrollSettings.initialBlocks;\n\n      if (initBlocks < this.maxPage && this.parent.pageSettings.currentPage <= this.maxPage) {\n        this.isInfiniteScroll = true;\n\n        if (isNullOrUndefined(this.infiniteCache[args.currentPage])) {\n          setTimeout(function () {\n            _this.getVirtualInfiniteEditedData();\n\n            _this.parent.notify('model-changed', args);\n          }, 100);\n        } else {\n          setTimeout(function () {\n            _this.getVirtualInfiniteEditedData();\n\n            _this.parent.notify(refreshInfiniteModeBlocks, args);\n          }, 100);\n        }\n      } else {\n        this.parent.pageSettings.currentPage = this.maxPage;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.infinitePageQuery = function (query) {\n    if (this.initialRender) {\n      this.initialRender = false;\n      this.intialPageQuery(query);\n    } else {\n      if (this.requestType === 'delete' || this.requestType === 'add') {\n        if (!this.isInfiniteScroll && !this.parent.groupSettings.enableLazyLoading) {\n          this.editPageQuery(query);\n        } else if (this.parent.groupSettings.enableLazyLoading && !this.parent.infiniteScrollSettings.enableCache) {\n          if (this.parent.infiniteScrollSettings.initialBlocks < this.parent.pageSettings.currentPage) {\n            query.page(1, this.parent.pageSettings.pageSize * this.parent.pageSettings.currentPage);\n          } else {\n            query.page(1, this.parent.pageSettings.pageSize * this.parent.infiniteScrollSettings.initialBlocks);\n          }\n        } else {\n          query.page(this.parent.pageSettings.currentPage, this.parent.pageSettings.pageSize);\n        }\n      } else {\n        query.page(this.parent.pageSettings.currentPage, this.parent.pageSettings.pageSize);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.editPageQuery = function (query) {\n    var initialBlocks = this.parent.infiniteScrollSettings.initialBlocks;\n    var isCache = this.parent.infiniteScrollSettings.enableCache;\n\n    if (isCache) {\n      this.infiniteCache = {};\n      this.infiniteFrozenCache = {};\n      this.infiniteCurrentViewData = {};\n      query.skip(this.firstIndex);\n      query.take(initialBlocks * this.parent.pageSettings.pageSize);\n    } else {\n      if (this.parent.editSettings.mode === 'Dialog') {\n        this.parent.clearSelection();\n      }\n\n      var index = this.requestType === 'delete' ? this.lastIndex : this.addRowIndex ? this.addRowIndex : this.firstIndex;\n      query.skip(index);\n\n      if (!isNullOrUndefined(this.parent.getDataModule().dataManager.dataSource.url) && (this.requestType === 'delete' || this.requestType === 'add')) {\n        query.take(initialBlocks * this.parent.pageSettings.pageSize);\n      } else {\n        query.take(1);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.intialPageQuery = function (query) {\n    if (this.parent.infiniteScrollSettings.enableCache && this.parent.infiniteScrollSettings.initialBlocks > this.parent.infiniteScrollSettings.maxBlocks) {\n      this.parent.infiniteScrollSettings.initialBlocks = this.parent.infiniteScrollSettings.maxBlocks;\n    }\n\n    var pageSize = this.parent.pageSettings.pageSize * this.parent.infiniteScrollSettings.initialBlocks;\n    query.page(1, pageSize);\n  };\n\n  InfiniteScroll.prototype.scrollToLastFocusedCell = function (e) {\n    var gObj = this.parent;\n    var rowIdx = this.lastFocusInfo.rowIdx + (e.keyArgs.action === upArrow ? -1 : 1);\n    var cellIdx = this.lastFocusInfo.cellIdx;\n    var row$$1 = gObj.getRowByIndex(rowIdx);\n\n    if (!row$$1) {\n      var rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n      var page = Math.floor(rowIdx / this.parent.pageSettings.pageSize) + 1;\n      gObj.pageSettings.currentPage = page;\n      var cols = gObj.getColumns();\n      remove(gObj.getContent().querySelector('tbody'));\n      gObj.getContent().querySelector('table').appendChild(gObj.createElement('tbody', {\n        attrs: {\n          'role': 'rowgroup'\n        }\n      }));\n      var focusRows = []; // eslint-disable-next-line @typescript-eslint/tslint/config\n\n      for (var i = page === 1 || this.maxPage === page ? 0 : -1, k = 0; k < gObj.infiniteScrollSettings.maxBlocks; this.maxPage === page ? i-- : i++, k++) {\n        var rows = this.infiniteCache[page + i];\n\n        if (rows) {\n          focusRows = focusRows.concat(rows);\n\n          for (var j = 0; j < rows.length; j++) {\n            gObj.getContent().querySelector('tbody').appendChild(rowRenderer.render(rows[j], cols));\n          }\n        }\n      }\n\n      gObj.notify(contentReady, {\n        rows: focusRows,\n        args: {}\n      });\n      setRowElements(gObj);\n    }\n\n    row$$1 = gObj.getRowByIndex(rowIdx);\n    var target = row$$1.cells[cellIdx];\n    gObj.focusModule.isInfiniteScroll = true;\n    gObj.focusModule.onClick({\n      target: target\n    }, true);\n    gObj.selectRow(rowIdx);\n    target.focus();\n    this.isFocusScroll = false;\n    e.cancel = true;\n  };\n\n  InfiniteScroll.prototype.setLastCellFocusInfo = function (e) {\n    var cell = e.byClick && e.clickArgs.target || e.byKey && e.keyArgs.target || (!this.isFocusScroll && e).target;\n\n    if (cell && cell.classList.contains('e-rowcell')) {\n      var cellIdx = parseInt(cell.getAttribute('data-colindex'), 10);\n      var rowIdx = parseInt(cell.parentElement.getAttribute('data-rowindex'), 10);\n      this.lastFocusInfo = {\n        rowIdx: rowIdx,\n        cellIdx: cellIdx\n      };\n    }\n  };\n\n  InfiniteScroll.prototype.infiniteCellFocus = function (e) {\n    var gObj = this.parent;\n    var cache = gObj.infiniteScrollSettings.enableCache;\n\n    if (e.byKey) {\n      if (cache && this.isFocusScroll) {\n        this.scrollToLastFocusedCell(e);\n        return;\n      }\n\n      var cell = document.activeElement;\n      var rowIndex = getRowIndexFromElement(cell.parentElement);\n      this.cellIndex = parseInt(cell.getAttribute(dataColIndex), 10);\n      var content$$1 = gObj.getContent().firstElementChild;\n      var totalRowsCount = this.maxPage * gObj.pageSettings.pageSize - 1;\n      var visibleRowCount = Math.floor(content$$1.offsetHeight / this.parent.getRowHeight());\n      var contentRect = content$$1.getBoundingClientRect();\n\n      if (!isNaN(rowIndex)) {\n        if (e.keyArgs.action === downArrow || e.keyArgs.action === enter) {\n          this.rowIndex = rowIndex += 1;\n          var row$$1 = gObj.getRowByIndex(rowIndex);\n          var rowRect = row$$1 && row$$1.getBoundingClientRect();\n\n          if (cache) {\n            rowIndex = cell.parentElement.rowIndex + 1;\n          }\n\n          if (this.isFocusScroll || !row$$1 && rowIndex < totalRowsCount || rowRect && rowRect.bottom >= contentRect.bottom) {\n            if (!this.isFocusScroll) {\n              this.pressedKey = e.keyArgs.action;\n            }\n\n            this.isFocusScroll = false;\n            content$$1.scrollTop = (rowIndex - visibleRowCount + 1) * this.parent.getRowHeight();\n          } else if (!cache && row$$1) {\n            if (rowRect && (rowRect.bottom >= contentRect.bottom || rowRect.top < contentRect.top)) {\n              row$$1.cells[this.cellIndex].scrollIntoView();\n            }\n          }\n        } else if (e.keyArgs.action === upArrow || e.keyArgs.action === shiftEnter) {\n          this.rowIndex = rowIndex -= 1;\n          var row$$1 = gObj.getRowByIndex(rowIndex);\n          var rowRect = row$$1 && row$$1.getBoundingClientRect();\n\n          if (cache) {\n            rowIndex = cell.parentElement.rowIndex - 1;\n          }\n\n          if (!row$$1 || rowRect.top <= contentRect.top) {\n            this.pressedKey = e.keyArgs.action;\n            content$$1.scrollTop = rowIndex * this.parent.getRowHeight();\n          }\n        }\n      }\n    } else if (e.key === 'PageDown' || e.key === 'PageUp') {\n      this.pressedKey = e.key;\n    }\n\n    this.setLastCellFocusInfo(e);\n  };\n\n  InfiniteScroll.prototype.createEmptyRowdata = function () {\n    var _this = this;\n\n    this.parent.getColumns().filter(function (e) {\n      _this.emptyRowData[e.field] = _this.empty;\n    });\n  };\n\n  InfiniteScroll.prototype.getVirtualInfiniteEditedData = function () {\n    var editForm = this.parent.element.querySelector('.' + editedRow);\n    var addForm = this.parent.element.querySelector('.' + addedRow);\n    var gridForm = this.parent.element.querySelector('.e-gridform');\n\n    if (this.parent.infiniteScrollSettings.enableCache && (editForm || addForm)) {\n      var rowData = editForm ? extend({}, this.getEditedRowObject().data) : extend({}, this.emptyRowData);\n      this.virtualInfiniteData = this.parent.editModule.getCurrentEditedData(gridForm, rowData);\n\n      if (this.parent.isFrozenGrid()) {\n        this.virtualInfiniteData = this.parent.editModule.getCurrentEditedData(this.parent.getMovableVirtualContent().querySelector('.e-gridform'), rowData);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.restoreInfiniteEdit = function () {\n    var content$$1 = this.parent.getContent().firstElementChild;\n    var frozenEdit = this.parent.frozenRows ? this.editRowIndex >= this.parent.frozenRows : true;\n\n    if (this.isNormaledit && this.parent.infiniteScrollSettings.enableCache && frozenEdit) {\n      if (this.parent.editSettings.allowEditing && !isNullOrUndefined(this.editRowIndex)) {\n        var row$$1 = this.parent.getRowByIndex(this.editRowIndex);\n\n        if (Object.keys(this.virtualInfiniteData).length && row$$1 && !this.parent.getContent().querySelector('.' + editedRow)) {\n          var top_1 = row$$1.getBoundingClientRect().top;\n\n          if (top_1 < content$$1.offsetHeight && top_1 > this.parent.getRowHeight()) {\n            this.parent.isEdit = false;\n            this.parent.editModule.startEdit(row$$1);\n          }\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.restoreInfiniteAdd = function () {\n    var content$$1 = this.parent.getContent().firstElementChild;\n\n    if (this.parent.getCurrentViewRecords().length && this.parent.getRowByIndex(0) && this.isNormaledit && this.parent.infiniteScrollSettings.enableCache && this.isAdd && !content$$1.querySelector('.' + addedRow)) {\n      var isTop = content$$1.scrollTop < this.parent.getRowHeight();\n\n      if (isTop) {\n        this.parent.isEdit = false;\n        this.parent.addRecord();\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.appendInfiniteRows = function (e) {\n    var frozenCols = this.parent.isFrozenGrid();\n    var scrollEle = this.parent.getContent().firstElementChild;\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll';\n    var isMovable = this.parent.getFrozenMode() === leftRight && e.tableName === 'movable';\n\n    if (isInfiniteScroll && !e.args.isFrozen && !isMovable || !isInfiniteScroll) {\n      if (isInfiniteScroll && e.args.direction === 'up') {\n        e.tbody.insertBefore(e.frag, e.tbody.firstElementChild);\n      } else {\n        e.tbody.appendChild(e.frag);\n      }\n    }\n\n    if (!frozenCols) {\n      this.parent.contentModule.getTable().appendChild(e.tbody);\n      this.updateCurrentViewData();\n    } else {\n      if (isInfiniteScroll) {\n        if (e.tableName === frozenLeft || this.parent.getFrozenMode() === 'Right' && e.tableName === frozenRight) {\n          this.frozenFrag = e.frag;\n        } else if (this.parent.getFrozenMode() === leftRight && e.tableName === 'movable') {\n          this.movableFrag = e.frag;\n        } else {\n          var tbody$$1 = this.parent.getFrozenVirtualContent().querySelector(tbody);\n\n          if (e.args.direction === 'up') {\n            tbody$$1.insertBefore(this.frozenFrag, tbody$$1.firstElementChild);\n          } else {\n            tbody$$1.appendChild(this.frozenFrag);\n          }\n\n          if (e.tableName === frozenRight) {\n            this.parent.getMovableVirtualContent().querySelector(tbody).appendChild(this.movableFrag);\n            this.parent.element.querySelector('.e-frozen-right-content').querySelector(tbody).appendChild(e.frag);\n          } else {\n            this.parent.getMovableVirtualContent().querySelector('.' + table).appendChild(e.tbody);\n          }\n\n          this.parent.contentModule.refreshScrollOffset();\n          this.updateCurrentViewData();\n        }\n      } else {\n        var table$$1 = void 0;\n\n        if (e.tableName === frozenLeft) {\n          table$$1 = this.parent.getFrozenVirtualContent().querySelector('.' + table);\n        } else if (e.tableName === 'movable') {\n          table$$1 = this.parent.getMovableVirtualContent().querySelector('.' + table);\n\n          if (this.parent.getFrozenMode() !== leftRight) {\n            this.parent.contentModule.refreshScrollOffset();\n            this.updateCurrentViewData();\n          }\n        } else {\n          table$$1 = this.parent.element.querySelector('.e-frozen-right-content').querySelector('.' + table);\n\n          if (this.parent.getFrozenMode() === leftRight) {\n            this.parent.contentModule.refreshScrollOffset();\n            this.updateCurrentViewData();\n          }\n        }\n\n        table$$1.appendChild(e.tbody);\n        this.widthService.refreshFrozenScrollbar();\n      }\n    }\n\n    if (this.isInitialRender && !e.args.isFrozen) {\n      this.isInitialRender = false;\n      this.parent.scrollModule.setHeight();\n    }\n\n    if (!e.args.isFrozen) {\n      this.rowTop = !this.rowTop ? this.parent.getRows()[0].getBoundingClientRect().top : this.rowTop;\n\n      if (isInfiniteScroll) {\n        if (this.parent.infiniteScrollSettings.enableCache && this.isRemove) {\n          scrollEle.scrollTop = this.top;\n        }\n\n        setRowElements(this.parent);\n      }\n\n      this.restoreInfiniteAdd();\n      this.isScroll = true;\n    }\n\n    this.isInfiniteScroll = false;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  InfiniteScroll.prototype.selectNewRow = function (args) {\n    var _this = this;\n\n    var gObj = this.parent;\n    var row$$1 = gObj.getRowByIndex(this.rowIndex);\n    var cache = gObj.infiniteScrollSettings.enableCache;\n\n    if (row$$1 && this.keys.some(function (value) {\n      return value === _this.pressedKey;\n    })) {\n      var content$$1 = gObj.getContent().firstElementChild;\n      var rowHeight = gObj.getRowHeight();\n      var target = row$$1.cells[this.cellIndex];\n\n      if (this.pressedKey === downArrow || this.pressedKey === enter || cache && (this.pressedKey === upArrow || this.pressedKey === shiftEnter)) {\n        if (!cache && this.pressedKey !== upArrow && this.pressedKey !== shiftEnter) {\n          content$$1.scrollTop = content$$1.scrollTop + rowHeight;\n        }\n\n        gObj.focusModule.isInfiniteScroll = true;\n        gObj.focusModule.onClick({\n          target: target\n        }, true);\n        gObj.selectRow(this.rowIndex);\n      }\n    } else if (this.lastFocusInfo && (this.pressedKey === pageDown || this.pressedKey === pageUp)) {\n      var idx = cache ? 0 : this.lastFocusInfo.rowIdx;\n\n      if (gObj.getRowByIndex(idx)) {\n        var target = gObj.getCellFromIndex(idx, this.lastFocusInfo.cellIdx);\n\n        if (target) {\n          this.isFocusScroll = true;\n\n          if (!cache) {\n            gObj.focusModule.isInfiniteScroll = true;\n            gObj.focusModule.onClick({\n              target: target\n            }, true);\n          } else {\n            target.focus({\n              preventScroll: true\n            });\n          }\n        }\n      }\n    }\n\n    this.pressedKey = undefined;\n  };\n\n  InfiniteScroll.prototype.removeInfiniteCacheRows = function (e) {\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll';\n\n    if (!e.args.isFrozen && isInfiniteScroll && this.parent.infiniteScrollSettings.enableCache && this.isRemove) {\n      var rows = [].slice.call(this.parent.getContentTable().getElementsByClassName(row));\n\n      if (e.args.direction === 'down') {\n        if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n          var captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n          this.removeCaptionRows(captionRows, e.args);\n        }\n\n        var addRowCount = this.parent.element.querySelector('.' + addedRow) ? 0 : 1;\n        this.removeTopRows(rows, this.parent.pageSettings.pageSize - addRowCount);\n      }\n\n      if (e.args.direction === 'up') {\n        if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n          var captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n          this.removeCaptionRows(captionRows, e.args);\n        } else {\n          this.removeBottomRows(rows, rows.length - 1, e.args);\n        }\n      }\n\n      this.isScroll = false;\n      this.top = this.calculateScrollTop(e.args);\n    }\n  };\n\n  InfiniteScroll.prototype.calculateScrollTop = function (args) {\n    var top = 0;\n    var scrollCnt = this.parent.getContent().firstElementChild;\n\n    if (args.direction === 'down') {\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !this.isInitialCollapse) {\n        top = this.captionRowHeight();\n      }\n\n      var captionRows = [].slice.call(this.parent.getContent().firstElementChild.querySelectorAll('tr:not(.e-row)'));\n      var captionCount = 0;\n\n      if (this.isInitialCollapse && !isNullOrUndefined(captionRows)) {\n        captionCount = Math.round((captionRows.length - 1) / this.parent.groupSettings.columns.length);\n      }\n\n      var value = captionCount ? captionCount : this.parent.pageSettings.pageSize * (this.parent.infiniteScrollSettings.maxBlocks - 1);\n      var currentViewRowCount = 0;\n      var i = 0;\n\n      while (currentViewRowCount < scrollCnt.clientHeight) {\n        i++;\n        currentViewRowCount = i * this.parent.getRowHeight();\n      }\n\n      i = i - 1;\n      top += (value - i) * this.parent.getRowHeight();\n    }\n\n    if (args.direction === 'up') {\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !this.isInitialCollapse) {\n        var len = this.refreshInfiniteCacheRowVisibleLength(this.infiniteCache, this.parent.pageSettings.currentPage);\n        top = len * this.parent.getRowHeight();\n      } else if (this.isInitialCollapse) {\n        var groupedData = this.infiniteCache[this.parent.pageSettings.currentPage];\n        var count = 0;\n\n        for (var i = 0; i < groupedData.length; i++) {\n          if (groupedData[i].isCaptionRow) {\n            count++;\n          }\n        }\n\n        top += Math.round(count / this.parent.groupSettings.columns.length) * this.parent.getRowHeight();\n      } else {\n        top += this.parent.pageSettings.pageSize * this.parent.getRowHeight() + getScrollBarWidth();\n      }\n    }\n\n    return top;\n  };\n\n  InfiniteScroll.prototype.captionRowHeight = function () {\n    var rows = [].slice.call(this.parent.getContent().querySelectorAll('tr:not(.e-row)'));\n    return rows.length * this.parent.getRowHeight();\n  };\n\n  InfiniteScroll.prototype.removeTopRows = function (rows, maxIndx) {\n    var frozeCols = this.parent.isFrozenGrid();\n    var frRows = this.parent.getFrozenMode() === leftRight ? [].slice.call(this.parent.element.querySelector('.e-frozen-right-content').getElementsByClassName(row)) : null;\n    var movableRows = frozeCols ? [].slice.call(this.parent.getMovableVirtualContent().getElementsByClassName(row)) : null;\n\n    for (var i = 0; i <= maxIndx; i++) {\n      if (this.parent.frozenRows && this.parent.pageSettings.currentPage === this.parent.infiniteScrollSettings.maxBlocks + 1 && i > maxIndx - this.parent.frozenRows) {\n        continue;\n      }\n\n      remove(rows[i]);\n\n      if (movableRows) {\n        remove(movableRows[i]);\n      }\n\n      if (frRows) {\n        remove(frRows[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.removeBottomRows = function (rows, maxIndx, args) {\n    var cnt = 0;\n    var frozeCols = this.parent.isFrozenGrid();\n    var movableRows = frozeCols ? [].slice.call(this.parent.getMovableVirtualContent().getElementsByClassName(row)) : null;\n    var frRows = this.parent.getFrozenMode() === leftRight ? [].slice.call(this.parent.element.querySelector('.e-frozen-right-content').getElementsByClassName(row)) : null;\n    var pageSize = this.parent.pageSettings.pageSize;\n\n    if (!frozeCols && this.infiniteCache[args.prevPage].length < pageSize) {\n      cnt = this.parent.pageSettings.pageSize - this.infiniteCache[args.prevPage].length;\n    }\n\n    if (frozeCols && this.infiniteFrozenCache[args.prevPage][1].length < pageSize) {\n      cnt = this.parent.pageSettings.pageSize - this.infiniteFrozenCache[args.prevPage][1].length;\n    }\n\n    for (var i = maxIndx; cnt < pageSize; i--) {\n      cnt++;\n      remove(rows[i]);\n\n      if (movableRows) {\n        remove(movableRows[i]);\n      }\n\n      if (frRows) {\n        remove(frRows[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.removeCaptionRows = function (rows, args) {\n    var rowElements = [].slice.call(this.parent.getContent().getElementsByClassName(row));\n\n    if (args.direction === 'down') {\n      var lastRow = rowElements[this.parent.pageSettings.pageSize - 1];\n      var lastRowIndex = getRowIndexFromElement(lastRow) - 1;\n      var k = 0;\n\n      for (var i = 0; k < lastRowIndex; i++) {\n        if (!rows[i].classList.contains(row)) {\n          remove(rows[i]);\n        } else {\n          k = getRowIndexFromElement(rows[i]);\n        }\n      }\n    }\n\n    if (args.direction === 'up') {\n      var lastIndex = getRowIndexFromElement(rowElements[rowElements.length - 1]);\n      var page = Math.ceil(lastIndex / this.parent.pageSettings.pageSize);\n      var startIndex = 0;\n\n      for (var i = this.parent.pageSettings.currentPage + 1; i < page; i++) {\n        startIndex += this.infiniteCache[i].length;\n      }\n\n      for (var i = startIndex; i < rows.length; i++) {\n        remove(rows[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.resetInfiniteBlocks = function (args, isDataModified) {\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && args.requestType !== 'infiniteScroll';\n\n    if (!this.initialRender && !isNullOrUndefined(this.parent.infiniteScrollModule) && isInfiniteScroll) {\n      if (this.actions.some(function (value) {\n        return value === args.requestType;\n      }) || isDataModified || args.requestType === 'save' && (this.parent.sortSettings.columns.length || this.parent.filterSettings.columns.length || this.parent.groupSettings.columns.length || this.parent.searchSettings.key)) {\n        var scrollEle = this.parent.getContent().firstElementChild;\n        this.initialRender = true;\n        scrollEle.scrollTop = 0;\n        this.parent.pageSettings.currentPage = 1;\n        this.infiniteCache = this.infiniteFrozenCache = {};\n        this.infiniteCurrentViewData = {};\n        this.resetContentModuleCache({});\n        this.isRemove = false;\n        this.top = 0;\n        this.isInitialMovableRender = true;\n        this.isInitialCollapse = false;\n        this.parent.contentModule.isRemove = this.isRemove;\n        this.parent.contentModule.isAddRows = this.isRemove;\n        this.parent.contentModule.visibleRows = [];\n        this.parent.contentModule.visibleFrozenRows = [];\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.setCache = function (e) {\n    if (this.parent.enableInfiniteScrolling && this.parent.infiniteScrollSettings.enableCache) {\n      var frozeCols = this.parent.isFrozenGrid();\n      var idx = e.args.isFrozen ? 1 : 0;\n      var isEdit = e.args.requestType !== 'infiniteScroll' && (this.requestType === 'delete' || this.requestType === 'add');\n      var currentPage = this.parent.pageSettings.currentPage;\n\n      if (frozeCols && this.isInitialMovableRender || !frozeCols && !Object.keys(this.infiniteCache).length || isEdit) {\n        this.isInitialMovableRender = !e.args.isFrozen;\n        this.setInitialCache(e.modelData, e.args, isEdit);\n      }\n\n      if (!frozeCols && isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage])) {\n        this.infiniteCache[this.parent.pageSettings.currentPage] = e.modelData;\n        this.resetContentModuleCache(this.infiniteCache);\n      }\n\n      if (frozeCols) {\n        if (idx === 0 && isNullOrUndefined(this.infiniteFrozenCache[currentPage]) || !this.infiniteFrozenCache[currentPage][idx].length) {\n          this.createFrozenCache(currentPage);\n          this.infiniteFrozenCache[currentPage][idx] = e.modelData;\n\n          if (idx === 1) {\n            this.resetContentModuleCache(this.infiniteFrozenCache);\n          }\n        }\n      }\n\n      if (e.isInfiniteScroll && !this.isRemove) {\n        this.isRemove = (currentPage - 1) % this.parent.infiniteScrollSettings.maxBlocks === 0;\n        this.parent.contentModule.isRemove = this.isRemove;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.setInitialCache = function (data, args, isEdit, isCurrentViewData) {\n    var frozenCols = this.parent.isFrozenGrid();\n    var idx = args.isFrozen ? 1 : 0;\n    var k = !isEdit ? 1 : this.firstBlock;\n\n    for (var i = 1; i <= this.parent.infiniteScrollSettings.initialBlocks; i++) {\n      var startIndex = (i - 1) * this.parent.pageSettings.pageSize;\n      var endIndex = i * this.parent.pageSettings.pageSize;\n\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !isCurrentViewData) {\n        this.setInitialGroupCache(data, k, startIndex, endIndex);\n      } else {\n        if (isCurrentViewData) {\n          this.infiniteCurrentViewData[k] = data.slice(startIndex, endIndex);\n        } else {\n          if (frozenCols) {\n            this.createFrozenCache(k);\n            this.infiniteFrozenCache[k][idx] = data.slice(startIndex, endIndex);\n            this.resetContentModuleCache(this.infiniteFrozenCache);\n          } else {\n            this.infiniteCache[k] = data.slice(startIndex, endIndex);\n            this.resetContentModuleCache(this.infiniteCache);\n          }\n        }\n      }\n\n      k++;\n    }\n  };\n\n  InfiniteScroll.prototype.createFrozenCache = function (index) {\n    if (!this.infiniteFrozenCache[index]) {\n      this.infiniteFrozenCache[index] = [[], []];\n    }\n  };\n\n  InfiniteScroll.prototype.setInitialGroupCache = function (data, index, sIndex, eIndex) {\n    var pageData = [];\n    var startIndex = 0;\n\n    for (var i = 1; i <= Object.keys(this.infiniteCache).length; i++) {\n      startIndex += this.infiniteCache[i].length;\n    }\n\n    var k = sIndex;\n\n    for (var i = startIndex; i < data.length && k < eIndex; i++) {\n      if (data[i].index < eIndex || data[i].isCaptionRow) {\n        k = data[i].isCaptionRow ? k : data[i].index;\n        pageData.push(data[i]);\n      }\n\n      if (data[i].index >= eIndex || data[i].index === eIndex - 1) {\n        break;\n      }\n    }\n\n    this.infiniteCache[index] = pageData;\n    this.resetContentModuleCache(this.infiniteCache);\n  };\n\n  InfiniteScroll.prototype.resetContentModuleCache = function (data) {\n    this.parent.contentModule.infiniteCache = data;\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  InfiniteScroll.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  return InfiniteScroll;\n}();\n\nvar __extends$36 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * GroupLazyLoadRenderer is used to perform lazy load grouping\n *\n * @hidden\n */\n\n\nvar GroupLazyLoadRenderer =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$36(GroupLazyLoadRenderer, _super);\n\n  function GroupLazyLoadRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.childCount = 0;\n    _this.scrollData = [];\n    _this.isFirstChildRow = false;\n    _this.isScrollDown = false;\n    _this.isScrollUp = false;\n    _this.groupCache = {};\n    _this.startIndexes = {};\n    _this.captionCounts = {};\n    _this.rowsByUid = {};\n    _this.objIdxByUid = {};\n    _this.initialGroupCaptions = {};\n    _this.requestType = ['paging', 'columnstate', 'reorder', 'cancel', 'save', 'beginEdit', 'add', 'delete', 'filterbeforeopen', 'filterchoicerequest', 'infiniteScroll'];\n    _this.scrollTopCache = undefined;\n    /** @hidden */\n\n    _this.refRowsObj = {};\n    /** @hidden */\n\n    _this.cacheMode = false;\n    /** @hidden */\n\n    _this.cacheBlockSize = 5;\n    /** @hidden */\n\n    _this.ignoreAccent = _this.parent.allowFiltering ? _this.parent.filterSettings.ignoreAccent : false;\n    /** @hidden */\n\n    _this.allowCaseSensitive = false;\n    _this.locator = locator;\n    _this.groupGenerator = new GroupModelGenerator(_this.parent);\n    _this.summaryModelGen = new GroupSummaryModelGenerator(_this.parent);\n    _this.captionModelGen = new CaptionSummaryModelGenerator(_this.parent);\n    _this.rowRenderer = new RowRenderer(_this.locator, null, _this.parent);\n\n    _this.eventListener();\n\n    return _this;\n  }\n\n  GroupLazyLoadRenderer.prototype.eventListener = function () {\n    this.parent.addEventListener(actionBegin, this.actionBegin.bind(this));\n    this.parent.addEventListener(actionComplete, this.actionComplete.bind(this));\n    this.parent.on(initialEnd, this.setLazyLoadPageSize, this);\n    this.parent.on(setGroupCache, this.setCache, this);\n    this.parent.on(lazyLoadScrollHandler, this.scrollHandler, this);\n    this.parent.on(columnVisibilityChanged, this.setVisible, this);\n    this.parent.on(groupCollapse, this.collapseShortcut, this);\n  };\n  /**\n   * @param {HTMLTableRowElement} tr - specifies the table row element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.captionExpand = function (tr) {\n    var _this = this;\n\n    var page = this.parent.pageSettings.currentPage;\n    var rowsObject = this.groupCache[page];\n    var uid = tr.getAttribute('data-uid');\n    this.refreshCaches();\n\n    if (!this.scrollTopCache || this.parent.scrollModule['content'].scrollTop > this.scrollTopCache) {\n      this.scrollTopCache = this.parent.scrollModule['content'].scrollTop;\n    }\n\n    var oriIndex = this.getRowObjectIndexByUid(uid);\n    var isRowExist = rowsObject[oriIndex + 1] ? rowsObject[oriIndex].indent < rowsObject[oriIndex + 1].indent : false;\n    var data = rowsObject[oriIndex];\n    var key = getGroupKeysAndFields(oriIndex, rowsObject);\n    var e = {\n      captionRowElement: tr,\n      groupInfo: data,\n      enableCaching: true,\n      cancel: false\n    };\n    this.parent.trigger(lazyLoadGroupExpand, e, function (args) {\n      if (args.cancel) {\n        return;\n      }\n\n      args.keys = key.keys;\n      args.fields = key.fields;\n      args.rowIndex = tr.rowIndex;\n      args.makeRequest = !args.enableCaching || !isRowExist;\n\n      if (!args.enableCaching && isRowExist) {\n        _this.clearCache([uid]);\n      }\n\n      args.skip = 0;\n      args.take = _this.pageSize;\n      data.isExpand = _this.rowsByUid[page][data.uid].isExpand = true;\n\n      _this.captionRowExpand(args);\n    });\n  };\n  /**\n   * @param {HTMLTableRowElement} tr - specifies the table row element\n   * @returns {void}\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.captionCollapse = function (tr) {\n    var _this = this;\n\n    var cache = this.groupCache[this.parent.pageSettings.currentPage];\n    var rowIdx = tr.rowIndex;\n    var uid = tr.getAttribute('data-uid');\n    this.refreshCaches();\n    var captionIndex = this.getRowObjectIndexByUid(uid);\n    var e = {\n      captionRowElement: tr,\n      groupInfo: cache[captionIndex],\n      cancel: false\n    };\n    this.parent.trigger(lazyLoadGroupCollapse, e, function (args) {\n      if (args.cancel) {\n        return;\n      }\n\n      args.isExpand = false;\n\n      _this.removeRows(captionIndex, rowIdx);\n\n      if (_this.parent.enableInfiniteScrolling) {\n        _this.groupCache[_this.parent.pageSettings.currentPage] = extend([], _this.refRowsObj[_this.parent.pageSettings.currentPage]);\n\n        _this.refreshRowObjects([], captionIndex);\n      }\n    });\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  GroupLazyLoadRenderer.prototype.setLazyLoadPageSize = function () {\n    var scrollEle = this.parent.getContent().firstElementChild;\n    var blockSize = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n    this.pageSize = this.pageSize ? this.pageSize : blockSize * 3;\n    this.blockSize = Math.ceil(this.pageSize / 2);\n  };\n  /**\n   * @returns {void}\n   * @hidden */\n\n\n  GroupLazyLoadRenderer.prototype.clearLazyGroupCache = function () {\n    this.clearCache();\n  };\n\n  GroupLazyLoadRenderer.prototype.clearCache = function (uids) {\n    uids = uids ? uids : this.getInitialCaptionIndexes();\n    var cache = this.groupCache[this.parent.pageSettings.currentPage];\n\n    if (uids.length) {\n      for (var i = 0; i < uids.length; i++) {\n        var capIdx = this.getRowObjectIndexByUid(uids[i]);\n        var capRow = cache[capIdx];\n\n        if (!capRow) {\n          continue;\n        }\n\n        if (this.captionCounts[this.parent.pageSettings.currentPage][capRow.uid]) {\n          for (var i_1 = capIdx + 1; i_1 < cache.length; i_1++) {\n            if (cache[i_1].indent === capRow.indent || cache[i_1].indent < capRow.indent) {\n              delete this.captionCounts[this.parent.pageSettings.currentPage][capRow.uid];\n              break;\n            }\n\n            if (cache[i_1].isCaptionRow) {\n              delete this.captionCounts[this.parent.pageSettings.currentPage][cache[i_1].uid];\n            }\n          }\n        }\n\n        if (capRow.isExpand) {\n          var tr = this.parent.getRowElementByUID(capRow.uid);\n\n          if (!tr) {\n            return;\n          }\n\n          this.parent.groupModule.expandCollapseRows(tr.querySelector('.e-recordplusexpand'));\n        }\n\n        var child = this.getNextChilds(capIdx);\n\n        if (!child.length) {\n          continue;\n        }\n\n        var subChild = [];\n\n        if (child[child.length - 1].isCaptionRow) {\n          subChild = this.getChildRowsByParentIndex(cache.indexOf(child[child.length - 1]), false, false, null, true, true);\n        }\n\n        var start = cache.indexOf(child[0]);\n        var end = subChild.length ? cache.indexOf(subChild[subChild.length - 1]) : cache.indexOf(child[child.length - 1]);\n        cache.splice(start, end - (start - 1));\n        this.refreshCaches();\n      }\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.refreshCaches = function () {\n    var page = this.parent.pageSettings.currentPage;\n    var cache = this.groupCache[page];\n\n    if (this.parent.enableInfiniteScrolling) {\n      this.rowsByUid[page] = [];\n      this.objIdxByUid[page] = [];\n    } else {\n      this.rowsByUid = {};\n      this.objIdxByUid = {};\n    }\n\n    for (var i = 0; i < cache.length; i++) {\n      this.maintainRows(cache[i], i);\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.getInitialCaptionIndexes = function () {\n    var page = this.parent.pageSettings.currentPage;\n    var uids = [];\n\n    for (var i = 0; i < this.initialGroupCaptions[page].length; i++) {\n      uids.push(this.initialGroupCaptions[page][i].uid);\n    }\n\n    return uids;\n  };\n  /**\n   * @param {string} uid - specifies the uid\n   * @returns {number} returns the row object uid\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.getRowObjectIndexByUid = function (uid) {\n    return this.objIdxByUid[this.parent.pageSettings.currentPage][uid];\n  };\n\n  GroupLazyLoadRenderer.prototype.collapseShortcut = function (args) {\n    if (this.parent.groupSettings.columns.length && args.target && parentsUntil(args.target, content) && args.target.parentElement.tagName === 'TR') {\n      if (!args.collapse && parentsUntil(args.target, row)) {\n        return;\n      }\n\n      var row$$1 = args.target.parentElement;\n      var uid = row$$1.getAttribute('data-uid');\n\n      if (args.collapse) {\n        var rowObj = this.getRowByUid(uid);\n        var capRow = this.getRowByUid(rowObj.parentUid);\n\n        if (capRow.isCaptionRow && capRow.isExpand) {\n          var capEle = this.getRowElementByUid(rowObj.parentUid);\n          this.parent.groupModule.expandCollapseRows(capEle.cells[rowObj.indent - 1]);\n        }\n      } else {\n        var capRow = this.getRowByUid(uid);\n\n        if (capRow.isCaptionRow && !capRow.isExpand) {\n          var capEle = this.getRowElementByUid(uid);\n          this.parent.groupModule.expandCollapseRows(capEle.cells[capRow.indent]);\n        }\n      }\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.getRowByUid = function (uid) {\n    return this.rowsByUid[this.parent.pageSettings.currentPage][uid];\n  };\n\n  GroupLazyLoadRenderer.prototype.actionBegin = function (args) {\n    if (!args.cancel) {\n      if (!this.requestType.some(function (value) {\n        return value === args.requestType;\n      })) {\n        this.groupCache = {};\n        this.resetRowMaintenance();\n      }\n\n      if (args.requestType === 'reorder' && this.parent.groupSettings.columns.length) {\n        var keys = Object.keys(this.groupCache);\n\n        for (var j = 0; j < keys.length; j++) {\n          var cache = this.groupCache[keys[j]];\n\n          for (var i = 0; i < cache.length; i++) {\n            if (cache[i].isCaptionRow && !this.captionModelGen.isEmpty()) {\n              this.changeCaptionRow(cache[i], null, keys[j]);\n            }\n\n            if (cache[i].isDataRow) {\n              var from = args.fromIndex + cache[i].indent;\n              var to = args.toIndex + cache[i].indent;\n              this.moveCells(cache[i].cells, from, to);\n            }\n          }\n        }\n      }\n\n      if (args.requestType === 'delete' || args.action === 'add' && args.requestType === 'save') {\n        this.groupCache = {};\n        this.resetRowMaintenance();\n      }\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.actionComplete = function (args) {\n    if (!args.cancel && args.requestType !== 'columnstate' && args.requestType !== 'beginEdit' && args.requestType !== 'delete' && args.requestType !== 'save' && args.requestType !== 'reorder') {\n      this.scrollReset();\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.resetRowMaintenance = function () {\n    this.startIndexes = {};\n    this.captionCounts = {};\n    this.rowsByUid = {};\n    this.objIdxByUid = {};\n    this.initialGroupCaptions = {};\n  };\n\n  GroupLazyLoadRenderer.prototype.moveCells = function (arr, from, to) {\n    if (from >= arr.length) {\n      var k = from - arr.length;\n\n      while (k-- + 1) {\n        arr.push(undefined);\n      }\n    }\n\n    arr.splice(from, 0, arr.splice(to, 1)[0]);\n  };\n\n  GroupLazyLoadRenderer.prototype.removeRows = function (idx, trIdx) {\n    var page = this.parent.pageSettings.currentPage;\n    var rows = this.groupCache[page];\n    var trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n    var aggUid;\n\n    if (this.parent.aggregates.length) {\n      var agg = this.getAggregateByCaptionIndex(idx);\n      aggUid = agg.length ? agg[agg.length - 1].uid : undefined;\n    }\n\n    var indent = rows[idx].indent;\n    this.addClass(this.getNextChilds(idx));\n    rows[idx].isExpand = this.rowsByUid[page][rows[idx].uid].isExpand = false;\n    var capUid;\n\n    for (var i = idx + 1; i < rows.length; i++) {\n      if (rows[i].indent === indent || rows[i].indent < indent) {\n        capUid = rows[i].uid;\n        break;\n      }\n\n      if (rows[i].isCaptionRow && rows[i].isExpand) {\n        this.addClass(this.getNextChilds(i));\n      }\n    }\n\n    for (var i = trIdx + 1; i < trs.length; i++) {\n      if (trs[i].getAttribute('data-uid') === capUid) {\n        break;\n      } else if (trs[i].getAttribute('data-uid') === aggUid) {\n        remove(trs[i]);\n        break;\n      } else {\n        remove(trs[i]);\n        this.refRowsObj[page].splice(trIdx + 1, 1);\n      }\n    }\n\n    if (this.parent.scrollModule['content'].scrollTop > this.scrollTopCache) {\n      this.parent.scrollModule['content'].scrollTop = this.scrollTopCache;\n    }\n\n    this.parent.notify(refreshExpandandCollapse, {\n      rows: this.refRowsObj[page]\n    });\n  };\n\n  GroupLazyLoadRenderer.prototype.addClass = function (rows) {\n    var last = rows[this.blockSize];\n\n    if (last) {\n      last.lazyLoadCssClass = 'e-lazyload-middle-down';\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.getNextChilds = function (index, rowObjects) {\n    var group = this.groupCache[this.parent.pageSettings.currentPage];\n    var rows = rowObjects ? rowObjects : group;\n    var indent = group[index].indent + 1;\n    var childRows = [];\n\n    for (var i = rowObjects ? 0 : index + 1; i < rows.length; i++) {\n      if (rows[i].indent < indent) {\n        break;\n      }\n\n      if (rows[i].indent === indent) {\n        childRows.push(rows[i]);\n      }\n    }\n\n    return childRows;\n  };\n\n  GroupLazyLoadRenderer.prototype.lazyLoadHandler = function (args) {\n    this.setStartIndexes();\n    var tr = this.parent.getContent().querySelectorAll('tr')[args.index];\n    var uid = tr.getAttribute('data-uid');\n    var captionIndex = this.getRowObjectIndexByUid(uid);\n    var captionRow = this.groupCache[this.parent.pageSettings.currentPage][captionIndex];\n    var rows = args.isRowExist ? args.isScroll ? this.scrollData : this.getChildRowsByParentIndex(captionIndex, true, true, null, true) : [];\n    this.scrollData = [];\n\n    if (!args.isRowExist) {\n      this.setRowIndexes(captionIndex, captionRow);\n      this.refreshCaptionRowCount(this.groupCache[this.parent.pageSettings.currentPage][captionIndex], args.count);\n\n      if (Object.keys(args.data).indexOf('GroupGuid') !== -1) {\n        for (var i = 0; i < args.data.length; i++) {\n          var data = this.groupGenerator.generateCaptionRow(args.data[i], args.level, captionRow.parentGid, undefined, 0, captionRow.uid);\n          rows.push(data);\n\n          if (this.parent.aggregates.length) {\n            rows = rows.concat(this.summaryModelGen.generateRows(args.data[i], {\n              level: args.level + 1,\n              parentUid: data.uid\n            }));\n          }\n        }\n      } else {\n        this.groupGenerator.index = this.getStartIndex(captionIndex, args.isScroll);\n        rows = this.groupGenerator.generateDataRows(args.data, args.level, captionRow.parentGid, 0, captionRow.uid);\n      }\n    }\n\n    var trIdx = args.isScroll ? this.rowIndex : args.index;\n    var nxtChild = this.getNextChilds(captionIndex, rows);\n    var lastRow = !args.up ? this.hasLastChildRow(args.isScroll, args.count, nxtChild.length) : true;\n\n    if (!args.isRowExist && !lastRow) {\n      nxtChild[this.blockSize].lazyLoadCssClass = 'e-lazyload-middle-down';\n    }\n\n    if (!lastRow) {\n      nxtChild[nxtChild.length - 1].lazyLoadCssClass = 'e-not-lazyload-end';\n    }\n\n    var aggregates = !args.isScroll && !args.isRowExist ? this.getAggregateByCaptionIndex(captionIndex) : [];\n\n    if (!args.up) {\n      if (!args.isRowExist) {\n        this.refreshRowObjects(rows, args.isScroll ? this.rowObjectIndex : captionIndex);\n      }\n    }\n\n    this.render(trIdx, rows, lastRow, aggregates);\n\n    if (this.isFirstChildRow && !args.up) {\n      this.parent.getContent().firstElementChild.scrollTop = rows.length * this.parent.getRowHeight();\n    }\n\n    this.isFirstChildRow = false;\n    this.rowIndex = undefined;\n    this.rowObjectIndex = undefined;\n    this.childCount = 0;\n\n    for (var i = 0; i < rows.length; i++) {\n      this.refRowsObj[this.parent.pageSettings.currentPage].splice(captionIndex + i + 1, 0, rows[i]);\n    }\n\n    this.parent.notify(refreshExpandandCollapse, {\n      rows: this.refRowsObj[this.parent.pageSettings.currentPage]\n    });\n  };\n\n  GroupLazyLoadRenderer.prototype.setRowIndexes = function (capIdx, row$$1) {\n    if (!this.captionCounts[this.parent.pageSettings.currentPage]) {\n      this.captionCounts[this.parent.pageSettings.currentPage] = {};\n    }\n\n    if (row$$1.isCaptionRow) {\n      this.captionCounts[this.parent.pageSettings.currentPage][row$$1.uid] = row$$1.data.count;\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.getStartIndex = function (capIdx, isScroll) {\n    var page = this.parent.pageSettings.currentPage;\n    var cache = this.groupCache[page];\n\n    if (isScroll) {\n      return cache[this.rowObjectIndex].index + 1;\n    }\n\n    var count = 0;\n    var idx = 0;\n    var prevCapRow = this.getRowByUid(cache[capIdx].parentUid);\n\n    if (prevCapRow) {\n      idx = this.prevCaptionCount(prevCapRow);\n    }\n\n    if (cache[capIdx].indent > 0) {\n      for (var i = capIdx - 1; i >= 0; i--) {\n        if (cache[i].indent < cache[capIdx].indent) {\n          break;\n        }\n\n        if (cache[i].isCaptionRow && cache[i].indent === cache[capIdx].indent) {\n          count = count + cache[i].data.count;\n        }\n      }\n    }\n\n    var index = count + idx + this.startIndexes[page][cache[capIdx].parentGid];\n    return index;\n  };\n\n  GroupLazyLoadRenderer.prototype.prevCaptionCount = function (prevCapRow) {\n    var page = this.parent.pageSettings.currentPage;\n    var cache = this.groupCache[page];\n    var idx = 0;\n\n    for (var i = cache.indexOf(prevCapRow) - 1; i >= 0; i--) {\n      if (cache[i].indent === 0) {\n        break;\n      }\n\n      if (cache[i].indent < prevCapRow.indent) {\n        break;\n      }\n\n      if (cache[i].isCaptionRow && cache[i].indent === prevCapRow.indent) {\n        var count = this.captionCounts[page][cache[i].uid];\n        idx = idx + (count ? count : cache[i].data.count);\n      }\n    }\n\n    var capRow = this.getRowByUid(prevCapRow.parentUid);\n\n    if (capRow) {\n      idx = idx + this.prevCaptionCount(capRow);\n    }\n\n    return idx;\n  };\n\n  GroupLazyLoadRenderer.prototype.setStartIndexes = function () {\n    var cache = this.groupCache[this.parent.pageSettings.currentPage];\n\n    if (!this.startIndexes[this.parent.pageSettings.currentPage]) {\n      var indexes = [];\n      var idx = void 0;\n\n      for (var i = 0; i < cache.length; i++) {\n        if (cache[i].isCaptionRow) {\n          if (!indexes.length) {\n            indexes.push(0);\n          } else {\n            indexes.push(cache[idx].data.count + indexes[indexes.length - 1]);\n          }\n\n          idx = i;\n        }\n      }\n\n      this.startIndexes[this.parent.pageSettings.currentPage] = indexes;\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.hasLastChildRow = function (isScroll, captionCount, rowCount) {\n    return isScroll ? captionCount === this.childCount + rowCount : captionCount === rowCount;\n  };\n\n  GroupLazyLoadRenderer.prototype.refreshCaptionRowCount = function (row$$1, count) {\n    row$$1.data.count = count;\n  };\n\n  GroupLazyLoadRenderer.prototype.render = function (trIdx, rows, hasLastChildRow, aggregates) {\n    var tr = this.parent.getContent().querySelectorAll('tr')[trIdx];\n    var scrollEle = this.parent.getContent().firstElementChild;\n    var rowHeight = this.parent.getRowHeight();\n\n    if (tr && aggregates.length) {\n      for (var i = aggregates.length - 1; i >= 0; i--) {\n        tr.insertAdjacentElement('afterend', this.rowRenderer.render(aggregates[i], this.parent.getColumns()));\n      }\n    }\n\n    if (tr && rows.length) {\n      for (var i = rows.length - 1; i >= 0; i--) {\n        if (this.confirmRowRendering(rows[i])) {\n          tr.insertAdjacentElement('afterend', this.rowRenderer.render(rows[i], this.parent.getColumns()));\n\n          if (this.isScrollDown) {\n            scrollEle.scrollTop = scrollEle.scrollTop - rowHeight;\n          }\n\n          if (this.isScrollUp) {\n            scrollEle.scrollTop = scrollEle.scrollTop + rowHeight;\n          }\n        }\n      }\n    }\n\n    this.isScrollDown = false;\n    this.isScrollUp = false;\n  };\n  /**\n   * @param {Row<Column>} row - specifies the row\n   * @param {number} index - specifies the index\n   * @returns {void}\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.maintainRows = function (row$$1, index) {\n    var page = this.parent.pageSettings.currentPage;\n\n    if (!this.rowsByUid[page]) {\n      this.rowsByUid[page] = {};\n      this.objIdxByUid[page] = {};\n    }\n\n    if (row$$1.uid) {\n      this.rowsByUid[page][row$$1.uid] = row$$1;\n    }\n\n    this.objIdxByUid[page][row$$1.uid] = index;\n  };\n\n  GroupLazyLoadRenderer.prototype.confirmRowRendering = function (row$$1) {\n    var check = true;\n\n    if (isNullOrUndefined(row$$1.indent) && !row$$1.isDataRow && !row$$1.isCaptionRow) {\n      var cap = this.getRowByUid(row$$1.parentUid);\n\n      if (cap.isCaptionRow && !cap.isExpand) {\n        check = false;\n      }\n    }\n\n    return check;\n  };\n\n  GroupLazyLoadRenderer.prototype.refreshRowObjects = function (newRows, index) {\n    var page = this.parent.pageSettings.currentPage;\n    var rowsObject = this.groupCache[page];\n    this.rowsByUid[page] = {};\n    this.objIdxByUid[page] = {};\n    var newRowsObject = [];\n    var k = 0;\n\n    for (var i = 0; i < rowsObject.length; i++) {\n      if (i === index) {\n        this.maintainRows(rowsObject[i], k);\n        newRowsObject.push(rowsObject[i]);\n        k++;\n\n        for (var j = 0; j < newRows.length; j++) {\n          this.maintainRows(newRows[j], k);\n          newRowsObject.push(newRows[j]);\n          k++;\n        }\n      } else {\n        this.maintainRows(rowsObject[i], k);\n        newRowsObject.push(rowsObject[i]);\n        k++;\n      }\n    }\n\n    this.groupCache[this.parent.pageSettings.currentPage] = extend([], newRowsObject);\n    this.updateCurrentViewData();\n  };\n\n  GroupLazyLoadRenderer.prototype.getAggregateByCaptionIndex = function (index) {\n    var cache = this.groupCache[this.parent.pageSettings.currentPage];\n    var parent = cache[index];\n    var indent = parent.indent;\n    var uid = parent.uid;\n    var agg = [];\n\n    for (var i = index + 1; i < cache.length; i++) {\n      if (cache[i].indent === indent) {\n        break;\n      }\n\n      if (isNullOrUndefined(cache[i].indent) && cache[i].parentUid === uid) {\n        agg.push(cache[i]);\n      }\n    }\n\n    return agg;\n  };\n\n  GroupLazyLoadRenderer.prototype.getChildRowsByParentIndex = function (index, deep, block, data, includeAgg, includeCollapseAgg) {\n    var cache = data ? data : this.groupCache[this.parent.pageSettings.currentPage];\n    var parentRow = cache[index];\n    var agg = [];\n\n    if (!parentRow.isCaptionRow || parentRow.isCaptionRow && !parentRow.isExpand && !includeCollapseAgg) {\n      return [];\n    }\n\n    if (includeAgg && this.parent.aggregates.length) {\n      agg = this.getAggregateByCaptionIndex(index);\n    }\n\n    var indent = parentRow.indent;\n    var uid = parentRow.uid;\n    var rows = [];\n    var count = 0;\n\n    for (var i = index + 1; i < cache.length; i++) {\n      if (cache[i].parentUid === uid) {\n        if (isNullOrUndefined(cache[i].indent)) {\n          continue;\n        }\n\n        count++;\n        rows.push(cache[i]);\n\n        if (deep && cache[i].isCaptionRow) {\n          rows = rows.concat(this.getChildRowsByParentIndex(i, deep, block, data, includeAgg));\n        }\n\n        if (block && count === this.pageSize) {\n          break;\n        }\n      }\n\n      if (cache[i].indent === indent) {\n        break;\n      }\n    }\n\n    return rows.concat(agg);\n  };\n  /**\n   * @param {boolean} isReorder - specifies the isreorder\n   * @returns {Row<Column>[]} returns the row\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.initialGroupRows = function (isReorder) {\n    var rows = [];\n    var cache = this.groupCache[this.parent.pageSettings.currentPage];\n\n    if (isReorder) {\n      return this.getRenderedRowsObject();\n    }\n\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].indent === 0) {\n        rows.push(cache[i]);\n        rows = rows.concat(this.getChildRowsByParentIndex(i, true, true, cache, true));\n      }\n    }\n\n    return rows;\n  };\n  /**\n   * @returns {Row<Column>[]} retruns the row\n   * @hidden */\n\n\n  GroupLazyLoadRenderer.prototype.getRenderedRowsObject = function () {\n    var rows = [];\n    var trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n\n    for (var i = 0; i < trs.length; i++) {\n      rows.push(this.getRowByUid(trs[i].getAttribute('data-uid')));\n    }\n\n    return rows;\n  };\n\n  GroupLazyLoadRenderer.prototype.getCacheRowsOnDownScroll = function (index) {\n    var rows = [];\n    var rowsObject = this.groupCache[this.parent.pageSettings.currentPage];\n    var k = index;\n\n    for (var i = 0; i < this.pageSize; i++) {\n      if (!rowsObject[k] || rowsObject[k].indent < rowsObject[index].indent) {\n        break;\n      }\n\n      if (rowsObject[k].indent === rowsObject[index].indent) {\n        rows.push(rowsObject[k]);\n\n        if (rowsObject[k].isCaptionRow && rowsObject[k].isExpand) {\n          rows = rows.concat(this.getChildRowsByParentIndex(k, true, true, null, true));\n        }\n      }\n\n      if (rowsObject[k].indent > rowsObject[index].indent || isNullOrUndefined(rowsObject[k].indent)) {\n        i--;\n      }\n\n      k++;\n    }\n\n    return rows;\n  };\n\n  GroupLazyLoadRenderer.prototype.getCacheRowsOnUpScroll = function (start, end, index) {\n    var rows = [];\n    var rowsObject = this.groupCache[this.parent.pageSettings.currentPage];\n    var str = false;\n\n    for (var i = 0; i < rowsObject.length; i++) {\n      if (str && (!rowsObject[i] || rowsObject[i].indent < rowsObject[index].indent || rowsObject[i].uid === end)) {\n        break;\n      }\n\n      if (!str && rowsObject[i].uid === start) {\n        str = true;\n      }\n\n      if (str && rowsObject[i].indent === rowsObject[index].indent) {\n        rows.push(rowsObject[i]);\n\n        if (rowsObject[i].isCaptionRow && rowsObject[i].isExpand) {\n          rows = rows.concat(this.getChildRowsByParentIndex(i, true, true, null, true));\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  GroupLazyLoadRenderer.prototype.scrollHandler = function (e) {\n    if (this.parent.isDestroyed || this.childCount) {\n      return;\n    }\n\n    var downTrs = [].slice.call(this.parent.getContent().getElementsByClassName('e-lazyload-middle-down'));\n    var upTrs = [].slice.call(this.parent.getContent().getElementsByClassName('e-lazyload-middle-up'));\n    var endTrs = [].slice.call(this.parent.getContent().getElementsByClassName('e-not-lazyload-end'));\n    var tr;\n    var lazyLoadDown = false;\n    var lazyLoadUp = false;\n    var lazyLoadEnd = false;\n\n    if (e.scrollDown && downTrs.length) {\n      var result = this.findRowElements(downTrs);\n      tr = result.tr;\n      lazyLoadDown = result.entered;\n    }\n\n    if (!e.scrollDown && endTrs) {\n      for (var i = 0; i < endTrs.length; i++) {\n        var top_1 = endTrs[i].getBoundingClientRect().top;\n        var scrollHeight = this.parent.getContent().scrollHeight;\n\n        if (top_1 > 0 && top_1 < scrollHeight) {\n          tr = endTrs[i];\n          lazyLoadEnd = true;\n          this.rowIndex = tr.rowIndex;\n          break;\n        }\n      }\n    }\n\n    if (!e.scrollDown && upTrs.length && !lazyLoadEnd) {\n      var result = this.findRowElements(upTrs);\n      tr = result.tr;\n      lazyLoadUp = result.entered;\n    }\n\n    if (tr) {\n      if (lazyLoadDown && e.scrollDown && lazyLoadDown && tr) {\n        this.scrollDownHandler(tr);\n      }\n\n      if (!e.scrollDown && lazyLoadEnd && tr) {\n        this.scrollUpEndRowHandler(tr);\n      }\n\n      if (this.cacheMode && !e.scrollDown && !lazyLoadEnd && lazyLoadUp && tr) {\n        this.scrollUpHandler(tr);\n      }\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.scrollUpEndRowHandler = function (tr) {\n    var page = this.parent.pageSettings.currentPage;\n    var rows = this.groupCache[page];\n    var uid = tr.getAttribute('data-uid');\n    var index = this.rowObjectIndex = this.getRowObjectIndexByUid(uid);\n    var idx = index;\n    var childRow = rows[index];\n    var parentCapRow = this.getRowByUid(childRow.parentUid);\n    var capRowObjIdx = this.getRowObjectIndexByUid(parentCapRow.uid);\n    var captionRowEle = this.parent.getContent().querySelector('tr[data-uid=' + parentCapRow.uid + ']');\n    var capRowEleIndex = captionRowEle.rowIndex;\n    var child = this.getChildRowsByParentIndex(capRowObjIdx);\n    var childIdx = child.indexOf(childRow);\n    var currentPage = Math.ceil(childIdx / this.pageSize);\n\n    if (currentPage === 1) {\n      return;\n    }\n\n    this.childCount = currentPage * this.pageSize;\n    index = this.getCurrentBlockEndIndex(childRow, index);\n\n    if (this.childCount < parentCapRow.data.count) {\n      tr.classList.remove('e-not-lazyload-end');\n      childRow.lazyLoadCssClass = '';\n      var isRowExist = rows[index + 1] ? childRow.indent === rows[index + 1].indent : false;\n      this.scrollData = isRowExist ? this.getCacheRowsOnDownScroll(index + 1) : [];\n      var key = getGroupKeysAndFields(capRowObjIdx, rows);\n      var args = {\n        rowIndex: capRowEleIndex,\n        makeRequest: !isRowExist,\n        groupInfo: parentCapRow,\n        fields: key.fields,\n        keys: key.keys,\n        skip: this.childCount,\n        take: this.pageSize,\n        isScroll: true\n      };\n\n      if (this.cacheMode && this.childCount >= this.pageSize * this.cacheBlockSize) {\n        var child_1 = this.getChildRowsByParentIndex(capRowObjIdx);\n        var currenBlock = Math.ceil(child_1.indexOf(rows[idx]) / this.pageSize);\n        var removeBlock = currenBlock - (this.cacheBlockSize - 1);\n        this.removeBlock(uid, isRowExist, removeBlock, child_1);\n        args.cachedRowIndex = removeBlock * this.pageSize;\n      }\n\n      this.captionRowExpand(args);\n    } else {\n      this.childCount = 0;\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.scrollDownHandler = function (tr) {\n    var page = this.parent.pageSettings.currentPage;\n    var rows = this.groupCache[page];\n    var uid = tr.getAttribute('data-uid');\n    var index = this.getRowObjectIndexByUid(uid);\n    var idx = index;\n    var childRow = rows[index];\n    var parentCapRow = this.getRowByUid(childRow.parentUid);\n    var capRowObjIdx = this.getRowObjectIndexByUid(parentCapRow.uid);\n    var captionRowEle = this.getRowElementByUid(parentCapRow.uid);\n    var capRowEleIndex = captionRowEle.rowIndex;\n    var child = this.getChildRowsByParentIndex(capRowObjIdx);\n    var childIdx = child.indexOf(childRow);\n    var currentPage = Math.ceil(childIdx / this.pageSize);\n    this.childCount = currentPage * this.pageSize;\n    index = this.rowObjectIndex = this.getRowObjectIndexByUid(child[this.childCount - 1].uid);\n    var lastchild = rows[index];\n    var lastRow = this.getRowElementByUid(lastchild.uid);\n    this.rowIndex = lastRow.rowIndex;\n    index = this.getCurrentBlockEndIndex(lastchild, index);\n\n    if (this.childCount < parentCapRow.data.count) {\n      var isRowExist = rows[index + 1] ? childRow.indent === rows[index + 1].indent : false;\n\n      if (isRowExist && !isNullOrUndefined(this.getRowElementByUid(rows[index + 1].uid))) {\n        this.childCount = 0;\n        return;\n      }\n\n      if (currentPage > 1 || !this.cacheMode) {\n        tr.classList.remove('e-lazyload-middle-down');\n        lastRow.classList.remove('e-not-lazyload-end');\n        lastchild.lazyLoadCssClass = '';\n      }\n\n      this.scrollData = isRowExist ? this.getCacheRowsOnDownScroll(this.rowObjectIndex + 1) : [];\n      var query = getGroupKeysAndFields(capRowObjIdx, rows);\n      var args = {\n        rowIndex: capRowEleIndex,\n        makeRequest: !isRowExist,\n        groupInfo: parentCapRow,\n        fields: query.fields,\n        keys: query.keys,\n        skip: this.childCount,\n        take: this.pageSize,\n        isScroll: true\n      };\n\n      if (this.cacheMode && this.childCount - this.pageSize >= this.pageSize * this.cacheBlockSize) {\n        this.isScrollDown = true;\n        var child_2 = this.getChildRowsByParentIndex(capRowObjIdx);\n        var currenBlock = Math.ceil(child_2.indexOf(rows[idx]) / this.pageSize) - 1;\n        var removeBlock = currenBlock - (this.cacheBlockSize - 1) + 1;\n        this.removeBlock(uid, isRowExist, removeBlock, child_2, lastchild);\n        args.cachedRowIndex = removeBlock * this.pageSize;\n      }\n\n      this.captionRowExpand(args);\n    } else {\n      this.childCount = 0;\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.getCurrentBlockEndIndex = function (row$$1, index) {\n    var page = this.parent.pageSettings.currentPage;\n    var rows = this.groupCache[page];\n\n    if (row$$1.isCaptionRow) {\n      if (row$$1.isExpand) {\n        var childCount = this.getChildRowsByParentIndex(index, true).length;\n        this.rowIndex = this.rowIndex + childCount;\n      }\n\n      var agg = this.getAggregateByCaptionIndex(index);\n      this.rowObjectIndex = this.rowObjectIndex + agg.length;\n      var idx = index;\n\n      for (var i = idx + 1; i < rows.length; i++) {\n        if (rows[i].indent === rows[index].indent || rows[i].indent < rows[index].indent) {\n          index = idx;\n          break;\n        } else {\n          idx++;\n        }\n      }\n    }\n\n    return index;\n  };\n\n  GroupLazyLoadRenderer.prototype.removeBlock = function (uid, isRowExist, removeBlock, child, lastchild) {\n    var page = this.parent.pageSettings.currentPage;\n    var rows = this.groupCache[page];\n    var uid1 = child[(removeBlock + 1) * this.pageSize - 1 - this.blockSize].uid;\n    var uid2 = child[removeBlock * this.pageSize - this.pageSize].uid;\n    var uid3 = child[removeBlock * this.pageSize].uid;\n    var firstIdx = this.getRowObjectIndexByUid(uid1);\n    rows[firstIdx].lazyLoadCssClass = 'e-lazyload-middle-up';\n    this.getRowElementByUid(uid1).classList.add('e-lazyload-middle-up');\n\n    if (lastchild) {\n      this.getRowElementByUid(uid3).classList.add('e-not-lazyload-first');\n      this.getRowByUid(uid3).lazyLoadCssClass = 'e-not-lazyload-first';\n      this.getRowByUid(uid2).lazyLoadCssClass = '';\n    }\n\n    if (isRowExist) {\n      this.removeTopRows(lastchild ? lastchild.uid : uid, uid2, uid3);\n    } else {\n      this.uid1 = uid2;\n      this.uid2 = uid3;\n      this.uid3 = lastchild ? lastchild.uid : uid;\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.scrollUpHandler = function (tr) {\n    var page = this.parent.pageSettings.currentPage;\n    var rows = this.groupCache[page];\n    var uid = tr.getAttribute('data-uid');\n    var row$$1 = this.getRowByUid(uid);\n    var index = this.rowObjectIndex = this.getRowObjectIndexByUid(uid);\n    var parentCapRow = this.getRowByUid(row$$1.parentUid);\n    var capRowObjIdx = this.rowIndex = this.getRowObjectIndexByUid(parentCapRow.uid);\n    var captionRowEle = this.parent.getRowElementByUID(parentCapRow.uid);\n    var capRowEleIndex = captionRowEle.rowIndex;\n    var child = this.getChildRowsByParentIndex(capRowObjIdx);\n    var childIdx = child.indexOf(rows[index]);\n    var currenBlock = Math.floor(childIdx / this.pageSize);\n    var idx = this.blockSize;\n\n    if (this.blockSize * 2 > this.pageSize) {\n      idx = this.blockSize * 2 - this.pageSize;\n      idx = this.blockSize - idx;\n    }\n\n    var start = child[childIdx - (idx - 1) - this.pageSize].uid;\n    var end = child[childIdx - (idx - 1)].uid;\n    this.scrollData = this.getCacheRowsOnUpScroll(start, end, index - (idx - 1));\n    this.isFirstChildRow = currenBlock > 1;\n\n    if (this.isFirstChildRow) {\n      this.scrollData[0].lazyLoadCssClass = 'e-not-lazyload-first';\n    }\n\n    this.getRowByUid(end).lazyLoadCssClass = '';\n    this.getRowElementByUid(end).classList.remove('e-not-lazyload-first');\n    var removeBlock = currenBlock + this.cacheBlockSize;\n\n    if (child.length !== parentCapRow.data.count && removeBlock * this.pageSize > child.length) {\n      this.isFirstChildRow = false;\n      this.scrollData[0].lazyLoadCssClass = '';\n      this.getRowElementByUid(end).classList.add('e-not-lazyload-first');\n      return;\n    }\n\n    var count = removeBlock * this.pageSize > parentCapRow.data.count ? parentCapRow.data.count : removeBlock * this.pageSize;\n    var size = removeBlock * this.pageSize > parentCapRow.data.count ? this.pageSize - (this.pageSize * removeBlock - parentCapRow.data.count) : this.pageSize;\n    var childRows = this.getChildRowsByParentIndex(rows.indexOf(child[count - 1]), true, false, null, true);\n    var uid1 = childRows.length ? childRows[childRows.length - 1].uid : child[count - 1].uid;\n    var uid2 = child[count - size].uid;\n    var uid3 = child[count - size - 1].uid;\n    var lastIdx = this.objIdxByUid[page][uid2] - idx;\n\n    if (rows[lastIdx].lazyLoadCssClass === 'e-lazyload-middle-down') {\n      var trEle = this.getRowElementByUid(rows[lastIdx].uid);\n\n      if (trEle) {\n        trEle.classList.add('e-lazyload-middle-down');\n      }\n    }\n\n    this.getRowByUid(uid1).lazyLoadCssClass = '';\n    this.getRowByUid(uid3).lazyLoadCssClass = 'e-not-lazyload-end';\n    this.getRowElementByUid(uid3).classList.add('e-not-lazyload-end');\n    this.removeBottomRows(uid1, uid2, uid3);\n    this.rowIndex = tr.rowIndex - idx;\n\n    if (tr.classList.length > 1) {\n      tr.classList.remove('e-lazyload-middle-up');\n    } else {\n      tr.removeAttribute('class');\n    }\n\n    if (!isNullOrUndefined(this.getRowElementByUid(start))) {\n      this.childCount = 0;\n      this.scrollData = [];\n      return;\n    }\n\n    var key = getGroupKeysAndFields(this.getRowObjectIndexByUid(parentCapRow.uid), rows);\n    var args = {\n      rowIndex: capRowEleIndex,\n      makeRequest: false,\n      groupInfo: parentCapRow,\n      fields: key.fields,\n      keys: key.keys,\n      skip: this.childCount,\n      take: this.pageSize,\n      isScroll: true,\n      scrollUp: true\n    };\n    this.isScrollUp = true;\n    this.captionRowExpand(args);\n  };\n\n  GroupLazyLoadRenderer.prototype.findRowElements = function (rows) {\n    var entered = false;\n    var tr;\n\n    for (var i = 0; i < rows.length; i++) {\n      var rowIdx = rows[i].rowIndex;\n\n      if (isRowEnteredInGrid(rowIdx, this.parent)) {\n        entered = true;\n        this.rowIndex = rowIdx;\n        tr = rows[i];\n        break;\n      }\n    }\n\n    return {\n      entered: entered,\n      tr: tr\n    };\n  };\n\n  GroupLazyLoadRenderer.prototype.getRowElementByUid = function (uid) {\n    return this.parent.getContent().querySelector('tr[data-uid=' + uid + ']');\n  };\n\n  GroupLazyLoadRenderer.prototype.removeTopRows = function (uid1, uid2, uid3) {\n    var trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n    var start = false;\n\n    for (var i = 0; i < trs.length; i++) {\n      if (trs[i].getAttribute('data-uid') === uid3) {\n        var tr = this.parent.getContent().querySelector('tr[data-uid=' + uid1 + ']');\n\n        if (tr) {\n          this.rowIndex = tr.rowIndex;\n        }\n\n        break;\n      }\n\n      if (trs[i].getAttribute('data-uid') === uid2) {\n        start = true;\n      }\n\n      if (start) {\n        remove(trs[i]);\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  GroupLazyLoadRenderer.prototype.removeBottomRows = function (uid1, uid2, uid3) {\n    var trs = [].slice.call(this.parent.getContent().querySelectorAll('tr'));\n    var trigger = false;\n\n    for (var i = 0; i < trs.length; i++) {\n      if (trs[i].getAttribute('data-uid') === uid2) {\n        trigger = true;\n      }\n\n      if (trigger) {\n        remove(trs[i]);\n\n        if (trs[i].getAttribute('data-uid') === uid1) {\n          break;\n        }\n      }\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.setCache = function (e) {\n    var page = this.parent.pageSettings.currentPage;\n\n    if (this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll' && e.args['prevPage'] != e.args['currentPage']) {\n      this.groupCache[page] = this.initialGroupCaptions[page] = this.groupCache[e.args['prevPage']].concat(extend([], e.data));\n    } else {\n      this.groupCache[page] = this.initialGroupCaptions[page] = extend([], e.data);\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.captionRowExpand = function (args) {\n    var _this = this;\n\n    var captionRow = args.groupInfo;\n    var level = this.parent.groupSettings.columns.indexOf(captionRow.data.field) + 1;\n    var pred = generateExpandPredicates(args.fields, args.keys, this);\n    var predicateList = getPredicates(pred);\n    var lazyLoad = {\n      level: level,\n      skip: args.skip,\n      take: args.take,\n      where: predicateList\n    };\n\n    if (args.makeRequest) {\n      var query = this.parent.renderModule.data.generateQuery(true);\n\n      if (!query.isCountRequired) {\n        query.isCountRequired = true;\n      }\n\n      query.lazyLoad.push({\n        key: 'onDemandGroupInfo',\n        value: lazyLoad\n      });\n\n      if (args.isScroll && this.parent.enableVirtualMaskRow) {\n        this.parent.showMaskRow();\n      } else {\n        this.parent.showSpinner();\n      }\n\n      this.parent.renderModule.data.getData({}, query).then(function (e) {\n        _this.parent.hideSpinner();\n\n        _this.parent.removeMaskRow();\n\n        if (e.result.length === 0) {\n          return;\n        }\n\n        if (_this.cacheMode && _this.uid1 && _this.uid2) {\n          _this.removeTopRows(_this.uid3, _this.uid1, _this.uid2);\n\n          _this.uid1 = _this.uid2 = _this.uid3 = undefined;\n        }\n\n        _this.lazyLoadHandler({\n          data: e.result,\n          count: e.count,\n          level: level,\n          index: args.rowIndex,\n          isRowExist: false,\n          isScroll: args.isScroll,\n          up: false,\n          rowIndex: args.cachedRowIndex\n        });\n      }).catch(function (e) {\n        return _this.parent.renderModule.dataManagerFailure(e, {\n          requestType: 'grouping'\n        });\n      });\n    } else {\n      this.lazyLoadHandler({\n        data: null,\n        count: args.groupInfo.data.count,\n        level: level,\n        index: args.rowIndex,\n        isRowExist: true,\n        isScroll: args.isScroll,\n        up: args.scrollUp,\n        rowIndex: args.cachedRowIndex\n      });\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.scrollReset = function (top) {\n    this.parent.getContent().firstElementChild.scrollTop = top ? this.parent.getContent().firstElementChild.scrollTop + top : 0;\n  };\n\n  GroupLazyLoadRenderer.prototype.updateCurrentViewData = function () {\n    var records = [];\n    this.getRows().filter(function (row$$1) {\n      if (row$$1.isDataRow) {\n        records[row$$1.index] = row$$1.data;\n      }\n    });\n    this.parent.currentViewData = records.length ? records : this.parent.currentViewData;\n  };\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden */\n\n\n  GroupLazyLoadRenderer.prototype.getGroupCache = function () {\n    return this.groupCache;\n  };\n  /**\n   * @returns {Row<Column>[]} returns the row\n   * @hidden */\n\n\n  GroupLazyLoadRenderer.prototype.getRows = function () {\n    return this.groupCache[this.parent.pageSettings.currentPage] || [];\n  };\n  /**\n   * @returns {Element} returns the element\n   * @hidden */\n\n\n  GroupLazyLoadRenderer.prototype.getRowElements = function () {\n    return [].slice.call(this.parent.getContent().getElementsByClassName(row));\n  };\n  /**\n   * @param {number} index - specifies the index\n   * @returns {Element} returns the element\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.getRowByIndex = function (index) {\n    var tr = [].slice.call(this.parent.getContent().getElementsByClassName(row));\n    var row$$1;\n\n    for (var i = 0; !isNullOrUndefined(index) && i < tr.length; i++) {\n      if (tr[i].getAttribute(dataRowIndex) === index.toString()) {\n        row$$1 = tr[i];\n        break;\n      }\n    }\n\n    return row$$1;\n  };\n  /**\n   * Tucntion to set the column visibility\n   *\n   * @param {Column[]} columns - specifies the column\n   * @returns {void}\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var rows = this.getRows();\n    var testRow;\n    rows.some(function (r) {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    var contentrows = this.getRows().filter(function (row$$1) {\n      return !row$$1.isDetailRow;\n    });\n\n    for (var i = 0; i < columns.length; i++) {\n      var column = columns[i];\n      var idx = this.parent.getNormalizedColumnIndex(column.uid);\n      var colIdx = this.parent.getColumnIndexByUid(column.uid);\n      var displayVal = column.visible === true ? '' : 'none';\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        setStyleAttribute(this.getColGroup().childNodes[idx], {\n          'display': displayVal\n        });\n      }\n\n      this.setDisplayNone(gObj.getDataRows(), colIdx, displayVal, contentrows, idx);\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n  };\n  /**\n   * Function to set display.\n   *\n   * @param {Object} tr - specifies the row object\n   * @param {number} idx - specifies the index\n   * @param {string} displayVal - specifies the display value\n   * @param {Row<Column>[]} rows - specifies the array of rows\n   * @param {number} oriIdx - specifies the index\n   * @returns {void}\n   * @hidden\n   */\n\n\n  GroupLazyLoadRenderer.prototype.setDisplayNone = function (tr, idx, displayVal, rows, oriIdx) {\n    if (!this.parent.groupSettings.columns.length) {\n      setDisplayValue(tr, idx, displayVal, rows);\n    } else {\n      var keys = Object.keys(this.groupCache);\n\n      for (var j = 0; j < keys.length; j++) {\n        var uids = this.rowsByUid[keys[j]];\n        var idxs = Object.keys(uids);\n\n        for (var i = 0; i < idxs.length; i++) {\n          var tr_1 = this.parent.getContent().querySelector('tr[data-uid=' + idxs[i] + ']');\n          var row$$1 = uids[idxs[i]];\n\n          if (row$$1.isCaptionRow) {\n            if (!this.captionModelGen.isEmpty()) {\n              this.changeCaptionRow(row$$1, tr_1, keys[j]);\n            } else {\n              row$$1.cells[row$$1.indent + 1].colSpan = displayVal === '' ? row$$1.cells[row$$1.indent + 1].colSpan + 1 : row$$1.cells[row$$1.indent + 1].colSpan - 1;\n\n              if (tr_1) {\n                tr_1.cells[row$$1.indent + 1].colSpan = row$$1.cells[row$$1.indent + 1].colSpan;\n              }\n            }\n          }\n\n          if (row$$1.isDataRow) {\n            this.showAndHideCells(tr_1, idx, displayVal, false);\n            row$$1.cells[oriIdx].visible = displayVal === '' ? true : false;\n          }\n\n          if (!row$$1.isCaptionRow && !row$$1.isDataRow && isNullOrUndefined(row$$1.indent)) {\n            row$$1.cells[oriIdx].visible = displayVal === '' ? true : false;\n            row$$1.visible = row$$1.cells.some(function (cell) {\n              return cell.isDataCell && cell.visible;\n            });\n            this.showAndHideCells(tr_1, idx, displayVal, true, row$$1);\n          }\n        }\n      }\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.changeCaptionRow = function (row$$1, tr, index) {\n    var capRow = row$$1;\n    var captionData = row$$1.data;\n    var data = this.groupGenerator.generateCaptionRow(captionData, capRow.indent, capRow.parentGid, undefined, capRow.tIndex, capRow.parentUid);\n    data.uid = row$$1.uid;\n    data.isExpand = row$$1.isExpand;\n    data.lazyLoadCssClass = row$$1.lazyLoadCssClass;\n    this.rowsByUid[index][row$$1.uid] = data;\n    this.groupCache[index][this.objIdxByUid[index][row$$1.uid]] = data;\n\n    if (tr) {\n      var tbody$$1 = this.parent.getContentTable().querySelector(tbody);\n      tbody$$1.replaceChild(this.rowRenderer.render(data, this.parent.getColumns()), tr);\n    }\n  };\n\n  GroupLazyLoadRenderer.prototype.showAndHideCells = function (tr, idx, displayVal, isSummary, row$$1) {\n    if (tr) {\n      var cls = isSummary ? 'td.e-summarycell' : 'td.e-rowcell';\n      setStyleAttribute(tr.querySelectorAll(cls)[idx], {\n        'display': displayVal\n      });\n\n      if (tr.querySelectorAll(cls)[idx].classList.contains('e-hide')) {\n        removeClass([tr.querySelectorAll(cls)[idx]], ['e-hide']);\n      }\n\n      if (isSummary) {\n        if (row$$1.visible && tr.classList.contains('e-hide')) {\n          removeClass([tr], ['e-hide']);\n        } else if (!row$$1.visible) {\n          addClass([tr], ['e-hide']);\n        }\n      }\n    }\n  };\n\n  return GroupLazyLoadRenderer;\n}(ContentRender);\n/**\n * Group lazy load class\n */\n\n\nvar LazyLoadGroup =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Constructor for Grid group lazy load module\n   *\n   * @param {IGrid} parent - specifies the IGrid\n   * @param {ServiceLocator} serviceLocator - specifies the ServiceLocator\n   * @hidden\n   */\n  function LazyLoadGroup(parent, serviceLocator) {\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.addEventListener();\n  }\n  /**\n   * For internal use only - Get the module name.\n   *\n   * @returns {string} returns the module name\n   * @private\n   */\n\n\n  LazyLoadGroup.prototype.getModuleName = function () {\n    return 'lazyLoadGroup';\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  LazyLoadGroup.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(initialLoad, this.instantiateRenderer, this);\n    this.parent.on(destroy, this.destroy, this);\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  LazyLoadGroup.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(initialLoad, this.instantiateRenderer);\n    this.parent.off(destroy, this.destroy);\n  };\n\n  LazyLoadGroup.prototype.instantiateRenderer = function () {\n    if (this.parent.height === 'auto') {\n      this.parent.height = this.parent.pageSettings.pageSize * this.parent.getRowHeight();\n    }\n\n    var renderer = this.serviceLocator.getService('rendererFactory');\n\n    if (this.parent.groupSettings.enableLazyLoading) {\n      renderer.addRenderer(RenderType.Content, new GroupLazyLoadRenderer(this.parent, this.serviceLocator));\n    }\n  };\n  /**\n   * @returns {void}\n   * @hidden\n   */\n\n\n  LazyLoadGroup.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  return LazyLoadGroup;\n}();\n/**\n * Action export\n */\n\n/**\n * Models\n */\n\n\nvar __extends$37 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `AutoCompleteEditCell` is used to handle autocomplete cell type editing.\n *\n * @hidden\n */\n\n\nvar AutoCompleteEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$37(AutoCompleteEditCell, _super);\n\n  function AutoCompleteEditCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AutoCompleteEditCell.prototype.write = function (args) {\n    this.column = args.column;\n    var isInlineEdit = this.parent.editSettings.mode !== 'Dialog';\n    this.object = new AutoComplete(extend({\n      dataSource: this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource),\n      query: new Query().select(args.column.field),\n      enabled: isEditable(args.column, args.requestType, args.element),\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      // enableRtl: this.parentect.enableRtl,\n      actionComplete: this.selectedValues.bind(this),\n      placeholder: isInlineEdit ? '' : args.column.headerText,\n      floatLabelType: isInlineEdit ? 'Never' : 'Always'\n    }, args.column.edit.params));\n    this.object.appendTo(args.element);\n    /* tslint:disable-next-line:no-any */\n\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n  };\n\n  AutoCompleteEditCell.prototype.selectedValues = function (valObj) {\n    valObj.result = DataUtil.distinct(valObj.result, this.object.fields.value, true);\n\n    if (this.column.dataSource) {\n      this.column.dataSource.dataSource.json = valObj.result;\n    }\n  };\n\n  return AutoCompleteEditCell;\n}(EditCellBase);\n\nvar __extends$38 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `ComboBoxEditCell` is used to handle ComboBoxEdit cell type editing.\n *\n * @hidden\n */\n\n\nvar ComboboxEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$38(ComboboxEditCell, _super);\n\n  function ComboboxEditCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ComboboxEditCell.prototype.write = function (args) {\n    this.column = args.column;\n    var isInlineMode = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new ComboBox(extend({\n      dataSource: this.parent.dataSource instanceof DataManager ? this.parent.dataSource : new DataManager(this.parent.dataSource),\n      query: new Query().select(args.column.field),\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      enableRtl: this.parent.enableRtl,\n      actionComplete: this.finalValue.bind(this),\n      placeholder: isInlineMode ? '' : args.column.headerText,\n      floatLabelType: isInlineMode ? 'Never' : 'Always',\n      enabled: isEditable(args.column, args.requestType, args.element),\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  };\n\n  ComboboxEditCell.prototype.finalValue = function (val) {\n    val.result = DataUtil.distinct(val.result, this.obj.fields.value, true);\n\n    if (this.column.dataSource) {\n      this.column.dataSource.dataSource.json = val.result;\n    }\n  };\n\n  return ComboboxEditCell;\n}(EditCellBase);\n\nvar __extends$39 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `MultiSelectEditCell` is used to handle multiselect dropdown cell type editing.\n *\n * @hidden\n */\n\n\nvar MultiSelectEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$39(MultiSelectEditCell, _super);\n\n  function MultiSelectEditCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MultiSelectEditCell.prototype.write = function (args) {\n    this.column = args.column;\n    var isInline = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new MultiSelect(extend({\n      fields: {\n        text: args.column.field,\n        value: args.column.field\n      },\n      value: getValue(args.column.field, args.rowData),\n      enableRtl: this.parent.enableRtl,\n      placeholder: isInline ? '' : args.column.headerText,\n      popupHeight: '200px',\n      floatLabelType: isInline ? 'Never' : 'Always',\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n    args.element.setAttribute('name', getComplexFieldID(args.column.field));\n  };\n\n  return MultiSelectEditCell;\n}(EditCellBase);\n\nvar __extends$40 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `TimePickerEditCell` is used to handle Timepicker cell type editing.\n *\n * @hidden\n */\n\n\nvar TimePickerEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$40(TimePickerEditCell, _super);\n\n  function TimePickerEditCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimePickerEditCell.prototype.write = function (args) {\n    var isInlineEdit = this.parent.editSettings.mode !== 'Dialog';\n    var rowDataValue = getObject(args.column.field, args.rowData);\n    rowDataValue = rowDataValue ? new Date(rowDataValue) : null;\n    this.obj = new TimePicker(extend({\n      floatLabelType: isInlineEdit ? 'Never' : 'Always',\n      value: rowDataValue,\n      placeholder: isInlineEdit ? '' : args.column.headerText,\n      enableRtl: this.parent.enableRtl,\n      enabled: isEditable(args.column, args.requestType, args.element),\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  };\n\n  return TimePickerEditCell;\n}(EditCellBase);\n\nvar __extends$41 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `ToggleEditCell` is used to handle boolean cell type editing.\n *\n * @hidden\n */\n\n\nvar ToggleEditCell =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$41(ToggleEditCell, _super);\n\n  function ToggleEditCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.activeClasses = ['e-selectionbackground', 'e-active'];\n    return _this;\n  }\n\n  ToggleEditCell.prototype.create = function (args) {\n    var clsNames = 'e-field e-boolcell';\n\n    if (args.column.type === 'checkbox') {\n      clsNames = 'e-field e-boolcell e-edit-checkselect';\n    }\n\n    return createEditElement(this.parent, args.column, clsNames, {\n      type: 'checkbox',\n      value: args.value\n    });\n  };\n\n  ToggleEditCell.prototype.read = function (element) {\n    return element.checked;\n  };\n\n  ToggleEditCell.prototype.write = function (args) {\n    var chkBoxElement = !isNullOrUndefined(args.row) && args.row.querySelector('.e-edit-checkselect');\n    var data = getObject(args.column.field, args.rowData);\n    var checkState = data && JSON.parse(data.toString().toLowerCase());\n\n    if (!isNullOrUndefined(chkBoxElement)) {\n      this.editType = this.parent.editSettings.mode;\n      this.editRow = args.row;\n\n      if (args.requestType !== 'add') {\n        var row$$1 = this.parent.getRowObjectFromUID(args.row.getAttribute('data-uid'));\n        checkState = row$$1 ? row$$1.isSelected : false;\n      }\n\n      addRemoveActiveClasses.apply(void 0, [[].slice.call(args.row.getElementsByClassName(rowCell)), checkState].concat(this.activeClasses));\n    }\n\n    this.obj = new Switch(extend({\n      label: this.parent.editSettings.mode !== 'Dialog' ? ' ' : args.column.headerText,\n      checked: checkState,\n      disabled: !isEditable(args.column, args.requestType, args.element),\n      enableRtl: this.parent.enableRtl,\n      change: this.switchModeChange.bind(this),\n      cssClass: this.parent.cssClass ? this.parent.cssClass : ''\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  };\n\n  ToggleEditCell.prototype.switchModeChange = function (args) {\n    if (this.editRow && this.editType !== 'Dialog') {\n      var addClass$$1 = false;\n\n      if (!args.checked) {\n        this.editRow.removeAttribute('aria-selected');\n      } else {\n        addClass$$1 = true;\n        this.editRow.setAttribute('aria-selected', addClass$$1.toString());\n      }\n\n      addRemoveActiveClasses.apply(void 0, [[].slice.call(this.editRow.getElementsByClassName(rowCell)), addClass$$1].concat(this.activeClasses));\n    }\n  };\n\n  return ToggleEditCell;\n}(EditCellBase);\n\nvar __extends$42 = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * `MaskedTextBoxCellEdit` is used to handle masked input cell type editing.\n *\n * @hidden\n */\n\n\nvar MaskedTextBoxCellEdit =\n/** @__PURE__ @class */\nfunction (_super) {\n  __extends$42(MaskedTextBoxCellEdit, _super);\n\n  function MaskedTextBoxCellEdit() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MaskedTextBoxCellEdit.prototype.write = function (args) {\n    this.column = args.column;\n    var isInlineEdit = this.parent.editSettings.mode !== 'Dialog';\n    this.obj = new MaskedTextBox(extend({\n      fields: {\n        value: args.column.field\n      },\n      value: getObject(args.column.field, args.rowData),\n      floatLabelType: isInlineEdit ? 'Never' : 'Always',\n      mask: '000-000-0000',\n      enabled: isEditable(args.column, args.requestType, args.element),\n      cssClass: this.parent.cssClass ? this.parent.cssClass : null\n    }, args.column.edit.params));\n    this.obj.appendTo(args.element);\n  };\n\n  return MaskedTextBoxCellEdit;\n}(EditCellBase);\n/**\n * Models\n */\n\n/**\n * Services\n */\n\n/**\n * Grid component exported items\n */\n\n/**\n * Pager component exported items\n */\n\n/**\n * Export Grid components\n */\n\n\nexport { CheckBoxFilterBase, ExcelFilterBase, SortDescriptor, SortSettings, Predicate$1 as Predicate, InfiniteScrollSettings, FilterSettings, SelectionSettings, SearchSettings, RowDropSettings, TextWrapSettings, ResizeSettings, GroupSettings, EditSettings, LoadingIndicator, Grid, CellType, RenderType, ToolbarItem, ResponsiveDialogAction, ResponsiveToolbarAction, doesImplementInterface, valueAccessor, headerValueAccessor, getUpdateUsingRaf, isExportColumns, updateColumnTypeForExportColumns, updatecloneRow, getCollapsedRowsCount, recursive, iterateArrayOrObject, iterateExtend, templateCompiler, setStyleAndAttributes, extend$1 as extend, setColumnIndex, prepareColumns, setCssInGridPopUp, getActualProperties, parentsUntil, getElementIndex, inArray, getActualPropFromColl, removeElement, getPosition, getUid, appendChildren, parents, calculateAggregate, getScrollBarWidth, getRowHeight, getActualRowHeight, isComplexField, getComplexFieldID, setComplexFieldID, isEditable, isActionPrevent, wrap, setFormatter, addRemoveActiveClasses, distinctStringValues, getFilterMenuPostion, getZIndexCalcualtion, toogleCheckbox, setChecked, createCboxWithWrap, removeAddCboxClasses, refreshForeignData, getForeignData, getColumnByForeignKeyValue, getDatePredicate, renderMovable, isGroupAdaptive, getObject, getCustomDateFormat, getExpandedState, getPrintGridModel, extendObjWithFn, measureColumnDepth, checkDepth, refreshFilteredColsUid, Global, getTransformValues, applyBiggerTheme, alignFrozenEditForm, ensureLastRow, ensureFirstRow, isRowEnteredInGrid, getEditedDataIndex, eventPromise, getStateEventArgument, ispercentageWidth, resetRowIndex, compareChanges, setRowElements, splitFrozenRowObjectCells, gridActionHandler, getGridRowObjects, getGridRowElements, sliceElements, getCellsByTableName, getCellByColAndRowIndex, setValidationRuels, getMovableTbody, getFrozenRightTbody, setRowsInTbody, getNumberFormat, addBiggerDialog, performComplexDataOperation, setDisplayValue, addRemoveEventListener, createEditElement, getColumnModelByUid, getColumnModelByFieldName, registerEventHandlers, removeEventHandlers, clearReactVueTemplates, getRowIndexFromElement, generateExpandPredicates, getPredicates, getGroupKeysAndFields, findCellIndex, created, destroyed, load, rowDataBound, queryCellInfo, headerCellInfo, actionBegin, actionComplete, actionFailure, dataBound, rowSelecting, rowSelected, rowDeselecting, rowDeselected, cellSelecting, cellSelected, cellDeselecting, cellDeselected, columnSelecting, columnSelected, columnDeselecting, columnDeselected, columnDragStart, columnDrag, columnDrop, rowDragStartHelper, rowDragStart, rowDrag, rowDrop, beforePrint, printComplete, detailDataBound, toolbarClick, batchAdd, batchCancel, batchDelete, beforeBatchAdd, beforeBatchDelete, beforeBatchSave, beginEdit, cellEdit, cellSave, cellSaved, endAdd, endDelete, endEdit, recordDoubleClick, recordClick, beforeDataBound, beforeOpenColumnChooser, beforeOpenAdaptiveDialog, resizeStart, onResize, resizeStop, checkBoxChange, beforeCopy, beforePaste, beforeAutoFill, filterChoiceRequest, filterAfterOpen, filterBeforeOpen, filterSearchBegin, commandClick, exportGroupCaption, lazyLoadGroupExpand, lazyLoadGroupCollapse, initialLoad, initialEnd, dataReady, contentReady, uiUpdate, onEmpty, inBoundModelChanged, modelChanged, colGroupRefresh, headerRefreshed, pageBegin, pageComplete, sortBegin, sortComplete, filterBegin, filterComplete, searchBegin, searchComplete, reorderBegin, reorderComplete, rowDragAndDropBegin, rowDragAndDropComplete, groupBegin, groupComplete, ungroupBegin, ungroupComplete, groupAggregates, refreshFooterRenderer, refreshAggregateCell, refreshAggregates, rowSelectionBegin, rowSelectionComplete, columnSelectionBegin, columnSelectionComplete, cellSelectionBegin, cellSelectionComplete, beforeCellFocused, cellFocused, keyPressed, click, destroy, columnVisibilityChanged, scroll, columnWidthChanged, columnPositionChanged, rowDragAndDrop, rowsAdded, rowsRemoved, columnDragStop, headerDrop, dataSourceModified, refreshComplete, refreshVirtualBlock, dblclick, toolbarRefresh, bulkSave, autoCol, tooltipDestroy, updateData, editBegin, editComplete, addBegin, addComplete, saveComplete, deleteBegin, deleteComplete, preventBatch, dialogDestroy, crudAction, addDeleteAction, destroyForm, doubleTap, beforeExcelExport, excelExportComplete, excelQueryCellInfo, excelHeaderQueryCellInfo, exportDetailDataBound, beforePdfExport, pdfExportComplete, pdfQueryCellInfo, pdfHeaderQueryCellInfo, accessPredicate, contextMenuClick, freezeRender, freezeRefresh, contextMenuOpen, columnMenuClick, columnMenuOpen, filterOpen, filterDialogCreated, filterMenuClose, initForeignKeyColumn, getForeignKeyData, generateQuery, showEmptyGrid, foreignKeyData, columnDataStateChange, dataStateChange, dataSourceChanged, rtlUpdated, beforeFragAppend, frozenHeight, textWrapRefresh, recordAdded, cancelBegin, editNextValCell, hierarchyPrint, expandChildGrid, printGridInit, exportRowDataBound, exportDataBound, rowPositionChanged, columnChooserOpened, batchForm, beforeStartEdit, beforeBatchCancel, batchEditFormRendered, partialRefresh, beforeCustomFilterOpen, selectVirtualRow, columnsPrepared, cBoxFltrBegin, cBoxFltrComplete, fltrPrevent, beforeFltrcMenuOpen, valCustomPlacement, filterCboxValue, componentRendered, restoreFocus, detailStateChange, detailIndentCellInfo, virtaulKeyHandler, virtaulCellFocus, virtualScrollEditActionBegin, virtualScrollEditSuccess, virtualScrollEditCancel, virtualScrollEdit, refreshVirtualCache, editReset, virtualScrollAddActionBegin, getVirtualData, refreshInfiniteModeBlocks, resetInfiniteBlocks, infiniteScrollHandler, infinitePageQuery, infiniteShowHide, appendInfiniteContent, removeInfiniteRows, setInfiniteCache, infiniteEditHandler, initialCollapse, getAggregateQuery, closeFilterDialog, columnChooserCancelBtnClick, getFilterBarOperator, resetColumns, pdfAggregateQueryCellInfo, excelAggregateQueryCellInfo, setGroupCache, lazyLoadScrollHandler, groupCollapse, beforeCheckboxRenderer, refreshHandlers, refreshFrozenColumns, setReorderDestinationElement, refreshVirtualFrozenHeight, setFreezeSelection, setInfiniteFrozenHeight, setInfiniteColFrozenHeight, beforeRefreshOnDataChange, immutableBatchCancel, refreshVirtualFrozenRows, checkScrollReset, refreshFrozenHeight, setHeightToFrozenElement, preventFrozenScrollRefresh, nextCellIndex, refreshInfiniteCurrentViewData, infiniteCrudCancel, filterDialogClose, refreshCustomFilterOkBtn, refreshCustomFilterClearBtn, renderResponsiveCmenu, filterCmenuSelect, customFilterClose, setFullScreenDialog, refreshExpandandCollapse, rowModeChange, enterKeyHandler, refreshVirtualMaxPage, setVirtualPageQuery, selectRowOnContextOpen, pagerRefresh, closeInline, closeBatch, closeEdit, resetVirtualFocus, afterContentRender, refreshVirtualEditFormCells, scrollToEdit, beforeCheckboxRendererQuery, createVirtualValidationForm, validateVirtualForm, destroyChildGrid, stickyScrollComplete, captionActionComplete, refreshInfinitePersistSelection, refreshInfiniteEditrowindex, afterFilterColumnMenuClose, beforeCheckboxfilterRenderer, commandColumnDestroy, rowCell, gridHeader, gridContent, gridFooter, headerContent, movableContent, movableHeader, frozenContent, frozenHeader, content, table, row, gridChkBox, editedRow, addedRow, changedRecords, addedRecords, deletedRecords, leftRight, frozenRight, frozenLeft, dataColIndex, ariaColIndex, dataRowIndex, ariaRowIndex, tbody, colGroup, open, change, focus, create, beforeOpen, downArrow, upArrow, pageUp, pageDown, enter, shiftEnter, tab, shiftTab, Data, Sort, Page, Selection, Filter, Search, Scroll, resizeClassList, Resize, Reorder, RowDD, Group, getCloneProperties, Print, DetailRow, Toolbar$1 as Toolbar, Aggregate, summaryIterator, VirtualScroll, Edit, BatchEdit, InlineEdit, NormalEdit, DialogEdit, ColumnChooser, ExcelExport, PdfExport, ExportHelper, ExportValueFormatter, Clipboard, CommandColumn, CheckBoxFilter, menuClass, ContextMenu$1 as ContextMenu, Freeze, ColumnMenu, ExcelFilter, ForeignKey, Logger, detailLists, InfiniteScroll, LazyLoadGroup, Column, CommandColumnModel, GridColumn, StackedColumn, Row, Cell, HeaderRender, ContentRender, RowRenderer, CellRenderer, HeaderCellRenderer, FilterCellRenderer, StackedHeaderCellRenderer, Render, IndentCellRenderer, GroupCaptionCellRenderer, GroupCaptionEmptyCellRenderer, BatchEditRender, DialogEditRender, InlineEditRender, EditRender, BooleanEditCell, DefaultEditCell, DropDownEditCell, NumericEditCell, DatePickerEditCell, CommandColumnRenderer, FreezeContentRender, FreezeRender, StringFilterUI, NumberFilterUI, DateFilterUI, BooleanFilterUI, FlMenuOptrUI, AutoCompleteEditCell, ComboboxEditCell, MultiSelectEditCell, TimePickerEditCell, ToggleEditCell, MaskedTextBoxCellEdit, VirtualContentRenderer, VirtualHeaderRenderer, VirtualElementHandler, VirtualFreezeRenderer, VirtualFreezeHdrRenderer, renderFrozenRows, splitCells, collectRows, setFreezeSelectionAction, selectFreezeRows, appendContent, generateRows, getReorderedFrozenRows, splitReorderedRows, isXaxis, getHeaderCells, getVirtualFreezeHeader, ensureFrozenCols, setColGroup, setCache, setDebounce, ColumnVirtualFreezeRenderer, GroupLazyLoadRenderer, ColumnFreezeHeaderRenderer, ColumnFreezeContentRenderer, ResponsiveDialogRenderer, EditCellBase, CellRendererFactory, ServiceLocator, RowModelGenerator, GroupModelGenerator, FreezeRowModelGenerator, ValueFormatter, VirtualRowModelGenerator, InterSectionObserver, Pager, ExternalMessage, NumericContainer, PagerMessage, PagerDropDown }; //# sourceMappingURL=ej2-grids.es5.js.map","map":null,"metadata":{},"sourceType":"module"}