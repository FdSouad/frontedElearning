{"ast":null,"code":"/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nclass Save {\n  /**\n   * Initialize new instance of {save}\n   */\n  constructor() {// tslint:disable\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param  {string} fileName- file name to save.\n   * @param  {Blob} buffer- the content to write in file\n   * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n   * @returns {void}\n   */\n\n\n  static save(fileName, buffer) {\n    if (fileName === null || fileName === undefined || fileName === '') {\n      throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n    }\n\n    let extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n    let mimeType = this.getMimeType(extension);\n\n    if (mimeType !== '') {\n      buffer = new Blob([buffer], {\n        type: mimeType\n      });\n    }\n\n    if (this.isMicrosoftBrowser) {\n      navigator.msSaveBlob(buffer, fileName);\n    } else {\n      let downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n      this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n    }\n  }\n\n  static saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n    if (hasDownloadAttribute) {\n      downloadLink.download = fileName;\n      let dataUrl = window.URL.createObjectURL(buffer);\n      downloadLink.href = dataUrl;\n      let event = document.createEvent('MouseEvent');\n      event.initEvent('click', true, true);\n      downloadLink.dispatchEvent(event);\n      setTimeout(() => {\n        window.URL.revokeObjectURL(dataUrl);\n        dataUrl = undefined;\n      });\n    } else {\n      if (extension !== 'docx' && extension !== 'xlsx') {\n        let url = window.URL.createObjectURL(buffer);\n        let isPopupBlocked = window.open(url, '_blank');\n\n        if (!isPopupBlocked) {\n          window.location.href = url;\n        }\n      } else {\n        let reader = new FileReader();\n\n        reader.onloadend = () => {\n          let isPopupBlocked = window.open(reader.result, '_blank');\n\n          if (!isPopupBlocked) {\n            window.location.href = reader.result;\n          }\n        };\n\n        reader.readAsDataURL(buffer);\n      }\n    }\n  }\n  /**\n   *\n   * @param {string} extension - get mime type of the specified extension\n   * @private\n   */\n\n\n  static getMimeType(extension) {\n    let mimeType = '';\n\n    switch (extension) {\n      case 'html':\n        mimeType = 'text/html';\n        break;\n\n      case 'pdf':\n        mimeType = 'application/pdf';\n        break;\n\n      case 'docx':\n        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n        break;\n\n      case 'xlsx':\n        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n        break;\n\n      case 'txt':\n        mimeType = 'text/plain';\n        break;\n    }\n\n    return mimeType;\n  }\n\n}\n/**\n * XmlWriter class provide method to create XML data\n */\n\n\nclass XmlWriter {\n  /**\n   * Initialize new instance of {XmlWriter}\n   */\n  constructor() {\n    this.contentPos = 0;\n    this.bufferText = '';\n    this.bufferBlob = new Blob([''], {\n      type: 'text/plain'\n    });\n    this.currentState = 'Initial';\n    this.namespaceStack = [];\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[2].set('', '', 'Implied');\n    this.elementStack = [];\n    this.elementStack.push(new XmlElement());\n    this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n    this.attributeStack = [];\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  /**\n   * Gets the content written to the {XmlWriter} as Blob.\n   * @returns {Blob}\n   */\n\n\n  get buffer() {\n    this.flush();\n    return this.bufferBlob;\n  }\n  /**\n   * Writes processing instruction with a space between the name and text\n   * @param {string} name - name of the processing instruction\n   * @param {string} text - text to write in the processing instruction\n   * @throws ArgumentException\n   * @throws InvalidArgumentException\n   * @throws InvalidOperationException\n   */\n\n\n  writeProcessingInstruction(name, text) {\n    if (name === undefined || name === null || name.length === 0) {\n      throw new Error('ArgumentException: name should not be undefined, null or empty');\n    }\n\n    this.checkName(name);\n\n    if (text === undefined || text === null) {\n      text = '';\n    }\n\n    if (name.length === 3 && name === 'xml') {\n      if (this.currentState !== 'Initial') {\n        // tslint:disable-next-line:max-line-length\n        throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n      }\n    }\n\n    if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    } else {\n      this.writeStartDocument();\n      this.writeProcessingInstructionInternal(name, text);\n    }\n  }\n  /**\n   * Writes Xml declaration with version and standalone attribute\n   * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n   * @throws InvalidOperation\n   */\n\n\n  writeStartDocument(standalone) {\n    if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n\n    this.currentState = 'StartDocument';\n    this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n\n    if (standalone !== null && standalone !== undefined) {\n      this.rawText('\" standalone=\"');\n      this.rawText(standalone ? 'yes' : 'no');\n    }\n\n    this.rawText('\"?>');\n  }\n  /**\n   * Closes any open tag or attribute and write the state back to start\n   */\n\n\n  writeEndDocument() {\n    while (this.elementStack.length - 1 > 0) {\n      this.writeEndElement();\n    }\n\n    this.currentState = 'EndDocument';\n    this.flush();\n  }\n  /**\n   * Writes the specified start tag and associates it with the given namespace and prefix.\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName -localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @throws ArgumentException\n   * @throws InvalidOperationException\n   */\n\n\n  writeStartElement(prefix, localName, namespace) {\n    if (this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n\n    if (localName === undefined || localName === null || localName.length === 0) {\n      throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n    }\n\n    this.checkName(localName);\n\n    if (this.currentState === 'Initial') {\n      this.writeStartDocument();\n    }\n\n    if (this.currentState === 'StartElement') {\n      this.startElementContent();\n    }\n\n    this.currentState = 'StartElement';\n\n    if (prefix === undefined || prefix === null) {\n      if (namespace !== undefined && namespace !== null) {\n        prefix = this.lookupPrefix(namespace);\n      }\n\n      if (prefix === undefined || prefix === null) {\n        prefix = '';\n      }\n    } else if (prefix.length > 0) {\n      if (namespace === undefined || namespace === null) {\n        namespace = this.lookupNamespace(prefix);\n      }\n\n      if (namespace === undefined || namespace === null || namespace !== undefined && namespace.length === 0) {\n        throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n      }\n    }\n\n    if (namespace === undefined || namespace === null) {\n      namespace = this.lookupNamespace(prefix);\n    }\n\n    this.writeStartElementInternal(prefix, localName, namespace);\n  }\n  /**\n   * Closes one element and pop corresponding namespace scope\n   */\n\n\n  writeEndElement() {\n    if (this.currentState === 'StartElement') {\n      this.startElementContent();\n      this.currentState = 'ElementContent';\n    } else if (this.currentState === 'ElementContent') {\n      this.currentState = 'ElementContent';\n    }\n\n    this.currentState = 'EndElement';\n    let top = this.elementStack.length - 1;\n    this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n    this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n    this.elementStack.splice(top);\n\n    if (this.bufferText.length > 10240) {\n      this.flush();\n    }\n  }\n  /**\n   * Writes an element with the specified prefix, local name, namespace URI, and value.\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName - localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @param {string} value - value of element\n   */\n\n\n  writeElementString(prefix, localName, namespace, value) {\n    this.writeStartElement(prefix, localName, namespace);\n\n    if (value !== undefined && value !== null && value.length !== 0) {\n      this.writeString(value);\n    }\n\n    this.writeEndElement();\n  }\n  /**\n   * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName - localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @param {string} value - value of element\n   */\n\n\n  writeAttributeString(prefix, localName, namespace, value) {\n    this.writeStartAttribute(prefix, localName, namespace, value);\n    this.writeStringInternal(value, true);\n    this.writeEndAttribute();\n  }\n  /**\n   * Writes the given text content\n   * @param {string} text - text to write\n   * @throws InvalidOperationException\n   */\n\n\n  writeString(text) {\n    this.writeInternal(text, false);\n  }\n  /**\n   * Write given text as raw data\n   * @param {string} text - text to write\n   * @throws InvalidOperationException\n   */\n\n\n  writeRaw(text) {\n    this.writeInternal(text, true);\n  }\n\n  writeInternal(text, isRawString) {\n    if (text === undefined || text === null) {\n      return;\n    } else {\n      if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n        throw new Error('InvalidOperationException: Wrong Token');\n      }\n\n      if (this.currentState === 'StartElement') {\n        this.startElementContent();\n      }\n\n      this.currentState = 'ElementContent';\n\n      if (isRawString) {\n        this.rawText(text);\n      } else {\n        this.writeStringInternal(text, false);\n      }\n    }\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param {string} fileName - file name\n   */\n\n\n  save(fileName) {\n    while (this.elementStack.length - 1 > 0) {\n      this.writeEndElement();\n    }\n\n    if (this.bufferText !== '') {\n      this.flush();\n    }\n\n    Save.save(fileName, this.buffer);\n  }\n  /**\n   * Releases the resources used by XmlWriter.\n   */\n\n\n  destroy() {\n    this.bufferBlob = undefined;\n\n    for (let i = 0; i < this.namespaceStack.length; i++) {\n      this.namespaceStack[i].destroy();\n    }\n\n    this.namespaceStack = [];\n\n    for (let i = 0; i < this.elementStack.length; i++) {\n      this.elementStack[i].destroy();\n    }\n\n    this.elementStack = [];\n    this.bufferText = '';\n    this.contentPos = 0;\n  }\n\n  flush() {\n    if (this.bufferBlob === undefined) {\n      return;\n    }\n\n    this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], {\n      type: 'text/plain'\n    });\n    this.bufferText = '';\n  }\n\n  writeProcessingInstructionInternal(name, text) {\n    this.bufferText += '<?';\n    this.rawText(name);\n\n    if (text.length > 0) {\n      this.bufferText += ' ';\n      text = text.replace(/\\?\\>/g, '? >');\n      this.bufferText += text;\n    }\n\n    this.bufferText += '?';\n    this.bufferText += '>';\n  }\n\n  writeStartAttribute(prefix, localName, namespace, value) {\n    if (localName === undefined || localName === null || localName.length === 0) {\n      if (prefix === 'xmlns') {\n        localName = 'xmlns';\n        prefix = '';\n      } else {\n        throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n      }\n    }\n\n    if (this.currentState !== 'StartElement') {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n\n    this.checkName(localName);\n    this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n  }\n\n  writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value) {\n    if (prefix === undefined || prefix === null) {\n      if (namespace !== undefined && namespace !== null) {\n        if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n          prefix = this.lookupPrefix(namespace);\n        }\n      }\n\n      if (prefix === undefined || prefix === null) {\n        prefix = '';\n      }\n    }\n\n    if (namespace === undefined || namespace === null) {\n      if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n        namespace = this.lookupNamespace(prefix);\n      }\n\n      if (namespace === undefined || namespace === null) {\n        namespace = '';\n      }\n    }\n\n    this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n  }\n\n  writeStartAttributeSpecialAttribute(prefix, localName, namespace, value) {\n    if (prefix.length === 0) {\n      if (localName[0] === 'x' && localName === 'xmlns') {\n        this.skipPushAndWrite(prefix, localName, namespace);\n        this.pushNamespaceExplicit('', value);\n        return;\n      } else if (namespace.length > 0) {\n        prefix = this.lookupPrefix(namespace);\n      }\n    } else {\n      if (prefix[0] === 'x') {\n        if (prefix === 'xmlns') {\n          this.skipPushAndWrite(prefix, localName, namespace);\n          this.pushNamespaceExplicit(localName, value);\n          return;\n        } else if (prefix === 'xml') {\n          if (localName === 'space' || localName === 'lang') {\n            this.skipPushAndWrite(prefix, localName, namespace);\n            return;\n          }\n        }\n      }\n\n      if (namespace.length === 0) {\n        prefix = '';\n      }\n    }\n\n    if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n      this.pushNamespaceImplicit(prefix, namespace);\n    }\n\n    this.skipPushAndWrite(prefix, localName, namespace);\n  }\n\n  writeEndAttribute() {\n    this.currentState = 'StartElement';\n    this.bufferText += '\"';\n  }\n\n  writeStartElementInternal(prefix, localName, namespace) {\n    this.bufferText += '<';\n\n    if (prefix.length > 0) {\n      this.rawText(prefix);\n      this.bufferText += ':';\n    }\n\n    this.rawText(localName);\n    let top = this.elementStack.length;\n    this.elementStack.push(new XmlElement());\n    this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n    this.pushNamespaceImplicit(prefix, namespace);\n\n    for (let i = 0; i < this.attributeStack.length; i++) {\n      this.attributeStack[i].destroy();\n    }\n\n    this.attributeStack = [];\n  }\n\n  writeEndElementInternal(prefix, localName) {\n    if (this.contentPos !== this.bufferText.length + 1) {\n      this.bufferText += '</';\n\n      if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n        this.rawText(prefix);\n        this.bufferText += ':';\n      }\n\n      this.rawText(localName);\n      this.bufferText += '>';\n    } else {\n      this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n      this.bufferText += ' />';\n    }\n  }\n\n  writeStartAttributeInternal(prefix, localName, namespaceName) {\n    this.bufferText += ' ';\n\n    if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n      this.rawText(prefix);\n      this.bufferText += ':';\n    }\n\n    this.rawText(localName);\n    this.bufferText += '=';\n    this.bufferText += '\"';\n  }\n\n  writeNamespaceDeclaration(prefix, namespaceUri) {\n    this.writeStartNamespaceDeclaration(prefix);\n    this.writeStringInternal(namespaceUri, true);\n    this.bufferText += '\"';\n  }\n\n  writeStartNamespaceDeclaration(prefix) {\n    if (prefix === undefined || prefix === null || prefix.length === 0) {\n      this.rawText(' xmlns=\\\"');\n    } else {\n      this.rawText(' xmlns:');\n      this.rawText(prefix);\n      this.bufferText += '=';\n      this.bufferText += '\"';\n    }\n  }\n\n  writeStringInternal(text, inAttributeValue) {\n    if (text === null || text === undefined) {\n      text = '';\n    }\n\n    text = text.replace(/\\&/g, '&amp;');\n    text = text.replace(/\\</g, '&lt;');\n    text = text.replace(/\\>/g, '&gt;');\n\n    if (inAttributeValue) {\n      text = text.replace(/\\\"/g, '&quot;');\n    }\n\n    this.bufferText += text;\n\n    if (!inAttributeValue) {\n      this.contentPos = 0;\n    }\n  }\n\n  startElementContent() {\n    let start = this.elementStack[this.elementStack.length - 1].previousTop;\n\n    for (let i = this.namespaceStack.length - 1; i > start; i--) {\n      if (this.namespaceStack[i].kind === 'NeedToWrite') {\n        this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n      }\n    }\n\n    this.bufferText += '>';\n    this.contentPos = this.bufferText.length + 1;\n  }\n\n  rawText(text) {\n    this.bufferText += text;\n  }\n\n  addNamespace(prefix, ns, kind) {\n    let top = this.namespaceStack.length;\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[top].set(prefix, ns, kind);\n  }\n\n  lookupPrefix(namespace) {\n    for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].namespaceUri === namespace) {\n        return this.namespaceStack[i].prefix;\n      }\n    }\n\n    return undefined;\n  }\n\n  lookupNamespace(prefix) {\n    for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].prefix === prefix) {\n        return this.namespaceStack[i].namespaceUri;\n      }\n    }\n\n    return undefined;\n  }\n\n  lookupNamespaceIndex(prefix) {\n    for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].prefix === prefix) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  pushNamespaceImplicit(prefix, ns) {\n    let kind;\n    let existingNsIndex = this.lookupNamespaceIndex(prefix);\n\n    if (existingNsIndex !== -1) {\n      if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n        if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n          throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n        }\n\n        return;\n      } else {\n        if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n          if (prefix === 'xml') {\n            if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n              throw new Error('InvalidArgumentException: Xml String');\n            } else {\n              kind = 'Implied';\n            }\n          } else {\n            throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n          }\n        } else {\n          kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? 'Implied' : 'NeedToWrite';\n        }\n      }\n    } else {\n      if (ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml' || ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns') {\n        throw new Error('InvalidArgumentException');\n      }\n\n      kind = 'NeedToWrite';\n    }\n\n    this.addNamespace(prefix, ns, kind);\n  }\n\n  pushNamespaceExplicit(prefix, ns) {\n    let existingNsIndex = this.lookupNamespaceIndex(prefix);\n\n    if (existingNsIndex !== -1) {\n      if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n        this.namespaceStack[existingNsIndex].kind = 'Written';\n        return;\n      }\n    }\n\n    this.addNamespace(prefix, ns, 'Written');\n    return;\n  }\n\n  addAttribute(prefix, localName, namespaceName) {\n    let top = this.attributeStack.length;\n    this.attributeStack.push(new XmlAttribute());\n    this.attributeStack[top].set(prefix, localName, namespaceName);\n\n    for (let i = 0; i < top; i++) {\n      if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n        throw new Error('XmlException: duplicate attribute name');\n      }\n    }\n  }\n\n  skipPushAndWrite(prefix, localName, namespace) {\n    this.addAttribute(prefix, localName, namespace);\n    this.writeStartAttributeInternal(prefix, localName, namespace);\n  }\n\n  checkName(text) {\n    let format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n\n    if (format.test(text)) {\n      throw new Error('InvalidArgumentException: invalid name character');\n    }\n  }\n\n}\n/**\n * class for managing namespace collection\n */\n\n\nclass Namespace {\n  /**\n   * set value for current namespace instance\n   * @param {string} prefix namespace's prefix\n   * @param {string} namespaceUri namespace URI\n   * @param {string} kind namespace kind\n   */\n  set(prefix, namespaceUri, kind) {\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.kind = kind;\n  }\n  /**\n   * Releases the resources used by Namespace\n   */\n\n\n  destroy() {\n    this.prefix = undefined;\n    this.namespaceUri = undefined;\n    this.kind = undefined;\n  }\n\n}\n/**\n * class for managing element collection\n */\n\n\nclass XmlElement {\n  /**\n   * set value of current element\n   * @param {string} prefix - element prefix\n   * @param {string} localName - element local name\n   * @param {string} namespaceUri -namespace URI\n   * @param {string} previousTop - previous namespace top\n   */\n  set(prefix, localName, namespaceUri, previousTop) {\n    this.previousTop = previousTop;\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.localName = localName;\n  }\n  /**\n   * Releases the resources used by XmlElement\n   */\n\n\n  destroy() {\n    this.previousTop = undefined;\n    this.prefix = undefined;\n    this.localName = undefined;\n    this.namespaceUri = undefined;\n  }\n\n}\n/**\n * class for managing attribute collection\n */\n\n\nclass XmlAttribute {\n  /**\n   * set value of current attribute\n   * @param {string} prefix - namespace's prefix\n   * @param {string} namespaceUri - namespace URI\n   * @param {string} localName - attribute localName\n   */\n  set(prefix, localName, namespaceUri) {\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.localName = localName;\n  }\n  /**\n   * get whether the attribute is duplicate or not\n   * @param {string} prefix - namespace's prefix\n   * @param {string} namespaceUri - namespace URI\n   * @param {string} localName - attribute localName\n   */\n\n\n  isDuplicate(prefix, localName, namespaceUri) {\n    return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);\n  }\n  /**\n   * Releases the resources used by XmlAttribute\n   */\n\n\n  destroy() {\n    this.prefix = undefined;\n    this.namespaceUri = undefined;\n    this.localName = undefined;\n  }\n\n}\n/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\n\n\nclass Encoding {\n  /**\n   * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n   * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n   */\n  constructor(includeBom) {\n    this.emitBOM = true;\n    this.encodingType = 'Ansi';\n    this.initBOM(includeBom);\n  }\n  /**\n   * Gets a value indicating whether to write a Unicode byte order mark\n   * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n   */\n\n\n  get includeBom() {\n    return this.emitBOM;\n  }\n  /**\n   * Gets the encoding type.\n   * @returns EncodingType\n   */\n\n\n  get type() {\n    return this.encodingType;\n  }\n  /**\n   * Sets the encoding type.\n   * @param  {EncodingType} value\n   */\n\n\n  set type(value) {\n    this.encodingType = value;\n  }\n  /**\n   * Initialize the includeBom to emit BOM or Not\n   * @param  {boolean} includeBom\n   */\n\n\n  initBOM(includeBom) {\n    if (includeBom === undefined || includeBom === null) {\n      this.emitBOM = true;\n    } else {\n      this.emitBOM = includeBom;\n    }\n  }\n  /**\n   * Calculates the number of bytes produced by encoding the characters in the specified string\n   * @param  {string} chars - The string containing the set of characters to encode\n   * @returns {number} - The number of bytes produced by encoding the specified characters\n   */\n\n\n  getByteCount(chars) {\n    validateNullOrUndefined(chars, 'string');\n\n    if (chars === '') {\n      let byte = this.utf8Len(chars.charCodeAt(0));\n      return byte;\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    return this.getByteCountInternal(chars, 0, chars.length);\n  }\n  /**\n   * Return the Byte of character\n   * @param  {number} codePoint\n   * @returns {number}\n   */\n\n\n  utf8Len(codePoint) {\n    let bytes = codePoint <= 0x7F ? 1 : codePoint <= 0x7FF ? 2 : codePoint <= 0xFFFF ? 3 : codePoint <= 0x1FFFFF ? 4 : 0;\n    return bytes;\n  }\n  /**\n   * for 4 byte character return surrogate pair true, otherwise false\n   * @param  {number} codeUnit\n   * @returns {boolean}\n   */\n\n\n  isHighSurrogate(codeUnit) {\n    return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n  }\n  /**\n   * for 4byte character generate the surrogate pair\n   * @param  {number} highCodeUnit\n   * @param  {number} lowCodeUnit\n   */\n\n\n  toCodepoint(highCodeUnit, lowCodeUnit) {\n    highCodeUnit = (0x3FF & highCodeUnit) << 10;\n    let u = highCodeUnit | 0x3FF & lowCodeUnit;\n    return u + 0x10000;\n  }\n  /**\n   * private method to get the byte count for specific charindex and count\n   * @param  {string} chars\n   * @param  {number} charIndex\n   * @param  {number} charCount\n   */\n\n\n  getByteCountInternal(chars, charIndex, charCount) {\n    let byteCount = 0;\n\n    if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n      let isUtf8 = this.encodingType === 'Utf8';\n\n      for (let i = 0; i < charCount; i++) {\n        let charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n\n        if (this.isHighSurrogate(charCode)) {\n          if (isUtf8) {\n            let high = charCode;\n            let low = chars.charCodeAt(++charIndex);\n            byteCount += this.utf8Len(this.toCodepoint(high, low));\n          } else {\n            byteCount += 4;\n            ++i;\n          }\n        } else {\n          if (isUtf8) {\n            byteCount += this.utf8Len(charCode);\n          } else {\n            byteCount += 2;\n          }\n        }\n\n        if (isUtf8) {\n          charIndex++;\n        }\n      }\n\n      return byteCount;\n    } else {\n      byteCount = charCount;\n      return byteCount;\n    }\n  }\n  /**\n   * Encodes a set of characters from the specified string into the ArrayBuffer.\n   * @param  {string} s- The string containing the set of characters to encode\n   * @param  {number} charIndex-The index of the first character to encode.\n   * @param  {number} charCount- The number of characters to encode.\n   * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n   */\n\n\n  getBytes(s, charIndex, charCount) {\n    validateNullOrUndefined(s, 'string');\n    validateNullOrUndefined(charIndex, 'charIndex');\n    validateNullOrUndefined(charCount, 'charCount');\n\n    if (charIndex < 0 || charCount < 0) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n    }\n\n    if (s.length - charIndex < charCount) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n    }\n\n    let bytes;\n\n    if (s === '') {\n      bytes = new ArrayBuffer(0);\n      return bytes;\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    let byteCount = this.getByteCountInternal(s, charIndex, charCount);\n\n    switch (this.type) {\n      case 'Utf8':\n        bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n        return bytes;\n\n      case 'Unicode':\n        bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n\n      default:\n        bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n    }\n  }\n  /**\n   * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n   * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n   * @param  {number} index- The index of the first byte to decode.\n   * @param  {number} count- The number of bytes to decode.\n   * @returns {string} - The string that contains the resulting set of characters.\n   */\n\n\n  getString(bytes, index, count) {\n    validateNullOrUndefined(bytes, 'bytes');\n    validateNullOrUndefined(index, 'index');\n    validateNullOrUndefined(count, 'count');\n\n    if (index < 0 || count < 0) {\n      throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n    }\n\n    if (bytes.byteLength - index < count) {\n      throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n    }\n\n    if (bytes.byteLength === 0 || count === 0) {\n      return '';\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    let out = '';\n    let byteCal = new Uint8Array(bytes);\n\n    switch (this.type) {\n      case 'Utf8':\n        let s = this.getStringOfUtf8Encoding(byteCal, index, count);\n        return s;\n\n      case 'Unicode':\n        let byteUnicode = new Uint16Array(bytes);\n        out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n        return out;\n\n      default:\n        let j = index;\n\n        for (let i = 0; i < count; i++) {\n          let c = byteCal[j];\n          out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n\n          j++;\n        }\n\n        return out;\n    }\n  }\n\n  getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount) {\n    let bytes = new ArrayBuffer(byteCount);\n    let bufview = new Uint8Array(bytes);\n    let k = 0;\n\n    for (let i = 0; i < charCount; i++) {\n      let charcode = s.charCodeAt(charIndex++);\n\n      if (charcode < 0x800) {\n        bufview[k] = charcode;\n      } else {\n        bufview[k] = 63; //replacement character '?'\n      }\n\n      k++;\n    }\n\n    return bytes;\n  }\n\n  getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount) {\n    let bytes = new ArrayBuffer(byteCount);\n    let uint = new Uint8Array(bytes);\n    let index = charIndex;\n    let j = 0;\n\n    for (let i = 0; i < charCount; i++) {\n      let charcode = s.charCodeAt(index);\n\n      if (charcode <= 0x7F) {\n        // 1 byte character 2^7\n        uint[j] = charcode;\n      } else if (charcode < 0x800) {\n        // 2 byte character 2^11\n        uint[j] = 0xc0 | charcode >> 6;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else if (charcode < 0xd800 || charcode >= 0xe000) {\n        // 3 byte character 2^16        \n        uint[j] = 0xe0 | charcode >> 12;\n        uint[++j] = 0x80 | charcode >> 6 & 0x3f;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else {\n        uint[j] = 0xef;\n        uint[++j] = 0xbf;\n        uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n      }\n\n      ++j;\n      ++index;\n    }\n\n    return bytes;\n  }\n\n  getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount) {\n    let bytes = new ArrayBuffer(byteCount);\n    let uint16 = new Uint16Array(bytes);\n\n    for (let i = 0; i < charCount; i++) {\n      let charcode = s.charCodeAt(i);\n      uint16[i] = charcode;\n    }\n\n    return bytes;\n  }\n\n  getStringOfUtf8Encoding(byteCal, index, count) {\n    let j = 0;\n    let i = index;\n    let s = '';\n\n    for (j; j < count; j++) {\n      let c = byteCal[i++];\n\n      while (i > byteCal.length) {\n        return s;\n      }\n\n      if (c > 127) {\n        if (c > 191 && c < 224 && i < count) {\n          c = (c & 31) << 6 | byteCal[i] & 63;\n        } else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n          c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n        } else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n          c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n        }\n\n        ++i;\n      }\n\n      s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n    }\n\n    return s;\n  }\n\n  getStringofUnicodeEncoding(byteUni, index, count) {\n    if (count > byteUni.length) {\n      throw new RangeError('ArgumentOutOfRange_Count');\n    }\n\n    let byte16 = new Uint16Array(count);\n    let out = '';\n\n    for (let i = 0; i < count && i < byteUni.length; i++) {\n      byte16[i] = byteUni[index++];\n    }\n\n    out = String.fromCharCode.apply(null, byte16);\n    return out;\n  }\n  /**\n   * To clear the encoding instance\n   * @return {void}\n   */\n\n\n  destroy() {\n    this.emitBOM = undefined;\n    this.encodingType = undefined;\n  }\n\n}\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\n\n\nfunction validateNullOrUndefined(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n  }\n}\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\n\n\nclass StreamWriter {\n  /**\n   * Gets the content written to the StreamWriter as Blob.\n   * @returns Blob\n   */\n  get buffer() {\n    this.flush();\n    return this.bufferBlob;\n  }\n  /**\n   * Gets the encoding.\n   * @returns Encoding\n   */\n\n\n  get encoding() {\n    return this.enc;\n  }\n  /**\n   * Initializes a new instance of the StreamWriter class by using the specified encoding.\n   * @param  {Encoding} encoding?- The character encoding to use.\n   */\n\n\n  constructor(encoding) {\n    this.bufferBlob = new Blob(['']);\n    this.bufferText = '';\n    this.init(encoding);\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  init(encoding) {\n    if (encoding === null || encoding === undefined) {\n      this.enc = new Encoding(false);\n      this.enc.type = 'Utf8';\n    } else {\n      this.enc = encoding;\n      this.setBomByte();\n    }\n  }\n  /**\n   * Private method to set Byte Order Mark(BOM) value based on EncodingType\n   */\n\n\n  setBomByte() {\n    if (this.encoding.includeBom) {\n      switch (this.encoding.type) {\n        case 'Unicode':\n          let arrayUnicode = new ArrayBuffer(2);\n          let uint8 = new Uint8Array(arrayUnicode);\n          uint8[0] = 255;\n          uint8[1] = 254;\n          this.bufferBlob = new Blob([arrayUnicode]);\n          break;\n\n        case 'Utf8':\n          let arrayUtf8 = new ArrayBuffer(3);\n          let utf8 = new Uint8Array(arrayUtf8);\n          utf8[0] = 239;\n          utf8[1] = 187;\n          utf8[2] = 191;\n          this.bufferBlob = new Blob([arrayUtf8]);\n          break;\n\n        default:\n          this.bufferBlob = new Blob(['']);\n          break;\n      }\n    }\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param  {string} fileName - The file name to save\n   * @returns {void}\n   */\n\n\n  save(fileName) {\n    if (this.bufferText !== '') {\n      this.flush();\n    }\n\n    Save.save(fileName, this.buffer);\n  }\n  /**\n   * Writes the specified string.\n   * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n   * @returns {void}\n   */\n\n\n  write(value) {\n    if (this.encoding === undefined) {\n      throw new Error('Object Disposed Exception: current writer is disposed');\n    }\n\n    validateNullOrUndefined(value, 'string');\n    this.bufferText += value;\n\n    if (this.bufferText.length >= 10240) {\n      this.flush();\n    }\n  }\n\n  flush() {\n    if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n      return;\n    }\n\n    let bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n    this.bufferText = '';\n    this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n  }\n  /**\n   * Writes the specified string followed by a line terminator\n   * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n   * @returns {void}\n   */\n\n\n  writeLine(value) {\n    if (this.encoding === undefined) {\n      throw new Error('Object Disposed Exception: current writer is disposed');\n    }\n\n    validateNullOrUndefined(value, 'string');\n    this.bufferText = this.bufferText + value + '\\r\\n';\n\n    if (this.bufferText.length >= 10240) {\n      this.flush();\n    }\n  }\n  /**\n   * Releases the resources used by the StreamWriter\n   * @returns {void}\n   */\n\n\n  destroy() {\n    this.bufferBlob = undefined;\n    this.bufferText = undefined;\n\n    if (this.enc instanceof Encoding) {\n      this.enc.destroy();\n    }\n\n    this.enc = undefined;\n  }\n\n} // export all modules from current location\n// example: export * from './module'\n\n/**\n * file utils modules\n */\n\n\nexport { XmlWriter, Namespace, XmlElement, XmlAttribute, StreamWriter, Encoding, validateNullOrUndefined, Save };","map":{"version":3,"names":["Save","constructor","save","fileName","buffer","undefined","Error","extension","substring","lastIndexOf","length","mimeType","getMimeType","Blob","type","isMicrosoftBrowser","navigator","msSaveBlob","downloadLink","document","createElementNS","saveInternal","hasDownloadAttribute","download","dataUrl","window","URL","createObjectURL","href","event","createEvent","initEvent","dispatchEvent","setTimeout","revokeObjectURL","url","isPopupBlocked","open","location","reader","FileReader","onloadend","result","readAsDataURL","XmlWriter","contentPos","bufferText","bufferBlob","currentState","namespaceStack","push","Namespace","set","elementStack","XmlElement","attributeStack","flush","writeProcessingInstruction","name","text","checkName","writeStartDocument","writeProcessingInstructionInternal","standalone","rawText","writeEndDocument","writeEndElement","writeStartElement","prefix","localName","namespace","startElementContent","lookupPrefix","lookupNamespace","writeStartElementInternal","top","writeEndElementInternal","splice","previousTop","writeElementString","value","writeString","writeAttributeString","writeStartAttribute","writeStringInternal","writeEndAttribute","writeInternal","writeRaw","isRawString","destroy","i","replace","writeStartAttributePrefixAndNameSpace","writeStartAttributeSpecialAttribute","skipPushAndWrite","pushNamespaceExplicit","pushNamespaceImplicit","writeStartAttributeInternal","namespaceName","writeNamespaceDeclaration","namespaceUri","writeStartNamespaceDeclaration","inAttributeValue","start","kind","addNamespace","ns","lookupNamespaceIndex","existingNsIndex","addAttribute","XmlAttribute","isDuplicate","format","test","Encoding","includeBom","emitBOM","encodingType","initBOM","getByteCount","chars","validateNullOrUndefined","byte","utf8Len","charCodeAt","getByteCountInternal","codePoint","bytes","isHighSurrogate","codeUnit","toCodepoint","highCodeUnit","lowCodeUnit","u","charIndex","charCount","byteCount","isUtf8","charCode","high","low","getBytes","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","getString","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","message","StreamWriter","encoding","enc","init","setBomByte","arrayUnicode","uint8","arrayUtf8","utf8","write","bufferArray","writeLine"],"sources":["D:/StageCap2022/e-learningProject__frontend/frontend/node_modules/@syncfusion/ej2-file-utils/dist/es6/ej2-file-utils.es2015.js"],"sourcesContent":["/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nclass Save {\n    /**\n     * Initialize new instance of {save}\n     */\n    constructor() {\n        // tslint:disable\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName- file name to save.\n     * @param  {Blob} buffer- the content to write in file\n     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n     * @returns {void}\n     */\n    static save(fileName, buffer) {\n        if (fileName === null || fileName === undefined || fileName === '') {\n            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n        }\n        let extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n        let mimeType = this.getMimeType(extension);\n        if (mimeType !== '') {\n            buffer = new Blob([buffer], { type: mimeType });\n        }\n        if (this.isMicrosoftBrowser) {\n            navigator.msSaveBlob(buffer, fileName);\n        }\n        else {\n            let downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n        }\n    }\n    static saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n        if (hasDownloadAttribute) {\n            downloadLink.download = fileName;\n            let dataUrl = window.URL.createObjectURL(buffer);\n            downloadLink.href = dataUrl;\n            let event = document.createEvent('MouseEvent');\n            event.initEvent('click', true, true);\n            downloadLink.dispatchEvent(event);\n            setTimeout(() => {\n                window.URL.revokeObjectURL(dataUrl);\n                dataUrl = undefined;\n            });\n        }\n        else {\n            if (extension !== 'docx' && extension !== 'xlsx') {\n                let url = window.URL.createObjectURL(buffer);\n                let isPopupBlocked = window.open(url, '_blank');\n                if (!isPopupBlocked) {\n                    window.location.href = url;\n                }\n            }\n            else {\n                let reader = new FileReader();\n                reader.onloadend = () => {\n                    let isPopupBlocked = window.open(reader.result, '_blank');\n                    if (!isPopupBlocked) {\n                        window.location.href = reader.result;\n                    }\n                };\n                reader.readAsDataURL(buffer);\n            }\n        }\n    }\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n    static getMimeType(extension) {\n        let mimeType = '';\n        switch (extension) {\n            case 'html':\n                mimeType = 'text/html';\n                break;\n            case 'pdf':\n                mimeType = 'application/pdf';\n                break;\n            case 'docx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n                break;\n            case 'xlsx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n                break;\n            case 'txt':\n                mimeType = 'text/plain';\n                break;\n        }\n        return mimeType;\n    }\n}\n\n/**\n * XmlWriter class provide method to create XML data\n */\nclass XmlWriter {\n    /**\n     * Initialize new instance of {XmlWriter}\n     */\n    constructor() {\n        this.contentPos = 0;\n        this.bufferText = '';\n        this.bufferBlob = new Blob([''], { type: 'text/plain' });\n        this.currentState = 'Initial';\n        this.namespaceStack = [];\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[2].set('', '', 'Implied');\n        this.elementStack = [];\n        this.elementStack.push(new XmlElement());\n        this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n        this.attributeStack = [];\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    /**\n     * Gets the content written to the {XmlWriter} as Blob.\n     * @returns {Blob}\n     */\n    get buffer() {\n        this.flush();\n        return this.bufferBlob;\n    }\n    /**\n     * Writes processing instruction with a space between the name and text\n     * @param {string} name - name of the processing instruction\n     * @param {string} text - text to write in the processing instruction\n     * @throws ArgumentException\n     * @throws InvalidArgumentException\n     * @throws InvalidOperationException\n     */\n    writeProcessingInstruction(name, text) {\n        if (name === undefined || name === null || name.length === 0) {\n            throw new Error('ArgumentException: name should not be undefined, null or empty');\n        }\n        this.checkName(name);\n        if (text === undefined || text === null) {\n            text = '';\n        }\n        if (name.length === 3 && name === 'xml') {\n            if (this.currentState !== 'Initial') {\n                // tslint:disable-next-line:max-line-length\n                throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n            }\n        }\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        else {\n            this.writeStartDocument();\n            this.writeProcessingInstructionInternal(name, text);\n        }\n    }\n    /**\n     * Writes Xml declaration with version and standalone attribute\n     * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n     * @throws InvalidOperation\n     */\n    writeStartDocument(standalone) {\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.currentState = 'StartDocument';\n        this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n        if (standalone !== null && standalone !== undefined) {\n            this.rawText('\" standalone=\"');\n            this.rawText(standalone ? 'yes' : 'no');\n        }\n        this.rawText('\"?>');\n    }\n    /**\n     * Closes any open tag or attribute and write the state back to start\n     */\n    writeEndDocument() {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        this.currentState = 'EndDocument';\n        this.flush();\n    }\n    /**\n     * Writes the specified start tag and associates it with the given namespace and prefix.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName -localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @throws ArgumentException\n     * @throws InvalidOperationException\n     */\n    writeStartElement(prefix, localName, namespace) {\n        if (this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        if (localName === undefined || localName === null || localName.length === 0) {\n            throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n        }\n        this.checkName(localName);\n        if (this.currentState === 'Initial') {\n            this.writeStartDocument();\n        }\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n        }\n        this.currentState = 'StartElement';\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                prefix = this.lookupPrefix(namespace);\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        else if (prefix.length > 0) {\n            if (namespace === undefined || namespace === null) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null || (namespace !== undefined && namespace.length === 0)) {\n                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            namespace = this.lookupNamespace(prefix);\n        }\n        this.writeStartElementInternal(prefix, localName, namespace);\n    }\n    /**\n     * Closes one element and pop corresponding namespace scope\n     */\n    writeEndElement() {\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n            this.currentState = 'ElementContent';\n        }\n        else if (this.currentState === 'ElementContent') {\n            this.currentState = 'ElementContent';\n        }\n        this.currentState = 'EndElement';\n        let top = this.elementStack.length - 1;\n        this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n        this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n        this.elementStack.splice(top);\n        if (this.bufferText.length > 10240) {\n            this.flush();\n        }\n    }\n    /**\n     * Writes an element with the specified prefix, local name, namespace URI, and value.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    writeElementString(prefix, localName, namespace, value) {\n        this.writeStartElement(prefix, localName, namespace);\n        if (value !== undefined && value !== null && value.length !== 0) {\n            this.writeString(value);\n        }\n        this.writeEndElement();\n    }\n    /**\n     * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    writeAttributeString(prefix, localName, namespace, value) {\n        this.writeStartAttribute(prefix, localName, namespace, value);\n        this.writeStringInternal(value, true);\n        this.writeEndAttribute();\n    }\n    /**\n     * Writes the given text content\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    writeString(text) {\n        this.writeInternal(text, false);\n    }\n    /**\n     * Write given text as raw data\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    writeRaw(text) {\n        this.writeInternal(text, true);\n    }\n    writeInternal(text, isRawString) {\n        if (text === undefined || text === null) {\n            return;\n        }\n        else {\n            if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n                throw new Error('InvalidOperationException: Wrong Token');\n            }\n            if (this.currentState === 'StartElement') {\n                this.startElementContent();\n            }\n            this.currentState = 'ElementContent';\n            if (isRawString) {\n                this.rawText(text);\n            }\n            else {\n                this.writeStringInternal(text, false);\n            }\n        }\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param {string} fileName - file name\n     */\n    save(fileName) {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    }\n    /**\n     * Releases the resources used by XmlWriter.\n     */\n    destroy() {\n        this.bufferBlob = undefined;\n        for (let i = 0; i < this.namespaceStack.length; i++) {\n            this.namespaceStack[i].destroy();\n        }\n        this.namespaceStack = [];\n        for (let i = 0; i < this.elementStack.length; i++) {\n            this.elementStack[i].destroy();\n        }\n        this.elementStack = [];\n        this.bufferText = '';\n        this.contentPos = 0;\n    }\n    flush() {\n        if (this.bufferBlob === undefined) {\n            return;\n        }\n        this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: 'text/plain' });\n        this.bufferText = '';\n    }\n    writeProcessingInstructionInternal(name, text) {\n        this.bufferText += '<?';\n        this.rawText(name);\n        if (text.length > 0) {\n            this.bufferText += ' ';\n            text = text.replace(/\\?\\>/g, '? >');\n            this.bufferText += text;\n        }\n        this.bufferText += '?';\n        this.bufferText += '>';\n    }\n    writeStartAttribute(prefix, localName, namespace, value) {\n        if (localName === undefined || localName === null || localName.length === 0) {\n            if (prefix === 'xmlns') {\n                localName = 'xmlns';\n                prefix = '';\n            }\n            else {\n                throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n            }\n        }\n        if (this.currentState !== 'StartElement') {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.checkName(localName);\n        this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n    }\n    writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value) {\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n                    prefix = this.lookupPrefix(namespace);\n                }\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null) {\n                namespace = '';\n            }\n        }\n        this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n    }\n    writeStartAttributeSpecialAttribute(prefix, localName, namespace, value) {\n        if (prefix.length === 0) {\n            if (localName[0] === 'x' && localName === 'xmlns') {\n                this.skipPushAndWrite(prefix, localName, namespace);\n                this.pushNamespaceExplicit('', value);\n                return;\n            }\n            else if (namespace.length > 0) {\n                prefix = this.lookupPrefix(namespace);\n            }\n        }\n        else {\n            if (prefix[0] === 'x') {\n                if (prefix === 'xmlns') {\n                    this.skipPushAndWrite(prefix, localName, namespace);\n                    this.pushNamespaceExplicit(localName, value);\n                    return;\n                }\n                else if (prefix === 'xml') {\n                    if (localName === 'space' || localName === 'lang') {\n                        this.skipPushAndWrite(prefix, localName, namespace);\n                        return;\n                    }\n                }\n            }\n            if (namespace.length === 0) {\n                prefix = '';\n            }\n        }\n        if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n            this.pushNamespaceImplicit(prefix, namespace);\n        }\n        this.skipPushAndWrite(prefix, localName, namespace);\n    }\n    writeEndAttribute() {\n        this.currentState = 'StartElement';\n        this.bufferText += '\"';\n    }\n    writeStartElementInternal(prefix, localName, namespace) {\n        this.bufferText += '<';\n        if (prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        let top = this.elementStack.length;\n        this.elementStack.push(new XmlElement());\n        this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n        this.pushNamespaceImplicit(prefix, namespace);\n        for (let i = 0; i < this.attributeStack.length; i++) {\n            this.attributeStack[i].destroy();\n        }\n        this.attributeStack = [];\n    }\n    writeEndElementInternal(prefix, localName) {\n        if (this.contentPos !== this.bufferText.length + 1) {\n            this.bufferText += '</';\n            if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n                this.rawText(prefix);\n                this.bufferText += ':';\n            }\n            this.rawText(localName);\n            this.bufferText += '>';\n        }\n        else {\n            this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n            this.bufferText += ' />';\n        }\n    }\n    writeStartAttributeInternal(prefix, localName, namespaceName) {\n        this.bufferText += ' ';\n        if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        this.bufferText += '=';\n        this.bufferText += '\"';\n    }\n    writeNamespaceDeclaration(prefix, namespaceUri) {\n        this.writeStartNamespaceDeclaration(prefix);\n        this.writeStringInternal(namespaceUri, true);\n        this.bufferText += '\"';\n    }\n    writeStartNamespaceDeclaration(prefix) {\n        if (prefix === undefined || prefix === null || prefix.length === 0) {\n            this.rawText(' xmlns=\\\"');\n        }\n        else {\n            this.rawText(' xmlns:');\n            this.rawText(prefix);\n            this.bufferText += '=';\n            this.bufferText += '\"';\n        }\n    }\n    writeStringInternal(text, inAttributeValue) {\n        if (text === null || text === undefined) {\n            text = '';\n        }\n        text = text.replace(/\\&/g, '&amp;');\n        text = text.replace(/\\</g, '&lt;');\n        text = text.replace(/\\>/g, '&gt;');\n        if (inAttributeValue) {\n            text = text.replace(/\\\"/g, '&quot;');\n        }\n        this.bufferText += text;\n        if (!inAttributeValue) {\n            this.contentPos = 0;\n        }\n    }\n    startElementContent() {\n        let start = this.elementStack[this.elementStack.length - 1].previousTop;\n        for (let i = this.namespaceStack.length - 1; i > start; i--) {\n            if (this.namespaceStack[i].kind === 'NeedToWrite') {\n                this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n            }\n        }\n        this.bufferText += '>';\n        this.contentPos = this.bufferText.length + 1;\n    }\n    rawText(text) {\n        this.bufferText += text;\n    }\n    addNamespace(prefix, ns, kind) {\n        let top = this.namespaceStack.length;\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[top].set(prefix, ns, kind);\n    }\n    lookupPrefix(namespace) {\n        for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].namespaceUri === namespace) {\n                return this.namespaceStack[i].prefix;\n            }\n        }\n        return undefined;\n    }\n    lookupNamespace(prefix) {\n        for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return this.namespaceStack[i].namespaceUri;\n            }\n        }\n        return undefined;\n    }\n    lookupNamespaceIndex(prefix) {\n        for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    pushNamespaceImplicit(prefix, ns) {\n        let kind;\n        let existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n                }\n                return;\n            }\n            else {\n                if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n                    if (prefix === 'xml') {\n                        if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n                            throw new Error('InvalidArgumentException: Xml String');\n                        }\n                        else {\n                            kind = 'Implied';\n                        }\n                    }\n                    else {\n                        throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n                    }\n                }\n                else {\n                    kind = (this.namespaceStack[existingNsIndex].namespaceUri === ns) ? 'Implied' : 'NeedToWrite';\n                }\n            }\n        }\n        else {\n            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||\n                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {\n                throw new Error('InvalidArgumentException');\n            }\n            kind = 'NeedToWrite';\n        }\n        this.addNamespace(prefix, ns, kind);\n    }\n    pushNamespaceExplicit(prefix, ns) {\n        let existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                this.namespaceStack[existingNsIndex].kind = 'Written';\n                return;\n            }\n        }\n        this.addNamespace(prefix, ns, 'Written');\n        return;\n    }\n    addAttribute(prefix, localName, namespaceName) {\n        let top = this.attributeStack.length;\n        this.attributeStack.push(new XmlAttribute());\n        this.attributeStack[top].set(prefix, localName, namespaceName);\n        for (let i = 0; i < top; i++) {\n            if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n                throw new Error('XmlException: duplicate attribute name');\n            }\n        }\n    }\n    skipPushAndWrite(prefix, localName, namespace) {\n        this.addAttribute(prefix, localName, namespace);\n        this.writeStartAttributeInternal(prefix, localName, namespace);\n    }\n    checkName(text) {\n        let format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n        if (format.test(text)) {\n            throw new Error('InvalidArgumentException: invalid name character');\n        }\n    }\n}\n/**\n * class for managing namespace collection\n */\nclass Namespace {\n    /**\n     * set value for current namespace instance\n     * @param {string} prefix namespace's prefix\n     * @param {string} namespaceUri namespace URI\n     * @param {string} kind namespace kind\n     */\n    set(prefix, namespaceUri, kind) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.kind = kind;\n    }\n    /**\n     * Releases the resources used by Namespace\n     */\n    destroy() {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.kind = undefined;\n    }\n}\n/**\n * class for managing element collection\n */\nclass XmlElement {\n    /**\n     * set value of current element\n     * @param {string} prefix - element prefix\n     * @param {string} localName - element local name\n     * @param {string} namespaceUri -namespace URI\n     * @param {string} previousTop - previous namespace top\n     */\n    set(prefix, localName, namespaceUri, previousTop) {\n        this.previousTop = previousTop;\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    }\n    /**\n     * Releases the resources used by XmlElement\n     */\n    destroy() {\n        this.previousTop = undefined;\n        this.prefix = undefined;\n        this.localName = undefined;\n        this.namespaceUri = undefined;\n    }\n}\n/**\n * class for managing attribute collection\n */\nclass XmlAttribute {\n    /**\n     * set value of current attribute\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    set(prefix, localName, namespaceUri) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    }\n    /**\n     * get whether the attribute is duplicate or not\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    isDuplicate(prefix, localName, namespaceUri) {\n        return ((this.localName === localName) && ((this.prefix === prefix) || (this.namespaceUri === namespaceUri)));\n    }\n    /**\n     * Releases the resources used by XmlAttribute\n     */\n    destroy() {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.localName = undefined;\n    }\n}\n\n/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nclass Encoding {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    constructor(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    /**\n     * Gets a value indicating whether to write a Unicode byte order mark\n     * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n     */\n    get includeBom() {\n        return this.emitBOM;\n    }\n    /**\n     * Gets the encoding type.\n     * @returns EncodingType\n     */\n    get type() {\n        return this.encodingType;\n    }\n    /**\n     * Sets the encoding type.\n     * @param  {EncodingType} value\n     */\n    set type(value) {\n        this.encodingType = value;\n    }\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    initBOM(includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    }\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    getByteCount(chars) {\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            let byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    }\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    utf8Len(codePoint) {\n        let bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    }\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    isHighSurrogate(codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    }\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    toCodepoint(highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        let u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    }\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    getByteCountInternal(chars, charIndex, charCount) {\n        let byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            let isUtf8 = this.encodingType === 'Utf8';\n            for (let i = 0; i < charCount; i++) {\n                let charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        let high = charCode;\n                        let low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    }\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    getBytes(s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        let bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        let byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    }\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    getString(bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        let out = '';\n        let byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                let s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                let byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                let j = index;\n                for (let i = 0; i < count; i++) {\n                    let c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    }\n    getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount) {\n        let bytes = new ArrayBuffer(byteCount);\n        let bufview = new Uint8Array(bytes);\n        let k = 0;\n        for (let i = 0; i < charCount; i++) {\n            let charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    }\n    getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount) {\n        let bytes = new ArrayBuffer(byteCount);\n        let uint = new Uint8Array(bytes);\n        let index = charIndex;\n        let j = 0;\n        for (let i = 0; i < charCount; i++) {\n            let charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) { // 1 byte character 2^7\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) { // 2 byte character 2^11\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        \n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    }\n    getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount) {\n        let bytes = new ArrayBuffer(byteCount);\n        let uint16 = new Uint16Array(bytes);\n        for (let i = 0; i < charCount; i++) {\n            let charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    }\n    getStringOfUtf8Encoding(byteCal, index, count) {\n        let j = 0;\n        let i = index;\n        let s = '';\n        for (j; j < count; j++) {\n            let c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    }\n    getStringofUnicodeEncoding(byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        let byte16 = new Uint16Array(count);\n        let out = '';\n        for (let i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    }\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    destroy() {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    }\n}\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nfunction validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nclass StreamWriter {\n    /**\n     * Gets the content written to the StreamWriter as Blob.\n     * @returns Blob\n     */\n    get buffer() {\n        this.flush();\n        return this.bufferBlob;\n    }\n    /**\n     * Gets the encoding.\n     * @returns Encoding\n     */\n    get encoding() {\n        return this.enc;\n    }\n    /**\n     * Initializes a new instance of the StreamWriter class by using the specified encoding.\n     * @param  {Encoding} encoding?- The character encoding to use.\n     */\n    constructor(encoding) {\n        this.bufferBlob = new Blob(['']);\n        this.bufferText = '';\n        this.init(encoding);\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    init(encoding) {\n        if (encoding === null || encoding === undefined) {\n            this.enc = new Encoding(false);\n            this.enc.type = 'Utf8';\n        }\n        else {\n            this.enc = encoding;\n            this.setBomByte();\n        }\n    }\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n    setBomByte() {\n        if (this.encoding.includeBom) {\n            switch (this.encoding.type) {\n                case 'Unicode':\n                    let arrayUnicode = new ArrayBuffer(2);\n                    let uint8 = new Uint8Array(arrayUnicode);\n                    uint8[0] = 255;\n                    uint8[1] = 254;\n                    this.bufferBlob = new Blob([arrayUnicode]);\n                    break;\n                case 'Utf8':\n                    let arrayUtf8 = new ArrayBuffer(3);\n                    let utf8 = new Uint8Array(arrayUtf8);\n                    utf8[0] = 239;\n                    utf8[1] = 187;\n                    utf8[2] = 191;\n                    this.bufferBlob = new Blob([arrayUtf8]);\n                    break;\n                default:\n                    this.bufferBlob = new Blob(['']);\n                    break;\n            }\n        }\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n    save(fileName) {\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    }\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n    write(value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText += value;\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    }\n    flush() {\n        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n            return;\n        }\n        let bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n        this.bufferText = '';\n        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    }\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n    writeLine(value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText = this.bufferText + value + '\\r\\n';\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    }\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n    destroy() {\n        this.bufferBlob = undefined;\n        this.bufferText = undefined;\n        if (this.enc instanceof Encoding) {\n            this.enc.destroy();\n        }\n        this.enc = undefined;\n    }\n}\n\n// export all modules from current location\n// example: export * from './module'\n/**\n * file utils modules\n */\n\nexport { XmlWriter, Namespace, XmlElement, XmlAttribute, StreamWriter, Encoding, validateNullOrUndefined, Save };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}