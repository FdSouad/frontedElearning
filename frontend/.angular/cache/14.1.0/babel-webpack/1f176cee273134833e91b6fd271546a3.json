{"ast":null,"code":"import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\n\nconst ARR_LITERAL_CODES = new Int16Array(286);\nconst ARR_LITERAL_LENGTHS = new Uint8Array(286);\nconst ARR_DISTANCE_CODES = new Int16Array(30);\nconst ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nclass CompressedStreamWriter {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  constructor(noWrap) {\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n  /**\n   * get compressed data\n   */\n\n\n  get compressedData() {\n    return this.stream;\n  }\n\n  get getCompressedString() {\n    let compressedString = '';\n\n    if (this.stream !== undefined) {\n      for (let i = 0; i < this.stream.length; i++) {\n        compressedString += String.fromCharCode.apply(null, this.stream[i]);\n      }\n    }\n\n    return compressedString;\n  }\n  /**\n   * Compresses data and writes it to the stream.\n   * @param {Uint8Array} data - data to compress\n   * @param {number} offset - offset in data\n   * @param {number} length - length of the data\n   * @returns {void}\n   */\n\n\n  write(data, offset, length) {\n    if (data === undefined || data === null) {\n      throw new Error('ArgumentException: data cannot null or undefined');\n    }\n\n    let end = offset + length;\n\n    if (0 > offset || offset > end || end > data.length) {\n      throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n    }\n\n    if (typeof data === 'string') {\n      let encode = new Encoding(false);\n      encode.type = 'Utf8';\n      data = new Uint8Array(encode.getBytes(data, 0, data.length));\n      end = offset + data.length;\n    }\n\n    this.inputBuffer = data;\n    this.inputOffset = offset;\n    this.inputEnd = end;\n\n    if (!this.noWrap) {\n      this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n    }\n\n    while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n      this.pendingBufferFlush();\n      this.compressData(false);\n    }\n  }\n  /**\n   * write ZLib header to the compressed data\n   * @return {void}\n   */\n\n\n  writeZLibHeader() {\n    /* Initialize header.*/\n    let headerDate = 8 + (7 << 4) << 8;\n    /* Save compression level.*/\n\n    headerDate |= (5 >> 2 & 3) << 6;\n    /* Align header.*/\n\n    headerDate += 31 - headerDate % 31;\n    /* Write header to stream.*/\n\n    this.pendingBufferWriteShortBytes(headerDate);\n  }\n  /**\n   *  Write Most Significant Bytes in to stream\n   * @param {number} s - check sum value\n   */\n\n\n  pendingBufferWriteShortBytes(s) {\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    this.pendingBuffer[this.pendingBufLength++] = s;\n  }\n\n  compressData(finish) {\n    let success;\n\n    do {\n      this.fillWindow();\n      let canFlush = finish && this.inputEnd === this.inputOffset;\n      success = this.compressSlow(canFlush, finish);\n    } while (this.pendingBufLength === 0 && success);\n\n    return success;\n  }\n\n  compressSlow(flush, finish) {\n    if (this.lookAhead < 262 && !flush) {\n      return false;\n    }\n\n    while (this.lookAhead >= 262 || flush) {\n      if (this.lookAhead === 0) {\n        return this.lookAheadCompleted(finish);\n      }\n\n      if (this.stringStart >= 2 * this.windowSize - 262) {\n        this.slideWindow();\n      }\n\n      let prevMatch = this.matchStart;\n      let prevLen = this.matchLength;\n\n      if (this.lookAhead >= 3) {\n        this.discardMatch();\n      }\n\n      if (prevLen >= 3 && this.matchLength <= prevLen) {\n        prevLen = this.matchPreviousBest(prevMatch, prevLen);\n      } else {\n        this.matchPreviousAvailable();\n      }\n\n      if (this.bufferPosition >= 1 << 14) {\n        return this.huffmanIsFull(finish);\n      }\n    }\n\n    return true;\n  }\n\n  discardMatch() {\n    let hashHead = this.insertString();\n\n    if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n      if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n        this.matchLength = 3 - 1;\n      }\n    }\n  }\n\n  matchPreviousAvailable() {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = true;\n    this.stringStart++;\n    this.lookAhead--;\n  }\n\n  matchPreviousBest(prevMatch, prevLen) {\n    this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n    prevLen -= 2;\n\n    do {\n      this.stringStart++;\n      this.lookAhead--;\n\n      if (this.lookAhead >= 3) {\n        this.insertString();\n      }\n    } while (--prevLen > 0);\n\n    this.stringStart++;\n    this.lookAhead--;\n    this.matchPrevAvail = false;\n    this.matchLength = 3 - 1;\n    return prevLen;\n  }\n\n  lookAheadCompleted(finish) {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = false;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n    this.blockStart = this.stringStart;\n    return false;\n  }\n\n  huffmanIsFull(finish) {\n    let len = this.stringStart - this.blockStart;\n\n    if (this.matchPrevAvail) {\n      len--;\n    }\n\n    let lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n    this.blockStart += len;\n    return !lastBlock;\n  }\n\n  fillWindow() {\n    if (this.stringStart >= this.windowSize + this.maxDist) {\n      this.slideWindow();\n    }\n\n    while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n      let more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n      if (more > this.inputEnd - this.inputOffset) {\n        more = this.inputEnd - this.inputOffset;\n      }\n\n      this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n      this.inputOffset += more;\n      this.totalBytesIn += more;\n      this.lookAhead += more;\n    }\n\n    if (this.lookAhead >= 3) {\n      this.updateHash();\n    }\n  }\n\n  slideWindow() {\n    this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n    this.matchStart -= this.windowSize;\n    this.stringStart -= this.windowSize;\n    this.blockStart -= this.windowSize;\n\n    for (let i = 0; i < this.hashSize; ++i) {\n      let m = this.hashHead[i] & 0xffff;\n      this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n\n    for (let i = 0; i < this.windowSize; i++) {\n      let m = this.hashPrevious[i] & 0xffff;\n      this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n  }\n\n  insertString() {\n    let match;\n    let hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n    this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n    this.hashHead[hash] = this.stringStart;\n    this.currentHash = hash;\n    return match & 0xffff;\n  }\n\n  findLongestMatch(curMatch) {\n    let chainLen = 4096;\n    let niceLen = 258;\n    let scan = this.stringStart;\n    let match;\n    let bestEnd = this.stringStart + this.matchLength;\n    let bestLength = Math.max(this.matchLength, 3 - 1);\n    let limit = Math.max(this.stringStart - this.maxDist, 0);\n    let stringEnd = this.stringStart + 258 - 1;\n    let scanEnd1 = this.dataWindow[bestEnd - 1];\n    let scanEnd = this.dataWindow[bestEnd];\n    let data = this.dataWindow;\n\n    if (bestLength >= 32) {\n      chainLen >>= 2;\n    }\n\n    if (niceLen > this.lookAhead) {\n      niceLen = this.lookAhead;\n    }\n\n    do {\n      if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n        continue;\n      }\n\n      match = curMatch + 2;\n      scan += 2;\n      /* tslint:disable */\n\n      while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n        /* tslint:disable */\n      }\n\n      if (scan > bestEnd) {\n        this.matchStart = curMatch;\n        bestEnd = scan;\n        bestLength = scan - this.stringStart;\n\n        if (bestLength >= niceLen) {\n          break;\n        }\n\n        scanEnd1 = data[bestEnd - 1];\n        scanEnd = data[bestEnd];\n      }\n\n      scan = this.stringStart;\n    } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n    this.matchLength = Math.min(bestLength, this.lookAhead);\n    return this.matchLength >= 3;\n  }\n\n  updateHash() {\n    this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n  }\n\n  huffmanTallyLit(literal) {\n    this.arrDistances[this.bufferPosition] = 0;\n    this.arrLiterals[this.bufferPosition++] = literal;\n    this.treeLiteral.codeFrequencies[literal]++;\n    return this.bufferPosition >= 1 << 14;\n  }\n\n  huffmanTallyDist(dist, len) {\n    this.arrDistances[this.bufferPosition] = dist;\n    this.arrLiterals[this.bufferPosition++] = len - 3;\n    let lc = this.huffmanLengthCode(len - 3);\n    this.treeLiteral.codeFrequencies[lc]++;\n\n    if (lc >= 265 && lc < 285) {\n      this.extraBits += Math.floor((lc - 261) / 4);\n    }\n\n    let dc = this.huffmanDistanceCode(dist - 1);\n    this.treeDistances.codeFrequencies[dc]++;\n\n    if (dc >= 4) {\n      this.extraBits += Math.floor(dc / 2 - 1);\n    }\n\n    return this.bufferPosition >= 1 << 14;\n  }\n\n  huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock) {\n    this.treeLiteral.codeFrequencies[256]++;\n    this.treeLiteral.buildTree();\n    this.treeDistances.buildTree();\n    this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n    this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n    this.treeCodeLengths.buildTree();\n    let blTreeCodes = 4;\n\n    for (let i = 18; i > blTreeCodes; i--) {\n      if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n        blTreeCodes = i + 1;\n      }\n    }\n\n    let opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n    let static_len = this.extraBits;\n\n    for (let i = 0; i < 286; i++) {\n      static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n    }\n\n    for (let i = 0; i < 30; i++) {\n      static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n    }\n\n    if (opt_len >= static_len) {\n      // Force static trees.\n      opt_len = static_len;\n    }\n\n    if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n      this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n    } else if (opt_len == static_len) {\n      // Encode with static tree.\n      this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n      this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n      this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    } else {\n      this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n      this.huffmanSendAllTrees(blTreeCodes);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    }\n  }\n\n  huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock) {\n    this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n    this.pendingBufferAlignToByte();\n    this.pendingBufferWriteShort(storedLength);\n    this.pendingBufferWriteShort(~storedLength);\n    this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n    this.huffmanReset();\n  }\n\n  huffmanLengthCode(len) {\n    if (len === 255) {\n      return 285;\n    }\n\n    let code = 257;\n\n    while (len >= 8) {\n      code += 4;\n      len >>= 1;\n    }\n\n    return code + len;\n  }\n\n  huffmanDistanceCode(distance) {\n    let code = 0;\n\n    while (distance >= 4) {\n      code += 2;\n      distance >>= 1;\n    }\n\n    return code + distance;\n  }\n\n  huffmanSendAllTrees(blTreeCodes) {\n    this.treeCodeLengths.buildCodes();\n    this.treeLiteral.buildCodes();\n    this.treeDistances.buildCodes();\n    this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n    this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n    this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n    for (let rank = 0; rank < blTreeCodes; rank++) {\n      this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n    }\n\n    this.treeLiteral.writeTree(this.treeCodeLengths);\n    this.treeDistances.writeTree(this.treeCodeLengths);\n  }\n\n  huffmanReset() {\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.treeLiteral.reset();\n    this.treeDistances.reset();\n    this.treeCodeLengths.reset();\n  }\n\n  huffmanCompressBlock() {\n    for (let i = 0; i < this.bufferPosition; i++) {\n      let literalLen = this.arrLiterals[i] & 255;\n      let dist = this.arrDistances[i];\n\n      if (dist-- !== 0) {\n        let lc = this.huffmanLengthCode(literalLen);\n        this.treeLiteral.writeCodeToStream(lc);\n        let bits = Math.floor((lc - 261) / 4);\n\n        if (bits > 0 && bits <= 5) {\n          this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n        }\n\n        let dc = this.huffmanDistanceCode(dist);\n        this.treeDistances.writeCodeToStream(dc);\n        bits = Math.floor(dc / 2 - 1);\n\n        if (bits > 0) {\n          this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n        }\n      } else {\n        this.treeLiteral.writeCodeToStream(literalLen);\n      }\n    }\n\n    this.treeLiteral.writeCodeToStream(256);\n  }\n  /**\n   * write bits in to internal buffer\n   * @param {number} b - source of bits\n   * @param {number} count - count of bits to write\n   */\n\n\n  pendingBufferWriteBits(b, count) {\n    let uint = new Uint32Array(1);\n    uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n    this.pendingBufCache = uint[0];\n    this.pendingBufBitsInCache += count;\n    this.pendingBufferFlushBits();\n  }\n\n  pendingBufferFlush(isClose) {\n    this.pendingBufferFlushBits();\n\n    if (this.pendingBufLength > 0) {\n      let array = new Uint8Array(this.pendingBufLength);\n      array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n      this.stream.push(array);\n    }\n\n    this.pendingBufLength = 0;\n  }\n\n  pendingBufferFlushBits() {\n    let result = 0;\n\n    while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      this.pendingBufCache >>= 8;\n      this.pendingBufBitsInCache -= 8;\n      result++;\n    }\n\n    return result;\n  }\n\n  pendingBufferWriteByteBlock(data, offset, length) {\n    let array = data.subarray(offset, offset + length);\n    this.pendingBuffer.set(array, this.pendingBufLength);\n    this.pendingBufLength += length;\n  }\n\n  pendingBufferWriteShort(s) {\n    this.pendingBuffer[this.pendingBufLength++] = s;\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n  }\n\n  pendingBufferAlignToByte() {\n    if (this.pendingBufBitsInCache > 0) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n    }\n\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n  }\n  /**\n   * Huffman Tree literal calculation\n   * @private\n   */\n\n\n  static initHuffmanTree() {\n    let i = 0;\n\n    while (i < 144) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    while (i < 256) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n      ARR_LITERAL_LENGTHS[i++] = 9;\n    }\n\n    while (i < 280) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n      ARR_LITERAL_LENGTHS[i++] = 7;\n    }\n\n    while (i < 286) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    for (i = 0; i < 30; i++) {\n      ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n      ARR_DISTANCE_LENGTHS[i] = 5;\n    }\n  }\n  /**\n   * close the stream and write all pending buffer in to stream\n   * @returns {void}\n   */\n\n\n  close() {\n    do {\n      this.pendingBufferFlush(true);\n\n      if (!this.compressData(true)) {\n        this.pendingBufferFlush(true);\n        this.pendingBufferAlignToByte();\n\n        if (!this.noWrap) {\n          this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n          this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n        }\n\n        this.pendingBufferFlush(true);\n      }\n    } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n  }\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  destroy() {\n    this.stream = [];\n    this.stream = undefined;\n    this.pendingBuffer = undefined;\n    this.treeLiteral = undefined;\n    this.treeDistances = undefined;\n    this.treeCodeLengths = undefined;\n    this.arrLiterals = undefined;\n    this.arrDistances = undefined;\n    this.hashHead = undefined;\n    this.hashPrevious = undefined;\n    this.dataWindow = undefined;\n    this.inputBuffer = undefined;\n    this.pendingBufLength = undefined;\n    this.pendingBufCache = undefined;\n    this.pendingBufBitsInCache = undefined;\n    this.bufferPosition = undefined;\n    this.extraBits = undefined;\n    this.currentHash = undefined;\n    this.matchStart = undefined;\n    this.matchLength = undefined;\n    this.matchPrevAvail = undefined;\n    this.blockStart = undefined;\n    this.stringStart = undefined;\n    this.lookAhead = undefined;\n    this.totalBytesIn = undefined;\n    this.inputOffset = undefined;\n    this.inputEnd = undefined;\n    this.windowSize = undefined;\n    this.windowMask = undefined;\n    this.hashSize = undefined;\n    this.hashMask = undefined;\n    this.hashShift = undefined;\n    this.maxDist = undefined;\n    this.checkSum = undefined;\n    this.noWrap = undefined;\n  }\n\n}\n\nCompressedStreamWriter.isHuffmanTreeInitiated = false;\n/**\n * represent the Huffman Tree\n */\n\nclass CompressorHuffmanTree {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  constructor(writer, elementCount, minCodes, maxLength) {\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n\n  get treeLength() {\n    return this.codeCount;\n  }\n\n  get codeLengths() {\n    return this.codeLength;\n  }\n\n  get codeFrequencies() {\n    return this.codeFrequency;\n  }\n\n  setStaticCodes(codes, lengths) {\n    let temp = new Int16Array(codes.length);\n    temp.set(codes, 0);\n    this.codes = temp;\n    let lengthTemp = new Uint8Array(lengths.length);\n    lengthTemp.set(lengths, 0);\n    this.codeLength = lengthTemp;\n  }\n  /**\n   * reset all code data in tree\n   * @returns {void}\n   */\n\n\n  reset() {\n    for (let i = 0; i < this.codeFrequency.length; i++) {\n      this.codeFrequency[i] = 0;\n    }\n\n    this.codes = undefined;\n    this.codeLength = undefined;\n  }\n  /**\n   * write code to the compressor output stream\n   * @param {number} code - code to be written\n   * @returns {void}\n   */\n\n\n  writeCodeToStream(code) {\n    this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n  }\n  /**\n   * calculate code from their frequencies\n   * @returns {void}\n   */\n\n\n  buildCodes() {\n    let nextCode = new Int32Array(this.maxLength);\n    this.codes = new Int16Array(this.codeCount);\n    let code = 0;\n\n    for (let bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n      nextCode[bitsCount] = code;\n      code += this.lengthCount[bitsCount] << 15 - bitsCount;\n    }\n\n    for (let i = 0; i < this.codeCount; i++) {\n      let bits = this.codeLength[i];\n\n      if (bits > 0) {\n        this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n        nextCode[bits - 1] += 1 << 16 - bits;\n      }\n    }\n  }\n\n  static bitReverse(value) {\n    return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n  }\n  /**\n   * calculate length of compressed data\n   * @returns {number}\n   */\n\n\n  getEncodedLength() {\n    let len = 0;\n\n    for (let i = 0; i < this.codeFrequency.length; i++) {\n      len += this.codeFrequency[i] * this.codeLength[i];\n    }\n\n    return len;\n  }\n  /**\n   * calculate code frequencies\n   * @param {CompressorHuffmanTree} blTree\n   * @returns {void}\n   */\n\n\n  calculateBLFreq(blTree) {\n    let maxCount;\n    let minCount;\n    let count;\n    let curLen = -1;\n    let i = 0;\n\n    while (i < this.codeCount) {\n      count = 1;\n      let nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxCount = 138;\n        minCount = 3;\n      } else {\n        maxCount = 6;\n        minCount = 3;\n\n        if (curLen !== nextLen) {\n          blTree.codeFrequency[nextLen]++;\n          count = 0;\n        }\n      }\n\n      curLen = nextLen;\n      i++;\n\n      while (i < this.codeCount && curLen === this.codeLength[i]) {\n        i++;\n\n        if (++count >= maxCount) {\n          break;\n        }\n      }\n\n      if (count < minCount) {\n        blTree.codeFrequency[curLen] += count;\n      } else if (curLen !== 0) {\n        blTree.codeFrequency[16]++;\n      } else if (count <= 10) {\n        blTree.codeFrequency[17]++;\n      } else {\n        blTree.codeFrequency[18]++;\n      }\n    }\n  }\n  /**\n   * @param {CompressorHuffmanTree} blTree - write tree to output stream\n   * @returns {void}\n   */\n\n\n  writeTree(blTree) {\n    let maxRepeatCount;\n    let minRepeatCount;\n    let currentRepeatCount;\n    let currentCodeLength = -1;\n    let i = 0;\n\n    while (i < this.codeCount) {\n      currentRepeatCount = 1;\n      let nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxRepeatCount = 138;\n        minRepeatCount = 3;\n      } else {\n        maxRepeatCount = 6;\n        minRepeatCount = 3;\n\n        if (currentCodeLength !== nextLen) {\n          blTree.writeCodeToStream(nextLen);\n          currentRepeatCount = 0;\n        }\n      }\n\n      currentCodeLength = nextLen;\n      i++;\n\n      while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n        i++;\n\n        if (++currentRepeatCount >= maxRepeatCount) {\n          break;\n        }\n      }\n\n      if (currentRepeatCount < minRepeatCount) {\n        while (currentRepeatCount-- > 0) {\n          blTree.writeCodeToStream(currentCodeLength);\n        }\n      } else if (currentCodeLength !== 0) {\n        blTree.writeCodeToStream(16);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n      } else if (currentRepeatCount <= 10) {\n        blTree.writeCodeToStream(17);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n      } else {\n        blTree.writeCodeToStream(18);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n      }\n    }\n  }\n  /**\n   * Build huffman tree\n   * @returns {void}\n   */\n\n\n  buildTree() {\n    let codesCount = this.codeFrequency.length;\n    let arrTree = new Int32Array(codesCount);\n    let treeLength = 0;\n    let maxCount = 0;\n\n    for (let n = 0; n < codesCount; n++) {\n      let freq = this.codeFrequency[n];\n\n      if (freq !== 0) {\n        let pos = treeLength++;\n        let pPos = 0;\n\n        while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n          arrTree[pos] = arrTree[pPos];\n          pos = pPos;\n        }\n\n        arrTree[pos] = n;\n        maxCount = n;\n      }\n    }\n\n    while (treeLength < 2) {\n      arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n    }\n\n    this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n    let leafsCount = treeLength;\n    let nodesCount = leafsCount;\n    let child = new Int32Array(4 * treeLength - 2);\n    let values = new Int32Array(2 * treeLength - 1);\n\n    for (let i = 0; i < treeLength; i++) {\n      let node = arrTree[i];\n      let iIndex = 2 * i;\n      child[iIndex] = node;\n      child[iIndex + 1] = -1;\n      values[i] = this.codeFrequency[node] << 8;\n      arrTree[i] = i;\n    }\n\n    this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n    this.buildLength(child);\n  }\n\n  constructHuffmanTree(arrTree, treeLength, values, nodesCount, child) {\n    do {\n      let first = arrTree[0];\n      let last = arrTree[--treeLength];\n      let lastVal = values[last];\n      let pPos = 0;\n      let path = 1;\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n      let second = arrTree[0];\n      last = nodesCount++;\n      child[2 * last] = first;\n      child[2 * last + 1] = second;\n      let minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n      values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n      pPos = 0;\n      path = 1;\n      /* tslint:disable */\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n      /* tslint:disable */\n\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n    } while (treeLength > 1);\n  }\n\n  buildLength(child) {\n    this.codeLength = new Uint8Array(this.codeFrequency.length);\n    let numNodes = Math.floor(child.length / 2);\n    let numLeafs = Math.floor((numNodes + 1) / 2);\n    let overflow = 0;\n\n    for (let i = 0; i < this.maxLength; i++) {\n      this.lengthCount[i] = 0;\n    }\n\n    overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n    if (overflow === 0) {\n      return;\n    }\n\n    let iIncreasableLength = this.maxLength - 1;\n\n    do {\n      while (this.lengthCount[--iIncreasableLength] === 0) {\n        /* tslint:disable */\n      }\n\n      do {\n        this.lengthCount[iIncreasableLength]--;\n        this.lengthCount[++iIncreasableLength]++;\n        overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n      } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n    } while (overflow > 0);\n\n    this.recreateTree(child, overflow, numLeafs);\n  }\n\n  recreateTree(child, overflow, numLeafs) {\n    this.lengthCount[this.maxLength - 1] += overflow;\n    this.lengthCount[this.maxLength - 2] -= overflow;\n    let nodePtr = 2 * numLeafs;\n\n    for (let bits = this.maxLength; bits !== 0; bits--) {\n      let n = this.lengthCount[bits - 1];\n\n      while (n > 0) {\n        let childPtr = 2 * child[nodePtr++];\n\n        if (child[childPtr + 1] === -1) {\n          this.codeLength[child[childPtr]] = bits;\n          n--;\n        }\n      }\n    }\n  }\n\n  calculateOptimalCodeLength(child, overflow, numNodes) {\n    let lengths = new Int32Array(numNodes);\n    lengths[numNodes - 1] = 0;\n\n    for (let i = numNodes - 1; i >= 0; i--) {\n      let childIndex = 2 * i + 1;\n\n      if (child[childIndex] !== -1) {\n        let bitLength = lengths[i] + 1;\n\n        if (bitLength > this.maxLength) {\n          bitLength = this.maxLength;\n          overflow++;\n        }\n\n        lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n      } else {\n        let bitLength = lengths[i];\n        this.lengthCount[bitLength - 1]++;\n        this.codeLength[child[childIndex - 1]] = lengths[i];\n      }\n    }\n\n    return overflow;\n  }\n\n}\n\nCompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\nCompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\n\nclass ChecksumCalculator {\n  /**\n   * Updates checksum by calculating checksum of the\n   * given buffer and adding it to current value.\n   * @param {number} checksum - current checksum.\n   * @param {Uint8Array} buffer - data byte array.\n   * @param {number} offset - offset in the buffer.\n   * @param {number} length - length of data to be used from the stream.\n   * @returns {number}\n   */\n  static checksumUpdate(checksum, buffer, offset, length) {\n    let uint = new Uint32Array(1);\n    uint[0] = checksum;\n    let checksum_uint = uint[0];\n    let s1 = uint[0] = checksum_uint & 65535;\n    let s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n    while (length > 0) {\n      let steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (uint[0] = buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= ChecksumCalculator.checksumBase;\n      s2 %= ChecksumCalculator.checksumBase;\n    }\n\n    checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n    return checksum_uint;\n  }\n\n}\n\nChecksumCalculator.checkSumBitOffset = 16;\nChecksumCalculator.checksumBase = 65521;\nChecksumCalculator.checksumIterationCount = 3800;\nconst CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nclass ZipArchive {\n  /**\n   * gets compression level\n   */\n  get compressionLevel() {\n    return this.level;\n  }\n  /**\n   * sets compression level\n   */\n\n\n  set compressionLevel(level) {\n    this.level = level;\n  }\n  /**\n   * gets items count\n   */\n\n\n  get length() {\n    if (this.files === undefined) {\n      return 0;\n    }\n\n    return this.files.length;\n  }\n  /**\n   * constructor for creating ZipArchive instance\n   */\n\n\n  constructor() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n\n  addItem(item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n\n    for (let i = 0; i < this.files.length; i++) {\n      let file = this.files[i];\n\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n\n    this.files.push(item);\n  }\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n\n\n  addDirectory(directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n\n    this.files.push(directoryName);\n  }\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n\n\n  getItem(index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n\n    return undefined;\n  }\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n\n\n  contains(item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  }\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n\n\n  save(fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n\n    let zipArchive = this;\n    let promise;\n    return promise = new Promise((resolve, reject) => {\n      zipArchive.saveInternal(fileName, false).then(() => {\n        resolve(zipArchive);\n      });\n    });\n  }\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n\n\n  saveAsBlob() {\n    let zipArchive = this;\n    let promise;\n    return promise = new Promise((resolve, reject) => {\n      zipArchive.saveInternal('', true).then(blob => {\n        resolve(blob);\n      });\n    });\n  }\n\n  saveInternal(fileName, skipFileSave) {\n    let zipArchive = this;\n    let promise;\n    return promise = new Promise((resolve, reject) => {\n      let zipData = [];\n      let dirLength = 0;\n\n      for (let i = 0; i < zipArchive.files.length; i++) {\n        let compressedObject = this.getCompressedData(this.files[i]);\n        compressedObject.then(data => {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n          if (zipData.length === zipArchive.files.length) {\n            let blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  }\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  destroy() {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (let i = 0; i < this.files.length; i++) {\n        let file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n\n        file = undefined;\n      }\n\n      this.files = [];\n    }\n\n    this.files = undefined;\n    this.level = undefined;\n  }\n\n  getCompressedData(item) {\n    let zipArchive = this;\n    let promise = new Promise((resolve, reject) => {\n      if (item instanceof ZipArchiveItem) {\n        let reader = new FileReader();\n\n        reader.onload = () => {\n          let input = new Uint8Array(reader.result);\n          let data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            let length = 0;\n\n            for (let i = 0; i < data.compressedData.length; i++) {\n              length += data.compressedData[i].length;\n            }\n\n            data.compressedSize = length;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n\n            data.compressedData.push(input);\n          }\n\n          resolve(data);\n        };\n\n        reader.readAsArrayBuffer(item.data);\n      } else {\n        let data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  }\n\n  compressData(input, data, crc32Table) {\n    let compressor = new CompressedStreamWriter(true);\n    let currentIndex = 0;\n    let nextIndex = 0;\n\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      let subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  }\n\n  constructZippedObject(zipParts, data, dirLength, isDirectory) {\n    let extFileAttr = 0;\n    let date = new Date();\n\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    let header = this.writeHeader(data, date);\n    let localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    let centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  }\n\n  writeHeader(data, date) {\n    let zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n    zipHeader += this.getBytes(0, 2); // extra field length\n\n    return zipHeader;\n  }\n\n  writeZippedContent(fileName, zipData, localDirLen, skipFileSave) {\n    let cenDirLen = 0;\n    let buffer = [];\n\n    for (let i = 0; i < zipData.length; i++) {\n      let item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n\n    for (let i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    let blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n\n    return blob;\n  }\n\n  writeCentralDirectory(data, localHeader, offset, externalFileAttribute) {\n    let directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n    this.getBytes(0, 2) + // comment length\n    '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n    this.getBytes(externalFileAttribute, 4) + // external file attributes\n    this.getBytes(offset, 4) + // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  }\n\n  writeFooter(zipData, centralLength, localLength) {\n    let dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  }\n\n  getArrayBuffer(input) {\n    let a = new Uint8Array(input.length);\n\n    for (let j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n\n    return a.buffer;\n  }\n\n  getBytes(value, offset) {\n    let bytes = '';\n\n    for (let i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n\n    return bytes;\n  }\n\n  getModifiedTime(date) {\n    let modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  }\n\n  getModifiedDate(date) {\n    let modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  }\n\n  calculateCrc32Value(crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n\n    for (let i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n\n    return crc32Value ^ -1;\n  }\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n\n\n  static initCrc32Table() {\n    let i;\n\n    for (let j = 0; j < 256; j++) {\n      i = j;\n\n      for (let k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n\n      CRC32TABLE[j] = i;\n    }\n  }\n\n}\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\n\nclass ZipArchiveItem {\n  /**\n   * Get the name of archive item\n   * @returns string\n   */\n  get name() {\n    return this.fileName;\n  }\n  /**\n   * Set the name of archive item\n   * @param  {string} value\n   */\n\n\n  set name(value) {\n    this.fileName = value;\n  }\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n\n\n  constructor(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  destroy() {\n    this.fileName = undefined;\n    this.data = undefined;\n  }\n\n}\n/**\n * export ZipArchive class\n */\n\n\nexport { ZipArchive, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator };","map":{"version":3,"names":["Encoding","Save","ARR_LITERAL_CODES","Int16Array","ARR_LITERAL_LENGTHS","Uint8Array","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","CompressedStreamWriter","constructor","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","isHuffmanTreeInitiated","initHuffmanTree","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","Uint16Array","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","compressedData","getCompressedString","compressedString","undefined","i","length","String","fromCharCode","apply","write","data","offset","Error","end","encode","type","getBytes","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","s","finish","success","fillWindow","canFlush","compressSlow","flush","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","set","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","count","uint","Uint32Array","pendingBufferFlushBits","isClose","array","push","result","bitReverse","close","destroy","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","value","reverseBits","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","leafsCount","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","buffer","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","CRC32TABLE","ZipArchive","compressionLevel","level","files","initCrc32Table","isMicrosoftBrowser","navigator","msSaveBlob","addItem","item","file","ZipArchiveItem","name","addDirectory","directoryName","slice","indexOf","getItem","index","contains","save","fileName","zipArchive","promise","Promise","resolve","reject","saveInternal","then","saveAsBlob","blob","skipFileSave","zipData","dirLength","compressedObject","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","reader","FileReader","onload","input","crc32Value","compressedSize","uncompressedDataSize","compressionType","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","currentIndex","nextIndex","subArray","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","Blob","externalFileAttribute","directoryHeader","centralLength","localLength","dirEnd","a","j","charCodeAt","bytes","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","k","itemName"],"sources":["D:/StageCap2022/e-learningProject__frontend/frontend/node_modules/@syncfusion/ej2-compression/dist/es6/ej2-compression.es2015.js"],"sourcesContent":["import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n\n/**\n * array literal codes\n */\nconst ARR_LITERAL_CODES = new Int16Array(286);\nconst ARR_LITERAL_LENGTHS = new Uint8Array(286);\nconst ARR_DISTANCE_CODES = new Int16Array(30);\nconst ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nclass CompressedStreamWriter {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    constructor(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    /**\n     * get compressed data\n     */\n    get compressedData() {\n        return this.stream;\n    }\n    get getCompressedString() {\n        let compressedString = '';\n        if (this.stream !== undefined) {\n            for (let i = 0; i < this.stream.length; i++) {\n                compressedString += String.fromCharCode.apply(null, this.stream[i]);\n            }\n        }\n        return compressedString;\n    }\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    write(data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        let end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            let encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    }\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    writeZLibHeader() {\n        /* Initialize header.*/\n        let headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    }\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    pendingBufferWriteShortBytes(s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    }\n    compressData(finish) {\n        let success;\n        do {\n            this.fillWindow();\n            let canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    }\n    compressSlow(flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            let prevMatch = this.matchStart;\n            let prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    }\n    discardMatch() {\n        let hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    }\n    matchPreviousAvailable() {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    }\n    matchPreviousBest(prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    }\n    lookAheadCompleted(finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    }\n    huffmanIsFull(finish) {\n        let len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        let lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    }\n    fillWindow() {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            let more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    }\n    slideWindow() {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (let i = 0; i < this.hashSize; ++i) {\n            let m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (let i = 0; i < this.windowSize; i++) {\n            let m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    }\n    insertString() {\n        let match;\n        let hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    }\n    findLongestMatch(curMatch) {\n        let chainLen = 4096;\n        let niceLen = 258;\n        let scan = this.stringStart;\n        let match;\n        let bestEnd = this.stringStart + this.matchLength;\n        let bestLength = Math.max(this.matchLength, 3 - 1);\n        let limit = Math.max(this.stringStart - this.maxDist, 0);\n        let stringEnd = this.stringStart + 258 - 1;\n        let scanEnd1 = this.dataWindow[bestEnd - 1];\n        let scanEnd = this.dataWindow[bestEnd];\n        let data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    }\n    updateHash() {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    }\n    huffmanTallyLit(literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    }\n    huffmanTallyDist(dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        let lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        let dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    }\n    huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        let blTreeCodes = 4;\n        for (let i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        let opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        let static_len = this.extraBits;\n        for (let i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (let i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    }\n    huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    }\n    huffmanLengthCode(len) {\n        if (len === 255) {\n            return 285;\n        }\n        let code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    }\n    huffmanDistanceCode(distance) {\n        let code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    }\n    huffmanSendAllTrees(blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (let rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    }\n    huffmanReset() {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    }\n    huffmanCompressBlock() {\n        for (let i = 0; i < this.bufferPosition; i++) {\n            let literalLen = this.arrLiterals[i] & 255;\n            let dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                let lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                let bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                let dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    }\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    pendingBufferWriteBits(b, count) {\n        let uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    }\n    pendingBufferFlush(isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            let array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    }\n    pendingBufferFlushBits() {\n        let result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    }\n    pendingBufferWriteByteBlock(data, offset, length) {\n        let array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    }\n    pendingBufferWriteShort(s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    }\n    pendingBufferAlignToByte() {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    }\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    static initHuffmanTree() {\n        let i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    }\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    close() {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    destroy() {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    }\n}\nCompressedStreamWriter.isHuffmanTreeInitiated = false;\n/**\n * represent the Huffman Tree\n */\nclass CompressorHuffmanTree {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    constructor(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    get treeLength() {\n        return this.codeCount;\n    }\n    get codeLengths() {\n        return this.codeLength;\n    }\n    get codeFrequencies() {\n        return this.codeFrequency;\n    }\n    setStaticCodes(codes, lengths) {\n        let temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        let lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    }\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    reset() {\n        for (let i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    }\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    writeCodeToStream(code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    }\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    buildCodes() {\n        let nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        let code = 0;\n        for (let bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (let i = 0; i < this.codeCount; i++) {\n            let bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    }\n    static bitReverse(value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    }\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    getEncodedLength() {\n        let len = 0;\n        for (let i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    }\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    calculateBLFreq(blTree) {\n        let maxCount;\n        let minCount;\n        let count;\n        let curLen = -1;\n        let i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            let nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    }\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    writeTree(blTree) {\n        let maxRepeatCount;\n        let minRepeatCount;\n        let currentRepeatCount;\n        let currentCodeLength = -1;\n        let i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            let nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    }\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    buildTree() {\n        let codesCount = this.codeFrequency.length;\n        let arrTree = new Int32Array(codesCount);\n        let treeLength = 0;\n        let maxCount = 0;\n        for (let n = 0; n < codesCount; n++) {\n            let freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                let pos = treeLength++;\n                let pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        let leafsCount = treeLength;\n        let nodesCount = leafsCount;\n        let child = new Int32Array(4 * treeLength - 2);\n        let values = new Int32Array(2 * treeLength - 1);\n        for (let i = 0; i < treeLength; i++) {\n            let node = arrTree[i];\n            let iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    }\n    constructHuffmanTree(arrTree, treeLength, values, nodesCount, child) {\n        do {\n            let first = arrTree[0];\n            let last = arrTree[--treeLength];\n            let lastVal = values[last];\n            let pPos = 0;\n            let path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            let second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            let minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    }\n    buildLength(child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        let numNodes = Math.floor(child.length / 2);\n        let numLeafs = Math.floor((numNodes + 1) / 2);\n        let overflow = 0;\n        for (let i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        let iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    }\n    recreateTree(child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        let nodePtr = 2 * numLeafs;\n        for (let bits = this.maxLength; bits !== 0; bits--) {\n            let n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                let childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    }\n    calculateOptimalCodeLength(child, overflow, numNodes) {\n        let lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (let i = numNodes - 1; i >= 0; i--) {\n            let childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                let bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                let bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    }\n}\nCompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\nCompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nclass ChecksumCalculator {\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    static checksumUpdate(checksum, buffer, offset, length) {\n        let uint = new Uint32Array(1);\n        uint[0] = checksum;\n        let checksum_uint = uint[0];\n        let s1 = uint[0] = checksum_uint & 65535;\n        let s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            let steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    }\n}\nChecksumCalculator.checkSumBitOffset = 16;\nChecksumCalculator.checksumBase = 65521;\nChecksumCalculator.checksumIterationCount = 3800;\n\nconst CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nclass ZipArchive {\n    /**\n     * gets compression level\n     */\n    get compressionLevel() {\n        return this.level;\n    }\n    /**\n     * sets compression level\n     */\n    set compressionLevel(level) {\n        this.level = level;\n    }\n    /**\n     * gets items count\n     */\n    get length() {\n        if (this.files === undefined) {\n            return 0;\n        }\n        return this.files.length;\n    }\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    constructor() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    addItem(item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (let i = 0; i < this.files.length; i++) {\n            let file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    }\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    addDirectory(directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    }\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    getItem(index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    }\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    contains(item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    }\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    save(fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        let zipArchive = this;\n        let promise;\n        return promise = new Promise((resolve, reject) => {\n            zipArchive.saveInternal(fileName, false).then(() => {\n                resolve(zipArchive);\n            });\n        });\n    }\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    saveAsBlob() {\n        let zipArchive = this;\n        let promise;\n        return promise = new Promise((resolve, reject) => {\n            zipArchive.saveInternal('', true).then((blob) => {\n                resolve(blob);\n            });\n        });\n    }\n    saveInternal(fileName, skipFileSave) {\n        let zipArchive = this;\n        let promise;\n        return promise = new Promise((resolve, reject) => {\n            let zipData = [];\n            let dirLength = 0;\n            for (let i = 0; i < zipArchive.files.length; i++) {\n                let compressedObject = this.getCompressedData(this.files[i]);\n                compressedObject.then((data) => {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        let blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    destroy() {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (let i = 0; i < this.files.length; i++) {\n                let file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    }\n    getCompressedData(item) {\n        let zipArchive = this;\n        let promise = new Promise((resolve, reject) => {\n            if (item instanceof ZipArchiveItem) {\n                let reader = new FileReader();\n                reader.onload = () => {\n                    let input = new Uint8Array(reader.result);\n                    let data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        let length = 0;\n                        for (let i = 0; i < data.compressedData.length; i++) {\n                            length += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader.readAsArrayBuffer(item.data);\n            }\n            else {\n                let data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    }\n    compressData(input, data, crc32Table) {\n        let compressor = new CompressedStreamWriter(true);\n        let currentIndex = 0;\n        let nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            let subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    }\n    constructZippedObject(zipParts, data, dirLength, isDirectory) {\n        let extFileAttr = 0;\n        let date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        let header = this.writeHeader(data, date);\n        let localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        let centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    }\n    writeHeader(data, date) {\n        let zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    }\n    writeZippedContent(fileName, zipData, localDirLen, skipFileSave) {\n        let cenDirLen = 0;\n        let buffer = [];\n        for (let i = 0; i < zipData.length; i++) {\n            let item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (let i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        let blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    }\n    writeCentralDirectory(data, localHeader, offset, externalFileAttribute) {\n        let directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    }\n    writeFooter(zipData, centralLength, localLength) {\n        let dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    }\n    getArrayBuffer(input) {\n        let a = new Uint8Array(input.length);\n        for (let j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    }\n    getBytes(value, offset) {\n        let bytes = '';\n        for (let i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    }\n    getModifiedTime(date) {\n        let modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    }\n    getModifiedDate(date) {\n        let modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    }\n    calculateCrc32Value(crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (let i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    }\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    static initCrc32Table() {\n        let i;\n        for (let j = 0; j < 256; j++) {\n            i = j;\n            for (let k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    }\n}\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nclass ZipArchiveItem {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get name() {\n        return this.fileName;\n    }\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set name(value) {\n        this.fileName = value;\n    }\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    constructor(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    destroy() {\n        this.fileName = undefined;\n        this.data = undefined;\n    }\n}\n\n/**\n * export ZipArchive class\n */\n\nexport { ZipArchive, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}